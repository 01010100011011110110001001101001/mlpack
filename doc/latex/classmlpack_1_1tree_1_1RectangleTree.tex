\section{mlpack\+:\+:tree\+:\+:Rectangle\+Tree$<$ Metric\+Type, Statistic\+Type, Mat\+Type, Split\+Type, Descent\+Type, Auxiliary\+Information\+Type $>$ Class Template Reference}
\label{classmlpack_1_1tree_1_1RectangleTree}\index{mlpack\+::tree\+::\+Rectangle\+Tree$<$ Metric\+Type, Statistic\+Type, Mat\+Type, Split\+Type, Descent\+Type, Auxiliary\+Information\+Type $>$@{mlpack\+::tree\+::\+Rectangle\+Tree$<$ Metric\+Type, Statistic\+Type, Mat\+Type, Split\+Type, Descent\+Type, Auxiliary\+Information\+Type $>$}}


A rectangle type tree tree, such as an R-\/tree or X-\/tree.  


\subsection*{Classes}
\begin{DoxyCompactItemize}
\item 
class {\bf Dual\+Tree\+Traverser}
\begin{DoxyCompactList}\small\item\em A dual tree traverser for rectangle type trees. \end{DoxyCompactList}\item 
class {\bf Single\+Tree\+Traverser}
\begin{DoxyCompactList}\small\item\em A single traverser for rectangle type trees. \end{DoxyCompactList}\end{DoxyCompactItemize}
\subsection*{Public Types}
\begin{DoxyCompactItemize}
\item 
typedef Auxiliary\+Information\+Type$<$ {\bf Rectangle\+Tree} $>$ {\bf Auxiliary\+Information}
\begin{DoxyCompactList}\small\item\em The auxiliary information type held by the tree. \end{DoxyCompactList}\item 
typedef Mat\+Type\+::elem\+\_\+type {\bf Elem\+Type}
\begin{DoxyCompactList}\small\item\em The element type held by the matrix type. \end{DoxyCompactList}\item 
typedef Mat\+Type {\bf Mat}
\begin{DoxyCompactList}\small\item\em So other classes can use Tree\+Type\+::\+Mat. \end{DoxyCompactList}\end{DoxyCompactItemize}
\subsection*{Public Member Functions}
\begin{DoxyCompactItemize}
\item 
{\bf Rectangle\+Tree} (const Mat\+Type \&data, const size\+\_\+t {\bf max\+Leaf\+Size}=20, const size\+\_\+t {\bf min\+Leaf\+Size}=8, const size\+\_\+t {\bf max\+Num\+Children}=5, const size\+\_\+t {\bf min\+Num\+Children}=2, const size\+\_\+t first\+Data\+Index=0)
\begin{DoxyCompactList}\small\item\em Construct this as the root node of a rectangle type tree using the given dataset. \end{DoxyCompactList}\item 
{\bf Rectangle\+Tree} (Mat\+Type \&\&data, const size\+\_\+t {\bf max\+Leaf\+Size}=20, const size\+\_\+t {\bf min\+Leaf\+Size}=8, const size\+\_\+t {\bf max\+Num\+Children}=5, const size\+\_\+t {\bf min\+Num\+Children}=2, const size\+\_\+t first\+Data\+Index=0)
\begin{DoxyCompactList}\small\item\em Construct this as the root node of a rectangle tree type using the given dataset, and taking ownership of the given dataset. \end{DoxyCompactList}\item 
{\bf Rectangle\+Tree} ({\bf Rectangle\+Tree} $\ast$parent\+Node, const size\+\_\+t num\+Max\+Children=0)
\begin{DoxyCompactList}\small\item\em Construct this as an empty node with the specified parent. \end{DoxyCompactList}\item 
{\bf Rectangle\+Tree} (const {\bf Rectangle\+Tree} \&other, const bool deep\+Copy=true, {\bf Rectangle\+Tree} $\ast$new\+Parent=N\+U\+LL)
\begin{DoxyCompactList}\small\item\em Create a rectangle tree by copying the other tree. \end{DoxyCompactList}\item 
{\bf Rectangle\+Tree} ({\bf Rectangle\+Tree} \&\&other)
\begin{DoxyCompactList}\small\item\em Create a rectangle tree by moving the other tree. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename Archive $>$ }\\{\bf Rectangle\+Tree} (Archive \&ar, const typename {\bf std\+::enable\+\_\+if\+\_\+t}$<$ Archive\+::is\+\_\+loading\+::value $>$ $\ast$=0)
\begin{DoxyCompactList}\small\item\em Construct the tree from a \doxyref{boost\+::serialization}{p.}{namespaceboost_1_1serialization} archive. \end{DoxyCompactList}\item 
{\bf $\sim$\+Rectangle\+Tree} ()
\begin{DoxyCompactList}\small\item\em Deletes this node, deallocating the memory for the children and calling their destructors in turn. \end{DoxyCompactList}\item 
const Auxiliary\+Information\+Type$<$ {\bf Rectangle\+Tree} $>$ \& {\bf Auxiliary\+Info} () const 
\begin{DoxyCompactList}\small\item\em Return the auxiliary information object of this node. \end{DoxyCompactList}\item 
Auxiliary\+Information\+Type$<$ {\bf Rectangle\+Tree} $>$ \& {\bf Auxiliary\+Info} ()
\begin{DoxyCompactList}\small\item\em Modify the split object of this node. \end{DoxyCompactList}\item 
size\+\_\+t {\bf Begin} () const 
\begin{DoxyCompactList}\small\item\em Return the index of the beginning point of this subset. \end{DoxyCompactList}\item 
size\+\_\+t \& {\bf Begin} ()
\begin{DoxyCompactList}\small\item\em Modify the index of the beginning point of this subset. \end{DoxyCompactList}\item 
const {\bf bound\+::\+H\+Rect\+Bound}$<$ Metric\+Type $>$ \& {\bf Bound} () const 
\begin{DoxyCompactList}\small\item\em Return the bound object for this node. \end{DoxyCompactList}\item 
{\bf bound\+::\+H\+Rect\+Bound}$<$ Metric\+Type $>$ \& {\bf Bound} ()
\begin{DoxyCompactList}\small\item\em Modify the bound object for this node. \end{DoxyCompactList}\item 
void {\bf Center} (arma\+::vec \&center)
\begin{DoxyCompactList}\small\item\em Get the centroid of the node and store it in the given vector. \end{DoxyCompactList}\item 
{\bf Rectangle\+Tree} \& {\bf Child} (const size\+\_\+t child) const 
\begin{DoxyCompactList}\small\item\em Get the specified child. \end{DoxyCompactList}\item 
{\bf Rectangle\+Tree} \& {\bf Child} (const size\+\_\+t child)
\begin{DoxyCompactList}\small\item\em Modify the specified child. \end{DoxyCompactList}\item 
void {\bf Condense\+Tree} (const arma\+::vec \&point, std\+::vector$<$ bool $>$ \&relevels, const bool use\+Point)
\begin{DoxyCompactList}\small\item\em Condense the bounding rectangles for this node based on the removal of the point specified by the arma\+::vec\&. \end{DoxyCompactList}\item 
size\+\_\+t {\bf Count} () const 
\begin{DoxyCompactList}\small\item\em Return the number of points in this subset. \end{DoxyCompactList}\item 
size\+\_\+t \& {\bf Count} ()
\begin{DoxyCompactList}\small\item\em Modify the number of points in this subset. \end{DoxyCompactList}\item 
const Mat\+Type \& {\bf Dataset} () const 
\begin{DoxyCompactList}\small\item\em Get the dataset which the tree is built on. \end{DoxyCompactList}\item 
Mat\+Type \& {\bf Dataset} ()
\begin{DoxyCompactList}\small\item\em Modify the dataset which the tree is built on. Be careful! \end{DoxyCompactList}\item 
bool {\bf Delete\+Point} (const size\+\_\+t point)
\begin{DoxyCompactList}\small\item\em Deletes a point from the treeand, updates the bounding rectangle. \end{DoxyCompactList}\item 
bool {\bf Delete\+Point} (const size\+\_\+t point, std\+::vector$<$ bool $>$ \&relevels)
\begin{DoxyCompactList}\small\item\em Deletes a point from the tree, updates the bounding rectangle, tracking levels. \end{DoxyCompactList}\item 
size\+\_\+t {\bf Descendant} (const size\+\_\+t index) const 
\begin{DoxyCompactList}\small\item\em Return the index (with reference to the dataset) of a particular descendant of this node. \end{DoxyCompactList}\item 
{\bf Rectangle\+Tree} $\ast$ {\bf Exact\+Clone} ()
\begin{DoxyCompactList}\small\item\em Make an exact copy of this node, pointers and everything. \end{DoxyCompactList}\item 
const {\bf Rectangle\+Tree} $\ast$ {\bf Find\+By\+Begin\+Count} (size\+\_\+t {\bf begin}, size\+\_\+t {\bf count}) const 
\begin{DoxyCompactList}\small\item\em Find a node in this tree by its begin and count (const). \end{DoxyCompactList}\item 
{\bf Rectangle\+Tree} $\ast$ {\bf Find\+By\+Begin\+Count} (size\+\_\+t {\bf begin}, size\+\_\+t {\bf count})
\begin{DoxyCompactList}\small\item\em Find a node in this tree by its begin and count. \end{DoxyCompactList}\item 
{\bf Elem\+Type} {\bf Furthest\+Descendant\+Distance} () const 
\begin{DoxyCompactList}\small\item\em Return the furthest possible descendant distance. \end{DoxyCompactList}\item 
{\bf Elem\+Type} {\bf Furthest\+Point\+Distance} () const 
\begin{DoxyCompactList}\small\item\em Return the furthest distance to a point held in this node. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename Vec\+Type $>$ }\\size\+\_\+t {\bf Get\+Furthest\+Child} (const Vec\+Type \&point, typename {\bf std\+::enable\+\_\+if\+\_\+t}$<$ {\bf Is\+Vector}$<$ Vec\+Type $>$\+::value $>$ $\ast$=0)
\begin{DoxyCompactList}\small\item\em Return the index of the furthest child node to the given query point. \end{DoxyCompactList}\item 
size\+\_\+t {\bf Get\+Furthest\+Child} (const {\bf Rectangle\+Tree} \&query\+Node)
\begin{DoxyCompactList}\small\item\em Return the index of the furthest child node to the given query node. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename Vec\+Type $>$ }\\size\+\_\+t {\bf Get\+Nearest\+Child} (const Vec\+Type \&point, typename {\bf std\+::enable\+\_\+if\+\_\+t}$<$ {\bf Is\+Vector}$<$ Vec\+Type $>$\+::value $>$ $\ast$=0)
\begin{DoxyCompactList}\small\item\em Return the index of the nearest child node to the given query point. \end{DoxyCompactList}\item 
size\+\_\+t {\bf Get\+Nearest\+Child} (const {\bf Rectangle\+Tree} \&query\+Node)
\begin{DoxyCompactList}\small\item\em Return the index of the nearest child node to the given query node. \end{DoxyCompactList}\item 
void {\bf Insert\+Node} ({\bf Rectangle\+Tree} $\ast$node, const size\+\_\+t level, std\+::vector$<$ bool $>$ \&relevels)
\begin{DoxyCompactList}\small\item\em Inserts a node into the tree, tracking which levels have been inserted into. \end{DoxyCompactList}\item 
void {\bf Insert\+Point} (const size\+\_\+t point)
\begin{DoxyCompactList}\small\item\em Inserts a point into the tree. \end{DoxyCompactList}\item 
void {\bf Insert\+Point} (const size\+\_\+t point, std\+::vector$<$ bool $>$ \&relevels)
\begin{DoxyCompactList}\small\item\em Inserts a point into the tree, tracking which levels have been inserted into. \end{DoxyCompactList}\item 
bool {\bf Is\+Leaf} () const 
\begin{DoxyCompactList}\small\item\em Return whether or not this node is a leaf (true if it has no children). \end{DoxyCompactList}\item 
{\bf Elem\+Type} {\bf Max\+Distance} (const {\bf Rectangle\+Tree} \&other) const 
\begin{DoxyCompactList}\small\item\em Return the maximum distance to another node. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename Vec\+Type $>$ }\\{\bf Elem\+Type} {\bf Max\+Distance} (const Vec\+Type \&point, typename {\bf std\+::enable\+\_\+if\+\_\+t}$<$ {\bf Is\+Vector}$<$ Vec\+Type $>$\+::value $>$ $\ast$=0) const 
\begin{DoxyCompactList}\small\item\em Return the maximum distance to another point. \end{DoxyCompactList}\item 
size\+\_\+t {\bf Max\+Leaf\+Size} () const 
\begin{DoxyCompactList}\small\item\em Return the maximum leaf size. \end{DoxyCompactList}\item 
size\+\_\+t \& {\bf Max\+Leaf\+Size} ()
\begin{DoxyCompactList}\small\item\em Modify the maximum leaf size. \end{DoxyCompactList}\item 
size\+\_\+t {\bf Max\+Num\+Children} () const 
\begin{DoxyCompactList}\small\item\em Return the maximum number of children (in a non-\/leaf node). \end{DoxyCompactList}\item 
size\+\_\+t \& {\bf Max\+Num\+Children} ()
\begin{DoxyCompactList}\small\item\em Modify the maximum number of children (in a non-\/leaf node). \end{DoxyCompactList}\item 
Metric\+Type {\bf Metric} () const 
\begin{DoxyCompactList}\small\item\em Get the metric which the tree uses. \end{DoxyCompactList}\item 
{\bf Elem\+Type} {\bf Min\+Distance} (const {\bf Rectangle\+Tree} \&other) const 
\begin{DoxyCompactList}\small\item\em Return the minimum distance to another node. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename Vec\+Type $>$ }\\{\bf Elem\+Type} {\bf Min\+Distance} (const Vec\+Type \&point, typename {\bf std\+::enable\+\_\+if\+\_\+t}$<$ {\bf Is\+Vector}$<$ Vec\+Type $>$\+::value $>$ $\ast$=0) const 
\begin{DoxyCompactList}\small\item\em Return the minimum distance to another point. \end{DoxyCompactList}\item 
{\bf Elem\+Type} {\bf Minimum\+Bound\+Distance} () const 
\begin{DoxyCompactList}\small\item\em Return the minimum distance from the center to any edge of the bound. \end{DoxyCompactList}\item 
size\+\_\+t {\bf Min\+Leaf\+Size} () const 
\begin{DoxyCompactList}\small\item\em Return the minimum leaf size. \end{DoxyCompactList}\item 
size\+\_\+t \& {\bf Min\+Leaf\+Size} ()
\begin{DoxyCompactList}\small\item\em Modify the minimum leaf size. \end{DoxyCompactList}\item 
size\+\_\+t {\bf Min\+Num\+Children} () const 
\begin{DoxyCompactList}\small\item\em Return the minimum number of children (in a non-\/leaf node). \end{DoxyCompactList}\item 
size\+\_\+t \& {\bf Min\+Num\+Children} ()
\begin{DoxyCompactList}\small\item\em Modify the minimum number of children (in a non-\/leaf node). \end{DoxyCompactList}\item 
void {\bf Nullify\+Data} ()
\begin{DoxyCompactList}\small\item\em Nullify the auxiliary information. \end{DoxyCompactList}\item 
size\+\_\+t {\bf Num\+Children} () const 
\begin{DoxyCompactList}\small\item\em Return the number of child nodes. (One level beneath this one only.) \end{DoxyCompactList}\item 
size\+\_\+t \& {\bf Num\+Children} ()
\begin{DoxyCompactList}\small\item\em Modify the number of child nodes. Be careful. \end{DoxyCompactList}\item 
size\+\_\+t {\bf Num\+Descendants} () const 
\begin{DoxyCompactList}\small\item\em Return the number of descendants of this node. \end{DoxyCompactList}\item 
size\+\_\+t {\bf Num\+Points} () const 
\begin{DoxyCompactList}\small\item\em Return the number of points in this node (returns 0 if this node is not a leaf). \end{DoxyCompactList}\item 
{\bf Rectangle\+Tree} $\ast$ {\bf Parent} () const 
\begin{DoxyCompactList}\small\item\em Gets the parent of this node. \end{DoxyCompactList}\item 
{\bf Rectangle\+Tree} $\ast$\& {\bf Parent} ()
\begin{DoxyCompactList}\small\item\em Modify the parent of this node. \end{DoxyCompactList}\item 
{\bf Elem\+Type} {\bf Parent\+Distance} () const 
\begin{DoxyCompactList}\small\item\em Return the distance from the center of this node to the center of the parent node. \end{DoxyCompactList}\item 
{\bf Elem\+Type} \& {\bf Parent\+Distance} ()
\begin{DoxyCompactList}\small\item\em Modify the distance from the center of this node to the center of the parent node. \end{DoxyCompactList}\item 
size\+\_\+t {\bf Point} (const size\+\_\+t index) const 
\begin{DoxyCompactList}\small\item\em Return the index (with reference to the dataset) of a particular point in this node. \end{DoxyCompactList}\item 
size\+\_\+t \& {\bf Point} (const size\+\_\+t index)
\begin{DoxyCompactList}\small\item\em Modify the index of a particular point in this node. \end{DoxyCompactList}\item 
{\bf math\+::\+Range\+Type}$<$ {\bf Elem\+Type} $>$ {\bf Range\+Distance} (const {\bf Rectangle\+Tree} \&other) const 
\begin{DoxyCompactList}\small\item\em Return the minimum and maximum distance to another node. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename Vec\+Type $>$ }\\{\bf math\+::\+Range\+Type}$<$ {\bf Elem\+Type} $>$ {\bf Range\+Distance} (const Vec\+Type \&point, typename {\bf std\+::enable\+\_\+if\+\_\+t}$<$ {\bf Is\+Vector}$<$ Vec\+Type $>$\+::value $>$ $\ast$=0) const 
\begin{DoxyCompactList}\small\item\em Return the minimum and maximum distance to another point. \end{DoxyCompactList}\item 
bool {\bf Remove\+Node} (const {\bf Rectangle\+Tree} $\ast$node, std\+::vector$<$ bool $>$ \&relevels)
\begin{DoxyCompactList}\small\item\em Removes a node from the tree. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename Archive $>$ }\\void {\bf Serialize} (Archive \&ar, const unsigned int)
\begin{DoxyCompactList}\small\item\em Serialize the tree. \end{DoxyCompactList}\item 
bool {\bf Shrink\+Bound\+For\+Bound} (const {\bf bound\+::\+H\+Rect\+Bound}$<$ Metric\+Type $>$ \&changed\+Bound)
\begin{DoxyCompactList}\small\item\em Shrink the bound object of this node for the removal of a child node. \end{DoxyCompactList}\item 
bool {\bf Shrink\+Bound\+For\+Point} (const arma\+::vec \&point)
\begin{DoxyCompactList}\small\item\em Shrink the bound object of this node for the removal of a point. \end{DoxyCompactList}\item 
void {\bf Soft\+Delete} ()
\begin{DoxyCompactList}\small\item\em Delete this node of the tree, but leave the stuff contained in it intact. \end{DoxyCompactList}\item 
const Statistic\+Type \& {\bf Stat} () const 
\begin{DoxyCompactList}\small\item\em Return the statistic object for this node. \end{DoxyCompactList}\item 
Statistic\+Type \& {\bf Stat} ()
\begin{DoxyCompactList}\small\item\em Modify the statistic object for this node. \end{DoxyCompactList}\item 
size\+\_\+t {\bf Tree\+Depth} () const 
\begin{DoxyCompactList}\small\item\em Obtains the number of levels below this node in the tree, starting with this. \end{DoxyCompactList}\item 
size\+\_\+t {\bf Tree\+Size} () const 
\begin{DoxyCompactList}\small\item\em Obtains the number of nodes in the tree, starting with this. \end{DoxyCompactList}\end{DoxyCompactItemize}
\subsection*{Protected Member Functions}
\begin{DoxyCompactItemize}
\item 
{\bf Rectangle\+Tree} ()
\begin{DoxyCompactList}\small\item\em A default constructor. \end{DoxyCompactList}\end{DoxyCompactItemize}
\subsection*{Protected Attributes}
\begin{DoxyCompactItemize}
\item 
friend {\bf Auxiliary\+Information}
\begin{DoxyCompactList}\small\item\em Give friend access for Auxiliary\+Information\+Type. \end{DoxyCompactList}\item 
friend {\bf Descent\+Type}
\begin{DoxyCompactList}\small\item\em Give friend access for Descent\+Type. \end{DoxyCompactList}\item 
friend {\bf Split\+Type}
\begin{DoxyCompactList}\small\item\em Give friend access for Split\+Type. \end{DoxyCompactList}\end{DoxyCompactItemize}
\subsection*{Private Member Functions}
\begin{DoxyCompactItemize}
\item 
void {\bf Split\+Node} (std\+::vector$<$ bool $>$ \&relevels)
\begin{DoxyCompactList}\small\item\em Splits the current node, recursing up the tree. \end{DoxyCompactList}\end{DoxyCompactItemize}
\subsection*{Private Attributes}
\begin{DoxyCompactItemize}
\item 
Auxiliary\+Information\+Type$<$ {\bf Rectangle\+Tree} $>$ {\bf auxiliary\+Info}
\begin{DoxyCompactList}\small\item\em A tree-\/specific information. \end{DoxyCompactList}\item 
size\+\_\+t {\bf begin}
\begin{DoxyCompactList}\small\item\em The index of the first point in the dataset contained in this node (and its children). \end{DoxyCompactList}\item 
{\bf bound\+::\+H\+Rect\+Bound}$<$ {\bf metric\+::\+Euclidean\+Distance}, {\bf Elem\+Type} $>$ {\bf bound}
\begin{DoxyCompactList}\small\item\em The bound object for this node. \end{DoxyCompactList}\item 
std\+::vector$<$ {\bf Rectangle\+Tree} $\ast$ $>$ {\bf children}
\begin{DoxyCompactList}\small\item\em The child nodes (Starting at 0 and ending at (num\+Children-\/1) ). \end{DoxyCompactList}\item 
size\+\_\+t {\bf count}
\begin{DoxyCompactList}\small\item\em The number of points in the dataset contained in this node (and its children). \end{DoxyCompactList}\item 
const Mat\+Type $\ast$ {\bf dataset}
\begin{DoxyCompactList}\small\item\em The dataset. \end{DoxyCompactList}\item 
size\+\_\+t {\bf max\+Leaf\+Size}
\begin{DoxyCompactList}\small\item\em The max leaf size. \end{DoxyCompactList}\item 
size\+\_\+t {\bf max\+Num\+Children}
\begin{DoxyCompactList}\small\item\em The max number of child nodes a non-\/leaf node can have. \end{DoxyCompactList}\item 
size\+\_\+t {\bf min\+Leaf\+Size}
\begin{DoxyCompactList}\small\item\em The minimum leaf size. \end{DoxyCompactList}\item 
size\+\_\+t {\bf min\+Num\+Children}
\begin{DoxyCompactList}\small\item\em The minimum number of child nodes a non-\/leaf node can have. \end{DoxyCompactList}\item 
size\+\_\+t {\bf num\+Children}
\begin{DoxyCompactList}\small\item\em The number of child nodes actually in use (0 if this is a leaf node). \end{DoxyCompactList}\item 
size\+\_\+t {\bf num\+Descendants}
\begin{DoxyCompactList}\small\item\em The number of descendants of this node. \end{DoxyCompactList}\item 
bool {\bf owns\+Dataset}
\begin{DoxyCompactList}\small\item\em Whether or not we are responsible for deleting the dataset. \end{DoxyCompactList}\item 
{\bf Rectangle\+Tree} $\ast$ {\bf parent}
\begin{DoxyCompactList}\small\item\em The parent node (N\+U\+LL if this is the root of the tree). \end{DoxyCompactList}\item 
{\bf Elem\+Type} {\bf parent\+Distance}
\begin{DoxyCompactList}\small\item\em The distance from the centroid of this node to the centroid of the parent. \end{DoxyCompactList}\item 
std\+::vector$<$ size\+\_\+t $>$ {\bf points}
\begin{DoxyCompactList}\small\item\em The mapping to the dataset. \end{DoxyCompactList}\item 
Statistic\+Type {\bf stat}
\begin{DoxyCompactList}\small\item\em Any extra data contained in the node. \end{DoxyCompactList}\end{DoxyCompactItemize}


\subsection{Detailed Description}
\subsubsection*{template$<$typename Metric\+Type = metric\+::\+Euclidean\+Distance, typename Statistic\+Type = Empty\+Statistic, typename Mat\+Type = arma\+::mat, typename Split\+Type = R\+Tree\+Split, typename Descent\+Type = R\+Tree\+Descent\+Heuristic, template$<$ typename $>$ class Auxiliary\+Information\+Type = No\+Auxiliary\+Information$>$\\*
class mlpack\+::tree\+::\+Rectangle\+Tree$<$ Metric\+Type, Statistic\+Type, Mat\+Type, Split\+Type, Descent\+Type, Auxiliary\+Information\+Type $>$}

A rectangle type tree tree, such as an R-\/tree or X-\/tree. 

Once the bound and type of dataset is defined, the tree will construct itself. Call the constructor with the dataset to build the tree on, and the entire tree will be built.

This tree does allow growth, so you can add and delete nodes from it.


\begin{DoxyTemplParams}{Template Parameters}
{\em Metric\+Type} & This {\itshape must} be Euclidean\+Distance, but the template parameter is required to satisfy the Tree\+Type A\+PI. \\
\hline
{\em Statistic\+Type} & Extra data contained in the node. See \doxyref{statistic.\+hpp}{p.}{statistic_8hpp} for the necessary skeleton interface. \\
\hline
{\em Mat\+Type} & The dataset class. \\
\hline
{\em Split\+Type} & The type of split to use when inserting points. \\
\hline
{\em Descent\+Type} & The heuristic to use when descending the tree to insert points. \\
\hline
{\em Auxiliary\+Information\+Type} & An auxiliary information contained in the node. This information depends on the type of the \doxyref{Rectangle\+Tree}{p.}{classmlpack_1_1tree_1_1RectangleTree}. \\
\hline
\end{DoxyTemplParams}


Definition at line 53 of file rectangle\+\_\+tree.\+hpp.



\subsection{Member Typedef Documentation}
\index{mlpack\+::tree\+::\+Rectangle\+Tree@{mlpack\+::tree\+::\+Rectangle\+Tree}!Auxiliary\+Information@{Auxiliary\+Information}}
\index{Auxiliary\+Information@{Auxiliary\+Information}!mlpack\+::tree\+::\+Rectangle\+Tree@{mlpack\+::tree\+::\+Rectangle\+Tree}}
\subsubsection[{Auxiliary\+Information}]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename Metric\+Type  = metric\+::\+Euclidean\+Distance, typename Statistic\+Type  = Empty\+Statistic, typename Mat\+Type  = arma\+::mat, typename Split\+Type  = R\+Tree\+Split, typename Descent\+Type  = R\+Tree\+Descent\+Heuristic, template$<$ typename $>$ class Auxiliary\+Information\+Type = No\+Auxiliary\+Information$>$ typedef Auxiliary\+Information\+Type$<${\bf Rectangle\+Tree}$>$ {\bf mlpack\+::tree\+::\+Rectangle\+Tree}$<$ Metric\+Type, Statistic\+Type, Mat\+Type, {\bf Split\+Type}, {\bf Descent\+Type}, Auxiliary\+Information\+Type $>$\+::{\bf Auxiliary\+Information}}\label{classmlpack_1_1tree_1_1RectangleTree_a50b508976eca72364518aa1623a664f1}


The auxiliary information type held by the tree. 



Definition at line 65 of file rectangle\+\_\+tree.\+hpp.

\index{mlpack\+::tree\+::\+Rectangle\+Tree@{mlpack\+::tree\+::\+Rectangle\+Tree}!Elem\+Type@{Elem\+Type}}
\index{Elem\+Type@{Elem\+Type}!mlpack\+::tree\+::\+Rectangle\+Tree@{mlpack\+::tree\+::\+Rectangle\+Tree}}
\subsubsection[{Elem\+Type}]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename Metric\+Type  = metric\+::\+Euclidean\+Distance, typename Statistic\+Type  = Empty\+Statistic, typename Mat\+Type  = arma\+::mat, typename Split\+Type  = R\+Tree\+Split, typename Descent\+Type  = R\+Tree\+Descent\+Heuristic, template$<$ typename $>$ class Auxiliary\+Information\+Type = No\+Auxiliary\+Information$>$ typedef Mat\+Type\+::elem\+\_\+type {\bf mlpack\+::tree\+::\+Rectangle\+Tree}$<$ Metric\+Type, Statistic\+Type, Mat\+Type, {\bf Split\+Type}, {\bf Descent\+Type}, Auxiliary\+Information\+Type $>$\+::{\bf Elem\+Type}}\label{classmlpack_1_1tree_1_1RectangleTree_aa75d976c5611214d9e9749e844877ce2}


The element type held by the matrix type. 



Definition at line 63 of file rectangle\+\_\+tree.\+hpp.

\index{mlpack\+::tree\+::\+Rectangle\+Tree@{mlpack\+::tree\+::\+Rectangle\+Tree}!Mat@{Mat}}
\index{Mat@{Mat}!mlpack\+::tree\+::\+Rectangle\+Tree@{mlpack\+::tree\+::\+Rectangle\+Tree}}
\subsubsection[{Mat}]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename Metric\+Type  = metric\+::\+Euclidean\+Distance, typename Statistic\+Type  = Empty\+Statistic, typename Mat\+Type  = arma\+::mat, typename Split\+Type  = R\+Tree\+Split, typename Descent\+Type  = R\+Tree\+Descent\+Heuristic, template$<$ typename $>$ class Auxiliary\+Information\+Type = No\+Auxiliary\+Information$>$ typedef Mat\+Type {\bf mlpack\+::tree\+::\+Rectangle\+Tree}$<$ Metric\+Type, Statistic\+Type, Mat\+Type, {\bf Split\+Type}, {\bf Descent\+Type}, Auxiliary\+Information\+Type $>$\+::{\bf Mat}}\label{classmlpack_1_1tree_1_1RectangleTree_abd25d752b4eca6f67d91343bdd50ff1b}


So other classes can use Tree\+Type\+::\+Mat. 



Definition at line 57 of file rectangle\+\_\+tree.\+hpp.



\subsection{Constructor \& Destructor Documentation}
\index{mlpack\+::tree\+::\+Rectangle\+Tree@{mlpack\+::tree\+::\+Rectangle\+Tree}!Rectangle\+Tree@{Rectangle\+Tree}}
\index{Rectangle\+Tree@{Rectangle\+Tree}!mlpack\+::tree\+::\+Rectangle\+Tree@{mlpack\+::tree\+::\+Rectangle\+Tree}}
\subsubsection[{Rectangle\+Tree(const Mat\+Type \&data, const size\+\_\+t max\+Leaf\+Size=20, const size\+\_\+t min\+Leaf\+Size=8, const size\+\_\+t max\+Num\+Children=5, const size\+\_\+t min\+Num\+Children=2, const size\+\_\+t first\+Data\+Index=0)}]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename Metric\+Type  = metric\+::\+Euclidean\+Distance, typename Statistic\+Type  = Empty\+Statistic, typename Mat\+Type  = arma\+::mat, typename Split\+Type  = R\+Tree\+Split, typename Descent\+Type  = R\+Tree\+Descent\+Heuristic, template$<$ typename $>$ class Auxiliary\+Information\+Type = No\+Auxiliary\+Information$>$ {\bf mlpack\+::tree\+::\+Rectangle\+Tree}$<$ Metric\+Type, Statistic\+Type, Mat\+Type, {\bf Split\+Type}, {\bf Descent\+Type}, Auxiliary\+Information\+Type $>$\+::{\bf Rectangle\+Tree} (
\begin{DoxyParamCaption}
\item[{const Mat\+Type \&}]{data, }
\item[{const size\+\_\+t}]{max\+Leaf\+Size = {\ttfamily 20}, }
\item[{const size\+\_\+t}]{min\+Leaf\+Size = {\ttfamily 8}, }
\item[{const size\+\_\+t}]{max\+Num\+Children = {\ttfamily 5}, }
\item[{const size\+\_\+t}]{min\+Num\+Children = {\ttfamily 2}, }
\item[{const size\+\_\+t}]{first\+Data\+Index = {\ttfamily 0}}
\end{DoxyParamCaption}
)}\label{classmlpack_1_1tree_1_1RectangleTree_a0d7d333256b052604b952f9325449451}


Construct this as the root node of a rectangle type tree using the given dataset. 

This will modify the ordering of the points in the dataset!


\begin{DoxyParams}{Parameters}
{\em data} & Dataset from which to create the tree. This will be modified! \\
\hline
{\em max\+Leaf\+Size} & Maximum size of each leaf in the tree. \\
\hline
{\em min\+Leaf\+Size} & Minimum size of each leaf in the tree. \\
\hline
{\em max\+Num\+Children} & The maximum number of child nodes a non-\/leaf node may have. \\
\hline
{\em min\+Num\+Children} & The minimum number of child nodes a non-\/leaf node may have. \\
\hline
{\em first\+Data\+Index} & The index of the first data point. U\+N\+U\+S\+ED U\+N\+L\+E\+SS WE A\+DD S\+U\+P\+P\+O\+RT F\+OR H\+A\+V\+I\+NG A \char`\"{}\+C\+E\+N\+T\+E\+R\+A\+L\char`\"{} D\+A\+TA M\+A\+T\+R\+IX. \\
\hline
\end{DoxyParams}
\index{mlpack\+::tree\+::\+Rectangle\+Tree@{mlpack\+::tree\+::\+Rectangle\+Tree}!Rectangle\+Tree@{Rectangle\+Tree}}
\index{Rectangle\+Tree@{Rectangle\+Tree}!mlpack\+::tree\+::\+Rectangle\+Tree@{mlpack\+::tree\+::\+Rectangle\+Tree}}
\subsubsection[{Rectangle\+Tree(\+Mat\+Type \&\&data, const size\+\_\+t max\+Leaf\+Size=20, const size\+\_\+t min\+Leaf\+Size=8, const size\+\_\+t max\+Num\+Children=5, const size\+\_\+t min\+Num\+Children=2, const size\+\_\+t first\+Data\+Index=0)}]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename Metric\+Type  = metric\+::\+Euclidean\+Distance, typename Statistic\+Type  = Empty\+Statistic, typename Mat\+Type  = arma\+::mat, typename Split\+Type  = R\+Tree\+Split, typename Descent\+Type  = R\+Tree\+Descent\+Heuristic, template$<$ typename $>$ class Auxiliary\+Information\+Type = No\+Auxiliary\+Information$>$ {\bf mlpack\+::tree\+::\+Rectangle\+Tree}$<$ Metric\+Type, Statistic\+Type, Mat\+Type, {\bf Split\+Type}, {\bf Descent\+Type}, Auxiliary\+Information\+Type $>$\+::{\bf Rectangle\+Tree} (
\begin{DoxyParamCaption}
\item[{Mat\+Type \&\&}]{data, }
\item[{const size\+\_\+t}]{max\+Leaf\+Size = {\ttfamily 20}, }
\item[{const size\+\_\+t}]{min\+Leaf\+Size = {\ttfamily 8}, }
\item[{const size\+\_\+t}]{max\+Num\+Children = {\ttfamily 5}, }
\item[{const size\+\_\+t}]{min\+Num\+Children = {\ttfamily 2}, }
\item[{const size\+\_\+t}]{first\+Data\+Index = {\ttfamily 0}}
\end{DoxyParamCaption}
)}\label{classmlpack_1_1tree_1_1RectangleTree_a23dda8640362387fa0615a44b9801fa0}


Construct this as the root node of a rectangle tree type using the given dataset, and taking ownership of the given dataset. 


\begin{DoxyParams}{Parameters}
{\em data} & Dataset from which to create the tree. \\
\hline
{\em max\+Leaf\+Size} & Maximum size of each leaf in the tree. \\
\hline
{\em min\+Leaf\+Size} & Minimum size of each leaf in the tree. \\
\hline
{\em max\+Num\+Children} & The maximum number of child nodes a non-\/leaf node may have. \\
\hline
{\em min\+Num\+Children} & The minimum number of child nodes a non-\/leaf node may have. \\
\hline
{\em first\+Data\+Index} & The index of the first data point. U\+N\+U\+S\+ED U\+N\+L\+E\+SS WE A\+DD S\+U\+P\+P\+O\+RT F\+OR H\+A\+V\+I\+NG A \char`\"{}\+C\+E\+N\+T\+E\+R\+A\+L\char`\"{} D\+A\+TA M\+A\+T\+R\+IX. \\
\hline
\end{DoxyParams}
\index{mlpack\+::tree\+::\+Rectangle\+Tree@{mlpack\+::tree\+::\+Rectangle\+Tree}!Rectangle\+Tree@{Rectangle\+Tree}}
\index{Rectangle\+Tree@{Rectangle\+Tree}!mlpack\+::tree\+::\+Rectangle\+Tree@{mlpack\+::tree\+::\+Rectangle\+Tree}}
\subsubsection[{Rectangle\+Tree(\+Rectangle\+Tree $\ast$parent\+Node, const size\+\_\+t num\+Max\+Children=0)}]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename Metric\+Type  = metric\+::\+Euclidean\+Distance, typename Statistic\+Type  = Empty\+Statistic, typename Mat\+Type  = arma\+::mat, typename Split\+Type  = R\+Tree\+Split, typename Descent\+Type  = R\+Tree\+Descent\+Heuristic, template$<$ typename $>$ class Auxiliary\+Information\+Type = No\+Auxiliary\+Information$>$ {\bf mlpack\+::tree\+::\+Rectangle\+Tree}$<$ Metric\+Type, Statistic\+Type, Mat\+Type, {\bf Split\+Type}, {\bf Descent\+Type}, Auxiliary\+Information\+Type $>$\+::{\bf Rectangle\+Tree} (
\begin{DoxyParamCaption}
\item[{{\bf Rectangle\+Tree}$<$ Metric\+Type, Statistic\+Type, Mat\+Type, {\bf Split\+Type}, {\bf Descent\+Type}, Auxiliary\+Information\+Type $>$ $\ast$}]{parent\+Node, }
\item[{const size\+\_\+t}]{num\+Max\+Children = {\ttfamily 0}}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [explicit]}}\label{classmlpack_1_1tree_1_1RectangleTree_a42f9044596dc95ce9b1954cb54449c29}


Construct this as an empty node with the specified parent. 

Copying the parameters (max\+Leaf\+Size, min\+Leaf\+Size, max\+Num\+Children, min\+Num\+Children, first\+Data\+Index) from the parent.


\begin{DoxyParams}{Parameters}
{\em parent\+Node} & The parent of the node that is being constructed. \\
\hline
{\em num\+Max\+Children} & The max number of child nodes (used in x-\/trees). \\
\hline
\end{DoxyParams}
\index{mlpack\+::tree\+::\+Rectangle\+Tree@{mlpack\+::tree\+::\+Rectangle\+Tree}!Rectangle\+Tree@{Rectangle\+Tree}}
\index{Rectangle\+Tree@{Rectangle\+Tree}!mlpack\+::tree\+::\+Rectangle\+Tree@{mlpack\+::tree\+::\+Rectangle\+Tree}}
\subsubsection[{Rectangle\+Tree(const Rectangle\+Tree \&other, const bool deep\+Copy=true, Rectangle\+Tree $\ast$new\+Parent=\+N\+U\+L\+L)}]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename Metric\+Type  = metric\+::\+Euclidean\+Distance, typename Statistic\+Type  = Empty\+Statistic, typename Mat\+Type  = arma\+::mat, typename Split\+Type  = R\+Tree\+Split, typename Descent\+Type  = R\+Tree\+Descent\+Heuristic, template$<$ typename $>$ class Auxiliary\+Information\+Type = No\+Auxiliary\+Information$>$ {\bf mlpack\+::tree\+::\+Rectangle\+Tree}$<$ Metric\+Type, Statistic\+Type, Mat\+Type, {\bf Split\+Type}, {\bf Descent\+Type}, Auxiliary\+Information\+Type $>$\+::{\bf Rectangle\+Tree} (
\begin{DoxyParamCaption}
\item[{const {\bf Rectangle\+Tree}$<$ Metric\+Type, Statistic\+Type, Mat\+Type, {\bf Split\+Type}, {\bf Descent\+Type}, Auxiliary\+Information\+Type $>$ \&}]{other, }
\item[{const bool}]{deep\+Copy = {\ttfamily true}, }
\item[{{\bf Rectangle\+Tree}$<$ Metric\+Type, Statistic\+Type, Mat\+Type, {\bf Split\+Type}, {\bf Descent\+Type}, Auxiliary\+Information\+Type $>$ $\ast$}]{new\+Parent = {\ttfamily NULL}}
\end{DoxyParamCaption}
)}\label{classmlpack_1_1tree_1_1RectangleTree_a4c521692ca76706d68bad3ed7b47f26a}


Create a rectangle tree by copying the other tree. 

Be careful! This can take a long time and use a lot of memory.


\begin{DoxyParams}{Parameters}
{\em other} & The tree to be copied. \\
\hline
{\em deep\+Copy} & If false, the children are not recursively copied. \\
\hline
\end{DoxyParams}
\index{mlpack\+::tree\+::\+Rectangle\+Tree@{mlpack\+::tree\+::\+Rectangle\+Tree}!Rectangle\+Tree@{Rectangle\+Tree}}
\index{Rectangle\+Tree@{Rectangle\+Tree}!mlpack\+::tree\+::\+Rectangle\+Tree@{mlpack\+::tree\+::\+Rectangle\+Tree}}
\subsubsection[{Rectangle\+Tree(\+Rectangle\+Tree \&\&other)}]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename Metric\+Type  = metric\+::\+Euclidean\+Distance, typename Statistic\+Type  = Empty\+Statistic, typename Mat\+Type  = arma\+::mat, typename Split\+Type  = R\+Tree\+Split, typename Descent\+Type  = R\+Tree\+Descent\+Heuristic, template$<$ typename $>$ class Auxiliary\+Information\+Type = No\+Auxiliary\+Information$>$ {\bf mlpack\+::tree\+::\+Rectangle\+Tree}$<$ Metric\+Type, Statistic\+Type, Mat\+Type, {\bf Split\+Type}, {\bf Descent\+Type}, Auxiliary\+Information\+Type $>$\+::{\bf Rectangle\+Tree} (
\begin{DoxyParamCaption}
\item[{{\bf Rectangle\+Tree}$<$ Metric\+Type, Statistic\+Type, Mat\+Type, {\bf Split\+Type}, {\bf Descent\+Type}, Auxiliary\+Information\+Type $>$ \&\&}]{other}
\end{DoxyParamCaption}
)}\label{classmlpack_1_1tree_1_1RectangleTree_adb9ea0f5c1160b70020a876a66675acc}


Create a rectangle tree by moving the other tree. 


\begin{DoxyParams}{Parameters}
{\em other} & The tree to be copied. \\
\hline
\end{DoxyParams}
\index{mlpack\+::tree\+::\+Rectangle\+Tree@{mlpack\+::tree\+::\+Rectangle\+Tree}!Rectangle\+Tree@{Rectangle\+Tree}}
\index{Rectangle\+Tree@{Rectangle\+Tree}!mlpack\+::tree\+::\+Rectangle\+Tree@{mlpack\+::tree\+::\+Rectangle\+Tree}}
\subsubsection[{Rectangle\+Tree(\+Archive \&ar, const typename std\+::enable\+\_\+if\+\_\+t$<$ Archive\+::is\+\_\+loading\+::value $>$ $\ast$=0)}]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename Metric\+Type  = metric\+::\+Euclidean\+Distance, typename Statistic\+Type  = Empty\+Statistic, typename Mat\+Type  = arma\+::mat, typename Split\+Type  = R\+Tree\+Split, typename Descent\+Type  = R\+Tree\+Descent\+Heuristic, template$<$ typename $>$ class Auxiliary\+Information\+Type = No\+Auxiliary\+Information$>$ template$<$typename Archive $>$ {\bf mlpack\+::tree\+::\+Rectangle\+Tree}$<$ Metric\+Type, Statistic\+Type, Mat\+Type, {\bf Split\+Type}, {\bf Descent\+Type}, Auxiliary\+Information\+Type $>$\+::{\bf Rectangle\+Tree} (
\begin{DoxyParamCaption}
\item[{Archive \&}]{ar, }
\item[{const typename {\bf std\+::enable\+\_\+if\+\_\+t}$<$ Archive\+::is\+\_\+loading\+::value $>$ $\ast$}]{ = {\ttfamily 0}}
\end{DoxyParamCaption}
)}\label{classmlpack_1_1tree_1_1RectangleTree_a739effe1e455985132deabe63fc1889d}


Construct the tree from a \doxyref{boost\+::serialization}{p.}{namespaceboost_1_1serialization} archive. 

\index{mlpack\+::tree\+::\+Rectangle\+Tree@{mlpack\+::tree\+::\+Rectangle\+Tree}!````~Rectangle\+Tree@{$\sim$\+Rectangle\+Tree}}
\index{````~Rectangle\+Tree@{$\sim$\+Rectangle\+Tree}!mlpack\+::tree\+::\+Rectangle\+Tree@{mlpack\+::tree\+::\+Rectangle\+Tree}}
\subsubsection[{$\sim$\+Rectangle\+Tree()}]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename Metric\+Type  = metric\+::\+Euclidean\+Distance, typename Statistic\+Type  = Empty\+Statistic, typename Mat\+Type  = arma\+::mat, typename Split\+Type  = R\+Tree\+Split, typename Descent\+Type  = R\+Tree\+Descent\+Heuristic, template$<$ typename $>$ class Auxiliary\+Information\+Type = No\+Auxiliary\+Information$>$ {\bf mlpack\+::tree\+::\+Rectangle\+Tree}$<$ Metric\+Type, Statistic\+Type, Mat\+Type, {\bf Split\+Type}, {\bf Descent\+Type}, Auxiliary\+Information\+Type $>$\+::$\sim${\bf Rectangle\+Tree} (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)}\label{classmlpack_1_1tree_1_1RectangleTree_a0fcda9c16e79413a73d137644950ebdb}


Deletes this node, deallocating the memory for the children and calling their destructors in turn. 

This will invalidate any younters or references to any nodes which are children of this one. \index{mlpack\+::tree\+::\+Rectangle\+Tree@{mlpack\+::tree\+::\+Rectangle\+Tree}!Rectangle\+Tree@{Rectangle\+Tree}}
\index{Rectangle\+Tree@{Rectangle\+Tree}!mlpack\+::tree\+::\+Rectangle\+Tree@{mlpack\+::tree\+::\+Rectangle\+Tree}}
\subsubsection[{Rectangle\+Tree()}]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename Metric\+Type  = metric\+::\+Euclidean\+Distance, typename Statistic\+Type  = Empty\+Statistic, typename Mat\+Type  = arma\+::mat, typename Split\+Type  = R\+Tree\+Split, typename Descent\+Type  = R\+Tree\+Descent\+Heuristic, template$<$ typename $>$ class Auxiliary\+Information\+Type = No\+Auxiliary\+Information$>$ {\bf mlpack\+::tree\+::\+Rectangle\+Tree}$<$ Metric\+Type, Statistic\+Type, Mat\+Type, {\bf Split\+Type}, {\bf Descent\+Type}, Auxiliary\+Information\+Type $>$\+::{\bf Rectangle\+Tree} (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [protected]}}\label{classmlpack_1_1tree_1_1RectangleTree_a0a65ef887779d8d086f56de15ff4f657}


A default constructor. 

This is meant to only be used with \doxyref{boost\+::serialization}{p.}{namespaceboost_1_1serialization}, which is allowed with the friend declaration below. This does not return a valid tree! This method must be protected, so that the serialization shim can work with the default constructor. 

Referenced by mlpack\+::tree\+::\+Rectangle\+Tree$<$ Metric\+Type, Statistic\+Type, Mat\+Type, Split\+Type, Descent\+Type, Auxiliary\+Information\+Type $>$\+::\+Count().



\subsection{Member Function Documentation}
\index{mlpack\+::tree\+::\+Rectangle\+Tree@{mlpack\+::tree\+::\+Rectangle\+Tree}!Auxiliary\+Info@{Auxiliary\+Info}}
\index{Auxiliary\+Info@{Auxiliary\+Info}!mlpack\+::tree\+::\+Rectangle\+Tree@{mlpack\+::tree\+::\+Rectangle\+Tree}}
\subsubsection[{Auxiliary\+Info() const }]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename Metric\+Type  = metric\+::\+Euclidean\+Distance, typename Statistic\+Type  = Empty\+Statistic, typename Mat\+Type  = arma\+::mat, typename Split\+Type  = R\+Tree\+Split, typename Descent\+Type  = R\+Tree\+Descent\+Heuristic, template$<$ typename $>$ class Auxiliary\+Information\+Type = No\+Auxiliary\+Information$>$ const Auxiliary\+Information\+Type$<${\bf Rectangle\+Tree}$>$\& {\bf mlpack\+::tree\+::\+Rectangle\+Tree}$<$ Metric\+Type, Statistic\+Type, Mat\+Type, {\bf Split\+Type}, {\bf Descent\+Type}, Auxiliary\+Information\+Type $>$\+::Auxiliary\+Info (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
) const\hspace{0.3cm}{\ttfamily [inline]}}\label{classmlpack_1_1tree_1_1RectangleTree_a2b73f6ee23da650834ff7afb210b6fd8}


Return the auxiliary information object of this node. 



Definition at line 309 of file rectangle\+\_\+tree.\+hpp.



References mlpack\+::tree\+::\+Rectangle\+Tree$<$ Metric\+Type, Statistic\+Type, Mat\+Type, Split\+Type, Descent\+Type, Auxiliary\+Information\+Type $>$\+::auxiliary\+Info.

\index{mlpack\+::tree\+::\+Rectangle\+Tree@{mlpack\+::tree\+::\+Rectangle\+Tree}!Auxiliary\+Info@{Auxiliary\+Info}}
\index{Auxiliary\+Info@{Auxiliary\+Info}!mlpack\+::tree\+::\+Rectangle\+Tree@{mlpack\+::tree\+::\+Rectangle\+Tree}}
\subsubsection[{Auxiliary\+Info()}]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename Metric\+Type  = metric\+::\+Euclidean\+Distance, typename Statistic\+Type  = Empty\+Statistic, typename Mat\+Type  = arma\+::mat, typename Split\+Type  = R\+Tree\+Split, typename Descent\+Type  = R\+Tree\+Descent\+Heuristic, template$<$ typename $>$ class Auxiliary\+Information\+Type = No\+Auxiliary\+Information$>$ Auxiliary\+Information\+Type$<${\bf Rectangle\+Tree}$>$\& {\bf mlpack\+::tree\+::\+Rectangle\+Tree}$<$ Metric\+Type, Statistic\+Type, Mat\+Type, {\bf Split\+Type}, {\bf Descent\+Type}, Auxiliary\+Information\+Type $>$\+::Auxiliary\+Info (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}}\label{classmlpack_1_1tree_1_1RectangleTree_a84083311e8e6fe23012c701a208072b4}


Modify the split object of this node. 



Definition at line 312 of file rectangle\+\_\+tree.\+hpp.



References mlpack\+::tree\+::\+Rectangle\+Tree$<$ Metric\+Type, Statistic\+Type, Mat\+Type, Split\+Type, Descent\+Type, Auxiliary\+Information\+Type $>$\+::auxiliary\+Info, and mlpack\+::tree\+::\+Rectangle\+Tree$<$ Metric\+Type, Statistic\+Type, Mat\+Type, Split\+Type, Descent\+Type, Auxiliary\+Information\+Type $>$\+::\+Is\+Leaf().

\index{mlpack\+::tree\+::\+Rectangle\+Tree@{mlpack\+::tree\+::\+Rectangle\+Tree}!Begin@{Begin}}
\index{Begin@{Begin}!mlpack\+::tree\+::\+Rectangle\+Tree@{mlpack\+::tree\+::\+Rectangle\+Tree}}
\subsubsection[{Begin() const }]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename Metric\+Type  = metric\+::\+Euclidean\+Distance, typename Statistic\+Type  = Empty\+Statistic, typename Mat\+Type  = arma\+::mat, typename Split\+Type  = R\+Tree\+Split, typename Descent\+Type  = R\+Tree\+Descent\+Heuristic, template$<$ typename $>$ class Auxiliary\+Information\+Type = No\+Auxiliary\+Information$>$ size\+\_\+t {\bf mlpack\+::tree\+::\+Rectangle\+Tree}$<$ Metric\+Type, Statistic\+Type, Mat\+Type, {\bf Split\+Type}, {\bf Descent\+Type}, Auxiliary\+Information\+Type $>$\+::Begin (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
) const\hspace{0.3cm}{\ttfamily [inline]}}\label{classmlpack_1_1tree_1_1RectangleTree_a8e6c2bfcdda3bc9114701a7e1106fde1}


Return the index of the beginning point of this subset. 



Definition at line 527 of file rectangle\+\_\+tree.\+hpp.



References mlpack\+::tree\+::\+Rectangle\+Tree$<$ Metric\+Type, Statistic\+Type, Mat\+Type, Split\+Type, Descent\+Type, Auxiliary\+Information\+Type $>$\+::begin.

\index{mlpack\+::tree\+::\+Rectangle\+Tree@{mlpack\+::tree\+::\+Rectangle\+Tree}!Begin@{Begin}}
\index{Begin@{Begin}!mlpack\+::tree\+::\+Rectangle\+Tree@{mlpack\+::tree\+::\+Rectangle\+Tree}}
\subsubsection[{Begin()}]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename Metric\+Type  = metric\+::\+Euclidean\+Distance, typename Statistic\+Type  = Empty\+Statistic, typename Mat\+Type  = arma\+::mat, typename Split\+Type  = R\+Tree\+Split, typename Descent\+Type  = R\+Tree\+Descent\+Heuristic, template$<$ typename $>$ class Auxiliary\+Information\+Type = No\+Auxiliary\+Information$>$ size\+\_\+t\& {\bf mlpack\+::tree\+::\+Rectangle\+Tree}$<$ Metric\+Type, Statistic\+Type, Mat\+Type, {\bf Split\+Type}, {\bf Descent\+Type}, Auxiliary\+Information\+Type $>$\+::Begin (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}}\label{classmlpack_1_1tree_1_1RectangleTree_aacf4cc65e032136bc307415db12fdf63}


Modify the index of the beginning point of this subset. 



Definition at line 529 of file rectangle\+\_\+tree.\+hpp.



References mlpack\+::tree\+::\+Rectangle\+Tree$<$ Metric\+Type, Statistic\+Type, Mat\+Type, Split\+Type, Descent\+Type, Auxiliary\+Information\+Type $>$\+::begin.

\index{mlpack\+::tree\+::\+Rectangle\+Tree@{mlpack\+::tree\+::\+Rectangle\+Tree}!Bound@{Bound}}
\index{Bound@{Bound}!mlpack\+::tree\+::\+Rectangle\+Tree@{mlpack\+::tree\+::\+Rectangle\+Tree}}
\subsubsection[{Bound() const }]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename Metric\+Type  = metric\+::\+Euclidean\+Distance, typename Statistic\+Type  = Empty\+Statistic, typename Mat\+Type  = arma\+::mat, typename Split\+Type  = R\+Tree\+Split, typename Descent\+Type  = R\+Tree\+Descent\+Heuristic, template$<$ typename $>$ class Auxiliary\+Information\+Type = No\+Auxiliary\+Information$>$ const {\bf bound\+::\+H\+Rect\+Bound}$<$Metric\+Type$>$\& {\bf mlpack\+::tree\+::\+Rectangle\+Tree}$<$ Metric\+Type, Statistic\+Type, Mat\+Type, {\bf Split\+Type}, {\bf Descent\+Type}, Auxiliary\+Information\+Type $>$\+::Bound (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
) const\hspace{0.3cm}{\ttfamily [inline]}}\label{classmlpack_1_1tree_1_1RectangleTree_a1981054082875530921edb8ebe1e64fa}


Return the bound object for this node. 



Definition at line 299 of file rectangle\+\_\+tree.\+hpp.



References mlpack\+::tree\+::\+Rectangle\+Tree$<$ Metric\+Type, Statistic\+Type, Mat\+Type, Split\+Type, Descent\+Type, Auxiliary\+Information\+Type $>$\+::bound.



Referenced by mlpack\+::tree\+::\+Rectangle\+Tree$<$ Metric\+Type, Statistic\+Type, Mat\+Type, Split\+Type, Descent\+Type, Auxiliary\+Information\+Type $>$\+::\+Max\+Distance(), mlpack\+::tree\+::\+Rectangle\+Tree$<$ Metric\+Type, Statistic\+Type, Mat\+Type, Split\+Type, Descent\+Type, Auxiliary\+Information\+Type $>$\+::\+Min\+Distance(), and mlpack\+::tree\+::\+Rectangle\+Tree$<$ Metric\+Type, Statistic\+Type, Mat\+Type, Split\+Type, Descent\+Type, Auxiliary\+Information\+Type $>$\+::\+Range\+Distance().

\index{mlpack\+::tree\+::\+Rectangle\+Tree@{mlpack\+::tree\+::\+Rectangle\+Tree}!Bound@{Bound}}
\index{Bound@{Bound}!mlpack\+::tree\+::\+Rectangle\+Tree@{mlpack\+::tree\+::\+Rectangle\+Tree}}
\subsubsection[{Bound()}]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename Metric\+Type  = metric\+::\+Euclidean\+Distance, typename Statistic\+Type  = Empty\+Statistic, typename Mat\+Type  = arma\+::mat, typename Split\+Type  = R\+Tree\+Split, typename Descent\+Type  = R\+Tree\+Descent\+Heuristic, template$<$ typename $>$ class Auxiliary\+Information\+Type = No\+Auxiliary\+Information$>$ {\bf bound\+::\+H\+Rect\+Bound}$<$Metric\+Type$>$\& {\bf mlpack\+::tree\+::\+Rectangle\+Tree}$<$ Metric\+Type, Statistic\+Type, Mat\+Type, {\bf Split\+Type}, {\bf Descent\+Type}, Auxiliary\+Information\+Type $>$\+::Bound (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}}\label{classmlpack_1_1tree_1_1RectangleTree_a7d07838301a85ca8e040a4367d3c4b95}


Modify the bound object for this node. 



Definition at line 301 of file rectangle\+\_\+tree.\+hpp.



References mlpack\+::tree\+::\+Rectangle\+Tree$<$ Metric\+Type, Statistic\+Type, Mat\+Type, Split\+Type, Descent\+Type, Auxiliary\+Information\+Type $>$\+::bound.

\index{mlpack\+::tree\+::\+Rectangle\+Tree@{mlpack\+::tree\+::\+Rectangle\+Tree}!Center@{Center}}
\index{Center@{Center}!mlpack\+::tree\+::\+Rectangle\+Tree@{mlpack\+::tree\+::\+Rectangle\+Tree}}
\subsubsection[{Center(arma\+::vec \&center)}]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename Metric\+Type  = metric\+::\+Euclidean\+Distance, typename Statistic\+Type  = Empty\+Statistic, typename Mat\+Type  = arma\+::mat, typename Split\+Type  = R\+Tree\+Split, typename Descent\+Type  = R\+Tree\+Descent\+Heuristic, template$<$ typename $>$ class Auxiliary\+Information\+Type = No\+Auxiliary\+Information$>$ void {\bf mlpack\+::tree\+::\+Rectangle\+Tree}$<$ Metric\+Type, Statistic\+Type, Mat\+Type, {\bf Split\+Type}, {\bf Descent\+Type}, Auxiliary\+Information\+Type $>$\+::Center (
\begin{DoxyParamCaption}
\item[{arma\+::vec \&}]{center}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}}\label{classmlpack_1_1tree_1_1RectangleTree_a14a6acf5ad9c6e288248c72d4c05824a}


Get the centroid of the node and store it in the given vector. 



Definition at line 352 of file rectangle\+\_\+tree.\+hpp.



References mlpack\+::bound\+::\+H\+Rect\+Bound$<$ Metric\+Type, Elem\+Type $>$\+::\+Center().

\index{mlpack\+::tree\+::\+Rectangle\+Tree@{mlpack\+::tree\+::\+Rectangle\+Tree}!Child@{Child}}
\index{Child@{Child}!mlpack\+::tree\+::\+Rectangle\+Tree@{mlpack\+::tree\+::\+Rectangle\+Tree}}
\subsubsection[{Child(const size\+\_\+t child) const }]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename Metric\+Type  = metric\+::\+Euclidean\+Distance, typename Statistic\+Type  = Empty\+Statistic, typename Mat\+Type  = arma\+::mat, typename Split\+Type  = R\+Tree\+Split, typename Descent\+Type  = R\+Tree\+Descent\+Heuristic, template$<$ typename $>$ class Auxiliary\+Information\+Type = No\+Auxiliary\+Information$>$ {\bf Rectangle\+Tree}\& {\bf mlpack\+::tree\+::\+Rectangle\+Tree}$<$ Metric\+Type, Statistic\+Type, Mat\+Type, {\bf Split\+Type}, {\bf Descent\+Type}, Auxiliary\+Information\+Type $>$\+::Child (
\begin{DoxyParamCaption}
\item[{const size\+\_\+t}]{child}
\end{DoxyParamCaption}
) const\hspace{0.3cm}{\ttfamily [inline]}}\label{classmlpack_1_1tree_1_1RectangleTree_a84f958edfd5b02f7fc82c8ee94d4b3c6}


Get the specified child. 


\begin{DoxyParams}{Parameters}
{\em child} & Index of child to return. \\
\hline
\end{DoxyParams}


Definition at line 421 of file rectangle\+\_\+tree.\+hpp.

\index{mlpack\+::tree\+::\+Rectangle\+Tree@{mlpack\+::tree\+::\+Rectangle\+Tree}!Child@{Child}}
\index{Child@{Child}!mlpack\+::tree\+::\+Rectangle\+Tree@{mlpack\+::tree\+::\+Rectangle\+Tree}}
\subsubsection[{Child(const size\+\_\+t child)}]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename Metric\+Type  = metric\+::\+Euclidean\+Distance, typename Statistic\+Type  = Empty\+Statistic, typename Mat\+Type  = arma\+::mat, typename Split\+Type  = R\+Tree\+Split, typename Descent\+Type  = R\+Tree\+Descent\+Heuristic, template$<$ typename $>$ class Auxiliary\+Information\+Type = No\+Auxiliary\+Information$>$ {\bf Rectangle\+Tree}\& {\bf mlpack\+::tree\+::\+Rectangle\+Tree}$<$ Metric\+Type, Statistic\+Type, Mat\+Type, {\bf Split\+Type}, {\bf Descent\+Type}, Auxiliary\+Information\+Type $>$\+::Child (
\begin{DoxyParamCaption}
\item[{const size\+\_\+t}]{child}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}}\label{classmlpack_1_1tree_1_1RectangleTree_afe4a23f661f296d8913fe4ec65782040}


Modify the specified child. 


\begin{DoxyParams}{Parameters}
{\em child} & Index of child to return. \\
\hline
\end{DoxyParams}


Definition at line 431 of file rectangle\+\_\+tree.\+hpp.



References mlpack\+::tree\+::\+Rectangle\+Tree$<$ Metric\+Type, Statistic\+Type, Mat\+Type, Split\+Type, Descent\+Type, Auxiliary\+Information\+Type $>$\+::\+Descendant(), mlpack\+::tree\+::\+Rectangle\+Tree$<$ Metric\+Type, Statistic\+Type, Mat\+Type, Split\+Type, Descent\+Type, Auxiliary\+Information\+Type $>$\+::\+Num\+Descendants(), and mlpack\+::tree\+::\+Rectangle\+Tree$<$ Metric\+Type, Statistic\+Type, Mat\+Type, Split\+Type, Descent\+Type, Auxiliary\+Information\+Type $>$\+::\+Num\+Points().

\index{mlpack\+::tree\+::\+Rectangle\+Tree@{mlpack\+::tree\+::\+Rectangle\+Tree}!Condense\+Tree@{Condense\+Tree}}
\index{Condense\+Tree@{Condense\+Tree}!mlpack\+::tree\+::\+Rectangle\+Tree@{mlpack\+::tree\+::\+Rectangle\+Tree}}
\subsubsection[{Condense\+Tree(const arma\+::vec \&point, std\+::vector$<$ bool $>$ \&relevels, const bool use\+Point)}]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename Metric\+Type  = metric\+::\+Euclidean\+Distance, typename Statistic\+Type  = Empty\+Statistic, typename Mat\+Type  = arma\+::mat, typename Split\+Type  = R\+Tree\+Split, typename Descent\+Type  = R\+Tree\+Descent\+Heuristic, template$<$ typename $>$ class Auxiliary\+Information\+Type = No\+Auxiliary\+Information$>$ void {\bf mlpack\+::tree\+::\+Rectangle\+Tree}$<$ Metric\+Type, Statistic\+Type, Mat\+Type, {\bf Split\+Type}, {\bf Descent\+Type}, Auxiliary\+Information\+Type $>$\+::Condense\+Tree (
\begin{DoxyParamCaption}
\item[{const arma\+::vec \&}]{point, }
\item[{std\+::vector$<$ bool $>$ \&}]{relevels, }
\item[{const bool}]{use\+Point}
\end{DoxyParamCaption}
)}\label{classmlpack_1_1tree_1_1RectangleTree_afe89ae84270b7504f23e3028c1e80fbf}


Condense the bounding rectangles for this node based on the removal of the point specified by the arma\+::vec\&. 

This recurses up the tree. If a node goes below the minimum fill, this function will fix the tree.


\begin{DoxyParams}{Parameters}
{\em point} & The arma\+::vec\& of the point that was removed to require this condesation of the tree. \\
\hline
{\em use\+Point} & True if we use the optimized version of the algorithm that is possible when we now what point was deleted. False otherwise (eg. if we deleted a node instead of a point). \\
\hline
\end{DoxyParams}
\index{mlpack\+::tree\+::\+Rectangle\+Tree@{mlpack\+::tree\+::\+Rectangle\+Tree}!Count@{Count}}
\index{Count@{Count}!mlpack\+::tree\+::\+Rectangle\+Tree@{mlpack\+::tree\+::\+Rectangle\+Tree}}
\subsubsection[{Count() const }]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename Metric\+Type  = metric\+::\+Euclidean\+Distance, typename Statistic\+Type  = Empty\+Statistic, typename Mat\+Type  = arma\+::mat, typename Split\+Type  = R\+Tree\+Split, typename Descent\+Type  = R\+Tree\+Descent\+Heuristic, template$<$ typename $>$ class Auxiliary\+Information\+Type = No\+Auxiliary\+Information$>$ size\+\_\+t {\bf mlpack\+::tree\+::\+Rectangle\+Tree}$<$ Metric\+Type, Statistic\+Type, Mat\+Type, {\bf Split\+Type}, {\bf Descent\+Type}, Auxiliary\+Information\+Type $>$\+::Count (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
) const\hspace{0.3cm}{\ttfamily [inline]}}\label{classmlpack_1_1tree_1_1RectangleTree_a3954773ba2d6df18dff98d6b9e5bedad}


Return the number of points in this subset. 



Definition at line 532 of file rectangle\+\_\+tree.\+hpp.



References mlpack\+::tree\+::\+Rectangle\+Tree$<$ Metric\+Type, Statistic\+Type, Mat\+Type, Split\+Type, Descent\+Type, Auxiliary\+Information\+Type $>$\+::count.

\index{mlpack\+::tree\+::\+Rectangle\+Tree@{mlpack\+::tree\+::\+Rectangle\+Tree}!Count@{Count}}
\index{Count@{Count}!mlpack\+::tree\+::\+Rectangle\+Tree@{mlpack\+::tree\+::\+Rectangle\+Tree}}
\subsubsection[{Count()}]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename Metric\+Type  = metric\+::\+Euclidean\+Distance, typename Statistic\+Type  = Empty\+Statistic, typename Mat\+Type  = arma\+::mat, typename Split\+Type  = R\+Tree\+Split, typename Descent\+Type  = R\+Tree\+Descent\+Heuristic, template$<$ typename $>$ class Auxiliary\+Information\+Type = No\+Auxiliary\+Information$>$ size\+\_\+t\& {\bf mlpack\+::tree\+::\+Rectangle\+Tree}$<$ Metric\+Type, Statistic\+Type, Mat\+Type, {\bf Split\+Type}, {\bf Descent\+Type}, Auxiliary\+Information\+Type $>$\+::Count (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}}\label{classmlpack_1_1tree_1_1RectangleTree_a7ff7aecab8ab4cc1e271ebed553a9e8c}


Modify the number of points in this subset. 



Definition at line 534 of file rectangle\+\_\+tree.\+hpp.



References mlpack\+::tree\+::\+Rectangle\+Tree$<$ Metric\+Type, Statistic\+Type, Mat\+Type, Split\+Type, Descent\+Type, Auxiliary\+Information\+Type $>$\+::count, mlpack\+::tree\+::\+Rectangle\+Tree$<$ Metric\+Type, Statistic\+Type, Mat\+Type, Split\+Type, Descent\+Type, Auxiliary\+Information\+Type $>$\+::\+Rectangle\+Tree(), and mlpack\+::tree\+::\+Rectangle\+Tree$<$ Metric\+Type, Statistic\+Type, Mat\+Type, Split\+Type, Descent\+Type, Auxiliary\+Information\+Type $>$\+::\+Split\+Node().

\index{mlpack\+::tree\+::\+Rectangle\+Tree@{mlpack\+::tree\+::\+Rectangle\+Tree}!Dataset@{Dataset}}
\index{Dataset@{Dataset}!mlpack\+::tree\+::\+Rectangle\+Tree@{mlpack\+::tree\+::\+Rectangle\+Tree}}
\subsubsection[{Dataset() const }]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename Metric\+Type  = metric\+::\+Euclidean\+Distance, typename Statistic\+Type  = Empty\+Statistic, typename Mat\+Type  = arma\+::mat, typename Split\+Type  = R\+Tree\+Split, typename Descent\+Type  = R\+Tree\+Descent\+Heuristic, template$<$ typename $>$ class Auxiliary\+Information\+Type = No\+Auxiliary\+Information$>$ const Mat\+Type\& {\bf mlpack\+::tree\+::\+Rectangle\+Tree}$<$ Metric\+Type, Statistic\+Type, Mat\+Type, {\bf Split\+Type}, {\bf Descent\+Type}, Auxiliary\+Information\+Type $>$\+::Dataset (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
) const\hspace{0.3cm}{\ttfamily [inline]}}\label{classmlpack_1_1tree_1_1RectangleTree_a8bae184394b0b44d314e3fe615409394}


Get the dataset which the tree is built on. 



Definition at line 344 of file rectangle\+\_\+tree.\+hpp.



References mlpack\+::tree\+::\+Rectangle\+Tree$<$ Metric\+Type, Statistic\+Type, Mat\+Type, Split\+Type, Descent\+Type, Auxiliary\+Information\+Type $>$\+::dataset.

\index{mlpack\+::tree\+::\+Rectangle\+Tree@{mlpack\+::tree\+::\+Rectangle\+Tree}!Dataset@{Dataset}}
\index{Dataset@{Dataset}!mlpack\+::tree\+::\+Rectangle\+Tree@{mlpack\+::tree\+::\+Rectangle\+Tree}}
\subsubsection[{Dataset()}]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename Metric\+Type  = metric\+::\+Euclidean\+Distance, typename Statistic\+Type  = Empty\+Statistic, typename Mat\+Type  = arma\+::mat, typename Split\+Type  = R\+Tree\+Split, typename Descent\+Type  = R\+Tree\+Descent\+Heuristic, template$<$ typename $>$ class Auxiliary\+Information\+Type = No\+Auxiliary\+Information$>$ Mat\+Type\& {\bf mlpack\+::tree\+::\+Rectangle\+Tree}$<$ Metric\+Type, Statistic\+Type, Mat\+Type, {\bf Split\+Type}, {\bf Descent\+Type}, Auxiliary\+Information\+Type $>$\+::Dataset (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}}\label{classmlpack_1_1tree_1_1RectangleTree_aac5cb5eee2c77ca34489008dbeb2d6f0}


Modify the dataset which the tree is built on. Be careful! 



Definition at line 346 of file rectangle\+\_\+tree.\+hpp.

\index{mlpack\+::tree\+::\+Rectangle\+Tree@{mlpack\+::tree\+::\+Rectangle\+Tree}!Delete\+Point@{Delete\+Point}}
\index{Delete\+Point@{Delete\+Point}!mlpack\+::tree\+::\+Rectangle\+Tree@{mlpack\+::tree\+::\+Rectangle\+Tree}}
\subsubsection[{Delete\+Point(const size\+\_\+t point)}]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename Metric\+Type  = metric\+::\+Euclidean\+Distance, typename Statistic\+Type  = Empty\+Statistic, typename Mat\+Type  = arma\+::mat, typename Split\+Type  = R\+Tree\+Split, typename Descent\+Type  = R\+Tree\+Descent\+Heuristic, template$<$ typename $>$ class Auxiliary\+Information\+Type = No\+Auxiliary\+Information$>$ bool {\bf mlpack\+::tree\+::\+Rectangle\+Tree}$<$ Metric\+Type, Statistic\+Type, Mat\+Type, {\bf Split\+Type}, {\bf Descent\+Type}, Auxiliary\+Information\+Type $>$\+::Delete\+Point (
\begin{DoxyParamCaption}
\item[{const size\+\_\+t}]{point}
\end{DoxyParamCaption}
)}\label{classmlpack_1_1tree_1_1RectangleTree_afea4ba63713c3deb25317a1500479171}


Deletes a point from the treeand, updates the bounding rectangle. 

However, the point will be kept in the centeral dataset. (The user may remove it from there if he wants, but he must not change the indices of the other points.) Returns true if the point is successfully removed and false if it is not. (ie. the point is not in the tree) \index{mlpack\+::tree\+::\+Rectangle\+Tree@{mlpack\+::tree\+::\+Rectangle\+Tree}!Delete\+Point@{Delete\+Point}}
\index{Delete\+Point@{Delete\+Point}!mlpack\+::tree\+::\+Rectangle\+Tree@{mlpack\+::tree\+::\+Rectangle\+Tree}}
\subsubsection[{Delete\+Point(const size\+\_\+t point, std\+::vector$<$ bool $>$ \&relevels)}]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename Metric\+Type  = metric\+::\+Euclidean\+Distance, typename Statistic\+Type  = Empty\+Statistic, typename Mat\+Type  = arma\+::mat, typename Split\+Type  = R\+Tree\+Split, typename Descent\+Type  = R\+Tree\+Descent\+Heuristic, template$<$ typename $>$ class Auxiliary\+Information\+Type = No\+Auxiliary\+Information$>$ bool {\bf mlpack\+::tree\+::\+Rectangle\+Tree}$<$ Metric\+Type, Statistic\+Type, Mat\+Type, {\bf Split\+Type}, {\bf Descent\+Type}, Auxiliary\+Information\+Type $>$\+::Delete\+Point (
\begin{DoxyParamCaption}
\item[{const size\+\_\+t}]{point, }
\item[{std\+::vector$<$ bool $>$ \&}]{relevels}
\end{DoxyParamCaption}
)}\label{classmlpack_1_1tree_1_1RectangleTree_aaaae5ac6d352d1bd8e70fa894ce6e201}


Deletes a point from the tree, updates the bounding rectangle, tracking levels. 

However, the point will be kept in the centeral dataset. (The user may remove it from there if he wants, but he must not change the indices of the other points.) Returns true if the point is successfully removed and false if it is not. (ie. the point is not in the tree) \index{mlpack\+::tree\+::\+Rectangle\+Tree@{mlpack\+::tree\+::\+Rectangle\+Tree}!Descendant@{Descendant}}
\index{Descendant@{Descendant}!mlpack\+::tree\+::\+Rectangle\+Tree@{mlpack\+::tree\+::\+Rectangle\+Tree}}
\subsubsection[{Descendant(const size\+\_\+t index) const }]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename Metric\+Type  = metric\+::\+Euclidean\+Distance, typename Statistic\+Type  = Empty\+Statistic, typename Mat\+Type  = arma\+::mat, typename Split\+Type  = R\+Tree\+Split, typename Descent\+Type  = R\+Tree\+Descent\+Heuristic, template$<$ typename $>$ class Auxiliary\+Information\+Type = No\+Auxiliary\+Information$>$ size\+\_\+t {\bf mlpack\+::tree\+::\+Rectangle\+Tree}$<$ Metric\+Type, Statistic\+Type, Mat\+Type, {\bf Split\+Type}, {\bf Descent\+Type}, Auxiliary\+Information\+Type $>$\+::Descendant (
\begin{DoxyParamCaption}
\item[{const size\+\_\+t}]{index}
\end{DoxyParamCaption}
) const}\label{classmlpack_1_1tree_1_1RectangleTree_a21e4ed5cf9c2f2c6aa8a21661687cb23}


Return the index (with reference to the dataset) of a particular descendant of this node. 

The index should be greater than zero but less than the number of descendants.


\begin{DoxyParams}{Parameters}
{\em index} & Index of the descendant. \\
\hline
\end{DoxyParams}


Referenced by mlpack\+::tree\+::\+Rectangle\+Tree$<$ Metric\+Type, Statistic\+Type, Mat\+Type, Split\+Type, Descent\+Type, Auxiliary\+Information\+Type $>$\+::\+Child().

\index{mlpack\+::tree\+::\+Rectangle\+Tree@{mlpack\+::tree\+::\+Rectangle\+Tree}!Exact\+Clone@{Exact\+Clone}}
\index{Exact\+Clone@{Exact\+Clone}!mlpack\+::tree\+::\+Rectangle\+Tree@{mlpack\+::tree\+::\+Rectangle\+Tree}}
\subsubsection[{Exact\+Clone()}]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename Metric\+Type  = metric\+::\+Euclidean\+Distance, typename Statistic\+Type  = Empty\+Statistic, typename Mat\+Type  = arma\+::mat, typename Split\+Type  = R\+Tree\+Split, typename Descent\+Type  = R\+Tree\+Descent\+Heuristic, template$<$ typename $>$ class Auxiliary\+Information\+Type = No\+Auxiliary\+Information$>$ {\bf Rectangle\+Tree}$\ast$ {\bf mlpack\+::tree\+::\+Rectangle\+Tree}$<$ Metric\+Type, Statistic\+Type, Mat\+Type, {\bf Split\+Type}, {\bf Descent\+Type}, Auxiliary\+Information\+Type $>$\+::Exact\+Clone (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)}\label{classmlpack_1_1tree_1_1RectangleTree_a0f1a70e2f087743676916c2a7855776c}


Make an exact copy of this node, pointers and everything. 

\index{mlpack\+::tree\+::\+Rectangle\+Tree@{mlpack\+::tree\+::\+Rectangle\+Tree}!Find\+By\+Begin\+Count@{Find\+By\+Begin\+Count}}
\index{Find\+By\+Begin\+Count@{Find\+By\+Begin\+Count}!mlpack\+::tree\+::\+Rectangle\+Tree@{mlpack\+::tree\+::\+Rectangle\+Tree}}
\subsubsection[{Find\+By\+Begin\+Count(size\+\_\+t begin, size\+\_\+t count) const }]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename Metric\+Type  = metric\+::\+Euclidean\+Distance, typename Statistic\+Type  = Empty\+Statistic, typename Mat\+Type  = arma\+::mat, typename Split\+Type  = R\+Tree\+Split, typename Descent\+Type  = R\+Tree\+Descent\+Heuristic, template$<$ typename $>$ class Auxiliary\+Information\+Type = No\+Auxiliary\+Information$>$ const {\bf Rectangle\+Tree}$\ast$ {\bf mlpack\+::tree\+::\+Rectangle\+Tree}$<$ Metric\+Type, Statistic\+Type, Mat\+Type, {\bf Split\+Type}, {\bf Descent\+Type}, Auxiliary\+Information\+Type $>$\+::Find\+By\+Begin\+Count (
\begin{DoxyParamCaption}
\item[{size\+\_\+t}]{begin, }
\item[{size\+\_\+t}]{count}
\end{DoxyParamCaption}
) const}\label{classmlpack_1_1tree_1_1RectangleTree_a57932b28735f7b1086b67dd5b9f6b904}


Find a node in this tree by its begin and count (const). 

Every node is uniquely identified by these two numbers. This is useful for communicating position over the network, when pointers would be invalid.


\begin{DoxyParams}{Parameters}
{\em begin} & The \doxyref{begin()}{p.}{classmlpack_1_1tree_1_1RectangleTree_a64d7a9888944babcf7b1bd658e8c3996} of the node to find. \\
\hline
{\em count} & The \doxyref{count()}{p.}{classmlpack_1_1tree_1_1RectangleTree_a6e46083ebbb6a00b65625e1e6eb89774} of the node to find. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
The found node, or N\+U\+LL if not found. 
\end{DoxyReturn}
\index{mlpack\+::tree\+::\+Rectangle\+Tree@{mlpack\+::tree\+::\+Rectangle\+Tree}!Find\+By\+Begin\+Count@{Find\+By\+Begin\+Count}}
\index{Find\+By\+Begin\+Count@{Find\+By\+Begin\+Count}!mlpack\+::tree\+::\+Rectangle\+Tree@{mlpack\+::tree\+::\+Rectangle\+Tree}}
\subsubsection[{Find\+By\+Begin\+Count(size\+\_\+t begin, size\+\_\+t count)}]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename Metric\+Type  = metric\+::\+Euclidean\+Distance, typename Statistic\+Type  = Empty\+Statistic, typename Mat\+Type  = arma\+::mat, typename Split\+Type  = R\+Tree\+Split, typename Descent\+Type  = R\+Tree\+Descent\+Heuristic, template$<$ typename $>$ class Auxiliary\+Information\+Type = No\+Auxiliary\+Information$>$ {\bf Rectangle\+Tree}$\ast$ {\bf mlpack\+::tree\+::\+Rectangle\+Tree}$<$ Metric\+Type, Statistic\+Type, Mat\+Type, {\bf Split\+Type}, {\bf Descent\+Type}, Auxiliary\+Information\+Type $>$\+::Find\+By\+Begin\+Count (
\begin{DoxyParamCaption}
\item[{size\+\_\+t}]{begin, }
\item[{size\+\_\+t}]{count}
\end{DoxyParamCaption}
)}\label{classmlpack_1_1tree_1_1RectangleTree_a4412b9d3f73fcc33b75b596238c4d6e2}


Find a node in this tree by its begin and count. 

Every node is uniquely identified by these two numbers. This is useful for communicating position over the network, when pointers would be invalid.


\begin{DoxyParams}{Parameters}
{\em begin} & The \doxyref{begin()}{p.}{classmlpack_1_1tree_1_1RectangleTree_a64d7a9888944babcf7b1bd658e8c3996} of the node to find. \\
\hline
{\em count} & The \doxyref{count()}{p.}{classmlpack_1_1tree_1_1RectangleTree_a6e46083ebbb6a00b65625e1e6eb89774} of the node to find. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
The found node, or N\+U\+LL if not found. 
\end{DoxyReturn}
\index{mlpack\+::tree\+::\+Rectangle\+Tree@{mlpack\+::tree\+::\+Rectangle\+Tree}!Furthest\+Descendant\+Distance@{Furthest\+Descendant\+Distance}}
\index{Furthest\+Descendant\+Distance@{Furthest\+Descendant\+Distance}!mlpack\+::tree\+::\+Rectangle\+Tree@{mlpack\+::tree\+::\+Rectangle\+Tree}}
\subsubsection[{Furthest\+Descendant\+Distance() const }]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename Metric\+Type  = metric\+::\+Euclidean\+Distance, typename Statistic\+Type  = Empty\+Statistic, typename Mat\+Type  = arma\+::mat, typename Split\+Type  = R\+Tree\+Split, typename Descent\+Type  = R\+Tree\+Descent\+Heuristic, template$<$ typename $>$ class Auxiliary\+Information\+Type = No\+Auxiliary\+Information$>$ {\bf Elem\+Type} {\bf mlpack\+::tree\+::\+Rectangle\+Tree}$<$ Metric\+Type, Statistic\+Type, Mat\+Type, {\bf Split\+Type}, {\bf Descent\+Type}, Auxiliary\+Information\+Type $>$\+::Furthest\+Descendant\+Distance (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
) const}\label{classmlpack_1_1tree_1_1RectangleTree_a9167b61658fe7275729a57bc362e9afc}


Return the furthest possible descendant distance. 

This returns the maximum distance from the centroid to the edge of the bound and not the empirical quantity which is the actual furthest descendant distance. So the actual furthest descendant distance may be less than what this method returns (but it will never be greater than this). 

Referenced by mlpack\+::tree\+::\+Rectangle\+Tree$<$ Metric\+Type, Statistic\+Type, Mat\+Type, Split\+Type, Descent\+Type, Auxiliary\+Information\+Type $>$\+::\+Num\+Children().

\index{mlpack\+::tree\+::\+Rectangle\+Tree@{mlpack\+::tree\+::\+Rectangle\+Tree}!Furthest\+Point\+Distance@{Furthest\+Point\+Distance}}
\index{Furthest\+Point\+Distance@{Furthest\+Point\+Distance}!mlpack\+::tree\+::\+Rectangle\+Tree@{mlpack\+::tree\+::\+Rectangle\+Tree}}
\subsubsection[{Furthest\+Point\+Distance() const }]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename Metric\+Type  = metric\+::\+Euclidean\+Distance, typename Statistic\+Type  = Empty\+Statistic, typename Mat\+Type  = arma\+::mat, typename Split\+Type  = R\+Tree\+Split, typename Descent\+Type  = R\+Tree\+Descent\+Heuristic, template$<$ typename $>$ class Auxiliary\+Information\+Type = No\+Auxiliary\+Information$>$ {\bf Elem\+Type} {\bf mlpack\+::tree\+::\+Rectangle\+Tree}$<$ Metric\+Type, Statistic\+Type, Mat\+Type, {\bf Split\+Type}, {\bf Descent\+Type}, Auxiliary\+Information\+Type $>$\+::Furthest\+Point\+Distance (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
) const}\label{classmlpack_1_1tree_1_1RectangleTree_a682b5d82004edc054aa4461f95df33c4}


Return the furthest distance to a point held in this node. 

If this is not a leaf node, then the distance is 0 because the node holds no points. 

Referenced by mlpack\+::tree\+::\+Rectangle\+Tree$<$ Metric\+Type, Statistic\+Type, Mat\+Type, Split\+Type, Descent\+Type, Auxiliary\+Information\+Type $>$\+::\+Num\+Children().

\index{mlpack\+::tree\+::\+Rectangle\+Tree@{mlpack\+::tree\+::\+Rectangle\+Tree}!Get\+Furthest\+Child@{Get\+Furthest\+Child}}
\index{Get\+Furthest\+Child@{Get\+Furthest\+Child}!mlpack\+::tree\+::\+Rectangle\+Tree@{mlpack\+::tree\+::\+Rectangle\+Tree}}
\subsubsection[{Get\+Furthest\+Child(const Vec\+Type \&point, typename std\+::enable\+\_\+if\+\_\+t$<$ Is\+Vector$<$ Vec\+Type $>$\+::value $>$ $\ast$=0)}]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename Metric\+Type  = metric\+::\+Euclidean\+Distance, typename Statistic\+Type  = Empty\+Statistic, typename Mat\+Type  = arma\+::mat, typename Split\+Type  = R\+Tree\+Split, typename Descent\+Type  = R\+Tree\+Descent\+Heuristic, template$<$ typename $>$ class Auxiliary\+Information\+Type = No\+Auxiliary\+Information$>$ template$<$typename Vec\+Type $>$ size\+\_\+t {\bf mlpack\+::tree\+::\+Rectangle\+Tree}$<$ Metric\+Type, Statistic\+Type, Mat\+Type, {\bf Split\+Type}, {\bf Descent\+Type}, Auxiliary\+Information\+Type $>$\+::Get\+Furthest\+Child (
\begin{DoxyParamCaption}
\item[{const Vec\+Type \&}]{point, }
\item[{typename {\bf std\+::enable\+\_\+if\+\_\+t}$<$ {\bf Is\+Vector}$<$ Vec\+Type $>$\+::value $>$ $\ast$}]{ = {\ttfamily 0}}
\end{DoxyParamCaption}
)}\label{classmlpack_1_1tree_1_1RectangleTree_a3a2a125a31a15ddaedd6971377a3786c}


Return the index of the furthest child node to the given query point. 

If this is a leaf node, it will return \doxyref{Num\+Children()}{p.}{classmlpack_1_1tree_1_1RectangleTree_a484a2e303a9d13e53ea1b607d07f4550} (invalid index). 

Referenced by mlpack\+::tree\+::\+Rectangle\+Tree$<$ Metric\+Type, Statistic\+Type, Mat\+Type, Split\+Type, Descent\+Type, Auxiliary\+Information\+Type $>$\+::\+Num\+Children().

\index{mlpack\+::tree\+::\+Rectangle\+Tree@{mlpack\+::tree\+::\+Rectangle\+Tree}!Get\+Furthest\+Child@{Get\+Furthest\+Child}}
\index{Get\+Furthest\+Child@{Get\+Furthest\+Child}!mlpack\+::tree\+::\+Rectangle\+Tree@{mlpack\+::tree\+::\+Rectangle\+Tree}}
\subsubsection[{Get\+Furthest\+Child(const Rectangle\+Tree \&query\+Node)}]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename Metric\+Type  = metric\+::\+Euclidean\+Distance, typename Statistic\+Type  = Empty\+Statistic, typename Mat\+Type  = arma\+::mat, typename Split\+Type  = R\+Tree\+Split, typename Descent\+Type  = R\+Tree\+Descent\+Heuristic, template$<$ typename $>$ class Auxiliary\+Information\+Type = No\+Auxiliary\+Information$>$ size\+\_\+t {\bf mlpack\+::tree\+::\+Rectangle\+Tree}$<$ Metric\+Type, Statistic\+Type, Mat\+Type, {\bf Split\+Type}, {\bf Descent\+Type}, Auxiliary\+Information\+Type $>$\+::Get\+Furthest\+Child (
\begin{DoxyParamCaption}
\item[{const {\bf Rectangle\+Tree}$<$ Metric\+Type, Statistic\+Type, Mat\+Type, {\bf Split\+Type}, {\bf Descent\+Type}, Auxiliary\+Information\+Type $>$ \&}]{query\+Node}
\end{DoxyParamCaption}
)}\label{classmlpack_1_1tree_1_1RectangleTree_afb1e645da67d2ad8244f3c030481f5ea}


Return the index of the furthest child node to the given query node. 

If it can\textquotesingle{}t decide, it will return \doxyref{Num\+Children()}{p.}{classmlpack_1_1tree_1_1RectangleTree_a484a2e303a9d13e53ea1b607d07f4550} (invalid index). \index{mlpack\+::tree\+::\+Rectangle\+Tree@{mlpack\+::tree\+::\+Rectangle\+Tree}!Get\+Nearest\+Child@{Get\+Nearest\+Child}}
\index{Get\+Nearest\+Child@{Get\+Nearest\+Child}!mlpack\+::tree\+::\+Rectangle\+Tree@{mlpack\+::tree\+::\+Rectangle\+Tree}}
\subsubsection[{Get\+Nearest\+Child(const Vec\+Type \&point, typename std\+::enable\+\_\+if\+\_\+t$<$ Is\+Vector$<$ Vec\+Type $>$\+::value $>$ $\ast$=0)}]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename Metric\+Type  = metric\+::\+Euclidean\+Distance, typename Statistic\+Type  = Empty\+Statistic, typename Mat\+Type  = arma\+::mat, typename Split\+Type  = R\+Tree\+Split, typename Descent\+Type  = R\+Tree\+Descent\+Heuristic, template$<$ typename $>$ class Auxiliary\+Information\+Type = No\+Auxiliary\+Information$>$ template$<$typename Vec\+Type $>$ size\+\_\+t {\bf mlpack\+::tree\+::\+Rectangle\+Tree}$<$ Metric\+Type, Statistic\+Type, Mat\+Type, {\bf Split\+Type}, {\bf Descent\+Type}, Auxiliary\+Information\+Type $>$\+::Get\+Nearest\+Child (
\begin{DoxyParamCaption}
\item[{const Vec\+Type \&}]{point, }
\item[{typename {\bf std\+::enable\+\_\+if\+\_\+t}$<$ {\bf Is\+Vector}$<$ Vec\+Type $>$\+::value $>$ $\ast$}]{ = {\ttfamily 0}}
\end{DoxyParamCaption}
)}\label{classmlpack_1_1tree_1_1RectangleTree_ae4bfcbfaf0683284513179c04b60f975}


Return the index of the nearest child node to the given query point. 

If this is a leaf node, it will return \doxyref{Num\+Children()}{p.}{classmlpack_1_1tree_1_1RectangleTree_a484a2e303a9d13e53ea1b607d07f4550} (invalid index). 

Referenced by mlpack\+::tree\+::\+Rectangle\+Tree$<$ Metric\+Type, Statistic\+Type, Mat\+Type, Split\+Type, Descent\+Type, Auxiliary\+Information\+Type $>$\+::\+Num\+Children().

\index{mlpack\+::tree\+::\+Rectangle\+Tree@{mlpack\+::tree\+::\+Rectangle\+Tree}!Get\+Nearest\+Child@{Get\+Nearest\+Child}}
\index{Get\+Nearest\+Child@{Get\+Nearest\+Child}!mlpack\+::tree\+::\+Rectangle\+Tree@{mlpack\+::tree\+::\+Rectangle\+Tree}}
\subsubsection[{Get\+Nearest\+Child(const Rectangle\+Tree \&query\+Node)}]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename Metric\+Type  = metric\+::\+Euclidean\+Distance, typename Statistic\+Type  = Empty\+Statistic, typename Mat\+Type  = arma\+::mat, typename Split\+Type  = R\+Tree\+Split, typename Descent\+Type  = R\+Tree\+Descent\+Heuristic, template$<$ typename $>$ class Auxiliary\+Information\+Type = No\+Auxiliary\+Information$>$ size\+\_\+t {\bf mlpack\+::tree\+::\+Rectangle\+Tree}$<$ Metric\+Type, Statistic\+Type, Mat\+Type, {\bf Split\+Type}, {\bf Descent\+Type}, Auxiliary\+Information\+Type $>$\+::Get\+Nearest\+Child (
\begin{DoxyParamCaption}
\item[{const {\bf Rectangle\+Tree}$<$ Metric\+Type, Statistic\+Type, Mat\+Type, {\bf Split\+Type}, {\bf Descent\+Type}, Auxiliary\+Information\+Type $>$ \&}]{query\+Node}
\end{DoxyParamCaption}
)}\label{classmlpack_1_1tree_1_1RectangleTree_aa0ec53643585bda72cf01770c968cf40}


Return the index of the nearest child node to the given query node. 

If it can\textquotesingle{}t decide, it will return \doxyref{Num\+Children()}{p.}{classmlpack_1_1tree_1_1RectangleTree_a484a2e303a9d13e53ea1b607d07f4550} (invalid index). \index{mlpack\+::tree\+::\+Rectangle\+Tree@{mlpack\+::tree\+::\+Rectangle\+Tree}!Insert\+Node@{Insert\+Node}}
\index{Insert\+Node@{Insert\+Node}!mlpack\+::tree\+::\+Rectangle\+Tree@{mlpack\+::tree\+::\+Rectangle\+Tree}}
\subsubsection[{Insert\+Node(\+Rectangle\+Tree $\ast$node, const size\+\_\+t level, std\+::vector$<$ bool $>$ \&relevels)}]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename Metric\+Type  = metric\+::\+Euclidean\+Distance, typename Statistic\+Type  = Empty\+Statistic, typename Mat\+Type  = arma\+::mat, typename Split\+Type  = R\+Tree\+Split, typename Descent\+Type  = R\+Tree\+Descent\+Heuristic, template$<$ typename $>$ class Auxiliary\+Information\+Type = No\+Auxiliary\+Information$>$ void {\bf mlpack\+::tree\+::\+Rectangle\+Tree}$<$ Metric\+Type, Statistic\+Type, Mat\+Type, {\bf Split\+Type}, {\bf Descent\+Type}, Auxiliary\+Information\+Type $>$\+::Insert\+Node (
\begin{DoxyParamCaption}
\item[{{\bf Rectangle\+Tree}$<$ Metric\+Type, Statistic\+Type, Mat\+Type, {\bf Split\+Type}, {\bf Descent\+Type}, Auxiliary\+Information\+Type $>$ $\ast$}]{node, }
\item[{const size\+\_\+t}]{level, }
\item[{std\+::vector$<$ bool $>$ \&}]{relevels}
\end{DoxyParamCaption}
)}\label{classmlpack_1_1tree_1_1RectangleTree_a4b113ca4f2e5679c9289bc6123d1d48b}


Inserts a node into the tree, tracking which levels have been inserted into. 

The node will be inserted so that the tree remains valid.


\begin{DoxyParams}{Parameters}
{\em node} & The node to be inserted. \\
\hline
{\em level} & The depth that should match the node where this node is finally inserted. This should be the number returned by calling \doxyref{Tree\+Depth()}{p.}{classmlpack_1_1tree_1_1RectangleTree_a3c015827f6306313b57e1e23dbbd1848} from the node that originally contained \char`\"{}node\char`\"{}. \\
\hline
{\em relevels} & The levels that have been reinserted to on this top level insertion. \\
\hline
\end{DoxyParams}
\index{mlpack\+::tree\+::\+Rectangle\+Tree@{mlpack\+::tree\+::\+Rectangle\+Tree}!Insert\+Point@{Insert\+Point}}
\index{Insert\+Point@{Insert\+Point}!mlpack\+::tree\+::\+Rectangle\+Tree@{mlpack\+::tree\+::\+Rectangle\+Tree}}
\subsubsection[{Insert\+Point(const size\+\_\+t point)}]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename Metric\+Type  = metric\+::\+Euclidean\+Distance, typename Statistic\+Type  = Empty\+Statistic, typename Mat\+Type  = arma\+::mat, typename Split\+Type  = R\+Tree\+Split, typename Descent\+Type  = R\+Tree\+Descent\+Heuristic, template$<$ typename $>$ class Auxiliary\+Information\+Type = No\+Auxiliary\+Information$>$ void {\bf mlpack\+::tree\+::\+Rectangle\+Tree}$<$ Metric\+Type, Statistic\+Type, Mat\+Type, {\bf Split\+Type}, {\bf Descent\+Type}, Auxiliary\+Information\+Type $>$\+::Insert\+Point (
\begin{DoxyParamCaption}
\item[{const size\+\_\+t}]{point}
\end{DoxyParamCaption}
)}\label{classmlpack_1_1tree_1_1RectangleTree_a5ebc8e2074e2645121e2061cdddfa021}


Inserts a point into the tree. 


\begin{DoxyParams}{Parameters}
{\em point} & The index of a point in the dataset. \\
\hline
\end{DoxyParams}
\index{mlpack\+::tree\+::\+Rectangle\+Tree@{mlpack\+::tree\+::\+Rectangle\+Tree}!Insert\+Point@{Insert\+Point}}
\index{Insert\+Point@{Insert\+Point}!mlpack\+::tree\+::\+Rectangle\+Tree@{mlpack\+::tree\+::\+Rectangle\+Tree}}
\subsubsection[{Insert\+Point(const size\+\_\+t point, std\+::vector$<$ bool $>$ \&relevels)}]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename Metric\+Type  = metric\+::\+Euclidean\+Distance, typename Statistic\+Type  = Empty\+Statistic, typename Mat\+Type  = arma\+::mat, typename Split\+Type  = R\+Tree\+Split, typename Descent\+Type  = R\+Tree\+Descent\+Heuristic, template$<$ typename $>$ class Auxiliary\+Information\+Type = No\+Auxiliary\+Information$>$ void {\bf mlpack\+::tree\+::\+Rectangle\+Tree}$<$ Metric\+Type, Statistic\+Type, Mat\+Type, {\bf Split\+Type}, {\bf Descent\+Type}, Auxiliary\+Information\+Type $>$\+::Insert\+Point (
\begin{DoxyParamCaption}
\item[{const size\+\_\+t}]{point, }
\item[{std\+::vector$<$ bool $>$ \&}]{relevels}
\end{DoxyParamCaption}
)}\label{classmlpack_1_1tree_1_1RectangleTree_a15342ec3e7b2244c8fda697033ea413a}


Inserts a point into the tree, tracking which levels have been inserted into. 


\begin{DoxyParams}{Parameters}
{\em point} & The index of a point in the dataset. \\
\hline
{\em relevels} & The levels that have been reinserted to on this top level insertion. \\
\hline
\end{DoxyParams}
\index{mlpack\+::tree\+::\+Rectangle\+Tree@{mlpack\+::tree\+::\+Rectangle\+Tree}!Is\+Leaf@{Is\+Leaf}}
\index{Is\+Leaf@{Is\+Leaf}!mlpack\+::tree\+::\+Rectangle\+Tree@{mlpack\+::tree\+::\+Rectangle\+Tree}}
\subsubsection[{Is\+Leaf() const }]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename Metric\+Type  = metric\+::\+Euclidean\+Distance, typename Statistic\+Type  = Empty\+Statistic, typename Mat\+Type  = arma\+::mat, typename Split\+Type  = R\+Tree\+Split, typename Descent\+Type  = R\+Tree\+Descent\+Heuristic, template$<$ typename $>$ class Auxiliary\+Information\+Type = No\+Auxiliary\+Information$>$ bool {\bf mlpack\+::tree\+::\+Rectangle\+Tree}$<$ Metric\+Type, Statistic\+Type, Mat\+Type, {\bf Split\+Type}, {\bf Descent\+Type}, Auxiliary\+Information\+Type $>$\+::Is\+Leaf (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
) const}\label{classmlpack_1_1tree_1_1RectangleTree_a917fb4a2851cb9e6dd725d6856c1bb70}


Return whether or not this node is a leaf (true if it has no children). 



Referenced by mlpack\+::tree\+::\+Rectangle\+Tree$<$ Metric\+Type, Statistic\+Type, Mat\+Type, Split\+Type, Descent\+Type, Auxiliary\+Information\+Type $>$\+::\+Auxiliary\+Info().

\index{mlpack\+::tree\+::\+Rectangle\+Tree@{mlpack\+::tree\+::\+Rectangle\+Tree}!Max\+Distance@{Max\+Distance}}
\index{Max\+Distance@{Max\+Distance}!mlpack\+::tree\+::\+Rectangle\+Tree@{mlpack\+::tree\+::\+Rectangle\+Tree}}
\subsubsection[{Max\+Distance(const Rectangle\+Tree \&other) const }]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename Metric\+Type  = metric\+::\+Euclidean\+Distance, typename Statistic\+Type  = Empty\+Statistic, typename Mat\+Type  = arma\+::mat, typename Split\+Type  = R\+Tree\+Split, typename Descent\+Type  = R\+Tree\+Descent\+Heuristic, template$<$ typename $>$ class Auxiliary\+Information\+Type = No\+Auxiliary\+Information$>$ {\bf Elem\+Type} {\bf mlpack\+::tree\+::\+Rectangle\+Tree}$<$ Metric\+Type, Statistic\+Type, Mat\+Type, {\bf Split\+Type}, {\bf Descent\+Type}, Auxiliary\+Information\+Type $>$\+::Max\+Distance (
\begin{DoxyParamCaption}
\item[{const {\bf Rectangle\+Tree}$<$ Metric\+Type, Statistic\+Type, Mat\+Type, {\bf Split\+Type}, {\bf Descent\+Type}, Auxiliary\+Information\+Type $>$ \&}]{other}
\end{DoxyParamCaption}
) const\hspace{0.3cm}{\ttfamily [inline]}}\label{classmlpack_1_1tree_1_1RectangleTree_a426a9c2a4bf9d87b524d5f6f9188d7e6}


Return the maximum distance to another node. 



Definition at line 477 of file rectangle\+\_\+tree.\+hpp.



References mlpack\+::tree\+::\+Rectangle\+Tree$<$ Metric\+Type, Statistic\+Type, Mat\+Type, Split\+Type, Descent\+Type, Auxiliary\+Information\+Type $>$\+::\+Bound(), and mlpack\+::bound\+::\+H\+Rect\+Bound$<$ Metric\+Type, Elem\+Type $>$\+::\+Max\+Distance().

\index{mlpack\+::tree\+::\+Rectangle\+Tree@{mlpack\+::tree\+::\+Rectangle\+Tree}!Max\+Distance@{Max\+Distance}}
\index{Max\+Distance@{Max\+Distance}!mlpack\+::tree\+::\+Rectangle\+Tree@{mlpack\+::tree\+::\+Rectangle\+Tree}}
\subsubsection[{Max\+Distance(const Vec\+Type \&point, typename std\+::enable\+\_\+if\+\_\+t$<$ Is\+Vector$<$ Vec\+Type $>$\+::value $>$ $\ast$=0) const }]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename Metric\+Type  = metric\+::\+Euclidean\+Distance, typename Statistic\+Type  = Empty\+Statistic, typename Mat\+Type  = arma\+::mat, typename Split\+Type  = R\+Tree\+Split, typename Descent\+Type  = R\+Tree\+Descent\+Heuristic, template$<$ typename $>$ class Auxiliary\+Information\+Type = No\+Auxiliary\+Information$>$ template$<$typename Vec\+Type $>$ {\bf Elem\+Type} {\bf mlpack\+::tree\+::\+Rectangle\+Tree}$<$ Metric\+Type, Statistic\+Type, Mat\+Type, {\bf Split\+Type}, {\bf Descent\+Type}, Auxiliary\+Information\+Type $>$\+::Max\+Distance (
\begin{DoxyParamCaption}
\item[{const Vec\+Type \&}]{point, }
\item[{typename {\bf std\+::enable\+\_\+if\+\_\+t}$<$ {\bf Is\+Vector}$<$ Vec\+Type $>$\+::value $>$ $\ast$}]{ = {\ttfamily 0}}
\end{DoxyParamCaption}
) const\hspace{0.3cm}{\ttfamily [inline]}}\label{classmlpack_1_1tree_1_1RectangleTree_ada6bc6257ed47f8a27023c1a4a60a069}


Return the maximum distance to another point. 



Definition at line 499 of file rectangle\+\_\+tree.\+hpp.



References mlpack\+::bound\+::\+H\+Rect\+Bound$<$ Metric\+Type, Elem\+Type $>$\+::\+Max\+Distance().

\index{mlpack\+::tree\+::\+Rectangle\+Tree@{mlpack\+::tree\+::\+Rectangle\+Tree}!Max\+Leaf\+Size@{Max\+Leaf\+Size}}
\index{Max\+Leaf\+Size@{Max\+Leaf\+Size}!mlpack\+::tree\+::\+Rectangle\+Tree@{mlpack\+::tree\+::\+Rectangle\+Tree}}
\subsubsection[{Max\+Leaf\+Size() const }]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename Metric\+Type  = metric\+::\+Euclidean\+Distance, typename Statistic\+Type  = Empty\+Statistic, typename Mat\+Type  = arma\+::mat, typename Split\+Type  = R\+Tree\+Split, typename Descent\+Type  = R\+Tree\+Descent\+Heuristic, template$<$ typename $>$ class Auxiliary\+Information\+Type = No\+Auxiliary\+Information$>$ size\+\_\+t {\bf mlpack\+::tree\+::\+Rectangle\+Tree}$<$ Metric\+Type, Statistic\+Type, Mat\+Type, {\bf Split\+Type}, {\bf Descent\+Type}, Auxiliary\+Information\+Type $>$\+::Max\+Leaf\+Size (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
) const\hspace{0.3cm}{\ttfamily [inline]}}\label{classmlpack_1_1tree_1_1RectangleTree_a7349b0a6f92eef8850b5579d58f4738b}


Return the maximum leaf size. 



Definition at line 319 of file rectangle\+\_\+tree.\+hpp.



References mlpack\+::tree\+::\+Rectangle\+Tree$<$ Metric\+Type, Statistic\+Type, Mat\+Type, Split\+Type, Descent\+Type, Auxiliary\+Information\+Type $>$\+::max\+Leaf\+Size.

\index{mlpack\+::tree\+::\+Rectangle\+Tree@{mlpack\+::tree\+::\+Rectangle\+Tree}!Max\+Leaf\+Size@{Max\+Leaf\+Size}}
\index{Max\+Leaf\+Size@{Max\+Leaf\+Size}!mlpack\+::tree\+::\+Rectangle\+Tree@{mlpack\+::tree\+::\+Rectangle\+Tree}}
\subsubsection[{Max\+Leaf\+Size()}]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename Metric\+Type  = metric\+::\+Euclidean\+Distance, typename Statistic\+Type  = Empty\+Statistic, typename Mat\+Type  = arma\+::mat, typename Split\+Type  = R\+Tree\+Split, typename Descent\+Type  = R\+Tree\+Descent\+Heuristic, template$<$ typename $>$ class Auxiliary\+Information\+Type = No\+Auxiliary\+Information$>$ size\+\_\+t\& {\bf mlpack\+::tree\+::\+Rectangle\+Tree}$<$ Metric\+Type, Statistic\+Type, Mat\+Type, {\bf Split\+Type}, {\bf Descent\+Type}, Auxiliary\+Information\+Type $>$\+::Max\+Leaf\+Size (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}}\label{classmlpack_1_1tree_1_1RectangleTree_abefbbec31cb655468f4bfe345bc89d30}


Modify the maximum leaf size. 



Definition at line 321 of file rectangle\+\_\+tree.\+hpp.



References mlpack\+::tree\+::\+Rectangle\+Tree$<$ Metric\+Type, Statistic\+Type, Mat\+Type, Split\+Type, Descent\+Type, Auxiliary\+Information\+Type $>$\+::max\+Leaf\+Size.

\index{mlpack\+::tree\+::\+Rectangle\+Tree@{mlpack\+::tree\+::\+Rectangle\+Tree}!Max\+Num\+Children@{Max\+Num\+Children}}
\index{Max\+Num\+Children@{Max\+Num\+Children}!mlpack\+::tree\+::\+Rectangle\+Tree@{mlpack\+::tree\+::\+Rectangle\+Tree}}
\subsubsection[{Max\+Num\+Children() const }]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename Metric\+Type  = metric\+::\+Euclidean\+Distance, typename Statistic\+Type  = Empty\+Statistic, typename Mat\+Type  = arma\+::mat, typename Split\+Type  = R\+Tree\+Split, typename Descent\+Type  = R\+Tree\+Descent\+Heuristic, template$<$ typename $>$ class Auxiliary\+Information\+Type = No\+Auxiliary\+Information$>$ size\+\_\+t {\bf mlpack\+::tree\+::\+Rectangle\+Tree}$<$ Metric\+Type, Statistic\+Type, Mat\+Type, {\bf Split\+Type}, {\bf Descent\+Type}, Auxiliary\+Information\+Type $>$\+::Max\+Num\+Children (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
) const\hspace{0.3cm}{\ttfamily [inline]}}\label{classmlpack_1_1tree_1_1RectangleTree_a875919b52cccd0046a4521cec2cdc9ee}


Return the maximum number of children (in a non-\/leaf node). 



Definition at line 329 of file rectangle\+\_\+tree.\+hpp.



References mlpack\+::tree\+::\+Rectangle\+Tree$<$ Metric\+Type, Statistic\+Type, Mat\+Type, Split\+Type, Descent\+Type, Auxiliary\+Information\+Type $>$\+::max\+Num\+Children.

\index{mlpack\+::tree\+::\+Rectangle\+Tree@{mlpack\+::tree\+::\+Rectangle\+Tree}!Max\+Num\+Children@{Max\+Num\+Children}}
\index{Max\+Num\+Children@{Max\+Num\+Children}!mlpack\+::tree\+::\+Rectangle\+Tree@{mlpack\+::tree\+::\+Rectangle\+Tree}}
\subsubsection[{Max\+Num\+Children()}]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename Metric\+Type  = metric\+::\+Euclidean\+Distance, typename Statistic\+Type  = Empty\+Statistic, typename Mat\+Type  = arma\+::mat, typename Split\+Type  = R\+Tree\+Split, typename Descent\+Type  = R\+Tree\+Descent\+Heuristic, template$<$ typename $>$ class Auxiliary\+Information\+Type = No\+Auxiliary\+Information$>$ size\+\_\+t\& {\bf mlpack\+::tree\+::\+Rectangle\+Tree}$<$ Metric\+Type, Statistic\+Type, Mat\+Type, {\bf Split\+Type}, {\bf Descent\+Type}, Auxiliary\+Information\+Type $>$\+::Max\+Num\+Children (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}}\label{classmlpack_1_1tree_1_1RectangleTree_a260739727a7f1a881957f89b926af880}


Modify the maximum number of children (in a non-\/leaf node). 



Definition at line 331 of file rectangle\+\_\+tree.\+hpp.



References mlpack\+::tree\+::\+Rectangle\+Tree$<$ Metric\+Type, Statistic\+Type, Mat\+Type, Split\+Type, Descent\+Type, Auxiliary\+Information\+Type $>$\+::max\+Num\+Children.

\index{mlpack\+::tree\+::\+Rectangle\+Tree@{mlpack\+::tree\+::\+Rectangle\+Tree}!Metric@{Metric}}
\index{Metric@{Metric}!mlpack\+::tree\+::\+Rectangle\+Tree@{mlpack\+::tree\+::\+Rectangle\+Tree}}
\subsubsection[{Metric() const }]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename Metric\+Type  = metric\+::\+Euclidean\+Distance, typename Statistic\+Type  = Empty\+Statistic, typename Mat\+Type  = arma\+::mat, typename Split\+Type  = R\+Tree\+Split, typename Descent\+Type  = R\+Tree\+Descent\+Heuristic, template$<$ typename $>$ class Auxiliary\+Information\+Type = No\+Auxiliary\+Information$>$ Metric\+Type {\bf mlpack\+::tree\+::\+Rectangle\+Tree}$<$ Metric\+Type, Statistic\+Type, Mat\+Type, {\bf Split\+Type}, {\bf Descent\+Type}, Auxiliary\+Information\+Type $>$\+::Metric (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
) const\hspace{0.3cm}{\ttfamily [inline]}}\label{classmlpack_1_1tree_1_1RectangleTree_ad37e375f49ac9d31aa8c03c032a65c36}


Get the metric which the tree uses. 



Definition at line 349 of file rectangle\+\_\+tree.\+hpp.

\index{mlpack\+::tree\+::\+Rectangle\+Tree@{mlpack\+::tree\+::\+Rectangle\+Tree}!Min\+Distance@{Min\+Distance}}
\index{Min\+Distance@{Min\+Distance}!mlpack\+::tree\+::\+Rectangle\+Tree@{mlpack\+::tree\+::\+Rectangle\+Tree}}
\subsubsection[{Min\+Distance(const Rectangle\+Tree \&other) const }]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename Metric\+Type  = metric\+::\+Euclidean\+Distance, typename Statistic\+Type  = Empty\+Statistic, typename Mat\+Type  = arma\+::mat, typename Split\+Type  = R\+Tree\+Split, typename Descent\+Type  = R\+Tree\+Descent\+Heuristic, template$<$ typename $>$ class Auxiliary\+Information\+Type = No\+Auxiliary\+Information$>$ {\bf Elem\+Type} {\bf mlpack\+::tree\+::\+Rectangle\+Tree}$<$ Metric\+Type, Statistic\+Type, Mat\+Type, {\bf Split\+Type}, {\bf Descent\+Type}, Auxiliary\+Information\+Type $>$\+::Min\+Distance (
\begin{DoxyParamCaption}
\item[{const {\bf Rectangle\+Tree}$<$ Metric\+Type, Statistic\+Type, Mat\+Type, {\bf Split\+Type}, {\bf Descent\+Type}, Auxiliary\+Information\+Type $>$ \&}]{other}
\end{DoxyParamCaption}
) const\hspace{0.3cm}{\ttfamily [inline]}}\label{classmlpack_1_1tree_1_1RectangleTree_a9ca09b552bd4af961e546359488a5865}


Return the minimum distance to another node. 



Definition at line 471 of file rectangle\+\_\+tree.\+hpp.



References mlpack\+::tree\+::\+Rectangle\+Tree$<$ Metric\+Type, Statistic\+Type, Mat\+Type, Split\+Type, Descent\+Type, Auxiliary\+Information\+Type $>$\+::\+Bound(), and mlpack\+::bound\+::\+H\+Rect\+Bound$<$ Metric\+Type, Elem\+Type $>$\+::\+Min\+Distance().

\index{mlpack\+::tree\+::\+Rectangle\+Tree@{mlpack\+::tree\+::\+Rectangle\+Tree}!Min\+Distance@{Min\+Distance}}
\index{Min\+Distance@{Min\+Distance}!mlpack\+::tree\+::\+Rectangle\+Tree@{mlpack\+::tree\+::\+Rectangle\+Tree}}
\subsubsection[{Min\+Distance(const Vec\+Type \&point, typename std\+::enable\+\_\+if\+\_\+t$<$ Is\+Vector$<$ Vec\+Type $>$\+::value $>$ $\ast$=0) const }]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename Metric\+Type  = metric\+::\+Euclidean\+Distance, typename Statistic\+Type  = Empty\+Statistic, typename Mat\+Type  = arma\+::mat, typename Split\+Type  = R\+Tree\+Split, typename Descent\+Type  = R\+Tree\+Descent\+Heuristic, template$<$ typename $>$ class Auxiliary\+Information\+Type = No\+Auxiliary\+Information$>$ template$<$typename Vec\+Type $>$ {\bf Elem\+Type} {\bf mlpack\+::tree\+::\+Rectangle\+Tree}$<$ Metric\+Type, Statistic\+Type, Mat\+Type, {\bf Split\+Type}, {\bf Descent\+Type}, Auxiliary\+Information\+Type $>$\+::Min\+Distance (
\begin{DoxyParamCaption}
\item[{const Vec\+Type \&}]{point, }
\item[{typename {\bf std\+::enable\+\_\+if\+\_\+t}$<$ {\bf Is\+Vector}$<$ Vec\+Type $>$\+::value $>$ $\ast$}]{ = {\ttfamily 0}}
\end{DoxyParamCaption}
) const\hspace{0.3cm}{\ttfamily [inline]}}\label{classmlpack_1_1tree_1_1RectangleTree_a5cfbe61260459c326ea6706fa192ddcb}


Return the minimum distance to another point. 



Definition at line 490 of file rectangle\+\_\+tree.\+hpp.



References mlpack\+::bound\+::\+H\+Rect\+Bound$<$ Metric\+Type, Elem\+Type $>$\+::\+Min\+Distance().

\index{mlpack\+::tree\+::\+Rectangle\+Tree@{mlpack\+::tree\+::\+Rectangle\+Tree}!Minimum\+Bound\+Distance@{Minimum\+Bound\+Distance}}
\index{Minimum\+Bound\+Distance@{Minimum\+Bound\+Distance}!mlpack\+::tree\+::\+Rectangle\+Tree@{mlpack\+::tree\+::\+Rectangle\+Tree}}
\subsubsection[{Minimum\+Bound\+Distance() const }]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename Metric\+Type  = metric\+::\+Euclidean\+Distance, typename Statistic\+Type  = Empty\+Statistic, typename Mat\+Type  = arma\+::mat, typename Split\+Type  = R\+Tree\+Split, typename Descent\+Type  = R\+Tree\+Descent\+Heuristic, template$<$ typename $>$ class Auxiliary\+Information\+Type = No\+Auxiliary\+Information$>$ {\bf Elem\+Type} {\bf mlpack\+::tree\+::\+Rectangle\+Tree}$<$ Metric\+Type, Statistic\+Type, Mat\+Type, {\bf Split\+Type}, {\bf Descent\+Type}, Auxiliary\+Information\+Type $>$\+::Minimum\+Bound\+Distance (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
) const\hspace{0.3cm}{\ttfamily [inline]}}\label{classmlpack_1_1tree_1_1RectangleTree_a0186e79ada1cc823521ff3faabf45792}


Return the minimum distance from the center to any edge of the bound. 

Currently, this returns 0, which doesn\textquotesingle{}t break algorithms, but it isn\textquotesingle{}t necessarily correct, either. 

Definition at line 407 of file rectangle\+\_\+tree.\+hpp.



References mlpack\+::bound\+::\+H\+Rect\+Bound$<$ Metric\+Type, Elem\+Type $>$\+::\+Min\+Width().

\index{mlpack\+::tree\+::\+Rectangle\+Tree@{mlpack\+::tree\+::\+Rectangle\+Tree}!Min\+Leaf\+Size@{Min\+Leaf\+Size}}
\index{Min\+Leaf\+Size@{Min\+Leaf\+Size}!mlpack\+::tree\+::\+Rectangle\+Tree@{mlpack\+::tree\+::\+Rectangle\+Tree}}
\subsubsection[{Min\+Leaf\+Size() const }]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename Metric\+Type  = metric\+::\+Euclidean\+Distance, typename Statistic\+Type  = Empty\+Statistic, typename Mat\+Type  = arma\+::mat, typename Split\+Type  = R\+Tree\+Split, typename Descent\+Type  = R\+Tree\+Descent\+Heuristic, template$<$ typename $>$ class Auxiliary\+Information\+Type = No\+Auxiliary\+Information$>$ size\+\_\+t {\bf mlpack\+::tree\+::\+Rectangle\+Tree}$<$ Metric\+Type, Statistic\+Type, Mat\+Type, {\bf Split\+Type}, {\bf Descent\+Type}, Auxiliary\+Information\+Type $>$\+::Min\+Leaf\+Size (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
) const\hspace{0.3cm}{\ttfamily [inline]}}\label{classmlpack_1_1tree_1_1RectangleTree_ab37fd4bacb6f5c933591df7bc9429f36}


Return the minimum leaf size. 



Definition at line 324 of file rectangle\+\_\+tree.\+hpp.



References mlpack\+::tree\+::\+Rectangle\+Tree$<$ Metric\+Type, Statistic\+Type, Mat\+Type, Split\+Type, Descent\+Type, Auxiliary\+Information\+Type $>$\+::min\+Leaf\+Size.

\index{mlpack\+::tree\+::\+Rectangle\+Tree@{mlpack\+::tree\+::\+Rectangle\+Tree}!Min\+Leaf\+Size@{Min\+Leaf\+Size}}
\index{Min\+Leaf\+Size@{Min\+Leaf\+Size}!mlpack\+::tree\+::\+Rectangle\+Tree@{mlpack\+::tree\+::\+Rectangle\+Tree}}
\subsubsection[{Min\+Leaf\+Size()}]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename Metric\+Type  = metric\+::\+Euclidean\+Distance, typename Statistic\+Type  = Empty\+Statistic, typename Mat\+Type  = arma\+::mat, typename Split\+Type  = R\+Tree\+Split, typename Descent\+Type  = R\+Tree\+Descent\+Heuristic, template$<$ typename $>$ class Auxiliary\+Information\+Type = No\+Auxiliary\+Information$>$ size\+\_\+t\& {\bf mlpack\+::tree\+::\+Rectangle\+Tree}$<$ Metric\+Type, Statistic\+Type, Mat\+Type, {\bf Split\+Type}, {\bf Descent\+Type}, Auxiliary\+Information\+Type $>$\+::Min\+Leaf\+Size (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}}\label{classmlpack_1_1tree_1_1RectangleTree_abc41f2efb966706458607e9711c22117}


Modify the minimum leaf size. 



Definition at line 326 of file rectangle\+\_\+tree.\+hpp.



References mlpack\+::tree\+::\+Rectangle\+Tree$<$ Metric\+Type, Statistic\+Type, Mat\+Type, Split\+Type, Descent\+Type, Auxiliary\+Information\+Type $>$\+::min\+Leaf\+Size.

\index{mlpack\+::tree\+::\+Rectangle\+Tree@{mlpack\+::tree\+::\+Rectangle\+Tree}!Min\+Num\+Children@{Min\+Num\+Children}}
\index{Min\+Num\+Children@{Min\+Num\+Children}!mlpack\+::tree\+::\+Rectangle\+Tree@{mlpack\+::tree\+::\+Rectangle\+Tree}}
\subsubsection[{Min\+Num\+Children() const }]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename Metric\+Type  = metric\+::\+Euclidean\+Distance, typename Statistic\+Type  = Empty\+Statistic, typename Mat\+Type  = arma\+::mat, typename Split\+Type  = R\+Tree\+Split, typename Descent\+Type  = R\+Tree\+Descent\+Heuristic, template$<$ typename $>$ class Auxiliary\+Information\+Type = No\+Auxiliary\+Information$>$ size\+\_\+t {\bf mlpack\+::tree\+::\+Rectangle\+Tree}$<$ Metric\+Type, Statistic\+Type, Mat\+Type, {\bf Split\+Type}, {\bf Descent\+Type}, Auxiliary\+Information\+Type $>$\+::Min\+Num\+Children (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
) const\hspace{0.3cm}{\ttfamily [inline]}}\label{classmlpack_1_1tree_1_1RectangleTree_a423c377f773eb123ddae0e287afd43cb}


Return the minimum number of children (in a non-\/leaf node). 



Definition at line 334 of file rectangle\+\_\+tree.\+hpp.



References mlpack\+::tree\+::\+Rectangle\+Tree$<$ Metric\+Type, Statistic\+Type, Mat\+Type, Split\+Type, Descent\+Type, Auxiliary\+Information\+Type $>$\+::min\+Num\+Children.

\index{mlpack\+::tree\+::\+Rectangle\+Tree@{mlpack\+::tree\+::\+Rectangle\+Tree}!Min\+Num\+Children@{Min\+Num\+Children}}
\index{Min\+Num\+Children@{Min\+Num\+Children}!mlpack\+::tree\+::\+Rectangle\+Tree@{mlpack\+::tree\+::\+Rectangle\+Tree}}
\subsubsection[{Min\+Num\+Children()}]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename Metric\+Type  = metric\+::\+Euclidean\+Distance, typename Statistic\+Type  = Empty\+Statistic, typename Mat\+Type  = arma\+::mat, typename Split\+Type  = R\+Tree\+Split, typename Descent\+Type  = R\+Tree\+Descent\+Heuristic, template$<$ typename $>$ class Auxiliary\+Information\+Type = No\+Auxiliary\+Information$>$ size\+\_\+t\& {\bf mlpack\+::tree\+::\+Rectangle\+Tree}$<$ Metric\+Type, Statistic\+Type, Mat\+Type, {\bf Split\+Type}, {\bf Descent\+Type}, Auxiliary\+Information\+Type $>$\+::Min\+Num\+Children (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}}\label{classmlpack_1_1tree_1_1RectangleTree_a1f86f8d07cc249182f8240e3edcaf3ea}


Modify the minimum number of children (in a non-\/leaf node). 



Definition at line 336 of file rectangle\+\_\+tree.\+hpp.



References mlpack\+::tree\+::\+Rectangle\+Tree$<$ Metric\+Type, Statistic\+Type, Mat\+Type, Split\+Type, Descent\+Type, Auxiliary\+Information\+Type $>$\+::min\+Num\+Children.

\index{mlpack\+::tree\+::\+Rectangle\+Tree@{mlpack\+::tree\+::\+Rectangle\+Tree}!Nullify\+Data@{Nullify\+Data}}
\index{Nullify\+Data@{Nullify\+Data}!mlpack\+::tree\+::\+Rectangle\+Tree@{mlpack\+::tree\+::\+Rectangle\+Tree}}
\subsubsection[{Nullify\+Data()}]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename Metric\+Type  = metric\+::\+Euclidean\+Distance, typename Statistic\+Type  = Empty\+Statistic, typename Mat\+Type  = arma\+::mat, typename Split\+Type  = R\+Tree\+Split, typename Descent\+Type  = R\+Tree\+Descent\+Heuristic, template$<$ typename $>$ class Auxiliary\+Information\+Type = No\+Auxiliary\+Information$>$ void {\bf mlpack\+::tree\+::\+Rectangle\+Tree}$<$ Metric\+Type, Statistic\+Type, Mat\+Type, {\bf Split\+Type}, {\bf Descent\+Type}, Auxiliary\+Information\+Type $>$\+::Nullify\+Data (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)}\label{classmlpack_1_1tree_1_1RectangleTree_a0f15a87b4ff056cbd1c889356cad874b}


Nullify the auxiliary information. 

Used for memory management. Be cafeful. \index{mlpack\+::tree\+::\+Rectangle\+Tree@{mlpack\+::tree\+::\+Rectangle\+Tree}!Num\+Children@{Num\+Children}}
\index{Num\+Children@{Num\+Children}!mlpack\+::tree\+::\+Rectangle\+Tree@{mlpack\+::tree\+::\+Rectangle\+Tree}}
\subsubsection[{Num\+Children() const }]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename Metric\+Type  = metric\+::\+Euclidean\+Distance, typename Statistic\+Type  = Empty\+Statistic, typename Mat\+Type  = arma\+::mat, typename Split\+Type  = R\+Tree\+Split, typename Descent\+Type  = R\+Tree\+Descent\+Heuristic, template$<$ typename $>$ class Auxiliary\+Information\+Type = No\+Auxiliary\+Information$>$ size\+\_\+t {\bf mlpack\+::tree\+::\+Rectangle\+Tree}$<$ Metric\+Type, Statistic\+Type, Mat\+Type, {\bf Split\+Type}, {\bf Descent\+Type}, Auxiliary\+Information\+Type $>$\+::Num\+Children (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
) const\hspace{0.3cm}{\ttfamily [inline]}}\label{classmlpack_1_1tree_1_1RectangleTree_a5170607ffd2d1ea9ec0960d3a7827d83}


Return the number of child nodes. (One level beneath this one only.) 



Definition at line 355 of file rectangle\+\_\+tree.\+hpp.



References mlpack\+::tree\+::\+Rectangle\+Tree$<$ Metric\+Type, Statistic\+Type, Mat\+Type, Split\+Type, Descent\+Type, Auxiliary\+Information\+Type $>$\+::num\+Children.

\index{mlpack\+::tree\+::\+Rectangle\+Tree@{mlpack\+::tree\+::\+Rectangle\+Tree}!Num\+Children@{Num\+Children}}
\index{Num\+Children@{Num\+Children}!mlpack\+::tree\+::\+Rectangle\+Tree@{mlpack\+::tree\+::\+Rectangle\+Tree}}
\subsubsection[{Num\+Children()}]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename Metric\+Type  = metric\+::\+Euclidean\+Distance, typename Statistic\+Type  = Empty\+Statistic, typename Mat\+Type  = arma\+::mat, typename Split\+Type  = R\+Tree\+Split, typename Descent\+Type  = R\+Tree\+Descent\+Heuristic, template$<$ typename $>$ class Auxiliary\+Information\+Type = No\+Auxiliary\+Information$>$ size\+\_\+t\& {\bf mlpack\+::tree\+::\+Rectangle\+Tree}$<$ Metric\+Type, Statistic\+Type, Mat\+Type, {\bf Split\+Type}, {\bf Descent\+Type}, Auxiliary\+Information\+Type $>$\+::Num\+Children (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}}\label{classmlpack_1_1tree_1_1RectangleTree_a484a2e303a9d13e53ea1b607d07f4550}


Modify the number of child nodes. Be careful. 



Definition at line 357 of file rectangle\+\_\+tree.\+hpp.



References mlpack\+::tree\+::\+Rectangle\+Tree$<$ Metric\+Type, Statistic\+Type, Mat\+Type, Split\+Type, Descent\+Type, Auxiliary\+Information\+Type $>$\+::\+Furthest\+Descendant\+Distance(), mlpack\+::tree\+::\+Rectangle\+Tree$<$ Metric\+Type, Statistic\+Type, Mat\+Type, Split\+Type, Descent\+Type, Auxiliary\+Information\+Type $>$\+::\+Furthest\+Point\+Distance(), mlpack\+::tree\+::\+Rectangle\+Tree$<$ Metric\+Type, Statistic\+Type, Mat\+Type, Split\+Type, Descent\+Type, Auxiliary\+Information\+Type $>$\+::\+Get\+Furthest\+Child(), mlpack\+::tree\+::\+Rectangle\+Tree$<$ Metric\+Type, Statistic\+Type, Mat\+Type, Split\+Type, Descent\+Type, Auxiliary\+Information\+Type $>$\+::\+Get\+Nearest\+Child(), and mlpack\+::tree\+::\+Rectangle\+Tree$<$ Metric\+Type, Statistic\+Type, Mat\+Type, Split\+Type, Descent\+Type, Auxiliary\+Information\+Type $>$\+::num\+Children.

\index{mlpack\+::tree\+::\+Rectangle\+Tree@{mlpack\+::tree\+::\+Rectangle\+Tree}!Num\+Descendants@{Num\+Descendants}}
\index{Num\+Descendants@{Num\+Descendants}!mlpack\+::tree\+::\+Rectangle\+Tree@{mlpack\+::tree\+::\+Rectangle\+Tree}}
\subsubsection[{Num\+Descendants() const }]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename Metric\+Type  = metric\+::\+Euclidean\+Distance, typename Statistic\+Type  = Empty\+Statistic, typename Mat\+Type  = arma\+::mat, typename Split\+Type  = R\+Tree\+Split, typename Descent\+Type  = R\+Tree\+Descent\+Heuristic, template$<$ typename $>$ class Auxiliary\+Information\+Type = No\+Auxiliary\+Information$>$ size\+\_\+t {\bf mlpack\+::tree\+::\+Rectangle\+Tree}$<$ Metric\+Type, Statistic\+Type, Mat\+Type, {\bf Split\+Type}, {\bf Descent\+Type}, Auxiliary\+Information\+Type $>$\+::Num\+Descendants (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
) const}\label{classmlpack_1_1tree_1_1RectangleTree_a036b2f36b896426d3de01195f41af169}


Return the number of descendants of this node. 

For a non-\/leaf in a binary space tree, this is the number of points at the descendant leaves. For a leaf, this is the number of points in the leaf. 

Referenced by mlpack\+::tree\+::\+Rectangle\+Tree$<$ Metric\+Type, Statistic\+Type, Mat\+Type, Split\+Type, Descent\+Type, Auxiliary\+Information\+Type $>$\+::\+Child().

\index{mlpack\+::tree\+::\+Rectangle\+Tree@{mlpack\+::tree\+::\+Rectangle\+Tree}!Num\+Points@{Num\+Points}}
\index{Num\+Points@{Num\+Points}!mlpack\+::tree\+::\+Rectangle\+Tree@{mlpack\+::tree\+::\+Rectangle\+Tree}}
\subsubsection[{Num\+Points() const }]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename Metric\+Type  = metric\+::\+Euclidean\+Distance, typename Statistic\+Type  = Empty\+Statistic, typename Mat\+Type  = arma\+::mat, typename Split\+Type  = R\+Tree\+Split, typename Descent\+Type  = R\+Tree\+Descent\+Heuristic, template$<$ typename $>$ class Auxiliary\+Information\+Type = No\+Auxiliary\+Information$>$ size\+\_\+t {\bf mlpack\+::tree\+::\+Rectangle\+Tree}$<$ Metric\+Type, Statistic\+Type, Mat\+Type, {\bf Split\+Type}, {\bf Descent\+Type}, Auxiliary\+Information\+Type $>$\+::Num\+Points (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
) const}\label{classmlpack_1_1tree_1_1RectangleTree_aed21f235e13060d96375a36dabdaf0ff}


Return the number of points in this node (returns 0 if this node is not a leaf). 



Referenced by mlpack\+::tree\+::\+Rectangle\+Tree$<$ Metric\+Type, Statistic\+Type, Mat\+Type, Split\+Type, Descent\+Type, Auxiliary\+Information\+Type $>$\+::\+Child().

\index{mlpack\+::tree\+::\+Rectangle\+Tree@{mlpack\+::tree\+::\+Rectangle\+Tree}!Parent@{Parent}}
\index{Parent@{Parent}!mlpack\+::tree\+::\+Rectangle\+Tree@{mlpack\+::tree\+::\+Rectangle\+Tree}}
\subsubsection[{Parent() const }]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename Metric\+Type  = metric\+::\+Euclidean\+Distance, typename Statistic\+Type  = Empty\+Statistic, typename Mat\+Type  = arma\+::mat, typename Split\+Type  = R\+Tree\+Split, typename Descent\+Type  = R\+Tree\+Descent\+Heuristic, template$<$ typename $>$ class Auxiliary\+Information\+Type = No\+Auxiliary\+Information$>$ {\bf Rectangle\+Tree}$\ast$ {\bf mlpack\+::tree\+::\+Rectangle\+Tree}$<$ Metric\+Type, Statistic\+Type, Mat\+Type, {\bf Split\+Type}, {\bf Descent\+Type}, Auxiliary\+Information\+Type $>$\+::Parent (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
) const\hspace{0.3cm}{\ttfamily [inline]}}\label{classmlpack_1_1tree_1_1RectangleTree_a181e38e78145b500e50cd34fb3d1fee5}


Gets the parent of this node. 



Definition at line 339 of file rectangle\+\_\+tree.\+hpp.



References mlpack\+::tree\+::\+Rectangle\+Tree$<$ Metric\+Type, Statistic\+Type, Mat\+Type, Split\+Type, Descent\+Type, Auxiliary\+Information\+Type $>$\+::parent.

\index{mlpack\+::tree\+::\+Rectangle\+Tree@{mlpack\+::tree\+::\+Rectangle\+Tree}!Parent@{Parent}}
\index{Parent@{Parent}!mlpack\+::tree\+::\+Rectangle\+Tree@{mlpack\+::tree\+::\+Rectangle\+Tree}}
\subsubsection[{Parent()}]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename Metric\+Type  = metric\+::\+Euclidean\+Distance, typename Statistic\+Type  = Empty\+Statistic, typename Mat\+Type  = arma\+::mat, typename Split\+Type  = R\+Tree\+Split, typename Descent\+Type  = R\+Tree\+Descent\+Heuristic, template$<$ typename $>$ class Auxiliary\+Information\+Type = No\+Auxiliary\+Information$>$ {\bf Rectangle\+Tree}$\ast$\& {\bf mlpack\+::tree\+::\+Rectangle\+Tree}$<$ Metric\+Type, Statistic\+Type, Mat\+Type, {\bf Split\+Type}, {\bf Descent\+Type}, Auxiliary\+Information\+Type $>$\+::Parent (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}}\label{classmlpack_1_1tree_1_1RectangleTree_ae571f34f6ab88743c3834096511a0599}


Modify the parent of this node. 



Definition at line 341 of file rectangle\+\_\+tree.\+hpp.



References mlpack\+::tree\+::\+Rectangle\+Tree$<$ Metric\+Type, Statistic\+Type, Mat\+Type, Split\+Type, Descent\+Type, Auxiliary\+Information\+Type $>$\+::parent.

\index{mlpack\+::tree\+::\+Rectangle\+Tree@{mlpack\+::tree\+::\+Rectangle\+Tree}!Parent\+Distance@{Parent\+Distance}}
\index{Parent\+Distance@{Parent\+Distance}!mlpack\+::tree\+::\+Rectangle\+Tree@{mlpack\+::tree\+::\+Rectangle\+Tree}}
\subsubsection[{Parent\+Distance() const }]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename Metric\+Type  = metric\+::\+Euclidean\+Distance, typename Statistic\+Type  = Empty\+Statistic, typename Mat\+Type  = arma\+::mat, typename Split\+Type  = R\+Tree\+Split, typename Descent\+Type  = R\+Tree\+Descent\+Heuristic, template$<$ typename $>$ class Auxiliary\+Information\+Type = No\+Auxiliary\+Information$>$ {\bf Elem\+Type} {\bf mlpack\+::tree\+::\+Rectangle\+Tree}$<$ Metric\+Type, Statistic\+Type, Mat\+Type, {\bf Split\+Type}, {\bf Descent\+Type}, Auxiliary\+Information\+Type $>$\+::Parent\+Distance (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
) const\hspace{0.3cm}{\ttfamily [inline]}}\label{classmlpack_1_1tree_1_1RectangleTree_a87f0cf07d1074712d2aba5cb7efcfbd9}


Return the distance from the center of this node to the center of the parent node. 



Definition at line 411 of file rectangle\+\_\+tree.\+hpp.



References mlpack\+::tree\+::\+Rectangle\+Tree$<$ Metric\+Type, Statistic\+Type, Mat\+Type, Split\+Type, Descent\+Type, Auxiliary\+Information\+Type $>$\+::parent\+Distance.

\index{mlpack\+::tree\+::\+Rectangle\+Tree@{mlpack\+::tree\+::\+Rectangle\+Tree}!Parent\+Distance@{Parent\+Distance}}
\index{Parent\+Distance@{Parent\+Distance}!mlpack\+::tree\+::\+Rectangle\+Tree@{mlpack\+::tree\+::\+Rectangle\+Tree}}
\subsubsection[{Parent\+Distance()}]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename Metric\+Type  = metric\+::\+Euclidean\+Distance, typename Statistic\+Type  = Empty\+Statistic, typename Mat\+Type  = arma\+::mat, typename Split\+Type  = R\+Tree\+Split, typename Descent\+Type  = R\+Tree\+Descent\+Heuristic, template$<$ typename $>$ class Auxiliary\+Information\+Type = No\+Auxiliary\+Information$>$ {\bf Elem\+Type}\& {\bf mlpack\+::tree\+::\+Rectangle\+Tree}$<$ Metric\+Type, Statistic\+Type, Mat\+Type, {\bf Split\+Type}, {\bf Descent\+Type}, Auxiliary\+Information\+Type $>$\+::Parent\+Distance (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}}\label{classmlpack_1_1tree_1_1RectangleTree_ab273324cb834b35cbcfc6000426126eb}


Modify the distance from the center of this node to the center of the parent node. 



Definition at line 414 of file rectangle\+\_\+tree.\+hpp.



References mlpack\+::tree\+::\+Rectangle\+Tree$<$ Metric\+Type, Statistic\+Type, Mat\+Type, Split\+Type, Descent\+Type, Auxiliary\+Information\+Type $>$\+::parent\+Distance.

\index{mlpack\+::tree\+::\+Rectangle\+Tree@{mlpack\+::tree\+::\+Rectangle\+Tree}!Point@{Point}}
\index{Point@{Point}!mlpack\+::tree\+::\+Rectangle\+Tree@{mlpack\+::tree\+::\+Rectangle\+Tree}}
\subsubsection[{Point(const size\+\_\+t index) const }]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename Metric\+Type  = metric\+::\+Euclidean\+Distance, typename Statistic\+Type  = Empty\+Statistic, typename Mat\+Type  = arma\+::mat, typename Split\+Type  = R\+Tree\+Split, typename Descent\+Type  = R\+Tree\+Descent\+Heuristic, template$<$ typename $>$ class Auxiliary\+Information\+Type = No\+Auxiliary\+Information$>$ size\+\_\+t {\bf mlpack\+::tree\+::\+Rectangle\+Tree}$<$ Metric\+Type, Statistic\+Type, Mat\+Type, {\bf Split\+Type}, {\bf Descent\+Type}, Auxiliary\+Information\+Type $>$\+::Point (
\begin{DoxyParamCaption}
\item[{const size\+\_\+t}]{index}
\end{DoxyParamCaption}
) const\hspace{0.3cm}{\ttfamily [inline]}}\label{classmlpack_1_1tree_1_1RectangleTree_aa12c57845c2f766d67c165f22d87758c}


Return the index (with reference to the dataset) of a particular point in this node. 

This will happily return invalid indices if the given index is greater than the number of points in this node (obtained with \doxyref{Num\+Points()}{p.}{classmlpack_1_1tree_1_1RectangleTree_aed21f235e13060d96375a36dabdaf0ff}) -- be careful.


\begin{DoxyParams}{Parameters}
{\em index} & Index of point for which a dataset index is wanted. \\
\hline
\end{DoxyParams}


Definition at line 464 of file rectangle\+\_\+tree.\+hpp.

\index{mlpack\+::tree\+::\+Rectangle\+Tree@{mlpack\+::tree\+::\+Rectangle\+Tree}!Point@{Point}}
\index{Point@{Point}!mlpack\+::tree\+::\+Rectangle\+Tree@{mlpack\+::tree\+::\+Rectangle\+Tree}}
\subsubsection[{Point(const size\+\_\+t index)}]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename Metric\+Type  = metric\+::\+Euclidean\+Distance, typename Statistic\+Type  = Empty\+Statistic, typename Mat\+Type  = arma\+::mat, typename Split\+Type  = R\+Tree\+Split, typename Descent\+Type  = R\+Tree\+Descent\+Heuristic, template$<$ typename $>$ class Auxiliary\+Information\+Type = No\+Auxiliary\+Information$>$ size\+\_\+t\& {\bf mlpack\+::tree\+::\+Rectangle\+Tree}$<$ Metric\+Type, Statistic\+Type, Mat\+Type, {\bf Split\+Type}, {\bf Descent\+Type}, Auxiliary\+Information\+Type $>$\+::Point (
\begin{DoxyParamCaption}
\item[{const size\+\_\+t}]{index}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}}\label{classmlpack_1_1tree_1_1RectangleTree_a06b97a1afcabd6ac431f5099a72f323f}


Modify the index of a particular point in this node. 

Be very careful when you do this! You may make the tree invalid. 

Definition at line 468 of file rectangle\+\_\+tree.\+hpp.

\index{mlpack\+::tree\+::\+Rectangle\+Tree@{mlpack\+::tree\+::\+Rectangle\+Tree}!Range\+Distance@{Range\+Distance}}
\index{Range\+Distance@{Range\+Distance}!mlpack\+::tree\+::\+Rectangle\+Tree@{mlpack\+::tree\+::\+Rectangle\+Tree}}
\subsubsection[{Range\+Distance(const Rectangle\+Tree \&other) const }]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename Metric\+Type  = metric\+::\+Euclidean\+Distance, typename Statistic\+Type  = Empty\+Statistic, typename Mat\+Type  = arma\+::mat, typename Split\+Type  = R\+Tree\+Split, typename Descent\+Type  = R\+Tree\+Descent\+Heuristic, template$<$ typename $>$ class Auxiliary\+Information\+Type = No\+Auxiliary\+Information$>$ {\bf math\+::\+Range\+Type}$<${\bf Elem\+Type}$>$ {\bf mlpack\+::tree\+::\+Rectangle\+Tree}$<$ Metric\+Type, Statistic\+Type, Mat\+Type, {\bf Split\+Type}, {\bf Descent\+Type}, Auxiliary\+Information\+Type $>$\+::Range\+Distance (
\begin{DoxyParamCaption}
\item[{const {\bf Rectangle\+Tree}$<$ Metric\+Type, Statistic\+Type, Mat\+Type, {\bf Split\+Type}, {\bf Descent\+Type}, Auxiliary\+Information\+Type $>$ \&}]{other}
\end{DoxyParamCaption}
) const\hspace{0.3cm}{\ttfamily [inline]}}\label{classmlpack_1_1tree_1_1RectangleTree_aa3b634d34fb326936c77ab389e1a8fe0}


Return the minimum and maximum distance to another node. 



Definition at line 483 of file rectangle\+\_\+tree.\+hpp.



References mlpack\+::tree\+::\+Rectangle\+Tree$<$ Metric\+Type, Statistic\+Type, Mat\+Type, Split\+Type, Descent\+Type, Auxiliary\+Information\+Type $>$\+::\+Bound(), and mlpack\+::bound\+::\+H\+Rect\+Bound$<$ Metric\+Type, Elem\+Type $>$\+::\+Range\+Distance().

\index{mlpack\+::tree\+::\+Rectangle\+Tree@{mlpack\+::tree\+::\+Rectangle\+Tree}!Range\+Distance@{Range\+Distance}}
\index{Range\+Distance@{Range\+Distance}!mlpack\+::tree\+::\+Rectangle\+Tree@{mlpack\+::tree\+::\+Rectangle\+Tree}}
\subsubsection[{Range\+Distance(const Vec\+Type \&point, typename std\+::enable\+\_\+if\+\_\+t$<$ Is\+Vector$<$ Vec\+Type $>$\+::value $>$ $\ast$=0) const }]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename Metric\+Type  = metric\+::\+Euclidean\+Distance, typename Statistic\+Type  = Empty\+Statistic, typename Mat\+Type  = arma\+::mat, typename Split\+Type  = R\+Tree\+Split, typename Descent\+Type  = R\+Tree\+Descent\+Heuristic, template$<$ typename $>$ class Auxiliary\+Information\+Type = No\+Auxiliary\+Information$>$ template$<$typename Vec\+Type $>$ {\bf math\+::\+Range\+Type}$<${\bf Elem\+Type}$>$ {\bf mlpack\+::tree\+::\+Rectangle\+Tree}$<$ Metric\+Type, Statistic\+Type, Mat\+Type, {\bf Split\+Type}, {\bf Descent\+Type}, Auxiliary\+Information\+Type $>$\+::Range\+Distance (
\begin{DoxyParamCaption}
\item[{const Vec\+Type \&}]{point, }
\item[{typename {\bf std\+::enable\+\_\+if\+\_\+t}$<$ {\bf Is\+Vector}$<$ Vec\+Type $>$\+::value $>$ $\ast$}]{ = {\ttfamily 0}}
\end{DoxyParamCaption}
) const\hspace{0.3cm}{\ttfamily [inline]}}\label{classmlpack_1_1tree_1_1RectangleTree_a1510aabc86f99d0bc6fc1ce436888425}


Return the minimum and maximum distance to another point. 



Definition at line 508 of file rectangle\+\_\+tree.\+hpp.



References mlpack\+::bound\+::\+H\+Rect\+Bound$<$ Metric\+Type, Elem\+Type $>$\+::\+Range\+Distance(), mlpack\+::tree\+::\+Rectangle\+Tree$<$ Metric\+Type, Statistic\+Type, Mat\+Type, Split\+Type, Descent\+Type, Auxiliary\+Information\+Type $>$\+::\+Tree\+Depth(), and mlpack\+::tree\+::\+Rectangle\+Tree$<$ Metric\+Type, Statistic\+Type, Mat\+Type, Split\+Type, Descent\+Type, Auxiliary\+Information\+Type $>$\+::\+Tree\+Size().

\index{mlpack\+::tree\+::\+Rectangle\+Tree@{mlpack\+::tree\+::\+Rectangle\+Tree}!Remove\+Node@{Remove\+Node}}
\index{Remove\+Node@{Remove\+Node}!mlpack\+::tree\+::\+Rectangle\+Tree@{mlpack\+::tree\+::\+Rectangle\+Tree}}
\subsubsection[{Remove\+Node(const Rectangle\+Tree $\ast$node, std\+::vector$<$ bool $>$ \&relevels)}]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename Metric\+Type  = metric\+::\+Euclidean\+Distance, typename Statistic\+Type  = Empty\+Statistic, typename Mat\+Type  = arma\+::mat, typename Split\+Type  = R\+Tree\+Split, typename Descent\+Type  = R\+Tree\+Descent\+Heuristic, template$<$ typename $>$ class Auxiliary\+Information\+Type = No\+Auxiliary\+Information$>$ bool {\bf mlpack\+::tree\+::\+Rectangle\+Tree}$<$ Metric\+Type, Statistic\+Type, Mat\+Type, {\bf Split\+Type}, {\bf Descent\+Type}, Auxiliary\+Information\+Type $>$\+::Remove\+Node (
\begin{DoxyParamCaption}
\item[{const {\bf Rectangle\+Tree}$<$ Metric\+Type, Statistic\+Type, Mat\+Type, {\bf Split\+Type}, {\bf Descent\+Type}, Auxiliary\+Information\+Type $>$ $\ast$}]{node, }
\item[{std\+::vector$<$ bool $>$ \&}]{relevels}
\end{DoxyParamCaption}
)}\label{classmlpack_1_1tree_1_1RectangleTree_ad96d2d549b3e0e89a7b7664889a3496c}


Removes a node from the tree. 

You are responsible for deleting it if you wish to do so. \index{mlpack\+::tree\+::\+Rectangle\+Tree@{mlpack\+::tree\+::\+Rectangle\+Tree}!Serialize@{Serialize}}
\index{Serialize@{Serialize}!mlpack\+::tree\+::\+Rectangle\+Tree@{mlpack\+::tree\+::\+Rectangle\+Tree}}
\subsubsection[{Serialize(\+Archive \&ar, const unsigned int)}]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename Metric\+Type  = metric\+::\+Euclidean\+Distance, typename Statistic\+Type  = Empty\+Statistic, typename Mat\+Type  = arma\+::mat, typename Split\+Type  = R\+Tree\+Split, typename Descent\+Type  = R\+Tree\+Descent\+Heuristic, template$<$ typename $>$ class Auxiliary\+Information\+Type = No\+Auxiliary\+Information$>$ template$<$typename Archive $>$ void {\bf mlpack\+::tree\+::\+Rectangle\+Tree}$<$ Metric\+Type, Statistic\+Type, Mat\+Type, {\bf Split\+Type}, {\bf Descent\+Type}, Auxiliary\+Information\+Type $>$\+::Serialize (
\begin{DoxyParamCaption}
\item[{Archive \&}]{ar, }
\item[{const unsigned}]{int}
\end{DoxyParamCaption}
)}\label{classmlpack_1_1tree_1_1RectangleTree_a4b6521cd2808ebec9d13115bb94ad90c}


Serialize the tree. 

\index{mlpack\+::tree\+::\+Rectangle\+Tree@{mlpack\+::tree\+::\+Rectangle\+Tree}!Shrink\+Bound\+For\+Bound@{Shrink\+Bound\+For\+Bound}}
\index{Shrink\+Bound\+For\+Bound@{Shrink\+Bound\+For\+Bound}!mlpack\+::tree\+::\+Rectangle\+Tree@{mlpack\+::tree\+::\+Rectangle\+Tree}}
\subsubsection[{Shrink\+Bound\+For\+Bound(const bound\+::\+H\+Rect\+Bound$<$ Metric\+Type $>$ \&changed\+Bound)}]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename Metric\+Type  = metric\+::\+Euclidean\+Distance, typename Statistic\+Type  = Empty\+Statistic, typename Mat\+Type  = arma\+::mat, typename Split\+Type  = R\+Tree\+Split, typename Descent\+Type  = R\+Tree\+Descent\+Heuristic, template$<$ typename $>$ class Auxiliary\+Information\+Type = No\+Auxiliary\+Information$>$ bool {\bf mlpack\+::tree\+::\+Rectangle\+Tree}$<$ Metric\+Type, Statistic\+Type, Mat\+Type, {\bf Split\+Type}, {\bf Descent\+Type}, Auxiliary\+Information\+Type $>$\+::Shrink\+Bound\+For\+Bound (
\begin{DoxyParamCaption}
\item[{const {\bf bound\+::\+H\+Rect\+Bound}$<$ Metric\+Type $>$ \&}]{changed\+Bound}
\end{DoxyParamCaption}
)}\label{classmlpack_1_1tree_1_1RectangleTree_aa65547e5551c1f03a7ff788aa3a6c2f8}


Shrink the bound object of this node for the removal of a child node. 


\begin{DoxyParams}{Parameters}
{\em bound} & The H\+Rect\+Bound$<$$>$\& of the bound that was removed to reqire this shrinking. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
true if the bound needed to be changed, false if it did not. 
\end{DoxyReturn}
\index{mlpack\+::tree\+::\+Rectangle\+Tree@{mlpack\+::tree\+::\+Rectangle\+Tree}!Shrink\+Bound\+For\+Point@{Shrink\+Bound\+For\+Point}}
\index{Shrink\+Bound\+For\+Point@{Shrink\+Bound\+For\+Point}!mlpack\+::tree\+::\+Rectangle\+Tree@{mlpack\+::tree\+::\+Rectangle\+Tree}}
\subsubsection[{Shrink\+Bound\+For\+Point(const arma\+::vec \&point)}]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename Metric\+Type  = metric\+::\+Euclidean\+Distance, typename Statistic\+Type  = Empty\+Statistic, typename Mat\+Type  = arma\+::mat, typename Split\+Type  = R\+Tree\+Split, typename Descent\+Type  = R\+Tree\+Descent\+Heuristic, template$<$ typename $>$ class Auxiliary\+Information\+Type = No\+Auxiliary\+Information$>$ bool {\bf mlpack\+::tree\+::\+Rectangle\+Tree}$<$ Metric\+Type, Statistic\+Type, Mat\+Type, {\bf Split\+Type}, {\bf Descent\+Type}, Auxiliary\+Information\+Type $>$\+::Shrink\+Bound\+For\+Point (
\begin{DoxyParamCaption}
\item[{const arma\+::vec \&}]{point}
\end{DoxyParamCaption}
)}\label{classmlpack_1_1tree_1_1RectangleTree_a2e5ac2ec5c49b4d8972fe3080887e3d2}


Shrink the bound object of this node for the removal of a point. 


\begin{DoxyParams}{Parameters}
{\em point} & The arma\+::vec\& of the point that was removed to require this shrinking. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
true if the bound needed to be changed, false if it did not. 
\end{DoxyReturn}
\index{mlpack\+::tree\+::\+Rectangle\+Tree@{mlpack\+::tree\+::\+Rectangle\+Tree}!Soft\+Delete@{Soft\+Delete}}
\index{Soft\+Delete@{Soft\+Delete}!mlpack\+::tree\+::\+Rectangle\+Tree@{mlpack\+::tree\+::\+Rectangle\+Tree}}
\subsubsection[{Soft\+Delete()}]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename Metric\+Type  = metric\+::\+Euclidean\+Distance, typename Statistic\+Type  = Empty\+Statistic, typename Mat\+Type  = arma\+::mat, typename Split\+Type  = R\+Tree\+Split, typename Descent\+Type  = R\+Tree\+Descent\+Heuristic, template$<$ typename $>$ class Auxiliary\+Information\+Type = No\+Auxiliary\+Information$>$ void {\bf mlpack\+::tree\+::\+Rectangle\+Tree}$<$ Metric\+Type, Statistic\+Type, Mat\+Type, {\bf Split\+Type}, {\bf Descent\+Type}, Auxiliary\+Information\+Type $>$\+::Soft\+Delete (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)}\label{classmlpack_1_1tree_1_1RectangleTree_a29b78a085198334b3a5fda00527ffda9}


Delete this node of the tree, but leave the stuff contained in it intact. 

This is used when splitting a node, where the data in this tree is moved to two other trees. \index{mlpack\+::tree\+::\+Rectangle\+Tree@{mlpack\+::tree\+::\+Rectangle\+Tree}!Split\+Node@{Split\+Node}}
\index{Split\+Node@{Split\+Node}!mlpack\+::tree\+::\+Rectangle\+Tree@{mlpack\+::tree\+::\+Rectangle\+Tree}}
\subsubsection[{Split\+Node(std\+::vector$<$ bool $>$ \&relevels)}]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename Metric\+Type  = metric\+::\+Euclidean\+Distance, typename Statistic\+Type  = Empty\+Statistic, typename Mat\+Type  = arma\+::mat, typename Split\+Type  = R\+Tree\+Split, typename Descent\+Type  = R\+Tree\+Descent\+Heuristic, template$<$ typename $>$ class Auxiliary\+Information\+Type = No\+Auxiliary\+Information$>$ void {\bf mlpack\+::tree\+::\+Rectangle\+Tree}$<$ Metric\+Type, Statistic\+Type, Mat\+Type, {\bf Split\+Type}, {\bf Descent\+Type}, Auxiliary\+Information\+Type $>$\+::Split\+Node (
\begin{DoxyParamCaption}
\item[{std\+::vector$<$ bool $>$ \&}]{relevels}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [private]}}\label{classmlpack_1_1tree_1_1RectangleTree_a7a21bbe570d288901db9c5ac5828dfd4}


Splits the current node, recursing up the tree. 


\begin{DoxyParams}{Parameters}
{\em relevels} & Vector to track which levels have been inserted to. \\
\hline
\end{DoxyParams}


Referenced by mlpack\+::tree\+::\+Rectangle\+Tree$<$ Metric\+Type, Statistic\+Type, Mat\+Type, Split\+Type, Descent\+Type, Auxiliary\+Information\+Type $>$\+::\+Count().

\index{mlpack\+::tree\+::\+Rectangle\+Tree@{mlpack\+::tree\+::\+Rectangle\+Tree}!Stat@{Stat}}
\index{Stat@{Stat}!mlpack\+::tree\+::\+Rectangle\+Tree@{mlpack\+::tree\+::\+Rectangle\+Tree}}
\subsubsection[{Stat() const }]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename Metric\+Type  = metric\+::\+Euclidean\+Distance, typename Statistic\+Type  = Empty\+Statistic, typename Mat\+Type  = arma\+::mat, typename Split\+Type  = R\+Tree\+Split, typename Descent\+Type  = R\+Tree\+Descent\+Heuristic, template$<$ typename $>$ class Auxiliary\+Information\+Type = No\+Auxiliary\+Information$>$ const Statistic\+Type\& {\bf mlpack\+::tree\+::\+Rectangle\+Tree}$<$ Metric\+Type, Statistic\+Type, Mat\+Type, {\bf Split\+Type}, {\bf Descent\+Type}, Auxiliary\+Information\+Type $>$\+::Stat (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
) const\hspace{0.3cm}{\ttfamily [inline]}}\label{classmlpack_1_1tree_1_1RectangleTree_a683030231dc987a470f60af460171e43}


Return the statistic object for this node. 



Definition at line 304 of file rectangle\+\_\+tree.\+hpp.



References mlpack\+::tree\+::\+Rectangle\+Tree$<$ Metric\+Type, Statistic\+Type, Mat\+Type, Split\+Type, Descent\+Type, Auxiliary\+Information\+Type $>$\+::stat.

\index{mlpack\+::tree\+::\+Rectangle\+Tree@{mlpack\+::tree\+::\+Rectangle\+Tree}!Stat@{Stat}}
\index{Stat@{Stat}!mlpack\+::tree\+::\+Rectangle\+Tree@{mlpack\+::tree\+::\+Rectangle\+Tree}}
\subsubsection[{Stat()}]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename Metric\+Type  = metric\+::\+Euclidean\+Distance, typename Statistic\+Type  = Empty\+Statistic, typename Mat\+Type  = arma\+::mat, typename Split\+Type  = R\+Tree\+Split, typename Descent\+Type  = R\+Tree\+Descent\+Heuristic, template$<$ typename $>$ class Auxiliary\+Information\+Type = No\+Auxiliary\+Information$>$ Statistic\+Type\& {\bf mlpack\+::tree\+::\+Rectangle\+Tree}$<$ Metric\+Type, Statistic\+Type, Mat\+Type, {\bf Split\+Type}, {\bf Descent\+Type}, Auxiliary\+Information\+Type $>$\+::Stat (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}}\label{classmlpack_1_1tree_1_1RectangleTree_a3f69eb9cabcbbf6a9746f525046355cb}


Modify the statistic object for this node. 



Definition at line 306 of file rectangle\+\_\+tree.\+hpp.



References mlpack\+::tree\+::\+Rectangle\+Tree$<$ Metric\+Type, Statistic\+Type, Mat\+Type, Split\+Type, Descent\+Type, Auxiliary\+Information\+Type $>$\+::stat.

\index{mlpack\+::tree\+::\+Rectangle\+Tree@{mlpack\+::tree\+::\+Rectangle\+Tree}!Tree\+Depth@{Tree\+Depth}}
\index{Tree\+Depth@{Tree\+Depth}!mlpack\+::tree\+::\+Rectangle\+Tree@{mlpack\+::tree\+::\+Rectangle\+Tree}}
\subsubsection[{Tree\+Depth() const }]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename Metric\+Type  = metric\+::\+Euclidean\+Distance, typename Statistic\+Type  = Empty\+Statistic, typename Mat\+Type  = arma\+::mat, typename Split\+Type  = R\+Tree\+Split, typename Descent\+Type  = R\+Tree\+Descent\+Heuristic, template$<$ typename $>$ class Auxiliary\+Information\+Type = No\+Auxiliary\+Information$>$ size\+\_\+t {\bf mlpack\+::tree\+::\+Rectangle\+Tree}$<$ Metric\+Type, Statistic\+Type, Mat\+Type, {\bf Split\+Type}, {\bf Descent\+Type}, Auxiliary\+Information\+Type $>$\+::Tree\+Depth (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
) const}\label{classmlpack_1_1tree_1_1RectangleTree_a3c015827f6306313b57e1e23dbbd1848}


Obtains the number of levels below this node in the tree, starting with this. 



Referenced by mlpack\+::tree\+::\+Rectangle\+Tree$<$ Metric\+Type, Statistic\+Type, Mat\+Type, Split\+Type, Descent\+Type, Auxiliary\+Information\+Type $>$\+::\+Range\+Distance().

\index{mlpack\+::tree\+::\+Rectangle\+Tree@{mlpack\+::tree\+::\+Rectangle\+Tree}!Tree\+Size@{Tree\+Size}}
\index{Tree\+Size@{Tree\+Size}!mlpack\+::tree\+::\+Rectangle\+Tree@{mlpack\+::tree\+::\+Rectangle\+Tree}}
\subsubsection[{Tree\+Size() const }]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename Metric\+Type  = metric\+::\+Euclidean\+Distance, typename Statistic\+Type  = Empty\+Statistic, typename Mat\+Type  = arma\+::mat, typename Split\+Type  = R\+Tree\+Split, typename Descent\+Type  = R\+Tree\+Descent\+Heuristic, template$<$ typename $>$ class Auxiliary\+Information\+Type = No\+Auxiliary\+Information$>$ size\+\_\+t {\bf mlpack\+::tree\+::\+Rectangle\+Tree}$<$ Metric\+Type, Statistic\+Type, Mat\+Type, {\bf Split\+Type}, {\bf Descent\+Type}, Auxiliary\+Information\+Type $>$\+::Tree\+Size (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
) const}\label{classmlpack_1_1tree_1_1RectangleTree_ab1f308fff8386b3fcaa60cbd8ff6e0a5}


Obtains the number of nodes in the tree, starting with this. 



Referenced by mlpack\+::tree\+::\+Rectangle\+Tree$<$ Metric\+Type, Statistic\+Type, Mat\+Type, Split\+Type, Descent\+Type, Auxiliary\+Information\+Type $>$\+::\+Range\+Distance().



\subsection{Member Data Documentation}
\index{mlpack\+::tree\+::\+Rectangle\+Tree@{mlpack\+::tree\+::\+Rectangle\+Tree}!auxiliary\+Info@{auxiliary\+Info}}
\index{auxiliary\+Info@{auxiliary\+Info}!mlpack\+::tree\+::\+Rectangle\+Tree@{mlpack\+::tree\+::\+Rectangle\+Tree}}
\subsubsection[{auxiliary\+Info}]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename Metric\+Type  = metric\+::\+Euclidean\+Distance, typename Statistic\+Type  = Empty\+Statistic, typename Mat\+Type  = arma\+::mat, typename Split\+Type  = R\+Tree\+Split, typename Descent\+Type  = R\+Tree\+Descent\+Heuristic, template$<$ typename $>$ class Auxiliary\+Information\+Type = No\+Auxiliary\+Information$>$ Auxiliary\+Information\+Type$<${\bf Rectangle\+Tree}$>$ {\bf mlpack\+::tree\+::\+Rectangle\+Tree}$<$ Metric\+Type, Statistic\+Type, Mat\+Type, {\bf Split\+Type}, {\bf Descent\+Type}, Auxiliary\+Information\+Type $>$\+::auxiliary\+Info\hspace{0.3cm}{\ttfamily [private]}}\label{classmlpack_1_1tree_1_1RectangleTree_aa898ff8c8c2a0576c83eca877a397fff}


A tree-\/specific information. 



Definition at line 105 of file rectangle\+\_\+tree.\+hpp.



Referenced by mlpack\+::tree\+::\+Rectangle\+Tree$<$ Metric\+Type, Statistic\+Type, Mat\+Type, Split\+Type, Descent\+Type, Auxiliary\+Information\+Type $>$\+::\+Auxiliary\+Info().

\index{mlpack\+::tree\+::\+Rectangle\+Tree@{mlpack\+::tree\+::\+Rectangle\+Tree}!Auxiliary\+Information@{Auxiliary\+Information}}
\index{Auxiliary\+Information@{Auxiliary\+Information}!mlpack\+::tree\+::\+Rectangle\+Tree@{mlpack\+::tree\+::\+Rectangle\+Tree}}
\subsubsection[{Auxiliary\+Information}]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename Metric\+Type  = metric\+::\+Euclidean\+Distance, typename Statistic\+Type  = Empty\+Statistic, typename Mat\+Type  = arma\+::mat, typename Split\+Type  = R\+Tree\+Split, typename Descent\+Type  = R\+Tree\+Descent\+Heuristic, template$<$ typename $>$ class Auxiliary\+Information\+Type = No\+Auxiliary\+Information$>$ friend {\bf mlpack\+::tree\+::\+Rectangle\+Tree}$<$ Metric\+Type, Statistic\+Type, Mat\+Type, {\bf Split\+Type}, {\bf Descent\+Type}, Auxiliary\+Information\+Type $>$\+::{\bf Auxiliary\+Information}\hspace{0.3cm}{\ttfamily [protected]}}\label{classmlpack_1_1tree_1_1RectangleTree_ad73772643eb101456f6329cb31490407}


Give friend access for Auxiliary\+Information\+Type. 



Definition at line 563 of file rectangle\+\_\+tree.\+hpp.

\index{mlpack\+::tree\+::\+Rectangle\+Tree@{mlpack\+::tree\+::\+Rectangle\+Tree}!begin@{begin}}
\index{begin@{begin}!mlpack\+::tree\+::\+Rectangle\+Tree@{mlpack\+::tree\+::\+Rectangle\+Tree}}
\subsubsection[{begin}]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename Metric\+Type  = metric\+::\+Euclidean\+Distance, typename Statistic\+Type  = Empty\+Statistic, typename Mat\+Type  = arma\+::mat, typename Split\+Type  = R\+Tree\+Split, typename Descent\+Type  = R\+Tree\+Descent\+Heuristic, template$<$ typename $>$ class Auxiliary\+Information\+Type = No\+Auxiliary\+Information$>$ size\+\_\+t {\bf mlpack\+::tree\+::\+Rectangle\+Tree}$<$ Metric\+Type, Statistic\+Type, Mat\+Type, {\bf Split\+Type}, {\bf Descent\+Type}, Auxiliary\+Information\+Type $>$\+::begin\hspace{0.3cm}{\ttfamily [private]}}\label{classmlpack_1_1tree_1_1RectangleTree_a64d7a9888944babcf7b1bd658e8c3996}


The index of the first point in the dataset contained in this node (and its children). 

T\+H\+IS IS A\+L\+W\+A\+YS 0 AT T\+HE M\+O\+M\+E\+NT. IT E\+X\+I\+S\+TS M\+E\+R\+E\+LY IN C\+A\+SE I T\+H\+I\+NK OF A W\+AY TO C\+H\+A\+N\+GE T\+H\+AT. IN O\+T\+H\+ER W\+O\+R\+DS, IT W\+I\+LL P\+R\+O\+B\+A\+B\+LY BE R\+E\+M\+O\+V\+ED. 

Definition at line 81 of file rectangle\+\_\+tree.\+hpp.



Referenced by mlpack\+::tree\+::\+Rectangle\+Tree$<$ Metric\+Type, Statistic\+Type, Mat\+Type, Split\+Type, Descent\+Type, Auxiliary\+Information\+Type $>$\+::\+Begin().

\index{mlpack\+::tree\+::\+Rectangle\+Tree@{mlpack\+::tree\+::\+Rectangle\+Tree}!bound@{bound}}
\index{bound@{bound}!mlpack\+::tree\+::\+Rectangle\+Tree@{mlpack\+::tree\+::\+Rectangle\+Tree}}
\subsubsection[{bound}]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename Metric\+Type  = metric\+::\+Euclidean\+Distance, typename Statistic\+Type  = Empty\+Statistic, typename Mat\+Type  = arma\+::mat, typename Split\+Type  = R\+Tree\+Split, typename Descent\+Type  = R\+Tree\+Descent\+Heuristic, template$<$ typename $>$ class Auxiliary\+Information\+Type = No\+Auxiliary\+Information$>$ {\bf bound\+::\+H\+Rect\+Bound}$<${\bf metric\+::\+Euclidean\+Distance}, {\bf Elem\+Type}$>$ {\bf mlpack\+::tree\+::\+Rectangle\+Tree}$<$ Metric\+Type, Statistic\+Type, Mat\+Type, {\bf Split\+Type}, {\bf Descent\+Type}, Auxiliary\+Information\+Type $>$\+::bound\hspace{0.3cm}{\ttfamily [private]}}\label{classmlpack_1_1tree_1_1RectangleTree_ade56ff5dd8b0ebc738e29a86448b38f0}


The bound object for this node. 



Definition at line 92 of file rectangle\+\_\+tree.\+hpp.



Referenced by mlpack\+::tree\+::\+Rectangle\+Tree$<$ Metric\+Type, Statistic\+Type, Mat\+Type, Split\+Type, Descent\+Type, Auxiliary\+Information\+Type $>$\+::\+Bound().

\index{mlpack\+::tree\+::\+Rectangle\+Tree@{mlpack\+::tree\+::\+Rectangle\+Tree}!children@{children}}
\index{children@{children}!mlpack\+::tree\+::\+Rectangle\+Tree@{mlpack\+::tree\+::\+Rectangle\+Tree}}
\subsubsection[{children}]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename Metric\+Type  = metric\+::\+Euclidean\+Distance, typename Statistic\+Type  = Empty\+Statistic, typename Mat\+Type  = arma\+::mat, typename Split\+Type  = R\+Tree\+Split, typename Descent\+Type  = R\+Tree\+Descent\+Heuristic, template$<$ typename $>$ class Auxiliary\+Information\+Type = No\+Auxiliary\+Information$>$ std\+::vector$<${\bf Rectangle\+Tree}$\ast$$>$ {\bf mlpack\+::tree\+::\+Rectangle\+Tree}$<$ Metric\+Type, Statistic\+Type, Mat\+Type, {\bf Split\+Type}, {\bf Descent\+Type}, Auxiliary\+Information\+Type $>$\+::children\hspace{0.3cm}{\ttfamily [private]}}\label{classmlpack_1_1tree_1_1RectangleTree_aa7322097ae5a0253388c689d2096e715}


The child nodes (Starting at 0 and ending at (num\+Children-\/1) ). 



Definition at line 74 of file rectangle\+\_\+tree.\+hpp.

\index{mlpack\+::tree\+::\+Rectangle\+Tree@{mlpack\+::tree\+::\+Rectangle\+Tree}!count@{count}}
\index{count@{count}!mlpack\+::tree\+::\+Rectangle\+Tree@{mlpack\+::tree\+::\+Rectangle\+Tree}}
\subsubsection[{count}]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename Metric\+Type  = metric\+::\+Euclidean\+Distance, typename Statistic\+Type  = Empty\+Statistic, typename Mat\+Type  = arma\+::mat, typename Split\+Type  = R\+Tree\+Split, typename Descent\+Type  = R\+Tree\+Descent\+Heuristic, template$<$ typename $>$ class Auxiliary\+Information\+Type = No\+Auxiliary\+Information$>$ size\+\_\+t {\bf mlpack\+::tree\+::\+Rectangle\+Tree}$<$ Metric\+Type, Statistic\+Type, Mat\+Type, {\bf Split\+Type}, {\bf Descent\+Type}, Auxiliary\+Information\+Type $>$\+::count\hspace{0.3cm}{\ttfamily [private]}}\label{classmlpack_1_1tree_1_1RectangleTree_a6e46083ebbb6a00b65625e1e6eb89774}


The number of points in the dataset contained in this node (and its children). 



Definition at line 84 of file rectangle\+\_\+tree.\+hpp.



Referenced by mlpack\+::tree\+::\+Rectangle\+Tree$<$ Metric\+Type, Statistic\+Type, Mat\+Type, Split\+Type, Descent\+Type, Auxiliary\+Information\+Type $>$\+::\+Count().

\index{mlpack\+::tree\+::\+Rectangle\+Tree@{mlpack\+::tree\+::\+Rectangle\+Tree}!dataset@{dataset}}
\index{dataset@{dataset}!mlpack\+::tree\+::\+Rectangle\+Tree@{mlpack\+::tree\+::\+Rectangle\+Tree}}
\subsubsection[{dataset}]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename Metric\+Type  = metric\+::\+Euclidean\+Distance, typename Statistic\+Type  = Empty\+Statistic, typename Mat\+Type  = arma\+::mat, typename Split\+Type  = R\+Tree\+Split, typename Descent\+Type  = R\+Tree\+Descent\+Heuristic, template$<$ typename $>$ class Auxiliary\+Information\+Type = No\+Auxiliary\+Information$>$ const Mat\+Type$\ast$ {\bf mlpack\+::tree\+::\+Rectangle\+Tree}$<$ Metric\+Type, Statistic\+Type, Mat\+Type, {\bf Split\+Type}, {\bf Descent\+Type}, Auxiliary\+Information\+Type $>$\+::dataset\hspace{0.3cm}{\ttfamily [private]}}\label{classmlpack_1_1tree_1_1RectangleTree_a097d671b202b31fb0132e8f98771520f}


The dataset. 



Definition at line 98 of file rectangle\+\_\+tree.\+hpp.



Referenced by mlpack\+::tree\+::\+Rectangle\+Tree$<$ Metric\+Type, Statistic\+Type, Mat\+Type, Split\+Type, Descent\+Type, Auxiliary\+Information\+Type $>$\+::\+Dataset().

\index{mlpack\+::tree\+::\+Rectangle\+Tree@{mlpack\+::tree\+::\+Rectangle\+Tree}!Descent\+Type@{Descent\+Type}}
\index{Descent\+Type@{Descent\+Type}!mlpack\+::tree\+::\+Rectangle\+Tree@{mlpack\+::tree\+::\+Rectangle\+Tree}}
\subsubsection[{Descent\+Type}]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename Metric\+Type  = metric\+::\+Euclidean\+Distance, typename Statistic\+Type  = Empty\+Statistic, typename Mat\+Type  = arma\+::mat, typename Split\+Type  = R\+Tree\+Split, typename Descent\+Type  = R\+Tree\+Descent\+Heuristic, template$<$ typename $>$ class Auxiliary\+Information\+Type = No\+Auxiliary\+Information$>$ friend {\bf mlpack\+::tree\+::\+Rectangle\+Tree}$<$ Metric\+Type, Statistic\+Type, Mat\+Type, {\bf Split\+Type}, Descent\+Type, Auxiliary\+Information\+Type $>$\+::Descent\+Type\hspace{0.3cm}{\ttfamily [protected]}}\label{classmlpack_1_1tree_1_1RectangleTree_a30b58322d74d44b78a9cd37651231372}


Give friend access for Descent\+Type. 



Definition at line 557 of file rectangle\+\_\+tree.\+hpp.

\index{mlpack\+::tree\+::\+Rectangle\+Tree@{mlpack\+::tree\+::\+Rectangle\+Tree}!max\+Leaf\+Size@{max\+Leaf\+Size}}
\index{max\+Leaf\+Size@{max\+Leaf\+Size}!mlpack\+::tree\+::\+Rectangle\+Tree@{mlpack\+::tree\+::\+Rectangle\+Tree}}
\subsubsection[{max\+Leaf\+Size}]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename Metric\+Type  = metric\+::\+Euclidean\+Distance, typename Statistic\+Type  = Empty\+Statistic, typename Mat\+Type  = arma\+::mat, typename Split\+Type  = R\+Tree\+Split, typename Descent\+Type  = R\+Tree\+Descent\+Heuristic, template$<$ typename $>$ class Auxiliary\+Information\+Type = No\+Auxiliary\+Information$>$ size\+\_\+t {\bf mlpack\+::tree\+::\+Rectangle\+Tree}$<$ Metric\+Type, Statistic\+Type, Mat\+Type, {\bf Split\+Type}, {\bf Descent\+Type}, Auxiliary\+Information\+Type $>$\+::max\+Leaf\+Size\hspace{0.3cm}{\ttfamily [private]}}\label{classmlpack_1_1tree_1_1RectangleTree_a9a4d4d1380b2ffc837798cf099af45a1}


The max leaf size. 



Definition at line 88 of file rectangle\+\_\+tree.\+hpp.



Referenced by mlpack\+::tree\+::\+Rectangle\+Tree$<$ Metric\+Type, Statistic\+Type, Mat\+Type, Split\+Type, Descent\+Type, Auxiliary\+Information\+Type $>$\+::\+Max\+Leaf\+Size().

\index{mlpack\+::tree\+::\+Rectangle\+Tree@{mlpack\+::tree\+::\+Rectangle\+Tree}!max\+Num\+Children@{max\+Num\+Children}}
\index{max\+Num\+Children@{max\+Num\+Children}!mlpack\+::tree\+::\+Rectangle\+Tree@{mlpack\+::tree\+::\+Rectangle\+Tree}}
\subsubsection[{max\+Num\+Children}]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename Metric\+Type  = metric\+::\+Euclidean\+Distance, typename Statistic\+Type  = Empty\+Statistic, typename Mat\+Type  = arma\+::mat, typename Split\+Type  = R\+Tree\+Split, typename Descent\+Type  = R\+Tree\+Descent\+Heuristic, template$<$ typename $>$ class Auxiliary\+Information\+Type = No\+Auxiliary\+Information$>$ size\+\_\+t {\bf mlpack\+::tree\+::\+Rectangle\+Tree}$<$ Metric\+Type, Statistic\+Type, Mat\+Type, {\bf Split\+Type}, {\bf Descent\+Type}, Auxiliary\+Information\+Type $>$\+::max\+Num\+Children\hspace{0.3cm}{\ttfamily [private]}}\label{classmlpack_1_1tree_1_1RectangleTree_a5ab211fb15c3bf9af62c394571011755}


The max number of child nodes a non-\/leaf node can have. 



Definition at line 68 of file rectangle\+\_\+tree.\+hpp.



Referenced by mlpack\+::tree\+::\+Rectangle\+Tree$<$ Metric\+Type, Statistic\+Type, Mat\+Type, Split\+Type, Descent\+Type, Auxiliary\+Information\+Type $>$\+::\+Max\+Num\+Children().

\index{mlpack\+::tree\+::\+Rectangle\+Tree@{mlpack\+::tree\+::\+Rectangle\+Tree}!min\+Leaf\+Size@{min\+Leaf\+Size}}
\index{min\+Leaf\+Size@{min\+Leaf\+Size}!mlpack\+::tree\+::\+Rectangle\+Tree@{mlpack\+::tree\+::\+Rectangle\+Tree}}
\subsubsection[{min\+Leaf\+Size}]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename Metric\+Type  = metric\+::\+Euclidean\+Distance, typename Statistic\+Type  = Empty\+Statistic, typename Mat\+Type  = arma\+::mat, typename Split\+Type  = R\+Tree\+Split, typename Descent\+Type  = R\+Tree\+Descent\+Heuristic, template$<$ typename $>$ class Auxiliary\+Information\+Type = No\+Auxiliary\+Information$>$ size\+\_\+t {\bf mlpack\+::tree\+::\+Rectangle\+Tree}$<$ Metric\+Type, Statistic\+Type, Mat\+Type, {\bf Split\+Type}, {\bf Descent\+Type}, Auxiliary\+Information\+Type $>$\+::min\+Leaf\+Size\hspace{0.3cm}{\ttfamily [private]}}\label{classmlpack_1_1tree_1_1RectangleTree_ad4fe57fbb5e987113af700b474cb3317}


The minimum leaf size. 



Definition at line 90 of file rectangle\+\_\+tree.\+hpp.



Referenced by mlpack\+::tree\+::\+Rectangle\+Tree$<$ Metric\+Type, Statistic\+Type, Mat\+Type, Split\+Type, Descent\+Type, Auxiliary\+Information\+Type $>$\+::\+Min\+Leaf\+Size().

\index{mlpack\+::tree\+::\+Rectangle\+Tree@{mlpack\+::tree\+::\+Rectangle\+Tree}!min\+Num\+Children@{min\+Num\+Children}}
\index{min\+Num\+Children@{min\+Num\+Children}!mlpack\+::tree\+::\+Rectangle\+Tree@{mlpack\+::tree\+::\+Rectangle\+Tree}}
\subsubsection[{min\+Num\+Children}]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename Metric\+Type  = metric\+::\+Euclidean\+Distance, typename Statistic\+Type  = Empty\+Statistic, typename Mat\+Type  = arma\+::mat, typename Split\+Type  = R\+Tree\+Split, typename Descent\+Type  = R\+Tree\+Descent\+Heuristic, template$<$ typename $>$ class Auxiliary\+Information\+Type = No\+Auxiliary\+Information$>$ size\+\_\+t {\bf mlpack\+::tree\+::\+Rectangle\+Tree}$<$ Metric\+Type, Statistic\+Type, Mat\+Type, {\bf Split\+Type}, {\bf Descent\+Type}, Auxiliary\+Information\+Type $>$\+::min\+Num\+Children\hspace{0.3cm}{\ttfamily [private]}}\label{classmlpack_1_1tree_1_1RectangleTree_a6e387b0a851a358294061a484cb6fa4c}


The minimum number of child nodes a non-\/leaf node can have. 



Definition at line 70 of file rectangle\+\_\+tree.\+hpp.



Referenced by mlpack\+::tree\+::\+Rectangle\+Tree$<$ Metric\+Type, Statistic\+Type, Mat\+Type, Split\+Type, Descent\+Type, Auxiliary\+Information\+Type $>$\+::\+Min\+Num\+Children().

\index{mlpack\+::tree\+::\+Rectangle\+Tree@{mlpack\+::tree\+::\+Rectangle\+Tree}!num\+Children@{num\+Children}}
\index{num\+Children@{num\+Children}!mlpack\+::tree\+::\+Rectangle\+Tree@{mlpack\+::tree\+::\+Rectangle\+Tree}}
\subsubsection[{num\+Children}]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename Metric\+Type  = metric\+::\+Euclidean\+Distance, typename Statistic\+Type  = Empty\+Statistic, typename Mat\+Type  = arma\+::mat, typename Split\+Type  = R\+Tree\+Split, typename Descent\+Type  = R\+Tree\+Descent\+Heuristic, template$<$ typename $>$ class Auxiliary\+Information\+Type = No\+Auxiliary\+Information$>$ size\+\_\+t {\bf mlpack\+::tree\+::\+Rectangle\+Tree}$<$ Metric\+Type, Statistic\+Type, Mat\+Type, {\bf Split\+Type}, {\bf Descent\+Type}, Auxiliary\+Information\+Type $>$\+::num\+Children\hspace{0.3cm}{\ttfamily [private]}}\label{classmlpack_1_1tree_1_1RectangleTree_aa8677324019f2370ac5db405007ef74a}


The number of child nodes actually in use (0 if this is a leaf node). 



Definition at line 72 of file rectangle\+\_\+tree.\+hpp.



Referenced by mlpack\+::tree\+::\+Rectangle\+Tree$<$ Metric\+Type, Statistic\+Type, Mat\+Type, Split\+Type, Descent\+Type, Auxiliary\+Information\+Type $>$\+::\+Num\+Children().

\index{mlpack\+::tree\+::\+Rectangle\+Tree@{mlpack\+::tree\+::\+Rectangle\+Tree}!num\+Descendants@{num\+Descendants}}
\index{num\+Descendants@{num\+Descendants}!mlpack\+::tree\+::\+Rectangle\+Tree@{mlpack\+::tree\+::\+Rectangle\+Tree}}
\subsubsection[{num\+Descendants}]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename Metric\+Type  = metric\+::\+Euclidean\+Distance, typename Statistic\+Type  = Empty\+Statistic, typename Mat\+Type  = arma\+::mat, typename Split\+Type  = R\+Tree\+Split, typename Descent\+Type  = R\+Tree\+Descent\+Heuristic, template$<$ typename $>$ class Auxiliary\+Information\+Type = No\+Auxiliary\+Information$>$ size\+\_\+t {\bf mlpack\+::tree\+::\+Rectangle\+Tree}$<$ Metric\+Type, Statistic\+Type, Mat\+Type, {\bf Split\+Type}, {\bf Descent\+Type}, Auxiliary\+Information\+Type $>$\+::num\+Descendants\hspace{0.3cm}{\ttfamily [private]}}\label{classmlpack_1_1tree_1_1RectangleTree_aca4b576efc5f3ca21f79134659c2bbda}


The number of descendants of this node. 



Definition at line 86 of file rectangle\+\_\+tree.\+hpp.

\index{mlpack\+::tree\+::\+Rectangle\+Tree@{mlpack\+::tree\+::\+Rectangle\+Tree}!owns\+Dataset@{owns\+Dataset}}
\index{owns\+Dataset@{owns\+Dataset}!mlpack\+::tree\+::\+Rectangle\+Tree@{mlpack\+::tree\+::\+Rectangle\+Tree}}
\subsubsection[{owns\+Dataset}]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename Metric\+Type  = metric\+::\+Euclidean\+Distance, typename Statistic\+Type  = Empty\+Statistic, typename Mat\+Type  = arma\+::mat, typename Split\+Type  = R\+Tree\+Split, typename Descent\+Type  = R\+Tree\+Descent\+Heuristic, template$<$ typename $>$ class Auxiliary\+Information\+Type = No\+Auxiliary\+Information$>$ bool {\bf mlpack\+::tree\+::\+Rectangle\+Tree}$<$ Metric\+Type, Statistic\+Type, Mat\+Type, {\bf Split\+Type}, {\bf Descent\+Type}, Auxiliary\+Information\+Type $>$\+::owns\+Dataset\hspace{0.3cm}{\ttfamily [private]}}\label{classmlpack_1_1tree_1_1RectangleTree_a033230f3123b3b5bd130f20a2eaefd22}


Whether or not we are responsible for deleting the dataset. 

This is probably not aligned well... 

Definition at line 101 of file rectangle\+\_\+tree.\+hpp.

\index{mlpack\+::tree\+::\+Rectangle\+Tree@{mlpack\+::tree\+::\+Rectangle\+Tree}!parent@{parent}}
\index{parent@{parent}!mlpack\+::tree\+::\+Rectangle\+Tree@{mlpack\+::tree\+::\+Rectangle\+Tree}}
\subsubsection[{parent}]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename Metric\+Type  = metric\+::\+Euclidean\+Distance, typename Statistic\+Type  = Empty\+Statistic, typename Mat\+Type  = arma\+::mat, typename Split\+Type  = R\+Tree\+Split, typename Descent\+Type  = R\+Tree\+Descent\+Heuristic, template$<$ typename $>$ class Auxiliary\+Information\+Type = No\+Auxiliary\+Information$>$ {\bf Rectangle\+Tree}$\ast$ {\bf mlpack\+::tree\+::\+Rectangle\+Tree}$<$ Metric\+Type, Statistic\+Type, Mat\+Type, {\bf Split\+Type}, {\bf Descent\+Type}, Auxiliary\+Information\+Type $>$\+::parent\hspace{0.3cm}{\ttfamily [private]}}\label{classmlpack_1_1tree_1_1RectangleTree_aa16c4f6142b2b241139030dae4ccb923}


The parent node (N\+U\+LL if this is the root of the tree). 



Definition at line 76 of file rectangle\+\_\+tree.\+hpp.



Referenced by mlpack\+::tree\+::\+Rectangle\+Tree$<$ Metric\+Type, Statistic\+Type, Mat\+Type, Split\+Type, Descent\+Type, Auxiliary\+Information\+Type $>$\+::\+Parent().

\index{mlpack\+::tree\+::\+Rectangle\+Tree@{mlpack\+::tree\+::\+Rectangle\+Tree}!parent\+Distance@{parent\+Distance}}
\index{parent\+Distance@{parent\+Distance}!mlpack\+::tree\+::\+Rectangle\+Tree@{mlpack\+::tree\+::\+Rectangle\+Tree}}
\subsubsection[{parent\+Distance}]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename Metric\+Type  = metric\+::\+Euclidean\+Distance, typename Statistic\+Type  = Empty\+Statistic, typename Mat\+Type  = arma\+::mat, typename Split\+Type  = R\+Tree\+Split, typename Descent\+Type  = R\+Tree\+Descent\+Heuristic, template$<$ typename $>$ class Auxiliary\+Information\+Type = No\+Auxiliary\+Information$>$ {\bf Elem\+Type} {\bf mlpack\+::tree\+::\+Rectangle\+Tree}$<$ Metric\+Type, Statistic\+Type, Mat\+Type, {\bf Split\+Type}, {\bf Descent\+Type}, Auxiliary\+Information\+Type $>$\+::parent\+Distance\hspace{0.3cm}{\ttfamily [private]}}\label{classmlpack_1_1tree_1_1RectangleTree_a4b76850f497a903d0c8454dba50ab22b}


The distance from the centroid of this node to the centroid of the parent. 



Definition at line 96 of file rectangle\+\_\+tree.\+hpp.



Referenced by mlpack\+::tree\+::\+Rectangle\+Tree$<$ Metric\+Type, Statistic\+Type, Mat\+Type, Split\+Type, Descent\+Type, Auxiliary\+Information\+Type $>$\+::\+Parent\+Distance().

\index{mlpack\+::tree\+::\+Rectangle\+Tree@{mlpack\+::tree\+::\+Rectangle\+Tree}!points@{points}}
\index{points@{points}!mlpack\+::tree\+::\+Rectangle\+Tree@{mlpack\+::tree\+::\+Rectangle\+Tree}}
\subsubsection[{points}]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename Metric\+Type  = metric\+::\+Euclidean\+Distance, typename Statistic\+Type  = Empty\+Statistic, typename Mat\+Type  = arma\+::mat, typename Split\+Type  = R\+Tree\+Split, typename Descent\+Type  = R\+Tree\+Descent\+Heuristic, template$<$ typename $>$ class Auxiliary\+Information\+Type = No\+Auxiliary\+Information$>$ std\+::vector$<$size\+\_\+t$>$ {\bf mlpack\+::tree\+::\+Rectangle\+Tree}$<$ Metric\+Type, Statistic\+Type, Mat\+Type, {\bf Split\+Type}, {\bf Descent\+Type}, Auxiliary\+Information\+Type $>$\+::points\hspace{0.3cm}{\ttfamily [private]}}\label{classmlpack_1_1tree_1_1RectangleTree_a53fc36e4d4e4cfd057e08c1fc5dd0b4b}


The mapping to the dataset. 



Definition at line 103 of file rectangle\+\_\+tree.\+hpp.

\index{mlpack\+::tree\+::\+Rectangle\+Tree@{mlpack\+::tree\+::\+Rectangle\+Tree}!Split\+Type@{Split\+Type}}
\index{Split\+Type@{Split\+Type}!mlpack\+::tree\+::\+Rectangle\+Tree@{mlpack\+::tree\+::\+Rectangle\+Tree}}
\subsubsection[{Split\+Type}]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename Metric\+Type  = metric\+::\+Euclidean\+Distance, typename Statistic\+Type  = Empty\+Statistic, typename Mat\+Type  = arma\+::mat, typename Split\+Type  = R\+Tree\+Split, typename Descent\+Type  = R\+Tree\+Descent\+Heuristic, template$<$ typename $>$ class Auxiliary\+Information\+Type = No\+Auxiliary\+Information$>$ friend {\bf mlpack\+::tree\+::\+Rectangle\+Tree}$<$ Metric\+Type, Statistic\+Type, Mat\+Type, Split\+Type, {\bf Descent\+Type}, Auxiliary\+Information\+Type $>$\+::Split\+Type\hspace{0.3cm}{\ttfamily [protected]}}\label{classmlpack_1_1tree_1_1RectangleTree_a3a4c25452da57888c09e09b74ee81f2b}


Give friend access for Split\+Type. 



Definition at line 560 of file rectangle\+\_\+tree.\+hpp.

\index{mlpack\+::tree\+::\+Rectangle\+Tree@{mlpack\+::tree\+::\+Rectangle\+Tree}!stat@{stat}}
\index{stat@{stat}!mlpack\+::tree\+::\+Rectangle\+Tree@{mlpack\+::tree\+::\+Rectangle\+Tree}}
\subsubsection[{stat}]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename Metric\+Type  = metric\+::\+Euclidean\+Distance, typename Statistic\+Type  = Empty\+Statistic, typename Mat\+Type  = arma\+::mat, typename Split\+Type  = R\+Tree\+Split, typename Descent\+Type  = R\+Tree\+Descent\+Heuristic, template$<$ typename $>$ class Auxiliary\+Information\+Type = No\+Auxiliary\+Information$>$ Statistic\+Type {\bf mlpack\+::tree\+::\+Rectangle\+Tree}$<$ Metric\+Type, Statistic\+Type, Mat\+Type, {\bf Split\+Type}, {\bf Descent\+Type}, Auxiliary\+Information\+Type $>$\+::stat\hspace{0.3cm}{\ttfamily [private]}}\label{classmlpack_1_1tree_1_1RectangleTree_a8a2547b1933bb1d09378b762e8e33aeb}


Any extra data contained in the node. 



Definition at line 94 of file rectangle\+\_\+tree.\+hpp.



Referenced by mlpack\+::tree\+::\+Rectangle\+Tree$<$ Metric\+Type, Statistic\+Type, Mat\+Type, Split\+Type, Descent\+Type, Auxiliary\+Information\+Type $>$\+::\+Stat().



The documentation for this class was generated from the following file\+:\begin{DoxyCompactItemize}
\item 
src/mlpack/core/tree/rectangle\+\_\+tree/{\bf rectangle\+\_\+tree.\+hpp}\end{DoxyCompactItemize}
