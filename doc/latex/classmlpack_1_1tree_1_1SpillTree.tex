\section{mlpack\+:\+:tree\+:\+:Spill\+Tree$<$ Metric\+Type, Statistic\+Type, Mat\+Type, Hyperplane\+Type, Split\+Type $>$ Class Template Reference}
\label{classmlpack_1_1tree_1_1SpillTree}\index{mlpack\+::tree\+::\+Spill\+Tree$<$ Metric\+Type, Statistic\+Type, Mat\+Type, Hyperplane\+Type, Split\+Type $>$@{mlpack\+::tree\+::\+Spill\+Tree$<$ Metric\+Type, Statistic\+Type, Mat\+Type, Hyperplane\+Type, Split\+Type $>$}}


A hybrid spill tree is a variant of binary space trees in which the children of a node can \char`\"{}spill over\char`\"{} each other, and contain shared datapoints.  


\subsection*{Classes}
\begin{DoxyCompactItemize}
\item 
class {\bf Spill\+Dual\+Tree\+Traverser}
\begin{DoxyCompactList}\small\item\em A generic dual-\/tree traverser for hybrid spill trees; see \doxyref{spill\+\_\+dual\+\_\+tree\+\_\+traverser.\+hpp}{p.}{spill__dual__tree__traverser_8hpp} for implementation. \end{DoxyCompactList}\item 
class {\bf Spill\+Single\+Tree\+Traverser}
\begin{DoxyCompactList}\small\item\em A generic single-\/tree traverser for hybrid spill trees; see \doxyref{spill\+\_\+single\+\_\+tree\+\_\+traverser.\+hpp}{p.}{spill__single__tree__traverser_8hpp} for implementation. \end{DoxyCompactList}\end{DoxyCompactItemize}
\subsection*{Public Types}
\begin{DoxyCompactItemize}
\item 
typedef Hyperplane\+Type$<$ Metric\+Type $>$\+::{\bf Bound\+Type} {\bf Bound\+Type}
\begin{DoxyCompactList}\small\item\em The bound type. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename Rule\+Type $>$ }\\using {\bf Defeatist\+Dual\+Tree\+Traverser} = {\bf Spill\+Dual\+Tree\+Traverser}$<$ Rule\+Type, true $>$
\begin{DoxyCompactList}\small\item\em A defeatist dual-\/tree traverser for hybrid spill trees. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename Rule\+Type $>$ }\\using {\bf Defeatist\+Single\+Tree\+Traverser} = {\bf Spill\+Single\+Tree\+Traverser}$<$ Rule\+Type, true $>$
\begin{DoxyCompactList}\small\item\em A defeatist single-\/tree traverser for hybrid spill trees. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename Rule\+Type $>$ }\\using {\bf Dual\+Tree\+Traverser} = {\bf Spill\+Dual\+Tree\+Traverser}$<$ Rule\+Type, false $>$
\begin{DoxyCompactList}\small\item\em A dual-\/tree traverser for hybrid spill trees. \end{DoxyCompactList}\item 
typedef Mat\+Type\+::elem\+\_\+type {\bf Elem\+Type}
\begin{DoxyCompactList}\small\item\em The type of element held in Mat\+Type. \end{DoxyCompactList}\item 
typedef Mat\+Type {\bf Mat}
\begin{DoxyCompactList}\small\item\em So other classes can use Tree\+Type\+::\+Mat. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename Rule\+Type $>$ }\\using {\bf Single\+Tree\+Traverser} = {\bf Spill\+Single\+Tree\+Traverser}$<$ Rule\+Type, false $>$
\begin{DoxyCompactList}\small\item\em A single-\/tree traverser for hybrid spill trees. \end{DoxyCompactList}\end{DoxyCompactItemize}
\subsection*{Public Member Functions}
\begin{DoxyCompactItemize}
\item 
{\bf Spill\+Tree} (const Mat\+Type \&data, const double tau=0, const size\+\_\+t max\+Leaf\+Size=20, const double rho=0.\+7)
\begin{DoxyCompactList}\small\item\em Construct this as the root node of a hybrid spill tree using the given dataset. \end{DoxyCompactList}\item 
{\bf Spill\+Tree} (Mat\+Type \&\&data, const double tau=0, const size\+\_\+t max\+Leaf\+Size=20, const double rho=0.\+7)
\begin{DoxyCompactList}\small\item\em Construct this as the root node of a hybrid spill tree using the given dataset. \end{DoxyCompactList}\item 
{\bf Spill\+Tree} ({\bf Spill\+Tree} $\ast${\bf parent}, arma\+::\+Col$<$ size\+\_\+t $>$ \&points, const double tau=0, const size\+\_\+t max\+Leaf\+Size=20, const double rho=0.\+7)
\begin{DoxyCompactList}\small\item\em Construct this node as a child of the given parent, including the given list of points. \end{DoxyCompactList}\item 
{\bf Spill\+Tree} (const {\bf Spill\+Tree} \&other)
\begin{DoxyCompactList}\small\item\em Create a hybrid spill tree by copying the other tree. \end{DoxyCompactList}\item 
{\bf Spill\+Tree} ({\bf Spill\+Tree} \&\&other)
\begin{DoxyCompactList}\small\item\em Move constructor for a \doxyref{Spill\+Tree}{p.}{classmlpack_1_1tree_1_1SpillTree}; possess all the members of the given tree. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename Archive $>$ }\\{\bf Spill\+Tree} (Archive \&ar, const typename {\bf std\+::enable\+\_\+if\+\_\+t}$<$ Archive\+::is\+\_\+loading\+::value $>$ $\ast$=0)
\begin{DoxyCompactList}\small\item\em Initialize the tree from a \doxyref{boost\+::serialization}{p.}{namespaceboost_1_1serialization} archive. \end{DoxyCompactList}\item 
{\bf $\sim$\+Spill\+Tree} ()
\begin{DoxyCompactList}\small\item\em Deletes this node, deallocating the memory for the children and calling their destructors in turn. \end{DoxyCompactList}\item 
const {\bf Bound\+Type} \& {\bf Bound} () const 
\begin{DoxyCompactList}\small\item\em Return the bound object for this node. \end{DoxyCompactList}\item 
{\bf Bound\+Type} \& {\bf Bound} ()
\begin{DoxyCompactList}\small\item\em Return the bound object for this node. \end{DoxyCompactList}\item 
void {\bf Center} (arma\+::vec \&center)
\begin{DoxyCompactList}\small\item\em Store the center of the bounding region in the given vector. \end{DoxyCompactList}\item 
{\bf Spill\+Tree} \& {\bf Child} (const size\+\_\+t child) const 
\begin{DoxyCompactList}\small\item\em Return the specified child (0 will be left, 1 will be right). \end{DoxyCompactList}\item 
{\bf Spill\+Tree} $\ast$\& {\bf Child\+Ptr} (const size\+\_\+t child)
\item 
const Mat\+Type \& {\bf Dataset} () const 
\begin{DoxyCompactList}\small\item\em Get the dataset which the tree is built on. \end{DoxyCompactList}\item 
size\+\_\+t {\bf Descendant} (const size\+\_\+t index) const 
\begin{DoxyCompactList}\small\item\em Return the index (with reference to the dataset) of a particular descendant of this node. \end{DoxyCompactList}\item 
{\bf Elem\+Type} {\bf Furthest\+Descendant\+Distance} () const 
\begin{DoxyCompactList}\small\item\em Return the furthest possible descendant distance. \end{DoxyCompactList}\item 
{\bf Elem\+Type} {\bf Furthest\+Point\+Distance} () const 
\begin{DoxyCompactList}\small\item\em Return the furthest distance to a point held in this node. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename Vec\+Type $>$ }\\size\+\_\+t {\bf Get\+Furthest\+Child} (const Vec\+Type \&point, typename {\bf std\+::enable\+\_\+if\+\_\+t}$<$ {\bf Is\+Vector}$<$ Vec\+Type $>$\+::value $>$ $\ast$=0)
\begin{DoxyCompactList}\small\item\em Return the index of the furthest child node to the given query point (this is an efficient estimation based on the splitting hyperplane, the node returned is not necessarily the furthest). \end{DoxyCompactList}\item 
size\+\_\+t {\bf Get\+Furthest\+Child} (const {\bf Spill\+Tree} \&query\+Node)
\begin{DoxyCompactList}\small\item\em Return the index of the furthest child node to the given query node (this is an efficient estimation based on the splitting hyperplane, the node returned is not necessarily the furthest). \end{DoxyCompactList}\item 
{\footnotesize template$<$typename Vec\+Type $>$ }\\size\+\_\+t {\bf Get\+Nearest\+Child} (const Vec\+Type \&point, typename {\bf std\+::enable\+\_\+if\+\_\+t}$<$ {\bf Is\+Vector}$<$ Vec\+Type $>$\+::value $>$ $\ast$=0)
\begin{DoxyCompactList}\small\item\em Return the index of the nearest child node to the given query point (this is an efficient estimation based on the splitting hyperplane, the node returned is not necessarily the nearest). \end{DoxyCompactList}\item 
size\+\_\+t {\bf Get\+Nearest\+Child} (const {\bf Spill\+Tree} \&query\+Node)
\begin{DoxyCompactList}\small\item\em Return the index of the nearest child node to the given query node (this is an efficient estimation based on the splitting hyperplane, the node returned is not necessarily the nearest). \end{DoxyCompactList}\item 
const Hyperplane\+Type$<$ Metric\+Type $>$ \& {\bf Hyperplane} () const 
\begin{DoxyCompactList}\small\item\em Get the Hyperplane instance. \end{DoxyCompactList}\item 
bool {\bf Is\+Leaf} () const 
\begin{DoxyCompactList}\small\item\em Return whether or not this node is a leaf (true if it has no children). \end{DoxyCompactList}\item 
{\bf Spill\+Tree} $\ast$ {\bf Left} () const 
\begin{DoxyCompactList}\small\item\em Gets the left child of this node. \end{DoxyCompactList}\item 
{\bf Spill\+Tree} $\ast$\& {\bf Left} ()
\begin{DoxyCompactList}\small\item\em Modify the left child of this node. \end{DoxyCompactList}\item 
{\bf Elem\+Type} {\bf Max\+Distance} (const {\bf Spill\+Tree} \&other) const 
\begin{DoxyCompactList}\small\item\em Return the maximum distance to another node. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename Vec\+Type $>$ }\\{\bf Elem\+Type} {\bf Max\+Distance} (const Vec\+Type \&point, typename {\bf std\+::enable\+\_\+if\+\_\+t}$<$ {\bf Is\+Vector}$<$ Vec\+Type $>$\+::value $>$ $\ast$=0) const 
\begin{DoxyCompactList}\small\item\em Return the maximum distance to another point. \end{DoxyCompactList}\item 
Metric\+Type {\bf Metric} () const 
\begin{DoxyCompactList}\small\item\em Get the metric that the tree uses. \end{DoxyCompactList}\item 
{\bf Elem\+Type} {\bf Min\+Distance} (const {\bf Spill\+Tree} \&other) const 
\begin{DoxyCompactList}\small\item\em Return the minimum distance to another node. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename Vec\+Type $>$ }\\{\bf Elem\+Type} {\bf Min\+Distance} (const Vec\+Type \&point, typename {\bf std\+::enable\+\_\+if\+\_\+t}$<$ {\bf Is\+Vector}$<$ Vec\+Type $>$\+::value $>$ $\ast$=0) const 
\begin{DoxyCompactList}\small\item\em Return the minimum distance to another point. \end{DoxyCompactList}\item 
{\bf Elem\+Type} {\bf Minimum\+Bound\+Distance} () const 
\begin{DoxyCompactList}\small\item\em Return the minimum distance from the center of the node to any bound edge. \end{DoxyCompactList}\item 
size\+\_\+t {\bf Num\+Children} () const 
\begin{DoxyCompactList}\small\item\em Return the number of children in this node. \end{DoxyCompactList}\item 
size\+\_\+t {\bf Num\+Descendants} () const 
\begin{DoxyCompactList}\small\item\em Return the number of descendants of this node. \end{DoxyCompactList}\item 
size\+\_\+t {\bf Num\+Points} () const 
\begin{DoxyCompactList}\small\item\em Return the number of points in this node (0 if not a leaf). \end{DoxyCompactList}\item 
bool {\bf Overlap} () const 
\begin{DoxyCompactList}\small\item\em Distinguish overlapping nodes from non-\/overlapping nodes. \end{DoxyCompactList}\item 
{\bf Spill\+Tree} $\ast$ {\bf Parent} () const 
\begin{DoxyCompactList}\small\item\em Gets the parent of this node. \end{DoxyCompactList}\item 
{\bf Spill\+Tree} $\ast$\& {\bf Parent} ()
\begin{DoxyCompactList}\small\item\em Modify the parent of this node. \end{DoxyCompactList}\item 
{\bf Elem\+Type} {\bf Parent\+Distance} () const 
\begin{DoxyCompactList}\small\item\em Return the distance from the center of this node to the center of the parent node. \end{DoxyCompactList}\item 
{\bf Elem\+Type} \& {\bf Parent\+Distance} ()
\begin{DoxyCompactList}\small\item\em Modify the distance from the center of this node to the center of the parent node. \end{DoxyCompactList}\item 
size\+\_\+t {\bf Point} (const size\+\_\+t index) const 
\begin{DoxyCompactList}\small\item\em Return the index (with reference to the dataset) of a particular point in this node. \end{DoxyCompactList}\item 
{\bf math\+::\+Range\+Type}$<$ {\bf Elem\+Type} $>$ {\bf Range\+Distance} (const {\bf Spill\+Tree} \&other) const 
\begin{DoxyCompactList}\small\item\em Return the minimum and maximum distance to another node. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename Vec\+Type $>$ }\\{\bf math\+::\+Range\+Type}$<$ {\bf Elem\+Type} $>$ {\bf Range\+Distance} (const Vec\+Type \&point, typename {\bf std\+::enable\+\_\+if\+\_\+t}$<$ {\bf Is\+Vector}$<$ Vec\+Type $>$\+::value $>$ $\ast$=0) const 
\begin{DoxyCompactList}\small\item\em Return the minimum and maximum distance to another point. \end{DoxyCompactList}\item 
{\bf Spill\+Tree} $\ast$ {\bf Right} () const 
\begin{DoxyCompactList}\small\item\em Gets the right child of this node. \end{DoxyCompactList}\item 
{\bf Spill\+Tree} $\ast$\& {\bf Right} ()
\begin{DoxyCompactList}\small\item\em Modify the right child of this node. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename Archive $>$ }\\void {\bf Serialize} (Archive \&ar, const unsigned int version)
\begin{DoxyCompactList}\small\item\em Serialize the tree. \end{DoxyCompactList}\item 
const Statistic\+Type \& {\bf Stat} () const 
\begin{DoxyCompactList}\small\item\em Return the statistic object for this node. \end{DoxyCompactList}\item 
Statistic\+Type \& {\bf Stat} ()
\begin{DoxyCompactList}\small\item\em Return the statistic object for this node. \end{DoxyCompactList}\end{DoxyCompactItemize}
\subsection*{Static Public Member Functions}
\begin{DoxyCompactItemize}
\item 
static bool {\bf Has\+Self\+Children} ()
\begin{DoxyCompactList}\small\item\em Returns false\+: this tree type does not have self children. \end{DoxyCompactList}\end{DoxyCompactItemize}
\subsection*{Protected Member Functions}
\begin{DoxyCompactItemize}
\item 
{\bf Spill\+Tree} ()
\begin{DoxyCompactList}\small\item\em A default constructor. \end{DoxyCompactList}\end{DoxyCompactItemize}
\subsection*{Private Member Functions}
\begin{DoxyCompactItemize}
\item 
void {\bf Split\+Node} (arma\+::\+Col$<$ size\+\_\+t $>$ \&points, const size\+\_\+t max\+Leaf\+Size, const double tau, const double rho)
\begin{DoxyCompactList}\small\item\em Splits the current node, assigning its left and right children recursively. \end{DoxyCompactList}\item 
bool {\bf Split\+Points} (const double tau, const double rho, const arma\+::\+Col$<$ size\+\_\+t $>$ \&points, arma\+::\+Col$<$ size\+\_\+t $>$ \&left\+Points, arma\+::\+Col$<$ size\+\_\+t $>$ \&right\+Points)
\begin{DoxyCompactList}\small\item\em Split the list of points. \end{DoxyCompactList}\end{DoxyCompactItemize}
\subsection*{Private Attributes}
\begin{DoxyCompactItemize}
\item 
{\bf Bound\+Type} {\bf bound}
\begin{DoxyCompactList}\small\item\em The bound object for this node. \end{DoxyCompactList}\item 
size\+\_\+t {\bf count}
\begin{DoxyCompactList}\small\item\em The number of points of the dataset contained in this node (and its children). \end{DoxyCompactList}\item 
const Mat\+Type $\ast$ {\bf dataset}
\begin{DoxyCompactList}\small\item\em The dataset. \end{DoxyCompactList}\item 
{\bf Elem\+Type} {\bf furthest\+Descendant\+Distance}
\begin{DoxyCompactList}\small\item\em The worst possible distance to the furthest descendant, cached to speed things up. \end{DoxyCompactList}\item 
Hyperplane\+Type$<$ Metric\+Type $>$ {\bf hyperplane}
\begin{DoxyCompactList}\small\item\em Splitting hyperplane represented by this node. \end{DoxyCompactList}\item 
{\bf Spill\+Tree} $\ast$ {\bf left}
\begin{DoxyCompactList}\small\item\em The left child node. \end{DoxyCompactList}\item 
bool {\bf local\+Dataset}
\begin{DoxyCompactList}\small\item\em If true, we own the dataset and need to destroy it in the destructor. \end{DoxyCompactList}\item 
{\bf Elem\+Type} {\bf minimum\+Bound\+Distance}
\begin{DoxyCompactList}\small\item\em The minimum distance from the center to any edge of the bound. \end{DoxyCompactList}\item 
bool {\bf overlapping\+Node}
\begin{DoxyCompactList}\small\item\em Flag to distinguish overlapping nodes from non-\/overlapping nodes. \end{DoxyCompactList}\item 
{\bf Spill\+Tree} $\ast$ {\bf parent}
\begin{DoxyCompactList}\small\item\em The parent node (N\+U\+LL if this is the root of the tree). \end{DoxyCompactList}\item 
{\bf Elem\+Type} {\bf parent\+Distance}
\begin{DoxyCompactList}\small\item\em The distance from the centroid of this node to the centroid of the parent. \end{DoxyCompactList}\item 
arma\+::\+Col$<$ size\+\_\+t $>$ $\ast$ {\bf points\+Index}
\begin{DoxyCompactList}\small\item\em The list of indexes of points contained in this node (non-\/null for leaf nodes). \end{DoxyCompactList}\item 
{\bf Spill\+Tree} $\ast$ {\bf right}
\begin{DoxyCompactList}\small\item\em The right child node. \end{DoxyCompactList}\item 
Statistic\+Type {\bf stat}
\begin{DoxyCompactList}\small\item\em Any extra data contained in the node. \end{DoxyCompactList}\end{DoxyCompactItemize}


\subsection{Detailed Description}
\subsubsection*{template$<$typename Metric\+Type, typename Statistic\+Type = Empty\+Statistic, typename Mat\+Type = arma\+::mat, template$<$ typename Hyperplane\+Metric\+Type $>$ class Hyperplane\+Type = Axis\+Orthogonal\+Hyperplane, template$<$ typename Split\+Metric\+Type, typename Split\+Mat\+Type $>$ class Split\+Type = Midpoint\+Space\+Split$>$\\*
class mlpack\+::tree\+::\+Spill\+Tree$<$ Metric\+Type, Statistic\+Type, Mat\+Type, Hyperplane\+Type, Split\+Type $>$}

A hybrid spill tree is a variant of binary space trees in which the children of a node can \char`\"{}spill over\char`\"{} each other, and contain shared datapoints. 

Two new separating planes lplane and rplane are defined, both of which are parallel to the original decision boundary and at a distance tau from it. The region between lplane and rplane is called \char`\"{}overlapping buffer\char`\"{}.

For each node, we first split the points considering the overlapping buffer. If either of its children contains more than rho fraction of the total points we undo the overlapping splitting. Instead a conventional partition is used. In this way, we can ensure that each split reduces the number of points of a node by at least a constant factor.

This particular tree does not allow growth, so you cannot add or delete nodes from it. If you need to add or delete a node, the better procedure is to rebuild the tree entirely.

Three runtime parameters are required in the constructor\+:
\begin{DoxyItemize}
\item max\+Leaf\+Size\+: Max leaf size to be used.
\item tau\+: Overlapping size.
\item rho\+: Balance threshold.
\end{DoxyItemize}

For more information on spill trees, see


\begin{DoxyCode}
@inproceedings\{
  author = \{Ting Liu, Andrew W. Moore, Alexander Gray and Ke Yang\},
  title = \{An Investigation of Practical Approximate Nearest Neighbor
    Algorithms\},
  booktitle = \{Advances in Neural Information Processing Systems 17\},
  year = \{2005\},
  pages = \{825--832\}
\}
\end{DoxyCode}



\begin{DoxyTemplParams}{Template Parameters}
{\em Metric\+Type} & The metric used for tree-\/building. \\
\hline
{\em Statistic\+Type} & Extra data contained in the node. See \doxyref{statistic.\+hpp}{p.}{statistic_8hpp} for the necessary skeleton interface. \\
\hline
{\em Mat\+Type} & The dataset class. \\
\hline
{\em Hyperplane\+Type} & The splitting hyperplane class. \\
\hline
{\em Split\+Type} & The class that partitions the dataset/points at a particular node into two parts. Its definition decides the way this split is done. \\
\hline
\end{DoxyTemplParams}


Definition at line 73 of file spill\+\_\+tree.\+hpp.



\subsection{Member Typedef Documentation}
\index{mlpack\+::tree\+::\+Spill\+Tree@{mlpack\+::tree\+::\+Spill\+Tree}!Bound\+Type@{Bound\+Type}}
\index{Bound\+Type@{Bound\+Type}!mlpack\+::tree\+::\+Spill\+Tree@{mlpack\+::tree\+::\+Spill\+Tree}}
\subsubsection[{Bound\+Type}]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename Metric\+Type , typename Statistic\+Type  = Empty\+Statistic, typename Mat\+Type  = arma\+::mat, template$<$ typename Hyperplane\+Metric\+Type $>$ class Hyperplane\+Type = Axis\+Orthogonal\+Hyperplane, template$<$ typename Split\+Metric\+Type, typename Split\+Mat\+Type $>$ class Split\+Type = Midpoint\+Space\+Split$>$ typedef Hyperplane\+Type$<$Metric\+Type$>$\+::{\bf Bound\+Type} {\bf mlpack\+::tree\+::\+Spill\+Tree}$<$ Metric\+Type, Statistic\+Type, Mat\+Type, Hyperplane\+Type, Split\+Type $>$\+::{\bf Bound\+Type}}\label{classmlpack_1_1tree_1_1SpillTree_a17fd81b3578ad9c1ba2c21bf8590319d}


The bound type. 



Definition at line 81 of file spill\+\_\+tree.\+hpp.

\index{mlpack\+::tree\+::\+Spill\+Tree@{mlpack\+::tree\+::\+Spill\+Tree}!Defeatist\+Dual\+Tree\+Traverser@{Defeatist\+Dual\+Tree\+Traverser}}
\index{Defeatist\+Dual\+Tree\+Traverser@{Defeatist\+Dual\+Tree\+Traverser}!mlpack\+::tree\+::\+Spill\+Tree@{mlpack\+::tree\+::\+Spill\+Tree}}
\subsubsection[{Defeatist\+Dual\+Tree\+Traverser}]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename Metric\+Type , typename Statistic\+Type  = Empty\+Statistic, typename Mat\+Type  = arma\+::mat, template$<$ typename Hyperplane\+Metric\+Type $>$ class Hyperplane\+Type = Axis\+Orthogonal\+Hyperplane, template$<$ typename Split\+Metric\+Type, typename Split\+Mat\+Type $>$ class Split\+Type = Midpoint\+Space\+Split$>$ template$<$typename Rule\+Type $>$ using {\bf mlpack\+::tree\+::\+Spill\+Tree}$<$ Metric\+Type, Statistic\+Type, Mat\+Type, Hyperplane\+Type, Split\+Type $>$\+::{\bf Defeatist\+Dual\+Tree\+Traverser} =  {\bf Spill\+Dual\+Tree\+Traverser}$<$Rule\+Type, true$>$}\label{classmlpack_1_1tree_1_1SpillTree_a407ac8fa6f6a73ed61c755933f64ace2}


A defeatist dual-\/tree traverser for hybrid spill trees. 



Definition at line 146 of file spill\+\_\+tree.\+hpp.

\index{mlpack\+::tree\+::\+Spill\+Tree@{mlpack\+::tree\+::\+Spill\+Tree}!Defeatist\+Single\+Tree\+Traverser@{Defeatist\+Single\+Tree\+Traverser}}
\index{Defeatist\+Single\+Tree\+Traverser@{Defeatist\+Single\+Tree\+Traverser}!mlpack\+::tree\+::\+Spill\+Tree@{mlpack\+::tree\+::\+Spill\+Tree}}
\subsubsection[{Defeatist\+Single\+Tree\+Traverser}]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename Metric\+Type , typename Statistic\+Type  = Empty\+Statistic, typename Mat\+Type  = arma\+::mat, template$<$ typename Hyperplane\+Metric\+Type $>$ class Hyperplane\+Type = Axis\+Orthogonal\+Hyperplane, template$<$ typename Split\+Metric\+Type, typename Split\+Mat\+Type $>$ class Split\+Type = Midpoint\+Space\+Split$>$ template$<$typename Rule\+Type $>$ using {\bf mlpack\+::tree\+::\+Spill\+Tree}$<$ Metric\+Type, Statistic\+Type, Mat\+Type, Hyperplane\+Type, Split\+Type $>$\+::{\bf Defeatist\+Single\+Tree\+Traverser} =  {\bf Spill\+Single\+Tree\+Traverser}$<$Rule\+Type, true$>$}\label{classmlpack_1_1tree_1_1SpillTree_aaae1fd43e08b5a226c1daab98efba83d}


A defeatist single-\/tree traverser for hybrid spill trees. 



Definition at line 138 of file spill\+\_\+tree.\+hpp.

\index{mlpack\+::tree\+::\+Spill\+Tree@{mlpack\+::tree\+::\+Spill\+Tree}!Dual\+Tree\+Traverser@{Dual\+Tree\+Traverser}}
\index{Dual\+Tree\+Traverser@{Dual\+Tree\+Traverser}!mlpack\+::tree\+::\+Spill\+Tree@{mlpack\+::tree\+::\+Spill\+Tree}}
\subsubsection[{Dual\+Tree\+Traverser}]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename Metric\+Type , typename Statistic\+Type  = Empty\+Statistic, typename Mat\+Type  = arma\+::mat, template$<$ typename Hyperplane\+Metric\+Type $>$ class Hyperplane\+Type = Axis\+Orthogonal\+Hyperplane, template$<$ typename Split\+Metric\+Type, typename Split\+Mat\+Type $>$ class Split\+Type = Midpoint\+Space\+Split$>$ template$<$typename Rule\+Type $>$ using {\bf mlpack\+::tree\+::\+Spill\+Tree}$<$ Metric\+Type, Statistic\+Type, Mat\+Type, Hyperplane\+Type, Split\+Type $>$\+::{\bf Dual\+Tree\+Traverser} =  {\bf Spill\+Dual\+Tree\+Traverser}$<$Rule\+Type, false$>$}\label{classmlpack_1_1tree_1_1SpillTree_a776c82e8b9d3711dcfdc1e7633c30306}


A dual-\/tree traverser for hybrid spill trees. 



Definition at line 142 of file spill\+\_\+tree.\+hpp.

\index{mlpack\+::tree\+::\+Spill\+Tree@{mlpack\+::tree\+::\+Spill\+Tree}!Elem\+Type@{Elem\+Type}}
\index{Elem\+Type@{Elem\+Type}!mlpack\+::tree\+::\+Spill\+Tree@{mlpack\+::tree\+::\+Spill\+Tree}}
\subsubsection[{Elem\+Type}]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename Metric\+Type , typename Statistic\+Type  = Empty\+Statistic, typename Mat\+Type  = arma\+::mat, template$<$ typename Hyperplane\+Metric\+Type $>$ class Hyperplane\+Type = Axis\+Orthogonal\+Hyperplane, template$<$ typename Split\+Metric\+Type, typename Split\+Mat\+Type $>$ class Split\+Type = Midpoint\+Space\+Split$>$ typedef Mat\+Type\+::elem\+\_\+type {\bf mlpack\+::tree\+::\+Spill\+Tree}$<$ Metric\+Type, Statistic\+Type, Mat\+Type, Hyperplane\+Type, Split\+Type $>$\+::{\bf Elem\+Type}}\label{classmlpack_1_1tree_1_1SpillTree_a5698c45a888029b584108bdc943700af}


The type of element held in Mat\+Type. 



Definition at line 79 of file spill\+\_\+tree.\+hpp.

\index{mlpack\+::tree\+::\+Spill\+Tree@{mlpack\+::tree\+::\+Spill\+Tree}!Mat@{Mat}}
\index{Mat@{Mat}!mlpack\+::tree\+::\+Spill\+Tree@{mlpack\+::tree\+::\+Spill\+Tree}}
\subsubsection[{Mat}]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename Metric\+Type , typename Statistic\+Type  = Empty\+Statistic, typename Mat\+Type  = arma\+::mat, template$<$ typename Hyperplane\+Metric\+Type $>$ class Hyperplane\+Type = Axis\+Orthogonal\+Hyperplane, template$<$ typename Split\+Metric\+Type, typename Split\+Mat\+Type $>$ class Split\+Type = Midpoint\+Space\+Split$>$ typedef Mat\+Type {\bf mlpack\+::tree\+::\+Spill\+Tree}$<$ Metric\+Type, Statistic\+Type, Mat\+Type, Hyperplane\+Type, Split\+Type $>$\+::{\bf Mat}}\label{classmlpack_1_1tree_1_1SpillTree_ab0b11ae05884a921d378e734922f8653}


So other classes can use Tree\+Type\+::\+Mat. 



Definition at line 77 of file spill\+\_\+tree.\+hpp.

\index{mlpack\+::tree\+::\+Spill\+Tree@{mlpack\+::tree\+::\+Spill\+Tree}!Single\+Tree\+Traverser@{Single\+Tree\+Traverser}}
\index{Single\+Tree\+Traverser@{Single\+Tree\+Traverser}!mlpack\+::tree\+::\+Spill\+Tree@{mlpack\+::tree\+::\+Spill\+Tree}}
\subsubsection[{Single\+Tree\+Traverser}]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename Metric\+Type , typename Statistic\+Type  = Empty\+Statistic, typename Mat\+Type  = arma\+::mat, template$<$ typename Hyperplane\+Metric\+Type $>$ class Hyperplane\+Type = Axis\+Orthogonal\+Hyperplane, template$<$ typename Split\+Metric\+Type, typename Split\+Mat\+Type $>$ class Split\+Type = Midpoint\+Space\+Split$>$ template$<$typename Rule\+Type $>$ using {\bf mlpack\+::tree\+::\+Spill\+Tree}$<$ Metric\+Type, Statistic\+Type, Mat\+Type, Hyperplane\+Type, Split\+Type $>$\+::{\bf Single\+Tree\+Traverser} =  {\bf Spill\+Single\+Tree\+Traverser}$<$Rule\+Type, false$>$}\label{classmlpack_1_1tree_1_1SpillTree_a02b7fc2ba94d53eaf705541b7fe99a30}


A single-\/tree traverser for hybrid spill trees. 



Definition at line 134 of file spill\+\_\+tree.\+hpp.



\subsection{Constructor \& Destructor Documentation}
\index{mlpack\+::tree\+::\+Spill\+Tree@{mlpack\+::tree\+::\+Spill\+Tree}!Spill\+Tree@{Spill\+Tree}}
\index{Spill\+Tree@{Spill\+Tree}!mlpack\+::tree\+::\+Spill\+Tree@{mlpack\+::tree\+::\+Spill\+Tree}}
\subsubsection[{Spill\+Tree(const Mat\+Type \&data, const double tau=0, const size\+\_\+t max\+Leaf\+Size=20, const double rho=0.\+7)}]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename Metric\+Type , typename Statistic\+Type  = Empty\+Statistic, typename Mat\+Type  = arma\+::mat, template$<$ typename Hyperplane\+Metric\+Type $>$ class Hyperplane\+Type = Axis\+Orthogonal\+Hyperplane, template$<$ typename Split\+Metric\+Type, typename Split\+Mat\+Type $>$ class Split\+Type = Midpoint\+Space\+Split$>$ {\bf mlpack\+::tree\+::\+Spill\+Tree}$<$ Metric\+Type, Statistic\+Type, Mat\+Type, Hyperplane\+Type, Split\+Type $>$\+::{\bf Spill\+Tree} (
\begin{DoxyParamCaption}
\item[{const Mat\+Type \&}]{data, }
\item[{const double}]{tau = {\ttfamily 0}, }
\item[{const size\+\_\+t}]{max\+Leaf\+Size = {\ttfamily 20}, }
\item[{const double}]{rho = {\ttfamily 0.7}}
\end{DoxyParamCaption}
)}\label{classmlpack_1_1tree_1_1SpillTree_ac96f40b48753be633942e0aa199c2696}


Construct this as the root node of a hybrid spill tree using the given dataset. 

The dataset will not be modified during the building procedure (unlike \doxyref{Binary\+Space\+Tree}{p.}{classmlpack_1_1tree_1_1BinarySpaceTree}).


\begin{DoxyParams}{Parameters}
{\em data} & Dataset to create tree from. \\
\hline
{\em tau} & Overlapping size. \\
\hline
{\em max\+Leaf\+Size} & Size of each leaf in the tree. \\
\hline
{\em rho} & Balance threshold. \\
\hline
\end{DoxyParams}
\index{mlpack\+::tree\+::\+Spill\+Tree@{mlpack\+::tree\+::\+Spill\+Tree}!Spill\+Tree@{Spill\+Tree}}
\index{Spill\+Tree@{Spill\+Tree}!mlpack\+::tree\+::\+Spill\+Tree@{mlpack\+::tree\+::\+Spill\+Tree}}
\subsubsection[{Spill\+Tree(\+Mat\+Type \&\&data, const double tau=0, const size\+\_\+t max\+Leaf\+Size=20, const double rho=0.\+7)}]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename Metric\+Type , typename Statistic\+Type  = Empty\+Statistic, typename Mat\+Type  = arma\+::mat, template$<$ typename Hyperplane\+Metric\+Type $>$ class Hyperplane\+Type = Axis\+Orthogonal\+Hyperplane, template$<$ typename Split\+Metric\+Type, typename Split\+Mat\+Type $>$ class Split\+Type = Midpoint\+Space\+Split$>$ {\bf mlpack\+::tree\+::\+Spill\+Tree}$<$ Metric\+Type, Statistic\+Type, Mat\+Type, Hyperplane\+Type, Split\+Type $>$\+::{\bf Spill\+Tree} (
\begin{DoxyParamCaption}
\item[{Mat\+Type \&\&}]{data, }
\item[{const double}]{tau = {\ttfamily 0}, }
\item[{const size\+\_\+t}]{max\+Leaf\+Size = {\ttfamily 20}, }
\item[{const double}]{rho = {\ttfamily 0.7}}
\end{DoxyParamCaption}
)}\label{classmlpack_1_1tree_1_1SpillTree_a4d80a9b70c117d80e0d6578cf309726b}


Construct this as the root node of a hybrid spill tree using the given dataset. 

This will take ownership of the data matrix; if you don\textquotesingle{}t want this, consider using the constructor that takes a const reference to a dataset.


\begin{DoxyParams}{Parameters}
{\em data} & Dataset to create tree from. \\
\hline
{\em tau} & Overlapping size. \\
\hline
{\em max\+Leaf\+Size} & Size of each leaf in the tree. \\
\hline
{\em rho} & Balance threshold. \\
\hline
\end{DoxyParams}
\index{mlpack\+::tree\+::\+Spill\+Tree@{mlpack\+::tree\+::\+Spill\+Tree}!Spill\+Tree@{Spill\+Tree}}
\index{Spill\+Tree@{Spill\+Tree}!mlpack\+::tree\+::\+Spill\+Tree@{mlpack\+::tree\+::\+Spill\+Tree}}
\subsubsection[{Spill\+Tree(\+Spill\+Tree $\ast$parent, arma\+::\+Col$<$ size\+\_\+t $>$ \&points, const double tau=0, const size\+\_\+t max\+Leaf\+Size=20, const double rho=0.\+7)}]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename Metric\+Type , typename Statistic\+Type  = Empty\+Statistic, typename Mat\+Type  = arma\+::mat, template$<$ typename Hyperplane\+Metric\+Type $>$ class Hyperplane\+Type = Axis\+Orthogonal\+Hyperplane, template$<$ typename Split\+Metric\+Type, typename Split\+Mat\+Type $>$ class Split\+Type = Midpoint\+Space\+Split$>$ {\bf mlpack\+::tree\+::\+Spill\+Tree}$<$ Metric\+Type, Statistic\+Type, Mat\+Type, Hyperplane\+Type, Split\+Type $>$\+::{\bf Spill\+Tree} (
\begin{DoxyParamCaption}
\item[{{\bf Spill\+Tree}$<$ Metric\+Type, Statistic\+Type, Mat\+Type, Hyperplane\+Type, Split\+Type $>$ $\ast$}]{parent, }
\item[{arma\+::\+Col$<$ size\+\_\+t $>$ \&}]{points, }
\item[{const double}]{tau = {\ttfamily 0}, }
\item[{const size\+\_\+t}]{max\+Leaf\+Size = {\ttfamily 20}, }
\item[{const double}]{rho = {\ttfamily 0.7}}
\end{DoxyParamCaption}
)}\label{classmlpack_1_1tree_1_1SpillTree_a8c0eb4c71bd9f14f268bc7d308e69df7}


Construct this node as a child of the given parent, including the given list of points. 

This is used for recursive tree-\/building by the other constructors which don\textquotesingle{}t specify point indices.


\begin{DoxyParams}{Parameters}
{\em parent} & Parent of this node. \\
\hline
{\em points} & Vector of indexes of points to be included in this node. \\
\hline
{\em tau} & Overlapping size. \\
\hline
{\em max\+Leaf\+Size} & Size of each leaf in the tree. \\
\hline
{\em rho} & Balance threshold. \\
\hline
\end{DoxyParams}
\index{mlpack\+::tree\+::\+Spill\+Tree@{mlpack\+::tree\+::\+Spill\+Tree}!Spill\+Tree@{Spill\+Tree}}
\index{Spill\+Tree@{Spill\+Tree}!mlpack\+::tree\+::\+Spill\+Tree@{mlpack\+::tree\+::\+Spill\+Tree}}
\subsubsection[{Spill\+Tree(const Spill\+Tree \&other)}]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename Metric\+Type , typename Statistic\+Type  = Empty\+Statistic, typename Mat\+Type  = arma\+::mat, template$<$ typename Hyperplane\+Metric\+Type $>$ class Hyperplane\+Type = Axis\+Orthogonal\+Hyperplane, template$<$ typename Split\+Metric\+Type, typename Split\+Mat\+Type $>$ class Split\+Type = Midpoint\+Space\+Split$>$ {\bf mlpack\+::tree\+::\+Spill\+Tree}$<$ Metric\+Type, Statistic\+Type, Mat\+Type, Hyperplane\+Type, Split\+Type $>$\+::{\bf Spill\+Tree} (
\begin{DoxyParamCaption}
\item[{const {\bf Spill\+Tree}$<$ Metric\+Type, Statistic\+Type, Mat\+Type, Hyperplane\+Type, Split\+Type $>$ \&}]{other}
\end{DoxyParamCaption}
)}\label{classmlpack_1_1tree_1_1SpillTree_a8523681f12549e5c5d622cfaf833c706}


Create a hybrid spill tree by copying the other tree. 

Be careful! This can take a long time and use a lot of memory.


\begin{DoxyParams}{Parameters}
{\em other} & tree to be replicated. \\
\hline
\end{DoxyParams}
\index{mlpack\+::tree\+::\+Spill\+Tree@{mlpack\+::tree\+::\+Spill\+Tree}!Spill\+Tree@{Spill\+Tree}}
\index{Spill\+Tree@{Spill\+Tree}!mlpack\+::tree\+::\+Spill\+Tree@{mlpack\+::tree\+::\+Spill\+Tree}}
\subsubsection[{Spill\+Tree(\+Spill\+Tree \&\&other)}]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename Metric\+Type , typename Statistic\+Type  = Empty\+Statistic, typename Mat\+Type  = arma\+::mat, template$<$ typename Hyperplane\+Metric\+Type $>$ class Hyperplane\+Type = Axis\+Orthogonal\+Hyperplane, template$<$ typename Split\+Metric\+Type, typename Split\+Mat\+Type $>$ class Split\+Type = Midpoint\+Space\+Split$>$ {\bf mlpack\+::tree\+::\+Spill\+Tree}$<$ Metric\+Type, Statistic\+Type, Mat\+Type, Hyperplane\+Type, Split\+Type $>$\+::{\bf Spill\+Tree} (
\begin{DoxyParamCaption}
\item[{{\bf Spill\+Tree}$<$ Metric\+Type, Statistic\+Type, Mat\+Type, Hyperplane\+Type, Split\+Type $>$ \&\&}]{other}
\end{DoxyParamCaption}
)}\label{classmlpack_1_1tree_1_1SpillTree_ad813d9ca5876687d6069518beffbdfe1}


Move constructor for a \doxyref{Spill\+Tree}{p.}{classmlpack_1_1tree_1_1SpillTree}; possess all the members of the given tree. 


\begin{DoxyParams}{Parameters}
{\em other} & tree to be moved. \\
\hline
\end{DoxyParams}
\index{mlpack\+::tree\+::\+Spill\+Tree@{mlpack\+::tree\+::\+Spill\+Tree}!Spill\+Tree@{Spill\+Tree}}
\index{Spill\+Tree@{Spill\+Tree}!mlpack\+::tree\+::\+Spill\+Tree@{mlpack\+::tree\+::\+Spill\+Tree}}
\subsubsection[{Spill\+Tree(\+Archive \&ar, const typename std\+::enable\+\_\+if\+\_\+t$<$ Archive\+::is\+\_\+loading\+::value $>$ $\ast$=0)}]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename Metric\+Type , typename Statistic\+Type  = Empty\+Statistic, typename Mat\+Type  = arma\+::mat, template$<$ typename Hyperplane\+Metric\+Type $>$ class Hyperplane\+Type = Axis\+Orthogonal\+Hyperplane, template$<$ typename Split\+Metric\+Type, typename Split\+Mat\+Type $>$ class Split\+Type = Midpoint\+Space\+Split$>$ template$<$typename Archive $>$ {\bf mlpack\+::tree\+::\+Spill\+Tree}$<$ Metric\+Type, Statistic\+Type, Mat\+Type, Hyperplane\+Type, Split\+Type $>$\+::{\bf Spill\+Tree} (
\begin{DoxyParamCaption}
\item[{Archive \&}]{ar, }
\item[{const typename {\bf std\+::enable\+\_\+if\+\_\+t}$<$ Archive\+::is\+\_\+loading\+::value $>$ $\ast$}]{ = {\ttfamily 0}}
\end{DoxyParamCaption}
)}\label{classmlpack_1_1tree_1_1SpillTree_a55ebc56b812906568182cf1b8402e7b5}


Initialize the tree from a \doxyref{boost\+::serialization}{p.}{namespaceboost_1_1serialization} archive. 


\begin{DoxyParams}{Parameters}
{\em ar} & Archive to load tree from. Must be an iarchive, not an oarchive. \\
\hline
\end{DoxyParams}
\index{mlpack\+::tree\+::\+Spill\+Tree@{mlpack\+::tree\+::\+Spill\+Tree}!````~Spill\+Tree@{$\sim$\+Spill\+Tree}}
\index{````~Spill\+Tree@{$\sim$\+Spill\+Tree}!mlpack\+::tree\+::\+Spill\+Tree@{mlpack\+::tree\+::\+Spill\+Tree}}
\subsubsection[{$\sim$\+Spill\+Tree()}]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename Metric\+Type , typename Statistic\+Type  = Empty\+Statistic, typename Mat\+Type  = arma\+::mat, template$<$ typename Hyperplane\+Metric\+Type $>$ class Hyperplane\+Type = Axis\+Orthogonal\+Hyperplane, template$<$ typename Split\+Metric\+Type, typename Split\+Mat\+Type $>$ class Split\+Type = Midpoint\+Space\+Split$>$ {\bf mlpack\+::tree\+::\+Spill\+Tree}$<$ Metric\+Type, Statistic\+Type, Mat\+Type, Hyperplane\+Type, Split\+Type $>$\+::$\sim${\bf Spill\+Tree} (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)}\label{classmlpack_1_1tree_1_1SpillTree_af9a25250eb841f4144bb235e32299a02}


Deletes this node, deallocating the memory for the children and calling their destructors in turn. 

This will invalidate any pointers or references to any nodes which are children of this one. \index{mlpack\+::tree\+::\+Spill\+Tree@{mlpack\+::tree\+::\+Spill\+Tree}!Spill\+Tree@{Spill\+Tree}}
\index{Spill\+Tree@{Spill\+Tree}!mlpack\+::tree\+::\+Spill\+Tree@{mlpack\+::tree\+::\+Spill\+Tree}}
\subsubsection[{Spill\+Tree()}]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename Metric\+Type , typename Statistic\+Type  = Empty\+Statistic, typename Mat\+Type  = arma\+::mat, template$<$ typename Hyperplane\+Metric\+Type $>$ class Hyperplane\+Type = Axis\+Orthogonal\+Hyperplane, template$<$ typename Split\+Metric\+Type, typename Split\+Mat\+Type $>$ class Split\+Type = Midpoint\+Space\+Split$>$ {\bf mlpack\+::tree\+::\+Spill\+Tree}$<$ Metric\+Type, Statistic\+Type, Mat\+Type, Hyperplane\+Type, Split\+Type $>$\+::{\bf Spill\+Tree} (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [protected]}}\label{classmlpack_1_1tree_1_1SpillTree_ad95db09fc45273615f04bdf3d5a21d40}


A default constructor. 

This is meant to only be used with \doxyref{boost\+::serialization}{p.}{namespaceboost_1_1serialization}, which is allowed with the friend declaration below. This does not return a valid tree! The method must be protected, so that the serialization shim can work with the default constructor. 

Referenced by mlpack\+::tree\+::\+Spill\+Tree$<$ Metric\+Type, Statistic\+Type, Mat\+Type, Hyperplane\+Type, Split\+Type $>$\+::\+Center().



\subsection{Member Function Documentation}
\index{mlpack\+::tree\+::\+Spill\+Tree@{mlpack\+::tree\+::\+Spill\+Tree}!Bound@{Bound}}
\index{Bound@{Bound}!mlpack\+::tree\+::\+Spill\+Tree@{mlpack\+::tree\+::\+Spill\+Tree}}
\subsubsection[{Bound() const }]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename Metric\+Type , typename Statistic\+Type  = Empty\+Statistic, typename Mat\+Type  = arma\+::mat, template$<$ typename Hyperplane\+Metric\+Type $>$ class Hyperplane\+Type = Axis\+Orthogonal\+Hyperplane, template$<$ typename Split\+Metric\+Type, typename Split\+Mat\+Type $>$ class Split\+Type = Midpoint\+Space\+Split$>$ const {\bf Bound\+Type}\& {\bf mlpack\+::tree\+::\+Spill\+Tree}$<$ Metric\+Type, Statistic\+Type, Mat\+Type, Hyperplane\+Type, Split\+Type $>$\+::Bound (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
) const\hspace{0.3cm}{\ttfamily [inline]}}\label{classmlpack_1_1tree_1_1SpillTree_a284c6e2186de53946f5ba5906bfbec85}


Return the bound object for this node. 



Definition at line 230 of file spill\+\_\+tree.\+hpp.



References mlpack\+::tree\+::\+Spill\+Tree$<$ Metric\+Type, Statistic\+Type, Mat\+Type, Hyperplane\+Type, Split\+Type $>$\+::bound.



Referenced by mlpack\+::tree\+::\+Spill\+Tree$<$ Metric\+Type, Statistic\+Type, Mat\+Type, Hyperplane\+Type, Split\+Type $>$\+::\+Max\+Distance(), mlpack\+::tree\+::\+Spill\+Tree$<$ Metric\+Type, Statistic\+Type, Mat\+Type, Hyperplane\+Type, Split\+Type $>$\+::\+Min\+Distance(), and mlpack\+::tree\+::\+Spill\+Tree$<$ Metric\+Type, Statistic\+Type, Mat\+Type, Hyperplane\+Type, Split\+Type $>$\+::\+Range\+Distance().

\index{mlpack\+::tree\+::\+Spill\+Tree@{mlpack\+::tree\+::\+Spill\+Tree}!Bound@{Bound}}
\index{Bound@{Bound}!mlpack\+::tree\+::\+Spill\+Tree@{mlpack\+::tree\+::\+Spill\+Tree}}
\subsubsection[{Bound()}]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename Metric\+Type , typename Statistic\+Type  = Empty\+Statistic, typename Mat\+Type  = arma\+::mat, template$<$ typename Hyperplane\+Metric\+Type $>$ class Hyperplane\+Type = Axis\+Orthogonal\+Hyperplane, template$<$ typename Split\+Metric\+Type, typename Split\+Mat\+Type $>$ class Split\+Type = Midpoint\+Space\+Split$>$ {\bf Bound\+Type}\& {\bf mlpack\+::tree\+::\+Spill\+Tree}$<$ Metric\+Type, Statistic\+Type, Mat\+Type, Hyperplane\+Type, Split\+Type $>$\+::Bound (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}}\label{classmlpack_1_1tree_1_1SpillTree_a9af02115e7005043125d967e5cb7c7f6}


Return the bound object for this node. 



Definition at line 232 of file spill\+\_\+tree.\+hpp.



References mlpack\+::tree\+::\+Spill\+Tree$<$ Metric\+Type, Statistic\+Type, Mat\+Type, Hyperplane\+Type, Split\+Type $>$\+::bound.

\index{mlpack\+::tree\+::\+Spill\+Tree@{mlpack\+::tree\+::\+Spill\+Tree}!Center@{Center}}
\index{Center@{Center}!mlpack\+::tree\+::\+Spill\+Tree@{mlpack\+::tree\+::\+Spill\+Tree}}
\subsubsection[{Center(arma\+::vec \&center)}]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename Metric\+Type , typename Statistic\+Type  = Empty\+Statistic, typename Mat\+Type  = arma\+::mat, template$<$ typename Hyperplane\+Metric\+Type $>$ class Hyperplane\+Type = Axis\+Orthogonal\+Hyperplane, template$<$ typename Split\+Metric\+Type, typename Split\+Mat\+Type $>$ class Split\+Type = Midpoint\+Space\+Split$>$ void {\bf mlpack\+::tree\+::\+Spill\+Tree}$<$ Metric\+Type, Statistic\+Type, Mat\+Type, Hyperplane\+Type, Split\+Type $>$\+::Center (
\begin{DoxyParamCaption}
\item[{arma\+::vec \&}]{center}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}}\label{classmlpack_1_1tree_1_1SpillTree_a6e896b966e7cd965b06954c83b911ff1}


Store the center of the bounding region in the given vector. 



Definition at line 424 of file spill\+\_\+tree.\+hpp.



References mlpack\+::tree\+::\+Spill\+Tree$<$ Metric\+Type, Statistic\+Type, Mat\+Type, Hyperplane\+Type, Split\+Type $>$\+::\+Spill\+Tree(), mlpack\+::tree\+::\+Spill\+Tree$<$ Metric\+Type, Statistic\+Type, Mat\+Type, Hyperplane\+Type, Split\+Type $>$\+::\+Split\+Node(), and mlpack\+::tree\+::\+Spill\+Tree$<$ Metric\+Type, Statistic\+Type, Mat\+Type, Hyperplane\+Type, Split\+Type $>$\+::\+Split\+Points().

\index{mlpack\+::tree\+::\+Spill\+Tree@{mlpack\+::tree\+::\+Spill\+Tree}!Child@{Child}}
\index{Child@{Child}!mlpack\+::tree\+::\+Spill\+Tree@{mlpack\+::tree\+::\+Spill\+Tree}}
\subsubsection[{Child(const size\+\_\+t child) const }]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename Metric\+Type , typename Statistic\+Type  = Empty\+Statistic, typename Mat\+Type  = arma\+::mat, template$<$ typename Hyperplane\+Metric\+Type $>$ class Hyperplane\+Type = Axis\+Orthogonal\+Hyperplane, template$<$ typename Split\+Metric\+Type, typename Split\+Mat\+Type $>$ class Split\+Type = Midpoint\+Space\+Split$>$ {\bf Spill\+Tree}\& {\bf mlpack\+::tree\+::\+Spill\+Tree}$<$ Metric\+Type, Statistic\+Type, Mat\+Type, Hyperplane\+Type, Split\+Type $>$\+::Child (
\begin{DoxyParamCaption}
\item[{const size\+\_\+t}]{child}
\end{DoxyParamCaption}
) const}\label{classmlpack_1_1tree_1_1SpillTree_a3e22ba4810151bbe4fa884190e199d92}


Return the specified child (0 will be left, 1 will be right). 

If the index is greater than 1, this will return the right child.


\begin{DoxyParams}{Parameters}
{\em child} & Index of child to return. \\
\hline
\end{DoxyParams}


Referenced by mlpack\+::tree\+::\+Spill\+Tree$<$ Metric\+Type, Statistic\+Type, Mat\+Type, Hyperplane\+Type, Split\+Type $>$\+::\+Parent\+Distance().

\index{mlpack\+::tree\+::\+Spill\+Tree@{mlpack\+::tree\+::\+Spill\+Tree}!Child\+Ptr@{Child\+Ptr}}
\index{Child\+Ptr@{Child\+Ptr}!mlpack\+::tree\+::\+Spill\+Tree@{mlpack\+::tree\+::\+Spill\+Tree}}
\subsubsection[{Child\+Ptr(const size\+\_\+t child)}]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename Metric\+Type , typename Statistic\+Type  = Empty\+Statistic, typename Mat\+Type  = arma\+::mat, template$<$ typename Hyperplane\+Metric\+Type $>$ class Hyperplane\+Type = Axis\+Orthogonal\+Hyperplane, template$<$ typename Split\+Metric\+Type, typename Split\+Mat\+Type $>$ class Split\+Type = Midpoint\+Space\+Split$>$ {\bf Spill\+Tree}$\ast$\& {\bf mlpack\+::tree\+::\+Spill\+Tree}$<$ Metric\+Type, Statistic\+Type, Mat\+Type, Hyperplane\+Type, Split\+Type $>$\+::Child\+Ptr (
\begin{DoxyParamCaption}
\item[{const size\+\_\+t}]{child}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}}\label{classmlpack_1_1tree_1_1SpillTree_a02faee35dd9e74c8b9f4b4691579d4c1}


Definition at line 343 of file spill\+\_\+tree.\+hpp.



References mlpack\+::tree\+::\+Spill\+Tree$<$ Metric\+Type, Statistic\+Type, Mat\+Type, Hyperplane\+Type, Split\+Type $>$\+::\+Descendant(), mlpack\+::tree\+::\+Spill\+Tree$<$ Metric\+Type, Statistic\+Type, Mat\+Type, Hyperplane\+Type, Split\+Type $>$\+::\+Num\+Descendants(), mlpack\+::tree\+::\+Spill\+Tree$<$ Metric\+Type, Statistic\+Type, Mat\+Type, Hyperplane\+Type, Split\+Type $>$\+::\+Num\+Points(), mlpack\+::tree\+::\+Spill\+Tree$<$ Metric\+Type, Statistic\+Type, Mat\+Type, Hyperplane\+Type, Split\+Type $>$\+::\+Point(), and mlpack\+::tree\+::\+Spill\+Tree$<$ Metric\+Type, Statistic\+Type, Mat\+Type, Hyperplane\+Type, Split\+Type $>$\+::right.

\index{mlpack\+::tree\+::\+Spill\+Tree@{mlpack\+::tree\+::\+Spill\+Tree}!Dataset@{Dataset}}
\index{Dataset@{Dataset}!mlpack\+::tree\+::\+Spill\+Tree@{mlpack\+::tree\+::\+Spill\+Tree}}
\subsubsection[{Dataset() const }]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename Metric\+Type , typename Statistic\+Type  = Empty\+Statistic, typename Mat\+Type  = arma\+::mat, template$<$ typename Hyperplane\+Metric\+Type $>$ class Hyperplane\+Type = Axis\+Orthogonal\+Hyperplane, template$<$ typename Split\+Metric\+Type, typename Split\+Mat\+Type $>$ class Split\+Type = Midpoint\+Space\+Split$>$ const Mat\+Type\& {\bf mlpack\+::tree\+::\+Spill\+Tree}$<$ Metric\+Type, Statistic\+Type, Mat\+Type, Hyperplane\+Type, Split\+Type $>$\+::Dataset (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
) const\hspace{0.3cm}{\ttfamily [inline]}}\label{classmlpack_1_1tree_1_1SpillTree_a247403cd94290da5dd752f5a77c4aee9}


Get the dataset which the tree is built on. 



Definition at line 258 of file spill\+\_\+tree.\+hpp.



References mlpack\+::tree\+::\+Spill\+Tree$<$ Metric\+Type, Statistic\+Type, Mat\+Type, Hyperplane\+Type, Split\+Type $>$\+::dataset.

\index{mlpack\+::tree\+::\+Spill\+Tree@{mlpack\+::tree\+::\+Spill\+Tree}!Descendant@{Descendant}}
\index{Descendant@{Descendant}!mlpack\+::tree\+::\+Spill\+Tree@{mlpack\+::tree\+::\+Spill\+Tree}}
\subsubsection[{Descendant(const size\+\_\+t index) const }]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename Metric\+Type , typename Statistic\+Type  = Empty\+Statistic, typename Mat\+Type  = arma\+::mat, template$<$ typename Hyperplane\+Metric\+Type $>$ class Hyperplane\+Type = Axis\+Orthogonal\+Hyperplane, template$<$ typename Split\+Metric\+Type, typename Split\+Mat\+Type $>$ class Split\+Type = Midpoint\+Space\+Split$>$ size\+\_\+t {\bf mlpack\+::tree\+::\+Spill\+Tree}$<$ Metric\+Type, Statistic\+Type, Mat\+Type, Hyperplane\+Type, Split\+Type $>$\+::Descendant (
\begin{DoxyParamCaption}
\item[{const size\+\_\+t}]{index}
\end{DoxyParamCaption}
) const}\label{classmlpack_1_1tree_1_1SpillTree_ae241a75ccb0f50802b64143c35f71a03}


Return the index (with reference to the dataset) of a particular descendant of this node. 

The index should be greater than zero but less than the number of descendants.


\begin{DoxyParams}{Parameters}
{\em index} & Index of the descendant. \\
\hline
\end{DoxyParams}


Referenced by mlpack\+::tree\+::\+Spill\+Tree$<$ Metric\+Type, Statistic\+Type, Mat\+Type, Hyperplane\+Type, Split\+Type $>$\+::\+Child\+Ptr().

\index{mlpack\+::tree\+::\+Spill\+Tree@{mlpack\+::tree\+::\+Spill\+Tree}!Furthest\+Descendant\+Distance@{Furthest\+Descendant\+Distance}}
\index{Furthest\+Descendant\+Distance@{Furthest\+Descendant\+Distance}!mlpack\+::tree\+::\+Spill\+Tree@{mlpack\+::tree\+::\+Spill\+Tree}}
\subsubsection[{Furthest\+Descendant\+Distance() const }]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename Metric\+Type , typename Statistic\+Type  = Empty\+Statistic, typename Mat\+Type  = arma\+::mat, template$<$ typename Hyperplane\+Metric\+Type $>$ class Hyperplane\+Type = Axis\+Orthogonal\+Hyperplane, template$<$ typename Split\+Metric\+Type, typename Split\+Mat\+Type $>$ class Split\+Type = Midpoint\+Space\+Split$>$ {\bf Elem\+Type} {\bf mlpack\+::tree\+::\+Spill\+Tree}$<$ Metric\+Type, Statistic\+Type, Mat\+Type, Hyperplane\+Type, Split\+Type $>$\+::Furthest\+Descendant\+Distance (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
) const}\label{classmlpack_1_1tree_1_1SpillTree_af64b2b9ca6117b3cf89c41a80b278532}


Return the furthest possible descendant distance. 

This returns the maximum distance from the centroid to the edge of the bound and not the empirical quantity which is the actual furthest descendant distance. So the actual furthest descendant distance may be less than what this method returns (but it will never be greater than this). 

Referenced by mlpack\+::tree\+::\+Spill\+Tree$<$ Metric\+Type, Statistic\+Type, Mat\+Type, Hyperplane\+Type, Split\+Type $>$\+::\+Metric().

\index{mlpack\+::tree\+::\+Spill\+Tree@{mlpack\+::tree\+::\+Spill\+Tree}!Furthest\+Point\+Distance@{Furthest\+Point\+Distance}}
\index{Furthest\+Point\+Distance@{Furthest\+Point\+Distance}!mlpack\+::tree\+::\+Spill\+Tree@{mlpack\+::tree\+::\+Spill\+Tree}}
\subsubsection[{Furthest\+Point\+Distance() const }]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename Metric\+Type , typename Statistic\+Type  = Empty\+Statistic, typename Mat\+Type  = arma\+::mat, template$<$ typename Hyperplane\+Metric\+Type $>$ class Hyperplane\+Type = Axis\+Orthogonal\+Hyperplane, template$<$ typename Split\+Metric\+Type, typename Split\+Mat\+Type $>$ class Split\+Type = Midpoint\+Space\+Split$>$ {\bf Elem\+Type} {\bf mlpack\+::tree\+::\+Spill\+Tree}$<$ Metric\+Type, Statistic\+Type, Mat\+Type, Hyperplane\+Type, Split\+Type $>$\+::Furthest\+Point\+Distance (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
) const}\label{classmlpack_1_1tree_1_1SpillTree_acfbe3ee7cd1b1b77a6b4291d473059e8}


Return the furthest distance to a point held in this node. 

If this is not a leaf node, then the distance is 0 because the node holds no points. 

Referenced by mlpack\+::tree\+::\+Spill\+Tree$<$ Metric\+Type, Statistic\+Type, Mat\+Type, Hyperplane\+Type, Split\+Type $>$\+::\+Metric().

\index{mlpack\+::tree\+::\+Spill\+Tree@{mlpack\+::tree\+::\+Spill\+Tree}!Get\+Furthest\+Child@{Get\+Furthest\+Child}}
\index{Get\+Furthest\+Child@{Get\+Furthest\+Child}!mlpack\+::tree\+::\+Spill\+Tree@{mlpack\+::tree\+::\+Spill\+Tree}}
\subsubsection[{Get\+Furthest\+Child(const Vec\+Type \&point, typename std\+::enable\+\_\+if\+\_\+t$<$ Is\+Vector$<$ Vec\+Type $>$\+::value $>$ $\ast$=0)}]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename Metric\+Type , typename Statistic\+Type  = Empty\+Statistic, typename Mat\+Type  = arma\+::mat, template$<$ typename Hyperplane\+Metric\+Type $>$ class Hyperplane\+Type = Axis\+Orthogonal\+Hyperplane, template$<$ typename Split\+Metric\+Type, typename Split\+Mat\+Type $>$ class Split\+Type = Midpoint\+Space\+Split$>$ template$<$typename Vec\+Type $>$ size\+\_\+t {\bf mlpack\+::tree\+::\+Spill\+Tree}$<$ Metric\+Type, Statistic\+Type, Mat\+Type, Hyperplane\+Type, Split\+Type $>$\+::Get\+Furthest\+Child (
\begin{DoxyParamCaption}
\item[{const Vec\+Type \&}]{point, }
\item[{typename {\bf std\+::enable\+\_\+if\+\_\+t}$<$ {\bf Is\+Vector}$<$ Vec\+Type $>$\+::value $>$ $\ast$}]{ = {\ttfamily 0}}
\end{DoxyParamCaption}
)}\label{classmlpack_1_1tree_1_1SpillTree_a7d748e559c8ac083cd5803a0aaffc354}


Return the index of the furthest child node to the given query point (this is an efficient estimation based on the splitting hyperplane, the node returned is not necessarily the furthest). 

If this is a leaf node, it will return \doxyref{Num\+Children()}{p.}{classmlpack_1_1tree_1_1SpillTree_a20190e12a6b9c7ab7c52f73b516bb3bf} (invalid index). 

Referenced by mlpack\+::tree\+::\+Spill\+Tree$<$ Metric\+Type, Statistic\+Type, Mat\+Type, Hyperplane\+Type, Split\+Type $>$\+::\+Metric().

\index{mlpack\+::tree\+::\+Spill\+Tree@{mlpack\+::tree\+::\+Spill\+Tree}!Get\+Furthest\+Child@{Get\+Furthest\+Child}}
\index{Get\+Furthest\+Child@{Get\+Furthest\+Child}!mlpack\+::tree\+::\+Spill\+Tree@{mlpack\+::tree\+::\+Spill\+Tree}}
\subsubsection[{Get\+Furthest\+Child(const Spill\+Tree \&query\+Node)}]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename Metric\+Type , typename Statistic\+Type  = Empty\+Statistic, typename Mat\+Type  = arma\+::mat, template$<$ typename Hyperplane\+Metric\+Type $>$ class Hyperplane\+Type = Axis\+Orthogonal\+Hyperplane, template$<$ typename Split\+Metric\+Type, typename Split\+Mat\+Type $>$ class Split\+Type = Midpoint\+Space\+Split$>$ size\+\_\+t {\bf mlpack\+::tree\+::\+Spill\+Tree}$<$ Metric\+Type, Statistic\+Type, Mat\+Type, Hyperplane\+Type, Split\+Type $>$\+::Get\+Furthest\+Child (
\begin{DoxyParamCaption}
\item[{const {\bf Spill\+Tree}$<$ Metric\+Type, Statistic\+Type, Mat\+Type, Hyperplane\+Type, Split\+Type $>$ \&}]{query\+Node}
\end{DoxyParamCaption}
)}\label{classmlpack_1_1tree_1_1SpillTree_a0f2f70ae3392aa7eaa412ddffee6034d}


Return the index of the furthest child node to the given query node (this is an efficient estimation based on the splitting hyperplane, the node returned is not necessarily the furthest). 

If it can\textquotesingle{}t decide it will return \doxyref{Num\+Children()}{p.}{classmlpack_1_1tree_1_1SpillTree_a20190e12a6b9c7ab7c52f73b516bb3bf} (invalid index). \index{mlpack\+::tree\+::\+Spill\+Tree@{mlpack\+::tree\+::\+Spill\+Tree}!Get\+Nearest\+Child@{Get\+Nearest\+Child}}
\index{Get\+Nearest\+Child@{Get\+Nearest\+Child}!mlpack\+::tree\+::\+Spill\+Tree@{mlpack\+::tree\+::\+Spill\+Tree}}
\subsubsection[{Get\+Nearest\+Child(const Vec\+Type \&point, typename std\+::enable\+\_\+if\+\_\+t$<$ Is\+Vector$<$ Vec\+Type $>$\+::value $>$ $\ast$=0)}]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename Metric\+Type , typename Statistic\+Type  = Empty\+Statistic, typename Mat\+Type  = arma\+::mat, template$<$ typename Hyperplane\+Metric\+Type $>$ class Hyperplane\+Type = Axis\+Orthogonal\+Hyperplane, template$<$ typename Split\+Metric\+Type, typename Split\+Mat\+Type $>$ class Split\+Type = Midpoint\+Space\+Split$>$ template$<$typename Vec\+Type $>$ size\+\_\+t {\bf mlpack\+::tree\+::\+Spill\+Tree}$<$ Metric\+Type, Statistic\+Type, Mat\+Type, Hyperplane\+Type, Split\+Type $>$\+::Get\+Nearest\+Child (
\begin{DoxyParamCaption}
\item[{const Vec\+Type \&}]{point, }
\item[{typename {\bf std\+::enable\+\_\+if\+\_\+t}$<$ {\bf Is\+Vector}$<$ Vec\+Type $>$\+::value $>$ $\ast$}]{ = {\ttfamily 0}}
\end{DoxyParamCaption}
)}\label{classmlpack_1_1tree_1_1SpillTree_a66015f3c1d1c981b38baee9867e05330}


Return the index of the nearest child node to the given query point (this is an efficient estimation based on the splitting hyperplane, the node returned is not necessarily the nearest). 

If this is a leaf node, it will return \doxyref{Num\+Children()}{p.}{classmlpack_1_1tree_1_1SpillTree_a20190e12a6b9c7ab7c52f73b516bb3bf} (invalid index). 

Referenced by mlpack\+::tree\+::\+Spill\+Tree$<$ Metric\+Type, Statistic\+Type, Mat\+Type, Hyperplane\+Type, Split\+Type $>$\+::\+Metric().

\index{mlpack\+::tree\+::\+Spill\+Tree@{mlpack\+::tree\+::\+Spill\+Tree}!Get\+Nearest\+Child@{Get\+Nearest\+Child}}
\index{Get\+Nearest\+Child@{Get\+Nearest\+Child}!mlpack\+::tree\+::\+Spill\+Tree@{mlpack\+::tree\+::\+Spill\+Tree}}
\subsubsection[{Get\+Nearest\+Child(const Spill\+Tree \&query\+Node)}]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename Metric\+Type , typename Statistic\+Type  = Empty\+Statistic, typename Mat\+Type  = arma\+::mat, template$<$ typename Hyperplane\+Metric\+Type $>$ class Hyperplane\+Type = Axis\+Orthogonal\+Hyperplane, template$<$ typename Split\+Metric\+Type, typename Split\+Mat\+Type $>$ class Split\+Type = Midpoint\+Space\+Split$>$ size\+\_\+t {\bf mlpack\+::tree\+::\+Spill\+Tree}$<$ Metric\+Type, Statistic\+Type, Mat\+Type, Hyperplane\+Type, Split\+Type $>$\+::Get\+Nearest\+Child (
\begin{DoxyParamCaption}
\item[{const {\bf Spill\+Tree}$<$ Metric\+Type, Statistic\+Type, Mat\+Type, Hyperplane\+Type, Split\+Type $>$ \&}]{query\+Node}
\end{DoxyParamCaption}
)}\label{classmlpack_1_1tree_1_1SpillTree_a50785371927a61d7236b8ae962de4d87}


Return the index of the nearest child node to the given query node (this is an efficient estimation based on the splitting hyperplane, the node returned is not necessarily the nearest). 

If it can\textquotesingle{}t decide it will return \doxyref{Num\+Children()}{p.}{classmlpack_1_1tree_1_1SpillTree_a20190e12a6b9c7ab7c52f73b516bb3bf} (invalid index). \index{mlpack\+::tree\+::\+Spill\+Tree@{mlpack\+::tree\+::\+Spill\+Tree}!Has\+Self\+Children@{Has\+Self\+Children}}
\index{Has\+Self\+Children@{Has\+Self\+Children}!mlpack\+::tree\+::\+Spill\+Tree@{mlpack\+::tree\+::\+Spill\+Tree}}
\subsubsection[{Has\+Self\+Children()}]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename Metric\+Type , typename Statistic\+Type  = Empty\+Statistic, typename Mat\+Type  = arma\+::mat, template$<$ typename Hyperplane\+Metric\+Type $>$ class Hyperplane\+Type = Axis\+Orthogonal\+Hyperplane, template$<$ typename Split\+Metric\+Type, typename Split\+Mat\+Type $>$ class Split\+Type = Midpoint\+Space\+Split$>$ static bool {\bf mlpack\+::tree\+::\+Spill\+Tree}$<$ Metric\+Type, Statistic\+Type, Mat\+Type, Hyperplane\+Type, Split\+Type $>$\+::Has\+Self\+Children (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [static]}}\label{classmlpack_1_1tree_1_1SpillTree_af1ec0e9ad1d695c404d6bfc3f40072cc}


Returns false\+: this tree type does not have self children. 



Definition at line 421 of file spill\+\_\+tree.\+hpp.

\index{mlpack\+::tree\+::\+Spill\+Tree@{mlpack\+::tree\+::\+Spill\+Tree}!Hyperplane@{Hyperplane}}
\index{Hyperplane@{Hyperplane}!mlpack\+::tree\+::\+Spill\+Tree@{mlpack\+::tree\+::\+Spill\+Tree}}
\subsubsection[{Hyperplane() const }]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename Metric\+Type , typename Statistic\+Type  = Empty\+Statistic, typename Mat\+Type  = arma\+::mat, template$<$ typename Hyperplane\+Metric\+Type $>$ class Hyperplane\+Type = Axis\+Orthogonal\+Hyperplane, template$<$ typename Split\+Metric\+Type, typename Split\+Mat\+Type $>$ class Split\+Type = Midpoint\+Space\+Split$>$ const Hyperplane\+Type$<$Metric\+Type$>$\& {\bf mlpack\+::tree\+::\+Spill\+Tree}$<$ Metric\+Type, Statistic\+Type, Mat\+Type, Hyperplane\+Type, Split\+Type $>$\+::{\bf Hyperplane} (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
) const\hspace{0.3cm}{\ttfamily [inline]}}\label{classmlpack_1_1tree_1_1SpillTree_a49e18c815ff2459feab39e6b4b8795fd}


Get the Hyperplane instance. 



Definition at line 264 of file spill\+\_\+tree.\+hpp.



References mlpack\+::tree\+::\+Spill\+Tree$<$ Metric\+Type, Statistic\+Type, Mat\+Type, Hyperplane\+Type, Split\+Type $>$\+::hyperplane.

\index{mlpack\+::tree\+::\+Spill\+Tree@{mlpack\+::tree\+::\+Spill\+Tree}!Is\+Leaf@{Is\+Leaf}}
\index{Is\+Leaf@{Is\+Leaf}!mlpack\+::tree\+::\+Spill\+Tree@{mlpack\+::tree\+::\+Spill\+Tree}}
\subsubsection[{Is\+Leaf() const }]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename Metric\+Type , typename Statistic\+Type  = Empty\+Statistic, typename Mat\+Type  = arma\+::mat, template$<$ typename Hyperplane\+Metric\+Type $>$ class Hyperplane\+Type = Axis\+Orthogonal\+Hyperplane, template$<$ typename Split\+Metric\+Type, typename Split\+Mat\+Type $>$ class Split\+Type = Midpoint\+Space\+Split$>$ bool {\bf mlpack\+::tree\+::\+Spill\+Tree}$<$ Metric\+Type, Statistic\+Type, Mat\+Type, Hyperplane\+Type, Split\+Type $>$\+::Is\+Leaf (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
) const}\label{classmlpack_1_1tree_1_1SpillTree_a1992b8610849049501a0f39cce136d51}


Return whether or not this node is a leaf (true if it has no children). 



Referenced by mlpack\+::tree\+::\+Spill\+Tree$<$ Metric\+Type, Statistic\+Type, Mat\+Type, Hyperplane\+Type, Split\+Type $>$\+::\+Stat().

\index{mlpack\+::tree\+::\+Spill\+Tree@{mlpack\+::tree\+::\+Spill\+Tree}!Left@{Left}}
\index{Left@{Left}!mlpack\+::tree\+::\+Spill\+Tree@{mlpack\+::tree\+::\+Spill\+Tree}}
\subsubsection[{Left() const }]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename Metric\+Type , typename Statistic\+Type  = Empty\+Statistic, typename Mat\+Type  = arma\+::mat, template$<$ typename Hyperplane\+Metric\+Type $>$ class Hyperplane\+Type = Axis\+Orthogonal\+Hyperplane, template$<$ typename Split\+Metric\+Type, typename Split\+Mat\+Type $>$ class Split\+Type = Midpoint\+Space\+Split$>$ {\bf Spill\+Tree}$\ast$ {\bf mlpack\+::tree\+::\+Spill\+Tree}$<$ Metric\+Type, Statistic\+Type, Mat\+Type, Hyperplane\+Type, Split\+Type $>$\+::Left (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
) const\hspace{0.3cm}{\ttfamily [inline]}}\label{classmlpack_1_1tree_1_1SpillTree_ac0aa14bd2cb0ab2a5059781f290ec88b}


Gets the left child of this node. 



Definition at line 243 of file spill\+\_\+tree.\+hpp.



References mlpack\+::tree\+::\+Spill\+Tree$<$ Metric\+Type, Statistic\+Type, Mat\+Type, Hyperplane\+Type, Split\+Type $>$\+::left.

\index{mlpack\+::tree\+::\+Spill\+Tree@{mlpack\+::tree\+::\+Spill\+Tree}!Left@{Left}}
\index{Left@{Left}!mlpack\+::tree\+::\+Spill\+Tree@{mlpack\+::tree\+::\+Spill\+Tree}}
\subsubsection[{Left()}]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename Metric\+Type , typename Statistic\+Type  = Empty\+Statistic, typename Mat\+Type  = arma\+::mat, template$<$ typename Hyperplane\+Metric\+Type $>$ class Hyperplane\+Type = Axis\+Orthogonal\+Hyperplane, template$<$ typename Split\+Metric\+Type, typename Split\+Mat\+Type $>$ class Split\+Type = Midpoint\+Space\+Split$>$ {\bf Spill\+Tree}$\ast$\& {\bf mlpack\+::tree\+::\+Spill\+Tree}$<$ Metric\+Type, Statistic\+Type, Mat\+Type, Hyperplane\+Type, Split\+Type $>$\+::Left (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}}\label{classmlpack_1_1tree_1_1SpillTree_a9fbc5932a9fdc72e8eaea4b6b478a968}


Modify the left child of this node. 



Definition at line 245 of file spill\+\_\+tree.\+hpp.



References mlpack\+::tree\+::\+Spill\+Tree$<$ Metric\+Type, Statistic\+Type, Mat\+Type, Hyperplane\+Type, Split\+Type $>$\+::left.

\index{mlpack\+::tree\+::\+Spill\+Tree@{mlpack\+::tree\+::\+Spill\+Tree}!Max\+Distance@{Max\+Distance}}
\index{Max\+Distance@{Max\+Distance}!mlpack\+::tree\+::\+Spill\+Tree@{mlpack\+::tree\+::\+Spill\+Tree}}
\subsubsection[{Max\+Distance(const Spill\+Tree \&other) const }]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename Metric\+Type , typename Statistic\+Type  = Empty\+Statistic, typename Mat\+Type  = arma\+::mat, template$<$ typename Hyperplane\+Metric\+Type $>$ class Hyperplane\+Type = Axis\+Orthogonal\+Hyperplane, template$<$ typename Split\+Metric\+Type, typename Split\+Mat\+Type $>$ class Split\+Type = Midpoint\+Space\+Split$>$ {\bf Elem\+Type} {\bf mlpack\+::tree\+::\+Spill\+Tree}$<$ Metric\+Type, Statistic\+Type, Mat\+Type, Hyperplane\+Type, Split\+Type $>$\+::Max\+Distance (
\begin{DoxyParamCaption}
\item[{const {\bf Spill\+Tree}$<$ Metric\+Type, Statistic\+Type, Mat\+Type, Hyperplane\+Type, Split\+Type $>$ \&}]{other}
\end{DoxyParamCaption}
) const\hspace{0.3cm}{\ttfamily [inline]}}\label{classmlpack_1_1tree_1_1SpillTree_a532a790cb96a882c5cf96a2e1f07d2f8}


Return the maximum distance to another node. 



Definition at line 382 of file spill\+\_\+tree.\+hpp.



References mlpack\+::tree\+::\+Spill\+Tree$<$ Metric\+Type, Statistic\+Type, Mat\+Type, Hyperplane\+Type, Split\+Type $>$\+::\+Bound().

\index{mlpack\+::tree\+::\+Spill\+Tree@{mlpack\+::tree\+::\+Spill\+Tree}!Max\+Distance@{Max\+Distance}}
\index{Max\+Distance@{Max\+Distance}!mlpack\+::tree\+::\+Spill\+Tree@{mlpack\+::tree\+::\+Spill\+Tree}}
\subsubsection[{Max\+Distance(const Vec\+Type \&point, typename std\+::enable\+\_\+if\+\_\+t$<$ Is\+Vector$<$ Vec\+Type $>$\+::value $>$ $\ast$=0) const }]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename Metric\+Type , typename Statistic\+Type  = Empty\+Statistic, typename Mat\+Type  = arma\+::mat, template$<$ typename Hyperplane\+Metric\+Type $>$ class Hyperplane\+Type = Axis\+Orthogonal\+Hyperplane, template$<$ typename Split\+Metric\+Type, typename Split\+Mat\+Type $>$ class Split\+Type = Midpoint\+Space\+Split$>$ template$<$typename Vec\+Type $>$ {\bf Elem\+Type} {\bf mlpack\+::tree\+::\+Spill\+Tree}$<$ Metric\+Type, Statistic\+Type, Mat\+Type, Hyperplane\+Type, Split\+Type $>$\+::Max\+Distance (
\begin{DoxyParamCaption}
\item[{const Vec\+Type \&}]{point, }
\item[{typename {\bf std\+::enable\+\_\+if\+\_\+t}$<$ {\bf Is\+Vector}$<$ Vec\+Type $>$\+::value $>$ $\ast$}]{ = {\ttfamily 0}}
\end{DoxyParamCaption}
) const\hspace{0.3cm}{\ttfamily [inline]}}\label{classmlpack_1_1tree_1_1SpillTree_aa541b880f75f73d0bfd3b4da8fc12c96}


Return the maximum distance to another point. 



Definition at line 404 of file spill\+\_\+tree.\+hpp.

\index{mlpack\+::tree\+::\+Spill\+Tree@{mlpack\+::tree\+::\+Spill\+Tree}!Metric@{Metric}}
\index{Metric@{Metric}!mlpack\+::tree\+::\+Spill\+Tree@{mlpack\+::tree\+::\+Spill\+Tree}}
\subsubsection[{Metric() const }]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename Metric\+Type , typename Statistic\+Type  = Empty\+Statistic, typename Mat\+Type  = arma\+::mat, template$<$ typename Hyperplane\+Metric\+Type $>$ class Hyperplane\+Type = Axis\+Orthogonal\+Hyperplane, template$<$ typename Split\+Metric\+Type, typename Split\+Mat\+Type $>$ class Split\+Type = Midpoint\+Space\+Split$>$ Metric\+Type {\bf mlpack\+::tree\+::\+Spill\+Tree}$<$ Metric\+Type, Statistic\+Type, Mat\+Type, Hyperplane\+Type, Split\+Type $>$\+::Metric (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
) const\hspace{0.3cm}{\ttfamily [inline]}}\label{classmlpack_1_1tree_1_1SpillTree_a6ac1e93b1d7fad7a472cb689d9b7b93f}


Get the metric that the tree uses. 



Definition at line 267 of file spill\+\_\+tree.\+hpp.



References mlpack\+::tree\+::\+Spill\+Tree$<$ Metric\+Type, Statistic\+Type, Mat\+Type, Hyperplane\+Type, Split\+Type $>$\+::\+Furthest\+Descendant\+Distance(), mlpack\+::tree\+::\+Spill\+Tree$<$ Metric\+Type, Statistic\+Type, Mat\+Type, Hyperplane\+Type, Split\+Type $>$\+::\+Furthest\+Point\+Distance(), mlpack\+::tree\+::\+Spill\+Tree$<$ Metric\+Type, Statistic\+Type, Mat\+Type, Hyperplane\+Type, Split\+Type $>$\+::\+Get\+Furthest\+Child(), mlpack\+::tree\+::\+Spill\+Tree$<$ Metric\+Type, Statistic\+Type, Mat\+Type, Hyperplane\+Type, Split\+Type $>$\+::\+Get\+Nearest\+Child(), mlpack\+::tree\+::\+Spill\+Tree$<$ Metric\+Type, Statistic\+Type, Mat\+Type, Hyperplane\+Type, Split\+Type $>$\+::\+Minimum\+Bound\+Distance(), and mlpack\+::tree\+::\+Spill\+Tree$<$ Metric\+Type, Statistic\+Type, Mat\+Type, Hyperplane\+Type, Split\+Type $>$\+::\+Num\+Children().

\index{mlpack\+::tree\+::\+Spill\+Tree@{mlpack\+::tree\+::\+Spill\+Tree}!Min\+Distance@{Min\+Distance}}
\index{Min\+Distance@{Min\+Distance}!mlpack\+::tree\+::\+Spill\+Tree@{mlpack\+::tree\+::\+Spill\+Tree}}
\subsubsection[{Min\+Distance(const Spill\+Tree \&other) const }]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename Metric\+Type , typename Statistic\+Type  = Empty\+Statistic, typename Mat\+Type  = arma\+::mat, template$<$ typename Hyperplane\+Metric\+Type $>$ class Hyperplane\+Type = Axis\+Orthogonal\+Hyperplane, template$<$ typename Split\+Metric\+Type, typename Split\+Mat\+Type $>$ class Split\+Type = Midpoint\+Space\+Split$>$ {\bf Elem\+Type} {\bf mlpack\+::tree\+::\+Spill\+Tree}$<$ Metric\+Type, Statistic\+Type, Mat\+Type, Hyperplane\+Type, Split\+Type $>$\+::Min\+Distance (
\begin{DoxyParamCaption}
\item[{const {\bf Spill\+Tree}$<$ Metric\+Type, Statistic\+Type, Mat\+Type, Hyperplane\+Type, Split\+Type $>$ \&}]{other}
\end{DoxyParamCaption}
) const\hspace{0.3cm}{\ttfamily [inline]}}\label{classmlpack_1_1tree_1_1SpillTree_aff6b18234af0f93400a8bf3dbf85d572}


Return the minimum distance to another node. 



Definition at line 376 of file spill\+\_\+tree.\+hpp.



References mlpack\+::tree\+::\+Spill\+Tree$<$ Metric\+Type, Statistic\+Type, Mat\+Type, Hyperplane\+Type, Split\+Type $>$\+::\+Bound().

\index{mlpack\+::tree\+::\+Spill\+Tree@{mlpack\+::tree\+::\+Spill\+Tree}!Min\+Distance@{Min\+Distance}}
\index{Min\+Distance@{Min\+Distance}!mlpack\+::tree\+::\+Spill\+Tree@{mlpack\+::tree\+::\+Spill\+Tree}}
\subsubsection[{Min\+Distance(const Vec\+Type \&point, typename std\+::enable\+\_\+if\+\_\+t$<$ Is\+Vector$<$ Vec\+Type $>$\+::value $>$ $\ast$=0) const }]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename Metric\+Type , typename Statistic\+Type  = Empty\+Statistic, typename Mat\+Type  = arma\+::mat, template$<$ typename Hyperplane\+Metric\+Type $>$ class Hyperplane\+Type = Axis\+Orthogonal\+Hyperplane, template$<$ typename Split\+Metric\+Type, typename Split\+Mat\+Type $>$ class Split\+Type = Midpoint\+Space\+Split$>$ template$<$typename Vec\+Type $>$ {\bf Elem\+Type} {\bf mlpack\+::tree\+::\+Spill\+Tree}$<$ Metric\+Type, Statistic\+Type, Mat\+Type, Hyperplane\+Type, Split\+Type $>$\+::Min\+Distance (
\begin{DoxyParamCaption}
\item[{const Vec\+Type \&}]{point, }
\item[{typename {\bf std\+::enable\+\_\+if\+\_\+t}$<$ {\bf Is\+Vector}$<$ Vec\+Type $>$\+::value $>$ $\ast$}]{ = {\ttfamily 0}}
\end{DoxyParamCaption}
) const\hspace{0.3cm}{\ttfamily [inline]}}\label{classmlpack_1_1tree_1_1SpillTree_a858cfecadd0072283606c9f44b2031c9}


Return the minimum distance to another point. 



Definition at line 395 of file spill\+\_\+tree.\+hpp.

\index{mlpack\+::tree\+::\+Spill\+Tree@{mlpack\+::tree\+::\+Spill\+Tree}!Minimum\+Bound\+Distance@{Minimum\+Bound\+Distance}}
\index{Minimum\+Bound\+Distance@{Minimum\+Bound\+Distance}!mlpack\+::tree\+::\+Spill\+Tree@{mlpack\+::tree\+::\+Spill\+Tree}}
\subsubsection[{Minimum\+Bound\+Distance() const }]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename Metric\+Type , typename Statistic\+Type  = Empty\+Statistic, typename Mat\+Type  = arma\+::mat, template$<$ typename Hyperplane\+Metric\+Type $>$ class Hyperplane\+Type = Axis\+Orthogonal\+Hyperplane, template$<$ typename Split\+Metric\+Type, typename Split\+Mat\+Type $>$ class Split\+Type = Midpoint\+Space\+Split$>$ {\bf Elem\+Type} {\bf mlpack\+::tree\+::\+Spill\+Tree}$<$ Metric\+Type, Statistic\+Type, Mat\+Type, Hyperplane\+Type, Split\+Type $>$\+::Minimum\+Bound\+Distance (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
) const}\label{classmlpack_1_1tree_1_1SpillTree_a1a0721e0735177434b262293cefb19e3}


Return the minimum distance from the center of the node to any bound edge. 



Referenced by mlpack\+::tree\+::\+Spill\+Tree$<$ Metric\+Type, Statistic\+Type, Mat\+Type, Hyperplane\+Type, Split\+Type $>$\+::\+Metric().

\index{mlpack\+::tree\+::\+Spill\+Tree@{mlpack\+::tree\+::\+Spill\+Tree}!Num\+Children@{Num\+Children}}
\index{Num\+Children@{Num\+Children}!mlpack\+::tree\+::\+Spill\+Tree@{mlpack\+::tree\+::\+Spill\+Tree}}
\subsubsection[{Num\+Children() const }]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename Metric\+Type , typename Statistic\+Type  = Empty\+Statistic, typename Mat\+Type  = arma\+::mat, template$<$ typename Hyperplane\+Metric\+Type $>$ class Hyperplane\+Type = Axis\+Orthogonal\+Hyperplane, template$<$ typename Split\+Metric\+Type, typename Split\+Mat\+Type $>$ class Split\+Type = Midpoint\+Space\+Split$>$ size\+\_\+t {\bf mlpack\+::tree\+::\+Spill\+Tree}$<$ Metric\+Type, Statistic\+Type, Mat\+Type, Hyperplane\+Type, Split\+Type $>$\+::Num\+Children (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
) const}\label{classmlpack_1_1tree_1_1SpillTree_a20190e12a6b9c7ab7c52f73b516bb3bf}


Return the number of children in this node. 



Referenced by mlpack\+::tree\+::\+Spill\+Tree$<$ Metric\+Type, Statistic\+Type, Mat\+Type, Hyperplane\+Type, Split\+Type $>$\+::\+Metric().

\index{mlpack\+::tree\+::\+Spill\+Tree@{mlpack\+::tree\+::\+Spill\+Tree}!Num\+Descendants@{Num\+Descendants}}
\index{Num\+Descendants@{Num\+Descendants}!mlpack\+::tree\+::\+Spill\+Tree@{mlpack\+::tree\+::\+Spill\+Tree}}
\subsubsection[{Num\+Descendants() const }]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename Metric\+Type , typename Statistic\+Type  = Empty\+Statistic, typename Mat\+Type  = arma\+::mat, template$<$ typename Hyperplane\+Metric\+Type $>$ class Hyperplane\+Type = Axis\+Orthogonal\+Hyperplane, template$<$ typename Split\+Metric\+Type, typename Split\+Mat\+Type $>$ class Split\+Type = Midpoint\+Space\+Split$>$ size\+\_\+t {\bf mlpack\+::tree\+::\+Spill\+Tree}$<$ Metric\+Type, Statistic\+Type, Mat\+Type, Hyperplane\+Type, Split\+Type $>$\+::Num\+Descendants (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
) const}\label{classmlpack_1_1tree_1_1SpillTree_a330791a347eadf429808ef4fb4f5e0d8}


Return the number of descendants of this node. 

For a non-\/leaf spill tree, this is the number of points at the descendant leaves. For a leaf, this is the number of points in the leaf. 

Referenced by mlpack\+::tree\+::\+Spill\+Tree$<$ Metric\+Type, Statistic\+Type, Mat\+Type, Hyperplane\+Type, Split\+Type $>$\+::\+Child\+Ptr().

\index{mlpack\+::tree\+::\+Spill\+Tree@{mlpack\+::tree\+::\+Spill\+Tree}!Num\+Points@{Num\+Points}}
\index{Num\+Points@{Num\+Points}!mlpack\+::tree\+::\+Spill\+Tree@{mlpack\+::tree\+::\+Spill\+Tree}}
\subsubsection[{Num\+Points() const }]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename Metric\+Type , typename Statistic\+Type  = Empty\+Statistic, typename Mat\+Type  = arma\+::mat, template$<$ typename Hyperplane\+Metric\+Type $>$ class Hyperplane\+Type = Axis\+Orthogonal\+Hyperplane, template$<$ typename Split\+Metric\+Type, typename Split\+Mat\+Type $>$ class Split\+Type = Midpoint\+Space\+Split$>$ size\+\_\+t {\bf mlpack\+::tree\+::\+Spill\+Tree}$<$ Metric\+Type, Statistic\+Type, Mat\+Type, Hyperplane\+Type, Split\+Type $>$\+::Num\+Points (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
) const}\label{classmlpack_1_1tree_1_1SpillTree_a94b30aac8ab1016393544e13382de438}


Return the number of points in this node (0 if not a leaf). 



Referenced by mlpack\+::tree\+::\+Spill\+Tree$<$ Metric\+Type, Statistic\+Type, Mat\+Type, Hyperplane\+Type, Split\+Type $>$\+::\+Child\+Ptr().

\index{mlpack\+::tree\+::\+Spill\+Tree@{mlpack\+::tree\+::\+Spill\+Tree}!Overlap@{Overlap}}
\index{Overlap@{Overlap}!mlpack\+::tree\+::\+Spill\+Tree@{mlpack\+::tree\+::\+Spill\+Tree}}
\subsubsection[{Overlap() const }]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename Metric\+Type , typename Statistic\+Type  = Empty\+Statistic, typename Mat\+Type  = arma\+::mat, template$<$ typename Hyperplane\+Metric\+Type $>$ class Hyperplane\+Type = Axis\+Orthogonal\+Hyperplane, template$<$ typename Split\+Metric\+Type, typename Split\+Mat\+Type $>$ class Split\+Type = Midpoint\+Space\+Split$>$ bool {\bf mlpack\+::tree\+::\+Spill\+Tree}$<$ Metric\+Type, Statistic\+Type, Mat\+Type, Hyperplane\+Type, Split\+Type $>$\+::Overlap (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
) const\hspace{0.3cm}{\ttfamily [inline]}}\label{classmlpack_1_1tree_1_1SpillTree_a6fee7d736b7d529587a23f7379fbed76}


Distinguish overlapping nodes from non-\/overlapping nodes. 



Definition at line 261 of file spill\+\_\+tree.\+hpp.



References mlpack\+::tree\+::\+Spill\+Tree$<$ Metric\+Type, Statistic\+Type, Mat\+Type, Hyperplane\+Type, Split\+Type $>$\+::overlapping\+Node.

\index{mlpack\+::tree\+::\+Spill\+Tree@{mlpack\+::tree\+::\+Spill\+Tree}!Parent@{Parent}}
\index{Parent@{Parent}!mlpack\+::tree\+::\+Spill\+Tree@{mlpack\+::tree\+::\+Spill\+Tree}}
\subsubsection[{Parent() const }]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename Metric\+Type , typename Statistic\+Type  = Empty\+Statistic, typename Mat\+Type  = arma\+::mat, template$<$ typename Hyperplane\+Metric\+Type $>$ class Hyperplane\+Type = Axis\+Orthogonal\+Hyperplane, template$<$ typename Split\+Metric\+Type, typename Split\+Mat\+Type $>$ class Split\+Type = Midpoint\+Space\+Split$>$ {\bf Spill\+Tree}$\ast$ {\bf mlpack\+::tree\+::\+Spill\+Tree}$<$ Metric\+Type, Statistic\+Type, Mat\+Type, Hyperplane\+Type, Split\+Type $>$\+::Parent (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
) const\hspace{0.3cm}{\ttfamily [inline]}}\label{classmlpack_1_1tree_1_1SpillTree_ab0c4368a28681f0b9b6b8240cae9a85c}


Gets the parent of this node. 



Definition at line 253 of file spill\+\_\+tree.\+hpp.



References mlpack\+::tree\+::\+Spill\+Tree$<$ Metric\+Type, Statistic\+Type, Mat\+Type, Hyperplane\+Type, Split\+Type $>$\+::parent.

\index{mlpack\+::tree\+::\+Spill\+Tree@{mlpack\+::tree\+::\+Spill\+Tree}!Parent@{Parent}}
\index{Parent@{Parent}!mlpack\+::tree\+::\+Spill\+Tree@{mlpack\+::tree\+::\+Spill\+Tree}}
\subsubsection[{Parent()}]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename Metric\+Type , typename Statistic\+Type  = Empty\+Statistic, typename Mat\+Type  = arma\+::mat, template$<$ typename Hyperplane\+Metric\+Type $>$ class Hyperplane\+Type = Axis\+Orthogonal\+Hyperplane, template$<$ typename Split\+Metric\+Type, typename Split\+Mat\+Type $>$ class Split\+Type = Midpoint\+Space\+Split$>$ {\bf Spill\+Tree}$\ast$\& {\bf mlpack\+::tree\+::\+Spill\+Tree}$<$ Metric\+Type, Statistic\+Type, Mat\+Type, Hyperplane\+Type, Split\+Type $>$\+::Parent (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}}\label{classmlpack_1_1tree_1_1SpillTree_ad28d4e02e3f2044fa692a508b4f52602}


Modify the parent of this node. 



Definition at line 255 of file spill\+\_\+tree.\+hpp.



References mlpack\+::tree\+::\+Spill\+Tree$<$ Metric\+Type, Statistic\+Type, Mat\+Type, Hyperplane\+Type, Split\+Type $>$\+::parent.

\index{mlpack\+::tree\+::\+Spill\+Tree@{mlpack\+::tree\+::\+Spill\+Tree}!Parent\+Distance@{Parent\+Distance}}
\index{Parent\+Distance@{Parent\+Distance}!mlpack\+::tree\+::\+Spill\+Tree@{mlpack\+::tree\+::\+Spill\+Tree}}
\subsubsection[{Parent\+Distance() const }]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename Metric\+Type , typename Statistic\+Type  = Empty\+Statistic, typename Mat\+Type  = arma\+::mat, template$<$ typename Hyperplane\+Metric\+Type $>$ class Hyperplane\+Type = Axis\+Orthogonal\+Hyperplane, template$<$ typename Split\+Metric\+Type, typename Split\+Mat\+Type $>$ class Split\+Type = Midpoint\+Space\+Split$>$ {\bf Elem\+Type} {\bf mlpack\+::tree\+::\+Spill\+Tree}$<$ Metric\+Type, Statistic\+Type, Mat\+Type, Hyperplane\+Type, Split\+Type $>$\+::Parent\+Distance (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
) const\hspace{0.3cm}{\ttfamily [inline]}}\label{classmlpack_1_1tree_1_1SpillTree_a90011a35463b64ac7e11f53a1e1e3160}


Return the distance from the center of this node to the center of the parent node. 



Definition at line 330 of file spill\+\_\+tree.\+hpp.



References mlpack\+::tree\+::\+Spill\+Tree$<$ Metric\+Type, Statistic\+Type, Mat\+Type, Hyperplane\+Type, Split\+Type $>$\+::parent\+Distance.

\index{mlpack\+::tree\+::\+Spill\+Tree@{mlpack\+::tree\+::\+Spill\+Tree}!Parent\+Distance@{Parent\+Distance}}
\index{Parent\+Distance@{Parent\+Distance}!mlpack\+::tree\+::\+Spill\+Tree@{mlpack\+::tree\+::\+Spill\+Tree}}
\subsubsection[{Parent\+Distance()}]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename Metric\+Type , typename Statistic\+Type  = Empty\+Statistic, typename Mat\+Type  = arma\+::mat, template$<$ typename Hyperplane\+Metric\+Type $>$ class Hyperplane\+Type = Axis\+Orthogonal\+Hyperplane, template$<$ typename Split\+Metric\+Type, typename Split\+Mat\+Type $>$ class Split\+Type = Midpoint\+Space\+Split$>$ {\bf Elem\+Type}\& {\bf mlpack\+::tree\+::\+Spill\+Tree}$<$ Metric\+Type, Statistic\+Type, Mat\+Type, Hyperplane\+Type, Split\+Type $>$\+::Parent\+Distance (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}}\label{classmlpack_1_1tree_1_1SpillTree_a1efc45482288c77246cd7c71e64a7de6}


Modify the distance from the center of this node to the center of the parent node. 



Definition at line 333 of file spill\+\_\+tree.\+hpp.



References mlpack\+::tree\+::\+Spill\+Tree$<$ Metric\+Type, Statistic\+Type, Mat\+Type, Hyperplane\+Type, Split\+Type $>$\+::\+Child(), and mlpack\+::tree\+::\+Spill\+Tree$<$ Metric\+Type, Statistic\+Type, Mat\+Type, Hyperplane\+Type, Split\+Type $>$\+::parent\+Distance.

\index{mlpack\+::tree\+::\+Spill\+Tree@{mlpack\+::tree\+::\+Spill\+Tree}!Point@{Point}}
\index{Point@{Point}!mlpack\+::tree\+::\+Spill\+Tree@{mlpack\+::tree\+::\+Spill\+Tree}}
\subsubsection[{Point(const size\+\_\+t index) const }]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename Metric\+Type , typename Statistic\+Type  = Empty\+Statistic, typename Mat\+Type  = arma\+::mat, template$<$ typename Hyperplane\+Metric\+Type $>$ class Hyperplane\+Type = Axis\+Orthogonal\+Hyperplane, template$<$ typename Split\+Metric\+Type, typename Split\+Mat\+Type $>$ class Split\+Type = Midpoint\+Space\+Split$>$ size\+\_\+t {\bf mlpack\+::tree\+::\+Spill\+Tree}$<$ Metric\+Type, Statistic\+Type, Mat\+Type, Hyperplane\+Type, Split\+Type $>$\+::Point (
\begin{DoxyParamCaption}
\item[{const size\+\_\+t}]{index}
\end{DoxyParamCaption}
) const}\label{classmlpack_1_1tree_1_1SpillTree_a69f650191492eee6c5bd4c53d4fe6dd8}


Return the index (with reference to the dataset) of a particular point in this node. 

This will happily return invalid indices if the given index is greater than the number of points in this node (obtained with \doxyref{Num\+Points()}{p.}{classmlpack_1_1tree_1_1SpillTree_a94b30aac8ab1016393544e13382de438}) -- be careful.


\begin{DoxyParams}{Parameters}
{\em index} & Index of point for which a dataset index is wanted. \\
\hline
\end{DoxyParams}


Referenced by mlpack\+::tree\+::\+Spill\+Tree$<$ Metric\+Type, Statistic\+Type, Mat\+Type, Hyperplane\+Type, Split\+Type $>$\+::\+Child\+Ptr().

\index{mlpack\+::tree\+::\+Spill\+Tree@{mlpack\+::tree\+::\+Spill\+Tree}!Range\+Distance@{Range\+Distance}}
\index{Range\+Distance@{Range\+Distance}!mlpack\+::tree\+::\+Spill\+Tree@{mlpack\+::tree\+::\+Spill\+Tree}}
\subsubsection[{Range\+Distance(const Spill\+Tree \&other) const }]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename Metric\+Type , typename Statistic\+Type  = Empty\+Statistic, typename Mat\+Type  = arma\+::mat, template$<$ typename Hyperplane\+Metric\+Type $>$ class Hyperplane\+Type = Axis\+Orthogonal\+Hyperplane, template$<$ typename Split\+Metric\+Type, typename Split\+Mat\+Type $>$ class Split\+Type = Midpoint\+Space\+Split$>$ {\bf math\+::\+Range\+Type}$<${\bf Elem\+Type}$>$ {\bf mlpack\+::tree\+::\+Spill\+Tree}$<$ Metric\+Type, Statistic\+Type, Mat\+Type, Hyperplane\+Type, Split\+Type $>$\+::Range\+Distance (
\begin{DoxyParamCaption}
\item[{const {\bf Spill\+Tree}$<$ Metric\+Type, Statistic\+Type, Mat\+Type, Hyperplane\+Type, Split\+Type $>$ \&}]{other}
\end{DoxyParamCaption}
) const\hspace{0.3cm}{\ttfamily [inline]}}\label{classmlpack_1_1tree_1_1SpillTree_ab2b673b990e6453cee38476b6c62c703}


Return the minimum and maximum distance to another node. 



Definition at line 388 of file spill\+\_\+tree.\+hpp.



References mlpack\+::tree\+::\+Spill\+Tree$<$ Metric\+Type, Statistic\+Type, Mat\+Type, Hyperplane\+Type, Split\+Type $>$\+::\+Bound().

\index{mlpack\+::tree\+::\+Spill\+Tree@{mlpack\+::tree\+::\+Spill\+Tree}!Range\+Distance@{Range\+Distance}}
\index{Range\+Distance@{Range\+Distance}!mlpack\+::tree\+::\+Spill\+Tree@{mlpack\+::tree\+::\+Spill\+Tree}}
\subsubsection[{Range\+Distance(const Vec\+Type \&point, typename std\+::enable\+\_\+if\+\_\+t$<$ Is\+Vector$<$ Vec\+Type $>$\+::value $>$ $\ast$=0) const }]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename Metric\+Type , typename Statistic\+Type  = Empty\+Statistic, typename Mat\+Type  = arma\+::mat, template$<$ typename Hyperplane\+Metric\+Type $>$ class Hyperplane\+Type = Axis\+Orthogonal\+Hyperplane, template$<$ typename Split\+Metric\+Type, typename Split\+Mat\+Type $>$ class Split\+Type = Midpoint\+Space\+Split$>$ template$<$typename Vec\+Type $>$ {\bf math\+::\+Range\+Type}$<${\bf Elem\+Type}$>$ {\bf mlpack\+::tree\+::\+Spill\+Tree}$<$ Metric\+Type, Statistic\+Type, Mat\+Type, Hyperplane\+Type, Split\+Type $>$\+::Range\+Distance (
\begin{DoxyParamCaption}
\item[{const Vec\+Type \&}]{point, }
\item[{typename {\bf std\+::enable\+\_\+if\+\_\+t}$<$ {\bf Is\+Vector}$<$ Vec\+Type $>$\+::value $>$ $\ast$}]{ = {\ttfamily 0}}
\end{DoxyParamCaption}
) const\hspace{0.3cm}{\ttfamily [inline]}}\label{classmlpack_1_1tree_1_1SpillTree_a7b075950256b6f058e459644f1fbdae2}


Return the minimum and maximum distance to another point. 



Definition at line 414 of file spill\+\_\+tree.\+hpp.

\index{mlpack\+::tree\+::\+Spill\+Tree@{mlpack\+::tree\+::\+Spill\+Tree}!Right@{Right}}
\index{Right@{Right}!mlpack\+::tree\+::\+Spill\+Tree@{mlpack\+::tree\+::\+Spill\+Tree}}
\subsubsection[{Right() const }]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename Metric\+Type , typename Statistic\+Type  = Empty\+Statistic, typename Mat\+Type  = arma\+::mat, template$<$ typename Hyperplane\+Metric\+Type $>$ class Hyperplane\+Type = Axis\+Orthogonal\+Hyperplane, template$<$ typename Split\+Metric\+Type, typename Split\+Mat\+Type $>$ class Split\+Type = Midpoint\+Space\+Split$>$ {\bf Spill\+Tree}$\ast$ {\bf mlpack\+::tree\+::\+Spill\+Tree}$<$ Metric\+Type, Statistic\+Type, Mat\+Type, Hyperplane\+Type, Split\+Type $>$\+::Right (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
) const\hspace{0.3cm}{\ttfamily [inline]}}\label{classmlpack_1_1tree_1_1SpillTree_a7e3accade12965b3fa514e1fe5f0d8a2}


Gets the right child of this node. 



Definition at line 248 of file spill\+\_\+tree.\+hpp.



References mlpack\+::tree\+::\+Spill\+Tree$<$ Metric\+Type, Statistic\+Type, Mat\+Type, Hyperplane\+Type, Split\+Type $>$\+::right.

\index{mlpack\+::tree\+::\+Spill\+Tree@{mlpack\+::tree\+::\+Spill\+Tree}!Right@{Right}}
\index{Right@{Right}!mlpack\+::tree\+::\+Spill\+Tree@{mlpack\+::tree\+::\+Spill\+Tree}}
\subsubsection[{Right()}]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename Metric\+Type , typename Statistic\+Type  = Empty\+Statistic, typename Mat\+Type  = arma\+::mat, template$<$ typename Hyperplane\+Metric\+Type $>$ class Hyperplane\+Type = Axis\+Orthogonal\+Hyperplane, template$<$ typename Split\+Metric\+Type, typename Split\+Mat\+Type $>$ class Split\+Type = Midpoint\+Space\+Split$>$ {\bf Spill\+Tree}$\ast$\& {\bf mlpack\+::tree\+::\+Spill\+Tree}$<$ Metric\+Type, Statistic\+Type, Mat\+Type, Hyperplane\+Type, Split\+Type $>$\+::Right (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}}\label{classmlpack_1_1tree_1_1SpillTree_a46375a4336e0fef8c52821e5029926f0}


Modify the right child of this node. 



Definition at line 250 of file spill\+\_\+tree.\+hpp.



References mlpack\+::tree\+::\+Spill\+Tree$<$ Metric\+Type, Statistic\+Type, Mat\+Type, Hyperplane\+Type, Split\+Type $>$\+::right.

\index{mlpack\+::tree\+::\+Spill\+Tree@{mlpack\+::tree\+::\+Spill\+Tree}!Serialize@{Serialize}}
\index{Serialize@{Serialize}!mlpack\+::tree\+::\+Spill\+Tree@{mlpack\+::tree\+::\+Spill\+Tree}}
\subsubsection[{Serialize(\+Archive \&ar, const unsigned int version)}]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename Metric\+Type , typename Statistic\+Type  = Empty\+Statistic, typename Mat\+Type  = arma\+::mat, template$<$ typename Hyperplane\+Metric\+Type $>$ class Hyperplane\+Type = Axis\+Orthogonal\+Hyperplane, template$<$ typename Split\+Metric\+Type, typename Split\+Mat\+Type $>$ class Split\+Type = Midpoint\+Space\+Split$>$ template$<$typename Archive $>$ void {\bf mlpack\+::tree\+::\+Spill\+Tree}$<$ Metric\+Type, Statistic\+Type, Mat\+Type, Hyperplane\+Type, Split\+Type $>$\+::Serialize (
\begin{DoxyParamCaption}
\item[{Archive \&}]{ar, }
\item[{const unsigned int}]{version}
\end{DoxyParamCaption}
)}\label{classmlpack_1_1tree_1_1SpillTree_a6897e914aad2bdfb8328c1ccaf4c65e1}


Serialize the tree. 

\index{mlpack\+::tree\+::\+Spill\+Tree@{mlpack\+::tree\+::\+Spill\+Tree}!Split\+Node@{Split\+Node}}
\index{Split\+Node@{Split\+Node}!mlpack\+::tree\+::\+Spill\+Tree@{mlpack\+::tree\+::\+Spill\+Tree}}
\subsubsection[{Split\+Node(arma\+::\+Col$<$ size\+\_\+t $>$ \&points, const size\+\_\+t max\+Leaf\+Size, const double tau, const double rho)}]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename Metric\+Type , typename Statistic\+Type  = Empty\+Statistic, typename Mat\+Type  = arma\+::mat, template$<$ typename Hyperplane\+Metric\+Type $>$ class Hyperplane\+Type = Axis\+Orthogonal\+Hyperplane, template$<$ typename Split\+Metric\+Type, typename Split\+Mat\+Type $>$ class Split\+Type = Midpoint\+Space\+Split$>$ void {\bf mlpack\+::tree\+::\+Spill\+Tree}$<$ Metric\+Type, Statistic\+Type, Mat\+Type, Hyperplane\+Type, Split\+Type $>$\+::Split\+Node (
\begin{DoxyParamCaption}
\item[{arma\+::\+Col$<$ size\+\_\+t $>$ \&}]{points, }
\item[{const size\+\_\+t}]{max\+Leaf\+Size, }
\item[{const double}]{tau, }
\item[{const double}]{rho}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [private]}}\label{classmlpack_1_1tree_1_1SpillTree_afcdf54e764b75f2777ece22ab978ca40}


Splits the current node, assigning its left and right children recursively. 


\begin{DoxyParams}{Parameters}
{\em points} & Vector of indexes of points to be included in this node. \\
\hline
{\em max\+Leaf\+Size} & Maximum number of points held in a leaf. \\
\hline
{\em tau} & Overlapping size. \\
\hline
{\em rho} & Balance threshold. \\
\hline
\end{DoxyParams}


Referenced by mlpack\+::tree\+::\+Spill\+Tree$<$ Metric\+Type, Statistic\+Type, Mat\+Type, Hyperplane\+Type, Split\+Type $>$\+::\+Center().

\index{mlpack\+::tree\+::\+Spill\+Tree@{mlpack\+::tree\+::\+Spill\+Tree}!Split\+Points@{Split\+Points}}
\index{Split\+Points@{Split\+Points}!mlpack\+::tree\+::\+Spill\+Tree@{mlpack\+::tree\+::\+Spill\+Tree}}
\subsubsection[{Split\+Points(const double tau, const double rho, const arma\+::\+Col$<$ size\+\_\+t $>$ \&points, arma\+::\+Col$<$ size\+\_\+t $>$ \&left\+Points, arma\+::\+Col$<$ size\+\_\+t $>$ \&right\+Points)}]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename Metric\+Type , typename Statistic\+Type  = Empty\+Statistic, typename Mat\+Type  = arma\+::mat, template$<$ typename Hyperplane\+Metric\+Type $>$ class Hyperplane\+Type = Axis\+Orthogonal\+Hyperplane, template$<$ typename Split\+Metric\+Type, typename Split\+Mat\+Type $>$ class Split\+Type = Midpoint\+Space\+Split$>$ bool {\bf mlpack\+::tree\+::\+Spill\+Tree}$<$ Metric\+Type, Statistic\+Type, Mat\+Type, Hyperplane\+Type, Split\+Type $>$\+::Split\+Points (
\begin{DoxyParamCaption}
\item[{const double}]{tau, }
\item[{const double}]{rho, }
\item[{const arma\+::\+Col$<$ size\+\_\+t $>$ \&}]{points, }
\item[{arma\+::\+Col$<$ size\+\_\+t $>$ \&}]{left\+Points, }
\item[{arma\+::\+Col$<$ size\+\_\+t $>$ \&}]{right\+Points}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [private]}}\label{classmlpack_1_1tree_1_1SpillTree_a2481745d31885b7bea113758204bc303}


Split the list of points. 


\begin{DoxyParams}{Parameters}
{\em tau} & Overlapping size. \\
\hline
{\em rho} & Balance threshold. \\
\hline
{\em points} & Vector of indexes of points to be included. \\
\hline
{\em left\+Points} & Indexes of points to be included in left child. \\
\hline
{\em right\+Points} & Indexes of points to be included in right child. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
Flag to know if the overlapping buffer was included. 
\end{DoxyReturn}


Referenced by mlpack\+::tree\+::\+Spill\+Tree$<$ Metric\+Type, Statistic\+Type, Mat\+Type, Hyperplane\+Type, Split\+Type $>$\+::\+Center().

\index{mlpack\+::tree\+::\+Spill\+Tree@{mlpack\+::tree\+::\+Spill\+Tree}!Stat@{Stat}}
\index{Stat@{Stat}!mlpack\+::tree\+::\+Spill\+Tree@{mlpack\+::tree\+::\+Spill\+Tree}}
\subsubsection[{Stat() const }]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename Metric\+Type , typename Statistic\+Type  = Empty\+Statistic, typename Mat\+Type  = arma\+::mat, template$<$ typename Hyperplane\+Metric\+Type $>$ class Hyperplane\+Type = Axis\+Orthogonal\+Hyperplane, template$<$ typename Split\+Metric\+Type, typename Split\+Mat\+Type $>$ class Split\+Type = Midpoint\+Space\+Split$>$ const Statistic\+Type\& {\bf mlpack\+::tree\+::\+Spill\+Tree}$<$ Metric\+Type, Statistic\+Type, Mat\+Type, Hyperplane\+Type, Split\+Type $>$\+::Stat (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
) const\hspace{0.3cm}{\ttfamily [inline]}}\label{classmlpack_1_1tree_1_1SpillTree_a07864908e6a19c4ae69a837a8fadd993}


Return the statistic object for this node. 



Definition at line 235 of file spill\+\_\+tree.\+hpp.



References mlpack\+::tree\+::\+Spill\+Tree$<$ Metric\+Type, Statistic\+Type, Mat\+Type, Hyperplane\+Type, Split\+Type $>$\+::stat.

\index{mlpack\+::tree\+::\+Spill\+Tree@{mlpack\+::tree\+::\+Spill\+Tree}!Stat@{Stat}}
\index{Stat@{Stat}!mlpack\+::tree\+::\+Spill\+Tree@{mlpack\+::tree\+::\+Spill\+Tree}}
\subsubsection[{Stat()}]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename Metric\+Type , typename Statistic\+Type  = Empty\+Statistic, typename Mat\+Type  = arma\+::mat, template$<$ typename Hyperplane\+Metric\+Type $>$ class Hyperplane\+Type = Axis\+Orthogonal\+Hyperplane, template$<$ typename Split\+Metric\+Type, typename Split\+Mat\+Type $>$ class Split\+Type = Midpoint\+Space\+Split$>$ Statistic\+Type\& {\bf mlpack\+::tree\+::\+Spill\+Tree}$<$ Metric\+Type, Statistic\+Type, Mat\+Type, Hyperplane\+Type, Split\+Type $>$\+::Stat (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}}\label{classmlpack_1_1tree_1_1SpillTree_afea9e6f62544ec7d08297113f885d923}


Return the statistic object for this node. 



Definition at line 237 of file spill\+\_\+tree.\+hpp.



References mlpack\+::tree\+::\+Spill\+Tree$<$ Metric\+Type, Statistic\+Type, Mat\+Type, Hyperplane\+Type, Split\+Type $>$\+::\+Is\+Leaf(), and mlpack\+::tree\+::\+Spill\+Tree$<$ Metric\+Type, Statistic\+Type, Mat\+Type, Hyperplane\+Type, Split\+Type $>$\+::stat.



\subsection{Member Data Documentation}
\index{mlpack\+::tree\+::\+Spill\+Tree@{mlpack\+::tree\+::\+Spill\+Tree}!bound@{bound}}
\index{bound@{bound}!mlpack\+::tree\+::\+Spill\+Tree@{mlpack\+::tree\+::\+Spill\+Tree}}
\subsubsection[{bound}]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename Metric\+Type , typename Statistic\+Type  = Empty\+Statistic, typename Mat\+Type  = arma\+::mat, template$<$ typename Hyperplane\+Metric\+Type $>$ class Hyperplane\+Type = Axis\+Orthogonal\+Hyperplane, template$<$ typename Split\+Metric\+Type, typename Split\+Mat\+Type $>$ class Split\+Type = Midpoint\+Space\+Split$>$ {\bf Bound\+Type} {\bf mlpack\+::tree\+::\+Spill\+Tree}$<$ Metric\+Type, Statistic\+Type, Mat\+Type, Hyperplane\+Type, Split\+Type $>$\+::bound\hspace{0.3cm}{\ttfamily [private]}}\label{classmlpack_1_1tree_1_1SpillTree_ab7fbd298a7cd3613abe861476ff2cc5f}


The bound object for this node. 



Definition at line 101 of file spill\+\_\+tree.\+hpp.



Referenced by mlpack\+::tree\+::\+Spill\+Tree$<$ Metric\+Type, Statistic\+Type, Mat\+Type, Hyperplane\+Type, Split\+Type $>$\+::\+Bound().

\index{mlpack\+::tree\+::\+Spill\+Tree@{mlpack\+::tree\+::\+Spill\+Tree}!count@{count}}
\index{count@{count}!mlpack\+::tree\+::\+Spill\+Tree@{mlpack\+::tree\+::\+Spill\+Tree}}
\subsubsection[{count}]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename Metric\+Type , typename Statistic\+Type  = Empty\+Statistic, typename Mat\+Type  = arma\+::mat, template$<$ typename Hyperplane\+Metric\+Type $>$ class Hyperplane\+Type = Axis\+Orthogonal\+Hyperplane, template$<$ typename Split\+Metric\+Type, typename Split\+Mat\+Type $>$ class Split\+Type = Midpoint\+Space\+Split$>$ size\+\_\+t {\bf mlpack\+::tree\+::\+Spill\+Tree}$<$ Metric\+Type, Statistic\+Type, Mat\+Type, Hyperplane\+Type, Split\+Type $>$\+::count\hspace{0.3cm}{\ttfamily [private]}}\label{classmlpack_1_1tree_1_1SpillTree_aca85648cacf8719be43a6534e6c33b37}


The number of points of the dataset contained in this node (and its children). 



Definition at line 92 of file spill\+\_\+tree.\+hpp.

\index{mlpack\+::tree\+::\+Spill\+Tree@{mlpack\+::tree\+::\+Spill\+Tree}!dataset@{dataset}}
\index{dataset@{dataset}!mlpack\+::tree\+::\+Spill\+Tree@{mlpack\+::tree\+::\+Spill\+Tree}}
\subsubsection[{dataset}]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename Metric\+Type , typename Statistic\+Type  = Empty\+Statistic, typename Mat\+Type  = arma\+::mat, template$<$ typename Hyperplane\+Metric\+Type $>$ class Hyperplane\+Type = Axis\+Orthogonal\+Hyperplane, template$<$ typename Split\+Metric\+Type, typename Split\+Mat\+Type $>$ class Split\+Type = Midpoint\+Space\+Split$>$ const Mat\+Type$\ast$ {\bf mlpack\+::tree\+::\+Spill\+Tree}$<$ Metric\+Type, Statistic\+Type, Mat\+Type, Hyperplane\+Type, Split\+Type $>$\+::dataset\hspace{0.3cm}{\ttfamily [private]}}\label{classmlpack_1_1tree_1_1SpillTree_a56354d3af9273a689fc3634f43fda61a}


The dataset. 

If we are the root of the tree, we own the dataset and must delete it. 

Definition at line 113 of file spill\+\_\+tree.\+hpp.



Referenced by mlpack\+::tree\+::\+Spill\+Tree$<$ Metric\+Type, Statistic\+Type, Mat\+Type, Hyperplane\+Type, Split\+Type $>$\+::\+Dataset().

\index{mlpack\+::tree\+::\+Spill\+Tree@{mlpack\+::tree\+::\+Spill\+Tree}!furthest\+Descendant\+Distance@{furthest\+Descendant\+Distance}}
\index{furthest\+Descendant\+Distance@{furthest\+Descendant\+Distance}!mlpack\+::tree\+::\+Spill\+Tree@{mlpack\+::tree\+::\+Spill\+Tree}}
\subsubsection[{furthest\+Descendant\+Distance}]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename Metric\+Type , typename Statistic\+Type  = Empty\+Statistic, typename Mat\+Type  = arma\+::mat, template$<$ typename Hyperplane\+Metric\+Type $>$ class Hyperplane\+Type = Axis\+Orthogonal\+Hyperplane, template$<$ typename Split\+Metric\+Type, typename Split\+Mat\+Type $>$ class Split\+Type = Midpoint\+Space\+Split$>$ {\bf Elem\+Type} {\bf mlpack\+::tree\+::\+Spill\+Tree}$<$ Metric\+Type, Statistic\+Type, Mat\+Type, Hyperplane\+Type, Split\+Type $>$\+::furthest\+Descendant\+Distance\hspace{0.3cm}{\ttfamily [private]}}\label{classmlpack_1_1tree_1_1SpillTree_a40ba4713f1d2a6feae5ffda01e9cf134}


The worst possible distance to the furthest descendant, cached to speed things up. 



Definition at line 108 of file spill\+\_\+tree.\+hpp.

\index{mlpack\+::tree\+::\+Spill\+Tree@{mlpack\+::tree\+::\+Spill\+Tree}!hyperplane@{hyperplane}}
\index{hyperplane@{hyperplane}!mlpack\+::tree\+::\+Spill\+Tree@{mlpack\+::tree\+::\+Spill\+Tree}}
\subsubsection[{hyperplane}]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename Metric\+Type , typename Statistic\+Type  = Empty\+Statistic, typename Mat\+Type  = arma\+::mat, template$<$ typename Hyperplane\+Metric\+Type $>$ class Hyperplane\+Type = Axis\+Orthogonal\+Hyperplane, template$<$ typename Split\+Metric\+Type, typename Split\+Mat\+Type $>$ class Split\+Type = Midpoint\+Space\+Split$>$ Hyperplane\+Type$<$Metric\+Type$>$ {\bf mlpack\+::tree\+::\+Spill\+Tree}$<$ Metric\+Type, Statistic\+Type, Mat\+Type, Hyperplane\+Type, Split\+Type $>$\+::hyperplane\hspace{0.3cm}{\ttfamily [private]}}\label{classmlpack_1_1tree_1_1SpillTree_a021457174c05bf5e17fc43bc499c0b2b}


Splitting hyperplane represented by this node. 



Definition at line 99 of file spill\+\_\+tree.\+hpp.



Referenced by mlpack\+::tree\+::\+Spill\+Tree$<$ Metric\+Type, Statistic\+Type, Mat\+Type, Hyperplane\+Type, Split\+Type $>$\+::\+Hyperplane().

\index{mlpack\+::tree\+::\+Spill\+Tree@{mlpack\+::tree\+::\+Spill\+Tree}!left@{left}}
\index{left@{left}!mlpack\+::tree\+::\+Spill\+Tree@{mlpack\+::tree\+::\+Spill\+Tree}}
\subsubsection[{left}]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename Metric\+Type , typename Statistic\+Type  = Empty\+Statistic, typename Mat\+Type  = arma\+::mat, template$<$ typename Hyperplane\+Metric\+Type $>$ class Hyperplane\+Type = Axis\+Orthogonal\+Hyperplane, template$<$ typename Split\+Metric\+Type, typename Split\+Mat\+Type $>$ class Split\+Type = Midpoint\+Space\+Split$>$ {\bf Spill\+Tree}$\ast$ {\bf mlpack\+::tree\+::\+Spill\+Tree}$<$ Metric\+Type, Statistic\+Type, Mat\+Type, Hyperplane\+Type, Split\+Type $>$\+::left\hspace{0.3cm}{\ttfamily [private]}}\label{classmlpack_1_1tree_1_1SpillTree_af3d3004d09c7057be8c849d7d265c588}


The left child node. 



Definition at line 85 of file spill\+\_\+tree.\+hpp.



Referenced by mlpack\+::tree\+::\+Spill\+Tree$<$ Metric\+Type, Statistic\+Type, Mat\+Type, Hyperplane\+Type, Split\+Type $>$\+::\+Left().

\index{mlpack\+::tree\+::\+Spill\+Tree@{mlpack\+::tree\+::\+Spill\+Tree}!local\+Dataset@{local\+Dataset}}
\index{local\+Dataset@{local\+Dataset}!mlpack\+::tree\+::\+Spill\+Tree@{mlpack\+::tree\+::\+Spill\+Tree}}
\subsubsection[{local\+Dataset}]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename Metric\+Type , typename Statistic\+Type  = Empty\+Statistic, typename Mat\+Type  = arma\+::mat, template$<$ typename Hyperplane\+Metric\+Type $>$ class Hyperplane\+Type = Axis\+Orthogonal\+Hyperplane, template$<$ typename Split\+Metric\+Type, typename Split\+Mat\+Type $>$ class Split\+Type = Midpoint\+Space\+Split$>$ bool {\bf mlpack\+::tree\+::\+Spill\+Tree}$<$ Metric\+Type, Statistic\+Type, Mat\+Type, Hyperplane\+Type, Split\+Type $>$\+::local\+Dataset\hspace{0.3cm}{\ttfamily [private]}}\label{classmlpack_1_1tree_1_1SpillTree_a31ead74b4a25d34f6221fef6ddae3caa}


If true, we own the dataset and need to destroy it in the destructor. 



Definition at line 115 of file spill\+\_\+tree.\+hpp.

\index{mlpack\+::tree\+::\+Spill\+Tree@{mlpack\+::tree\+::\+Spill\+Tree}!minimum\+Bound\+Distance@{minimum\+Bound\+Distance}}
\index{minimum\+Bound\+Distance@{minimum\+Bound\+Distance}!mlpack\+::tree\+::\+Spill\+Tree@{mlpack\+::tree\+::\+Spill\+Tree}}
\subsubsection[{minimum\+Bound\+Distance}]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename Metric\+Type , typename Statistic\+Type  = Empty\+Statistic, typename Mat\+Type  = arma\+::mat, template$<$ typename Hyperplane\+Metric\+Type $>$ class Hyperplane\+Type = Axis\+Orthogonal\+Hyperplane, template$<$ typename Split\+Metric\+Type, typename Split\+Mat\+Type $>$ class Split\+Type = Midpoint\+Space\+Split$>$ {\bf Elem\+Type} {\bf mlpack\+::tree\+::\+Spill\+Tree}$<$ Metric\+Type, Statistic\+Type, Mat\+Type, Hyperplane\+Type, Split\+Type $>$\+::minimum\+Bound\+Distance\hspace{0.3cm}{\ttfamily [private]}}\label{classmlpack_1_1tree_1_1SpillTree_a6709ead9cc97ea742b36d86a38ca56d0}


The minimum distance from the center to any edge of the bound. 



Definition at line 110 of file spill\+\_\+tree.\+hpp.

\index{mlpack\+::tree\+::\+Spill\+Tree@{mlpack\+::tree\+::\+Spill\+Tree}!overlapping\+Node@{overlapping\+Node}}
\index{overlapping\+Node@{overlapping\+Node}!mlpack\+::tree\+::\+Spill\+Tree@{mlpack\+::tree\+::\+Spill\+Tree}}
\subsubsection[{overlapping\+Node}]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename Metric\+Type , typename Statistic\+Type  = Empty\+Statistic, typename Mat\+Type  = arma\+::mat, template$<$ typename Hyperplane\+Metric\+Type $>$ class Hyperplane\+Type = Axis\+Orthogonal\+Hyperplane, template$<$ typename Split\+Metric\+Type, typename Split\+Mat\+Type $>$ class Split\+Type = Midpoint\+Space\+Split$>$ bool {\bf mlpack\+::tree\+::\+Spill\+Tree}$<$ Metric\+Type, Statistic\+Type, Mat\+Type, Hyperplane\+Type, Split\+Type $>$\+::overlapping\+Node\hspace{0.3cm}{\ttfamily [private]}}\label{classmlpack_1_1tree_1_1SpillTree_a0309a97ec7fadb3ca6baabd3fd3d9986}


Flag to distinguish overlapping nodes from non-\/overlapping nodes. 



Definition at line 97 of file spill\+\_\+tree.\+hpp.



Referenced by mlpack\+::tree\+::\+Spill\+Tree$<$ Metric\+Type, Statistic\+Type, Mat\+Type, Hyperplane\+Type, Split\+Type $>$\+::\+Overlap().

\index{mlpack\+::tree\+::\+Spill\+Tree@{mlpack\+::tree\+::\+Spill\+Tree}!parent@{parent}}
\index{parent@{parent}!mlpack\+::tree\+::\+Spill\+Tree@{mlpack\+::tree\+::\+Spill\+Tree}}
\subsubsection[{parent}]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename Metric\+Type , typename Statistic\+Type  = Empty\+Statistic, typename Mat\+Type  = arma\+::mat, template$<$ typename Hyperplane\+Metric\+Type $>$ class Hyperplane\+Type = Axis\+Orthogonal\+Hyperplane, template$<$ typename Split\+Metric\+Type, typename Split\+Mat\+Type $>$ class Split\+Type = Midpoint\+Space\+Split$>$ {\bf Spill\+Tree}$\ast$ {\bf mlpack\+::tree\+::\+Spill\+Tree}$<$ Metric\+Type, Statistic\+Type, Mat\+Type, Hyperplane\+Type, Split\+Type $>$\+::parent\hspace{0.3cm}{\ttfamily [private]}}\label{classmlpack_1_1tree_1_1SpillTree_a5cd7de5c98bd88b4dfbee977e05c9c3b}


The parent node (N\+U\+LL if this is the root of the tree). 



Definition at line 89 of file spill\+\_\+tree.\+hpp.



Referenced by mlpack\+::tree\+::\+Spill\+Tree$<$ Metric\+Type, Statistic\+Type, Mat\+Type, Hyperplane\+Type, Split\+Type $>$\+::\+Parent().

\index{mlpack\+::tree\+::\+Spill\+Tree@{mlpack\+::tree\+::\+Spill\+Tree}!parent\+Distance@{parent\+Distance}}
\index{parent\+Distance@{parent\+Distance}!mlpack\+::tree\+::\+Spill\+Tree@{mlpack\+::tree\+::\+Spill\+Tree}}
\subsubsection[{parent\+Distance}]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename Metric\+Type , typename Statistic\+Type  = Empty\+Statistic, typename Mat\+Type  = arma\+::mat, template$<$ typename Hyperplane\+Metric\+Type $>$ class Hyperplane\+Type = Axis\+Orthogonal\+Hyperplane, template$<$ typename Split\+Metric\+Type, typename Split\+Mat\+Type $>$ class Split\+Type = Midpoint\+Space\+Split$>$ {\bf Elem\+Type} {\bf mlpack\+::tree\+::\+Spill\+Tree}$<$ Metric\+Type, Statistic\+Type, Mat\+Type, Hyperplane\+Type, Split\+Type $>$\+::parent\+Distance\hspace{0.3cm}{\ttfamily [private]}}\label{classmlpack_1_1tree_1_1SpillTree_a2d95d83df84b6171d1d757aab81930c2}


The distance from the centroid of this node to the centroid of the parent. 



Definition at line 105 of file spill\+\_\+tree.\+hpp.



Referenced by mlpack\+::tree\+::\+Spill\+Tree$<$ Metric\+Type, Statistic\+Type, Mat\+Type, Hyperplane\+Type, Split\+Type $>$\+::\+Parent\+Distance().

\index{mlpack\+::tree\+::\+Spill\+Tree@{mlpack\+::tree\+::\+Spill\+Tree}!points\+Index@{points\+Index}}
\index{points\+Index@{points\+Index}!mlpack\+::tree\+::\+Spill\+Tree@{mlpack\+::tree\+::\+Spill\+Tree}}
\subsubsection[{points\+Index}]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename Metric\+Type , typename Statistic\+Type  = Empty\+Statistic, typename Mat\+Type  = arma\+::mat, template$<$ typename Hyperplane\+Metric\+Type $>$ class Hyperplane\+Type = Axis\+Orthogonal\+Hyperplane, template$<$ typename Split\+Metric\+Type, typename Split\+Mat\+Type $>$ class Split\+Type = Midpoint\+Space\+Split$>$ arma\+::\+Col$<$size\+\_\+t$>$$\ast$ {\bf mlpack\+::tree\+::\+Spill\+Tree}$<$ Metric\+Type, Statistic\+Type, Mat\+Type, Hyperplane\+Type, Split\+Type $>$\+::points\+Index\hspace{0.3cm}{\ttfamily [private]}}\label{classmlpack_1_1tree_1_1SpillTree_aeeb3ccd91792473d6dd696073487d273}


The list of indexes of points contained in this node (non-\/null for leaf nodes). 



Definition at line 95 of file spill\+\_\+tree.\+hpp.

\index{mlpack\+::tree\+::\+Spill\+Tree@{mlpack\+::tree\+::\+Spill\+Tree}!right@{right}}
\index{right@{right}!mlpack\+::tree\+::\+Spill\+Tree@{mlpack\+::tree\+::\+Spill\+Tree}}
\subsubsection[{right}]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename Metric\+Type , typename Statistic\+Type  = Empty\+Statistic, typename Mat\+Type  = arma\+::mat, template$<$ typename Hyperplane\+Metric\+Type $>$ class Hyperplane\+Type = Axis\+Orthogonal\+Hyperplane, template$<$ typename Split\+Metric\+Type, typename Split\+Mat\+Type $>$ class Split\+Type = Midpoint\+Space\+Split$>$ {\bf Spill\+Tree}$\ast$ {\bf mlpack\+::tree\+::\+Spill\+Tree}$<$ Metric\+Type, Statistic\+Type, Mat\+Type, Hyperplane\+Type, Split\+Type $>$\+::right\hspace{0.3cm}{\ttfamily [private]}}\label{classmlpack_1_1tree_1_1SpillTree_a3c6f54dc452dcb8ab57bf2b241fb4d46}


The right child node. 



Definition at line 87 of file spill\+\_\+tree.\+hpp.



Referenced by mlpack\+::tree\+::\+Spill\+Tree$<$ Metric\+Type, Statistic\+Type, Mat\+Type, Hyperplane\+Type, Split\+Type $>$\+::\+Child\+Ptr(), and mlpack\+::tree\+::\+Spill\+Tree$<$ Metric\+Type, Statistic\+Type, Mat\+Type, Hyperplane\+Type, Split\+Type $>$\+::\+Right().

\index{mlpack\+::tree\+::\+Spill\+Tree@{mlpack\+::tree\+::\+Spill\+Tree}!stat@{stat}}
\index{stat@{stat}!mlpack\+::tree\+::\+Spill\+Tree@{mlpack\+::tree\+::\+Spill\+Tree}}
\subsubsection[{stat}]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename Metric\+Type , typename Statistic\+Type  = Empty\+Statistic, typename Mat\+Type  = arma\+::mat, template$<$ typename Hyperplane\+Metric\+Type $>$ class Hyperplane\+Type = Axis\+Orthogonal\+Hyperplane, template$<$ typename Split\+Metric\+Type, typename Split\+Mat\+Type $>$ class Split\+Type = Midpoint\+Space\+Split$>$ Statistic\+Type {\bf mlpack\+::tree\+::\+Spill\+Tree}$<$ Metric\+Type, Statistic\+Type, Mat\+Type, Hyperplane\+Type, Split\+Type $>$\+::stat\hspace{0.3cm}{\ttfamily [private]}}\label{classmlpack_1_1tree_1_1SpillTree_a678d2447ace8bb1709d740dc63e6b817}


Any extra data contained in the node. 



Definition at line 103 of file spill\+\_\+tree.\+hpp.



Referenced by mlpack\+::tree\+::\+Spill\+Tree$<$ Metric\+Type, Statistic\+Type, Mat\+Type, Hyperplane\+Type, Split\+Type $>$\+::\+Stat().



The documentation for this class was generated from the following file\+:\begin{DoxyCompactItemize}
\item 
src/mlpack/core/tree/spill\+\_\+tree/{\bf spill\+\_\+tree.\+hpp}\end{DoxyCompactItemize}
