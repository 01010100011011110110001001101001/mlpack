\section{mlpack\+:\+:neighbor\+:\+:L\+S\+H\+Search$<$ Sort\+Policy $>$ Class Template Reference}
\label{classmlpack_1_1neighbor_1_1LSHSearch}\index{mlpack\+::neighbor\+::\+L\+S\+H\+Search$<$ Sort\+Policy $>$@{mlpack\+::neighbor\+::\+L\+S\+H\+Search$<$ Sort\+Policy $>$}}


The \doxyref{L\+S\+H\+Search}{p.}{classmlpack_1_1neighbor_1_1LSHSearch} class; this class builds a hash on the reference set and uses this hash to compute the distance-\/approximate nearest-\/neighbors of the given queries.  


\subsection*{Classes}
\begin{DoxyCompactItemize}
\item 
struct {\bf Candidate\+Cmp}
\begin{DoxyCompactList}\small\item\em Compare two candidates based on the distance. \end{DoxyCompactList}\end{DoxyCompactItemize}
\subsection*{Public Member Functions}
\begin{DoxyCompactItemize}
\item 
{\bf L\+S\+H\+Search} (const arma\+::mat \&{\bf reference\+Set}, const arma\+::cube \&{\bf projections}, const double {\bf hash\+Width}=0.\+0, const size\+\_\+t {\bf second\+Hash\+Size}=99901, const size\+\_\+t {\bf bucket\+Size}=500)
\begin{DoxyCompactList}\small\item\em This function initializes the L\+SH class. \end{DoxyCompactList}\item 
{\bf L\+S\+H\+Search} (const arma\+::mat \&{\bf reference\+Set}, const size\+\_\+t {\bf num\+Proj}, const size\+\_\+t {\bf num\+Tables}, const double {\bf hash\+Width}=0.\+0, const size\+\_\+t {\bf second\+Hash\+Size}=99901, const size\+\_\+t {\bf bucket\+Size}=500)
\begin{DoxyCompactList}\small\item\em This function initializes the L\+SH class. \end{DoxyCompactList}\item 
{\bf L\+S\+H\+Search} ()
\begin{DoxyCompactList}\small\item\em Create an untrained L\+SH model. \end{DoxyCompactList}\item 
{\bf L\+S\+H\+Search} (const {\bf L\+S\+H\+Search} \&other)
\begin{DoxyCompactList}\small\item\em Copy the given L\+SH model. \end{DoxyCompactList}\item 
{\bf L\+S\+H\+Search} ({\bf L\+S\+H\+Search} \&\&other)
\begin{DoxyCompactList}\small\item\em Take ownership of the given L\+SH model. \end{DoxyCompactList}\item 
{\bf $\sim$\+L\+S\+H\+Search} ()
\begin{DoxyCompactList}\small\item\em Clean memory. \end{DoxyCompactList}\item 
size\+\_\+t {\bf Bucket\+Size} () const 
\begin{DoxyCompactList}\small\item\em Get the bucket size of the second hash. \end{DoxyCompactList}\item 
size\+\_\+t {\bf Distance\+Evaluations} () const 
\begin{DoxyCompactList}\small\item\em Return the number of distance evaluations performed. \end{DoxyCompactList}\item 
size\+\_\+t \& {\bf Distance\+Evaluations} ()
\begin{DoxyCompactList}\small\item\em Modify the number of distance evaluations performed. \end{DoxyCompactList}\item 
size\+\_\+t {\bf Num\+Projections} () const 
\begin{DoxyCompactList}\small\item\em Get the number of projections. \end{DoxyCompactList}\item 
const arma\+::mat \& {\bf Offsets} () const 
\begin{DoxyCompactList}\small\item\em Get the offsets \textquotesingle{}b\textquotesingle{} for each of the projections. (One \textquotesingle{}b\textquotesingle{} per column.) \end{DoxyCompactList}\item 
{\bf L\+S\+H\+Search} \& {\bf operator=} (const {\bf L\+S\+H\+Search} \&other)
\begin{DoxyCompactList}\small\item\em Copy the given L\+SH model. \end{DoxyCompactList}\item 
{\bf L\+S\+H\+Search} \& {\bf operator=} ({\bf L\+S\+H\+Search} \&\&other)
\begin{DoxyCompactList}\small\item\em Take ownership of the given L\+SH model. \end{DoxyCompactList}\item 
const arma\+::cube \& {\bf Projections} ()
\begin{DoxyCompactList}\small\item\em Get the projection tables. \end{DoxyCompactList}\item 
void {\bf Projections} (const arma\+::cube \&proj\+Tables)
\begin{DoxyCompactList}\small\item\em Change the projection tables (this retrains the L\+SH model). \end{DoxyCompactList}\item 
const arma\+::mat \& {\bf Reference\+Set} () const 
\begin{DoxyCompactList}\small\item\em Return the reference dataset. \end{DoxyCompactList}\item 
void {\bf Search} (const arma\+::mat \&query\+Set, const size\+\_\+t k, arma\+::\+Mat$<$ size\+\_\+t $>$ \&resulting\+Neighbors, arma\+::mat \&distances, const size\+\_\+t num\+Tables\+To\+Search=0, const size\+\_\+t T=0)
\begin{DoxyCompactList}\small\item\em Compute the nearest neighbors of the points in the given query set and store the output in the given matrices. \end{DoxyCompactList}\item 
void {\bf Search} (const size\+\_\+t k, arma\+::\+Mat$<$ size\+\_\+t $>$ \&resulting\+Neighbors, arma\+::mat \&distances, const size\+\_\+t num\+Tables\+To\+Search=0, size\+\_\+t T=0)
\begin{DoxyCompactList}\small\item\em Compute the nearest neighbors and store the output in the given matrices. \end{DoxyCompactList}\item 
const std\+::vector$<$ arma\+::\+Col$<$ size\+\_\+t $>$ $>$ \& {\bf Second\+Hash\+Table} () const 
\begin{DoxyCompactList}\small\item\em Get the second hash table. \end{DoxyCompactList}\item 
const arma\+::vec \& {\bf Second\+Hash\+Weights} () const 
\begin{DoxyCompactList}\small\item\em Get the weights of the second hash. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename Archive $>$ }\\void {\bf Serialize} (Archive \&ar, const unsigned int version)
\begin{DoxyCompactList}\small\item\em Serialize the L\+SH model. \end{DoxyCompactList}\item 
void {\bf Train} (const arma\+::mat \&{\bf reference\+Set}, const size\+\_\+t {\bf num\+Proj}, const size\+\_\+t {\bf num\+Tables}, const double {\bf hash\+Width}=0.\+0, const size\+\_\+t {\bf second\+Hash\+Size}=99901, const size\+\_\+t {\bf bucket\+Size}=500, const arma\+::cube \&projection=arma\+::cube())
\begin{DoxyCompactList}\small\item\em Train the L\+SH model on the given dataset. \end{DoxyCompactList}\end{DoxyCompactItemize}
\subsection*{Static Public Member Functions}
\begin{DoxyCompactItemize}
\item 
static double {\bf Compute\+Recall} (const arma\+::\+Mat$<$ size\+\_\+t $>$ \&found\+Neighbors, const arma\+::\+Mat$<$ size\+\_\+t $>$ \&real\+Neighbors)
\begin{DoxyCompactList}\small\item\em Compute the recall (\% of neighbors found) given the neighbors returned by \doxyref{L\+S\+H\+Search\+::\+Search}{p.}{classmlpack_1_1neighbor_1_1LSHSearch_a6544db04dfac2ee9b81a4ca029c6f223} and a \char`\"{}ground truth\char`\"{} set of neighbors. \end{DoxyCompactList}\end{DoxyCompactItemize}
\subsection*{Private Types}
\begin{DoxyCompactItemize}
\item 
typedef std\+::pair$<$ double, size\+\_\+t $>$ {\bf Candidate}
\begin{DoxyCompactList}\small\item\em Candidate represents a possible candidate neighbor (distance, index). \end{DoxyCompactList}\item 
typedef std\+::priority\+\_\+queue$<$ {\bf Candidate}, std\+::vector$<$ {\bf Candidate} $>$, {\bf Candidate\+Cmp} $>$ {\bf Candidate\+List}
\begin{DoxyCompactList}\small\item\em Use a priority queue to represent the list of candidate neighbors. \end{DoxyCompactList}\end{DoxyCompactItemize}
\subsection*{Private Member Functions}
\begin{DoxyCompactItemize}
\item 
void {\bf Base\+Case} (const size\+\_\+t query\+Index, const arma\+::uvec \&reference\+Indices, const size\+\_\+t k, arma\+::\+Mat$<$ size\+\_\+t $>$ \&neighbors, arma\+::mat \&distances) const 
\begin{DoxyCompactList}\small\item\em This is a helper function that computes the distance of the query to the neighbor candidates and appropriately stores the best \textquotesingle{}k\textquotesingle{} candidates. \end{DoxyCompactList}\item 
void {\bf Base\+Case} (const size\+\_\+t query\+Index, const arma\+::uvec \&reference\+Indices, const size\+\_\+t k, const arma\+::mat \&query\+Set, arma\+::\+Mat$<$ size\+\_\+t $>$ \&neighbors, arma\+::mat \&distances) const 
\begin{DoxyCompactList}\small\item\em This is a helper function that computes the distance of the query to the neighbor candidates and appropriately stores the best \textquotesingle{}k\textquotesingle{} candidates. \end{DoxyCompactList}\item 
void {\bf Get\+Additional\+Probing\+Bins} (const arma\+::vec \&query\+Code, const arma\+::vec \&query\+Code\+Not\+Floored, const size\+\_\+t T, arma\+::mat \&additional\+Probing\+Bins) const 
\begin{DoxyCompactList}\small\item\em This function implements the core idea behind Multiprobe L\+SH. \end{DoxyCompactList}\item 
bool {\bf Perturbation\+Expand} (std\+::vector$<$ bool $>$ \&A) const 
\begin{DoxyCompactList}\small\item\em Inline function used by Get\+Additional\+Probing\+Bins. \end{DoxyCompactList}\item 
double {\bf Perturbation\+Score} (const std\+::vector$<$ bool $>$ \&A, const arma\+::vec \&scores) const 
\begin{DoxyCompactList}\small\item\em Returns the score of a perturbation vector generated by perturbation set A. \end{DoxyCompactList}\item 
bool {\bf Perturbation\+Shift} (std\+::vector$<$ bool $>$ \&A) const 
\begin{DoxyCompactList}\small\item\em Inline function used by Get\+Additional\+Probing\+Bins. \end{DoxyCompactList}\item 
bool {\bf Perturbation\+Valid} (const std\+::vector$<$ bool $>$ \&A) const 
\begin{DoxyCompactList}\small\item\em Return true if perturbation set A is valid. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename Vec\+Type $>$ }\\void {\bf Return\+Indices\+From\+Table} (const Vec\+Type \&query\+Point, arma\+::uvec \&reference\+Indices, size\+\_\+t num\+Tables\+To\+Search, const size\+\_\+t T) const 
\begin{DoxyCompactList}\small\item\em This function takes a query and hashes it into each of the hash tables to get keys for the query and then the key is hashed to a bucket of the second hash table and all the points (if any) in those buckets are collected as the potential neighbor candidates. \end{DoxyCompactList}\end{DoxyCompactItemize}
\subsection*{Private Attributes}
\begin{DoxyCompactItemize}
\item 
arma\+::\+Col$<$ size\+\_\+t $>$ {\bf bucket\+Content\+Size}
\begin{DoxyCompactList}\small\item\em The number of elements present in each hash bucket; should be second\+Hash\+Size. \end{DoxyCompactList}\item 
arma\+::\+Col$<$ size\+\_\+t $>$ {\bf bucket\+Row\+In\+Hash\+Table}
\begin{DoxyCompactList}\small\item\em For a particular hash value, points to the row in second\+Hash\+Table corresponding to this value. \end{DoxyCompactList}\item 
size\+\_\+t {\bf bucket\+Size}
\begin{DoxyCompactList}\small\item\em The bucket size of the second hash. \end{DoxyCompactList}\item 
size\+\_\+t {\bf distance\+Evaluations}
\begin{DoxyCompactList}\small\item\em The number of distance evaluations. \end{DoxyCompactList}\item 
double {\bf hash\+Width}
\begin{DoxyCompactList}\small\item\em The hash width. \end{DoxyCompactList}\item 
size\+\_\+t {\bf num\+Proj}
\begin{DoxyCompactList}\small\item\em The number of projections. \end{DoxyCompactList}\item 
size\+\_\+t {\bf num\+Tables}
\begin{DoxyCompactList}\small\item\em The number of hash tables. \end{DoxyCompactList}\item 
arma\+::mat {\bf offsets}
\begin{DoxyCompactList}\small\item\em The list of the offsets \textquotesingle{}b\textquotesingle{} for each of the projection for each table. \end{DoxyCompactList}\item 
bool {\bf owns\+Set}
\begin{DoxyCompactList}\small\item\em If true, we own the reference set. \end{DoxyCompactList}\item 
arma\+::cube {\bf projections}
\begin{DoxyCompactList}\small\item\em The arma\+::cube containing the projection matrix of each table. \end{DoxyCompactList}\item 
const arma\+::mat $\ast$ {\bf reference\+Set}
\begin{DoxyCompactList}\small\item\em Reference dataset. \end{DoxyCompactList}\item 
size\+\_\+t {\bf second\+Hash\+Size}
\begin{DoxyCompactList}\small\item\em The big prime representing the size of the second hash. \end{DoxyCompactList}\item 
std\+::vector$<$ arma\+::\+Col$<$ size\+\_\+t $>$ $>$ {\bf second\+Hash\+Table}
\begin{DoxyCompactList}\small\item\em The final hash table; should be ($<$ second\+Hash\+Size) vectors each with ($<$= bucket\+Size) elements. \end{DoxyCompactList}\item 
arma\+::vec {\bf second\+Hash\+Weights}
\begin{DoxyCompactList}\small\item\em The weights of the second hash. \end{DoxyCompactList}\end{DoxyCompactItemize}


\subsection{Detailed Description}
\subsubsection*{template$<$typename Sort\+Policy = Nearest\+Neighbor\+Sort$>$\\*
class mlpack\+::neighbor\+::\+L\+S\+H\+Search$<$ Sort\+Policy $>$}

The \doxyref{L\+S\+H\+Search}{p.}{classmlpack_1_1neighbor_1_1LSHSearch} class; this class builds a hash on the reference set and uses this hash to compute the distance-\/approximate nearest-\/neighbors of the given queries. 


\begin{DoxyTemplParams}{Template Parameters}
{\em Sort\+Policy} & The sort policy for distances; see \doxyref{Nearest\+Neighbor\+Sort}{p.}{classmlpack_1_1neighbor_1_1NearestNeighborSort}. \\
\hline
\end{DoxyTemplParams}


Definition at line 62 of file lsh\+\_\+search.\+hpp.



\subsection{Member Typedef Documentation}
\index{mlpack\+::neighbor\+::\+L\+S\+H\+Search@{mlpack\+::neighbor\+::\+L\+S\+H\+Search}!Candidate@{Candidate}}
\index{Candidate@{Candidate}!mlpack\+::neighbor\+::\+L\+S\+H\+Search@{mlpack\+::neighbor\+::\+L\+S\+H\+Search}}
\subsubsection[{Candidate}]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename Sort\+Policy  = Nearest\+Neighbor\+Sort$>$ typedef std\+::pair$<$double, size\+\_\+t$>$ {\bf mlpack\+::neighbor\+::\+L\+S\+H\+Search}$<$ Sort\+Policy $>$\+::{\bf Candidate}\hspace{0.3cm}{\ttfamily [private]}}\label{classmlpack_1_1neighbor_1_1LSHSearch_a9810f49c59b50c0765ef1be98d55b7c7}


Candidate represents a possible candidate neighbor (distance, index). 



Definition at line 460 of file lsh\+\_\+search.\+hpp.

\index{mlpack\+::neighbor\+::\+L\+S\+H\+Search@{mlpack\+::neighbor\+::\+L\+S\+H\+Search}!Candidate\+List@{Candidate\+List}}
\index{Candidate\+List@{Candidate\+List}!mlpack\+::neighbor\+::\+L\+S\+H\+Search@{mlpack\+::neighbor\+::\+L\+S\+H\+Search}}
\subsubsection[{Candidate\+List}]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename Sort\+Policy  = Nearest\+Neighbor\+Sort$>$ typedef std\+::priority\+\_\+queue$<${\bf Candidate}, std\+::vector$<${\bf Candidate}$>$, {\bf Candidate\+Cmp}$>$ {\bf mlpack\+::neighbor\+::\+L\+S\+H\+Search}$<$ Sort\+Policy $>$\+::{\bf Candidate\+List}\hspace{0.3cm}{\ttfamily [private]}}\label{classmlpack_1_1neighbor_1_1LSHSearch_aaa566acc84a1175490463732014723d1}


Use a priority queue to represent the list of candidate neighbors. 



Definition at line 472 of file lsh\+\_\+search.\+hpp.



\subsection{Constructor \& Destructor Documentation}
\index{mlpack\+::neighbor\+::\+L\+S\+H\+Search@{mlpack\+::neighbor\+::\+L\+S\+H\+Search}!L\+S\+H\+Search@{L\+S\+H\+Search}}
\index{L\+S\+H\+Search@{L\+S\+H\+Search}!mlpack\+::neighbor\+::\+L\+S\+H\+Search@{mlpack\+::neighbor\+::\+L\+S\+H\+Search}}
\subsubsection[{L\+S\+H\+Search(const arma\+::mat \&reference\+Set, const arma\+::cube \&projections, const double hash\+Width=0.\+0, const size\+\_\+t second\+Hash\+Size=99901, const size\+\_\+t bucket\+Size=500)}]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename Sort\+Policy  = Nearest\+Neighbor\+Sort$>$ {\bf mlpack\+::neighbor\+::\+L\+S\+H\+Search}$<$ Sort\+Policy $>$\+::{\bf L\+S\+H\+Search} (
\begin{DoxyParamCaption}
\item[{const arma\+::mat \&}]{reference\+Set, }
\item[{const arma\+::cube \&}]{projections, }
\item[{const double}]{hash\+Width = {\ttfamily 0.0}, }
\item[{const size\+\_\+t}]{second\+Hash\+Size = {\ttfamily 99901}, }
\item[{const size\+\_\+t}]{bucket\+Size = {\ttfamily 500}}
\end{DoxyParamCaption}
)}\label{classmlpack_1_1neighbor_1_1LSHSearch_aef85d7eda320d6db8eaf9b94e489587c}


This function initializes the L\+SH class. 

It builds the hash on the reference set with 2-\/stable distributions. See the individual functions performing the hashing for details on how the hashing is done.


\begin{DoxyParams}{Parameters}
{\em reference\+Set} & Set of reference points and the set of queries. \\
\hline
{\em projections} & Cube of projection tables. For a cube of size (a, b, c) we set num\+Proj = a, num\+Tables = c. b is the reference set dimensionality. \\
\hline
{\em hash\+Width} & The width of hash for every table. If 0 (the default) is provided, then the hash width is automatically obtained by computing the average pairwise distance of 25 pairs. This should be a reasonable upper bound on the nearest-\/neighbor distance in general. \\
\hline
{\em second\+Hash\+Size} & The size of the second hash table. This should be a large prime number. \\
\hline
{\em bucket\+Size} & The size of the bucket in the second hash table. This is the maximum number of points that can be hashed into single bucket. A value of 0 indicates that there is no limit (so the second hash table can be arbitrarily large---be careful!). \\
\hline
\end{DoxyParams}
\index{mlpack\+::neighbor\+::\+L\+S\+H\+Search@{mlpack\+::neighbor\+::\+L\+S\+H\+Search}!L\+S\+H\+Search@{L\+S\+H\+Search}}
\index{L\+S\+H\+Search@{L\+S\+H\+Search}!mlpack\+::neighbor\+::\+L\+S\+H\+Search@{mlpack\+::neighbor\+::\+L\+S\+H\+Search}}
\subsubsection[{L\+S\+H\+Search(const arma\+::mat \&reference\+Set, const size\+\_\+t num\+Proj, const size\+\_\+t num\+Tables, const double hash\+Width=0.\+0, const size\+\_\+t second\+Hash\+Size=99901, const size\+\_\+t bucket\+Size=500)}]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename Sort\+Policy  = Nearest\+Neighbor\+Sort$>$ {\bf mlpack\+::neighbor\+::\+L\+S\+H\+Search}$<$ Sort\+Policy $>$\+::{\bf L\+S\+H\+Search} (
\begin{DoxyParamCaption}
\item[{const arma\+::mat \&}]{reference\+Set, }
\item[{const size\+\_\+t}]{num\+Proj, }
\item[{const size\+\_\+t}]{num\+Tables, }
\item[{const double}]{hash\+Width = {\ttfamily 0.0}, }
\item[{const size\+\_\+t}]{second\+Hash\+Size = {\ttfamily 99901}, }
\item[{const size\+\_\+t}]{bucket\+Size = {\ttfamily 500}}
\end{DoxyParamCaption}
)}\label{classmlpack_1_1neighbor_1_1LSHSearch_aa73976fa89f5358aa51e0640124d1947}


This function initializes the L\+SH class. 

It builds the hash one the reference set using the provided projections. See the individual functions performing the hashing for details on how the hashing is done.


\begin{DoxyParams}{Parameters}
{\em reference\+Set} & Set of reference points and the set of queries. \\
\hline
{\em num\+Proj} & Number of projections in each hash table (anything between 10-\/50 might be a decent choice). \\
\hline
{\em num\+Tables} & Total number of hash tables (anything between 10-\/20 should suffice). \\
\hline
{\em hash\+Width} & The width of hash for every table. If 0 (the default) is provided, then the hash width is automatically obtained by computing the average pairwise distance of 25 pairs. This should be a reasonable upper bound on the nearest-\/neighbor distance in general. \\
\hline
{\em second\+Hash\+Size} & The size of the second hash table. This should be a large prime number. \\
\hline
{\em bucket\+Size} & The size of the bucket in the second hash table. This is the maximum number of points that can be hashed into single bucket. A value of 0 indicates that there is no limit (so the second hash table can be arbitrarily large---be careful!). \\
\hline
\end{DoxyParams}
\index{mlpack\+::neighbor\+::\+L\+S\+H\+Search@{mlpack\+::neighbor\+::\+L\+S\+H\+Search}!L\+S\+H\+Search@{L\+S\+H\+Search}}
\index{L\+S\+H\+Search@{L\+S\+H\+Search}!mlpack\+::neighbor\+::\+L\+S\+H\+Search@{mlpack\+::neighbor\+::\+L\+S\+H\+Search}}
\subsubsection[{L\+S\+H\+Search()}]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename Sort\+Policy  = Nearest\+Neighbor\+Sort$>$ {\bf mlpack\+::neighbor\+::\+L\+S\+H\+Search}$<$ Sort\+Policy $>$\+::{\bf L\+S\+H\+Search} (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)}\label{classmlpack_1_1neighbor_1_1LSHSearch_a499b01e2439a996689ab924361358d18}


Create an untrained L\+SH model. 

Be sure to call \doxyref{Train()}{p.}{classmlpack_1_1neighbor_1_1LSHSearch_a059328483c99eef38fd5855214a25f4a} before calling \doxyref{Search()}{p.}{classmlpack_1_1neighbor_1_1LSHSearch_a6544db04dfac2ee9b81a4ca029c6f223}; otherwise, an exception will be thrown when \doxyref{Search()}{p.}{classmlpack_1_1neighbor_1_1LSHSearch_a6544db04dfac2ee9b81a4ca029c6f223} is called. \index{mlpack\+::neighbor\+::\+L\+S\+H\+Search@{mlpack\+::neighbor\+::\+L\+S\+H\+Search}!L\+S\+H\+Search@{L\+S\+H\+Search}}
\index{L\+S\+H\+Search@{L\+S\+H\+Search}!mlpack\+::neighbor\+::\+L\+S\+H\+Search@{mlpack\+::neighbor\+::\+L\+S\+H\+Search}}
\subsubsection[{L\+S\+H\+Search(const L\+S\+H\+Search \&other)}]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename Sort\+Policy  = Nearest\+Neighbor\+Sort$>$ {\bf mlpack\+::neighbor\+::\+L\+S\+H\+Search}$<$ Sort\+Policy $>$\+::{\bf L\+S\+H\+Search} (
\begin{DoxyParamCaption}
\item[{const {\bf L\+S\+H\+Search}$<$ Sort\+Policy $>$ \&}]{other}
\end{DoxyParamCaption}
)}\label{classmlpack_1_1neighbor_1_1LSHSearch_ad11a269e110ec7276c6c349eee2b5732}


Copy the given L\+SH model. 


\begin{DoxyParams}{Parameters}
{\em other} & Other L\+SH model to copy. \\
\hline
\end{DoxyParams}
\index{mlpack\+::neighbor\+::\+L\+S\+H\+Search@{mlpack\+::neighbor\+::\+L\+S\+H\+Search}!L\+S\+H\+Search@{L\+S\+H\+Search}}
\index{L\+S\+H\+Search@{L\+S\+H\+Search}!mlpack\+::neighbor\+::\+L\+S\+H\+Search@{mlpack\+::neighbor\+::\+L\+S\+H\+Search}}
\subsubsection[{L\+S\+H\+Search(\+L\+S\+H\+Search \&\&other)}]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename Sort\+Policy  = Nearest\+Neighbor\+Sort$>$ {\bf mlpack\+::neighbor\+::\+L\+S\+H\+Search}$<$ Sort\+Policy $>$\+::{\bf L\+S\+H\+Search} (
\begin{DoxyParamCaption}
\item[{{\bf L\+S\+H\+Search}$<$ Sort\+Policy $>$ \&\&}]{other}
\end{DoxyParamCaption}
)}\label{classmlpack_1_1neighbor_1_1LSHSearch_a4cef2e985f92c91f9ad6d2bf702f0186}


Take ownership of the given L\+SH model. 


\begin{DoxyParams}{Parameters}
{\em other} & Other L\+SH model to take ownership of. \\
\hline
\end{DoxyParams}
\index{mlpack\+::neighbor\+::\+L\+S\+H\+Search@{mlpack\+::neighbor\+::\+L\+S\+H\+Search}!````~L\+S\+H\+Search@{$\sim$\+L\+S\+H\+Search}}
\index{````~L\+S\+H\+Search@{$\sim$\+L\+S\+H\+Search}!mlpack\+::neighbor\+::\+L\+S\+H\+Search@{mlpack\+::neighbor\+::\+L\+S\+H\+Search}}
\subsubsection[{$\sim$\+L\+S\+H\+Search()}]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename Sort\+Policy  = Nearest\+Neighbor\+Sort$>$ {\bf mlpack\+::neighbor\+::\+L\+S\+H\+Search}$<$ Sort\+Policy $>$\+::$\sim${\bf L\+S\+H\+Search} (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)}\label{classmlpack_1_1neighbor_1_1LSHSearch_af3204354ed10d2e154e159ab05b0cce9}


Clean memory. 



\subsection{Member Function Documentation}
\index{mlpack\+::neighbor\+::\+L\+S\+H\+Search@{mlpack\+::neighbor\+::\+L\+S\+H\+Search}!Base\+Case@{Base\+Case}}
\index{Base\+Case@{Base\+Case}!mlpack\+::neighbor\+::\+L\+S\+H\+Search@{mlpack\+::neighbor\+::\+L\+S\+H\+Search}}
\subsubsection[{Base\+Case(const size\+\_\+t query\+Index, const arma\+::uvec \&reference\+Indices, const size\+\_\+t k, arma\+::\+Mat$<$ size\+\_\+t $>$ \&neighbors, arma\+::mat \&distances) const }]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename Sort\+Policy  = Nearest\+Neighbor\+Sort$>$ void {\bf mlpack\+::neighbor\+::\+L\+S\+H\+Search}$<$ Sort\+Policy $>$\+::Base\+Case (
\begin{DoxyParamCaption}
\item[{const size\+\_\+t}]{query\+Index, }
\item[{const arma\+::uvec \&}]{reference\+Indices, }
\item[{const size\+\_\+t}]{k, }
\item[{arma\+::\+Mat$<$ size\+\_\+t $>$ \&}]{neighbors, }
\item[{arma\+::mat \&}]{distances}
\end{DoxyParamCaption}
) const\hspace{0.3cm}{\ttfamily [private]}}\label{classmlpack_1_1neighbor_1_1LSHSearch_a45fa853f65a5f41ceac8f7e4c242f61a}


This is a helper function that computes the distance of the query to the neighbor candidates and appropriately stores the best \textquotesingle{}k\textquotesingle{} candidates. 

This is specific to the monochromatic search case, where the query set is the reference set.


\begin{DoxyParams}{Parameters}
{\em query\+Index} & The index of the query in question \\
\hline
{\em reference\+Indices} & The vector of indices of candidate neighbors for the query. \\
\hline
{\em k} & Number of neighbors to search for. \\
\hline
{\em neighbors} & Matrix holding output neighbors. \\
\hline
{\em distances} & Matrix holding output distances. \\
\hline
\end{DoxyParams}


Referenced by mlpack\+::neighbor\+::\+L\+S\+H\+Search$<$ Sort\+Policy $>$\+::\+Projections().

\index{mlpack\+::neighbor\+::\+L\+S\+H\+Search@{mlpack\+::neighbor\+::\+L\+S\+H\+Search}!Base\+Case@{Base\+Case}}
\index{Base\+Case@{Base\+Case}!mlpack\+::neighbor\+::\+L\+S\+H\+Search@{mlpack\+::neighbor\+::\+L\+S\+H\+Search}}
\subsubsection[{Base\+Case(const size\+\_\+t query\+Index, const arma\+::uvec \&reference\+Indices, const size\+\_\+t k, const arma\+::mat \&query\+Set, arma\+::\+Mat$<$ size\+\_\+t $>$ \&neighbors, arma\+::mat \&distances) const }]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename Sort\+Policy  = Nearest\+Neighbor\+Sort$>$ void {\bf mlpack\+::neighbor\+::\+L\+S\+H\+Search}$<$ Sort\+Policy $>$\+::Base\+Case (
\begin{DoxyParamCaption}
\item[{const size\+\_\+t}]{query\+Index, }
\item[{const arma\+::uvec \&}]{reference\+Indices, }
\item[{const size\+\_\+t}]{k, }
\item[{const arma\+::mat \&}]{query\+Set, }
\item[{arma\+::\+Mat$<$ size\+\_\+t $>$ \&}]{neighbors, }
\item[{arma\+::mat \&}]{distances}
\end{DoxyParamCaption}
) const\hspace{0.3cm}{\ttfamily [private]}}\label{classmlpack_1_1neighbor_1_1LSHSearch_a74f887b39607db3bdf5c7989b3c80b76}


This is a helper function that computes the distance of the query to the neighbor candidates and appropriately stores the best \textquotesingle{}k\textquotesingle{} candidates. 

This is specific to bichromatic search, where the query set is not the same as the reference set.


\begin{DoxyParams}{Parameters}
{\em query\+Index} & The index of the query in question \\
\hline
{\em reference\+Indices} & The vector of indices of candidate neighbors for the query. \\
\hline
{\em k} & Number of neighbors to search for. \\
\hline
{\em query\+Set} & Set of query points. \\
\hline
{\em neighbors} & Matrix holding output neighbors. \\
\hline
{\em distances} & Matrix holding output distances. \\
\hline
\end{DoxyParams}
\index{mlpack\+::neighbor\+::\+L\+S\+H\+Search@{mlpack\+::neighbor\+::\+L\+S\+H\+Search}!Bucket\+Size@{Bucket\+Size}}
\index{Bucket\+Size@{Bucket\+Size}!mlpack\+::neighbor\+::\+L\+S\+H\+Search@{mlpack\+::neighbor\+::\+L\+S\+H\+Search}}
\subsubsection[{Bucket\+Size() const }]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename Sort\+Policy  = Nearest\+Neighbor\+Sort$>$ size\+\_\+t {\bf mlpack\+::neighbor\+::\+L\+S\+H\+Search}$<$ Sort\+Policy $>$\+::Bucket\+Size (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
) const\hspace{0.3cm}{\ttfamily [inline]}}\label{classmlpack_1_1neighbor_1_1LSHSearch_a09fcb9c8823a1232f0187c76109dfea6}


Get the bucket size of the second hash. 



Definition at line 280 of file lsh\+\_\+search.\+hpp.



References mlpack\+::neighbor\+::\+L\+S\+H\+Search$<$ Sort\+Policy $>$\+::bucket\+Size.

\index{mlpack\+::neighbor\+::\+L\+S\+H\+Search@{mlpack\+::neighbor\+::\+L\+S\+H\+Search}!Compute\+Recall@{Compute\+Recall}}
\index{Compute\+Recall@{Compute\+Recall}!mlpack\+::neighbor\+::\+L\+S\+H\+Search@{mlpack\+::neighbor\+::\+L\+S\+H\+Search}}
\subsubsection[{Compute\+Recall(const arma\+::\+Mat$<$ size\+\_\+t $>$ \&found\+Neighbors, const arma\+::\+Mat$<$ size\+\_\+t $>$ \&real\+Neighbors)}]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename Sort\+Policy  = Nearest\+Neighbor\+Sort$>$ static double {\bf mlpack\+::neighbor\+::\+L\+S\+H\+Search}$<$ Sort\+Policy $>$\+::Compute\+Recall (
\begin{DoxyParamCaption}
\item[{const arma\+::\+Mat$<$ size\+\_\+t $>$ \&}]{found\+Neighbors, }
\item[{const arma\+::\+Mat$<$ size\+\_\+t $>$ \&}]{real\+Neighbors}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [static]}}\label{classmlpack_1_1neighbor_1_1LSHSearch_a297b1782802c92780f037cf726bdc8d2}


Compute the recall (\% of neighbors found) given the neighbors returned by \doxyref{L\+S\+H\+Search\+::\+Search}{p.}{classmlpack_1_1neighbor_1_1LSHSearch_a6544db04dfac2ee9b81a4ca029c6f223} and a \char`\"{}ground truth\char`\"{} set of neighbors. 

The recall returned will be in the range [0, 1].


\begin{DoxyParams}{Parameters}
{\em found\+Neighbors} & Set of neighbors to compute recall of. \\
\hline
{\em real\+Neighbors} & Set of \char`\"{}ground truth\char`\"{} neighbors to compute recall against. \\
\hline
\end{DoxyParams}
\index{mlpack\+::neighbor\+::\+L\+S\+H\+Search@{mlpack\+::neighbor\+::\+L\+S\+H\+Search}!Distance\+Evaluations@{Distance\+Evaluations}}
\index{Distance\+Evaluations@{Distance\+Evaluations}!mlpack\+::neighbor\+::\+L\+S\+H\+Search@{mlpack\+::neighbor\+::\+L\+S\+H\+Search}}
\subsubsection[{Distance\+Evaluations() const }]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename Sort\+Policy  = Nearest\+Neighbor\+Sort$>$ size\+\_\+t {\bf mlpack\+::neighbor\+::\+L\+S\+H\+Search}$<$ Sort\+Policy $>$\+::Distance\+Evaluations (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
) const\hspace{0.3cm}{\ttfamily [inline]}}\label{classmlpack_1_1neighbor_1_1LSHSearch_a0667d5e5b01dfd9b2694b1291603e9f2}


Return the number of distance evaluations performed. 



Definition at line 263 of file lsh\+\_\+search.\+hpp.



References mlpack\+::neighbor\+::\+L\+S\+H\+Search$<$ Sort\+Policy $>$\+::distance\+Evaluations.

\index{mlpack\+::neighbor\+::\+L\+S\+H\+Search@{mlpack\+::neighbor\+::\+L\+S\+H\+Search}!Distance\+Evaluations@{Distance\+Evaluations}}
\index{Distance\+Evaluations@{Distance\+Evaluations}!mlpack\+::neighbor\+::\+L\+S\+H\+Search@{mlpack\+::neighbor\+::\+L\+S\+H\+Search}}
\subsubsection[{Distance\+Evaluations()}]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename Sort\+Policy  = Nearest\+Neighbor\+Sort$>$ size\+\_\+t\& {\bf mlpack\+::neighbor\+::\+L\+S\+H\+Search}$<$ Sort\+Policy $>$\+::Distance\+Evaluations (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}}\label{classmlpack_1_1neighbor_1_1LSHSearch_a78b0fbb840d90d166297f747ea70953f}


Modify the number of distance evaluations performed. 



Definition at line 265 of file lsh\+\_\+search.\+hpp.



References mlpack\+::neighbor\+::\+L\+S\+H\+Search$<$ Sort\+Policy $>$\+::distance\+Evaluations.

\index{mlpack\+::neighbor\+::\+L\+S\+H\+Search@{mlpack\+::neighbor\+::\+L\+S\+H\+Search}!Get\+Additional\+Probing\+Bins@{Get\+Additional\+Probing\+Bins}}
\index{Get\+Additional\+Probing\+Bins@{Get\+Additional\+Probing\+Bins}!mlpack\+::neighbor\+::\+L\+S\+H\+Search@{mlpack\+::neighbor\+::\+L\+S\+H\+Search}}
\subsubsection[{Get\+Additional\+Probing\+Bins(const arma\+::vec \&query\+Code, const arma\+::vec \&query\+Code\+Not\+Floored, const size\+\_\+t T, arma\+::mat \&additional\+Probing\+Bins) const }]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename Sort\+Policy  = Nearest\+Neighbor\+Sort$>$ void {\bf mlpack\+::neighbor\+::\+L\+S\+H\+Search}$<$ Sort\+Policy $>$\+::Get\+Additional\+Probing\+Bins (
\begin{DoxyParamCaption}
\item[{const arma\+::vec \&}]{query\+Code, }
\item[{const arma\+::vec \&}]{query\+Code\+Not\+Floored, }
\item[{const size\+\_\+t}]{T, }
\item[{arma\+::mat \&}]{additional\+Probing\+Bins}
\end{DoxyParamCaption}
) const\hspace{0.3cm}{\ttfamily [private]}}\label{classmlpack_1_1neighbor_1_1LSHSearch_a570a4704f9ad01a79231e74dfa6364ba}


This function implements the core idea behind Multiprobe L\+SH. 

It is called by Return\+Indices\+From\+Tables when T $>$ 0. Given a query\textquotesingle{}s code and its projection location, Get\+Additional\+Probing\+Bins will calculate the T most likely alternative bin codes (other than query\+Code) where a query\textquotesingle{}s neighbors might be found in.


\begin{DoxyParams}{Parameters}
{\em query\+Code} & vector containing the num\+Proj-\/dimensional query code. \\
\hline
{\em query\+Code\+Not\+Floored} & vector containing the projection location of the query. \\
\hline
{\em T} & number of additional probing bins. \\
\hline
{\em additional\+Probing\+Bins} & matrix. Each column will hold one additional bin. \\
\hline
\end{DoxyParams}


Referenced by mlpack\+::neighbor\+::\+L\+S\+H\+Search$<$ Sort\+Policy $>$\+::\+Projections().

\index{mlpack\+::neighbor\+::\+L\+S\+H\+Search@{mlpack\+::neighbor\+::\+L\+S\+H\+Search}!Num\+Projections@{Num\+Projections}}
\index{Num\+Projections@{Num\+Projections}!mlpack\+::neighbor\+::\+L\+S\+H\+Search@{mlpack\+::neighbor\+::\+L\+S\+H\+Search}}
\subsubsection[{Num\+Projections() const }]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename Sort\+Policy  = Nearest\+Neighbor\+Sort$>$ size\+\_\+t {\bf mlpack\+::neighbor\+::\+L\+S\+H\+Search}$<$ Sort\+Policy $>$\+::Num\+Projections (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
) const\hspace{0.3cm}{\ttfamily [inline]}}\label{classmlpack_1_1neighbor_1_1LSHSearch_a812b124cef808b3dce508cad0148c456}


Get the number of projections. 



Definition at line 271 of file lsh\+\_\+search.\+hpp.

\index{mlpack\+::neighbor\+::\+L\+S\+H\+Search@{mlpack\+::neighbor\+::\+L\+S\+H\+Search}!Offsets@{Offsets}}
\index{Offsets@{Offsets}!mlpack\+::neighbor\+::\+L\+S\+H\+Search@{mlpack\+::neighbor\+::\+L\+S\+H\+Search}}
\subsubsection[{Offsets() const }]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename Sort\+Policy  = Nearest\+Neighbor\+Sort$>$ const arma\+::mat\& {\bf mlpack\+::neighbor\+::\+L\+S\+H\+Search}$<$ Sort\+Policy $>$\+::Offsets (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
) const\hspace{0.3cm}{\ttfamily [inline]}}\label{classmlpack_1_1neighbor_1_1LSHSearch_a451e52da1f5b157923dfa8bbf2cf4114}


Get the offsets \textquotesingle{}b\textquotesingle{} for each of the projections. (One \textquotesingle{}b\textquotesingle{} per column.) 



Definition at line 274 of file lsh\+\_\+search.\+hpp.



References mlpack\+::neighbor\+::\+L\+S\+H\+Search$<$ Sort\+Policy $>$\+::offsets.

\index{mlpack\+::neighbor\+::\+L\+S\+H\+Search@{mlpack\+::neighbor\+::\+L\+S\+H\+Search}!operator=@{operator=}}
\index{operator=@{operator=}!mlpack\+::neighbor\+::\+L\+S\+H\+Search@{mlpack\+::neighbor\+::\+L\+S\+H\+Search}}
\subsubsection[{operator=(const L\+S\+H\+Search \&other)}]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename Sort\+Policy  = Nearest\+Neighbor\+Sort$>$ {\bf L\+S\+H\+Search}\& {\bf mlpack\+::neighbor\+::\+L\+S\+H\+Search}$<$ Sort\+Policy $>$\+::operator= (
\begin{DoxyParamCaption}
\item[{const {\bf L\+S\+H\+Search}$<$ Sort\+Policy $>$ \&}]{other}
\end{DoxyParamCaption}
)}\label{classmlpack_1_1neighbor_1_1LSHSearch_a7909241131e350629cae10f9c2812246}


Copy the given L\+SH model. 


\begin{DoxyParams}{Parameters}
{\em other} & Other L\+SH model to copy. \\
\hline
\end{DoxyParams}
\index{mlpack\+::neighbor\+::\+L\+S\+H\+Search@{mlpack\+::neighbor\+::\+L\+S\+H\+Search}!operator=@{operator=}}
\index{operator=@{operator=}!mlpack\+::neighbor\+::\+L\+S\+H\+Search@{mlpack\+::neighbor\+::\+L\+S\+H\+Search}}
\subsubsection[{operator=(\+L\+S\+H\+Search \&\&other)}]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename Sort\+Policy  = Nearest\+Neighbor\+Sort$>$ {\bf L\+S\+H\+Search}\& {\bf mlpack\+::neighbor\+::\+L\+S\+H\+Search}$<$ Sort\+Policy $>$\+::operator= (
\begin{DoxyParamCaption}
\item[{{\bf L\+S\+H\+Search}$<$ Sort\+Policy $>$ \&\&}]{other}
\end{DoxyParamCaption}
)}\label{classmlpack_1_1neighbor_1_1LSHSearch_a12f7af5d52b4b6750569ce898332e6e8}


Take ownership of the given L\+SH model. 


\begin{DoxyParams}{Parameters}
{\em other} & Other L\+SH model to take ownership of. \\
\hline
\end{DoxyParams}
\index{mlpack\+::neighbor\+::\+L\+S\+H\+Search@{mlpack\+::neighbor\+::\+L\+S\+H\+Search}!Perturbation\+Expand@{Perturbation\+Expand}}
\index{Perturbation\+Expand@{Perturbation\+Expand}!mlpack\+::neighbor\+::\+L\+S\+H\+Search@{mlpack\+::neighbor\+::\+L\+S\+H\+Search}}
\subsubsection[{Perturbation\+Expand(std\+::vector$<$ bool $>$ \&\+A) const }]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename Sort\+Policy  = Nearest\+Neighbor\+Sort$>$ bool {\bf mlpack\+::neighbor\+::\+L\+S\+H\+Search}$<$ Sort\+Policy $>$\+::Perturbation\+Expand (
\begin{DoxyParamCaption}
\item[{std\+::vector$<$ bool $>$ \&}]{A}
\end{DoxyParamCaption}
) const\hspace{0.3cm}{\ttfamily [private]}}\label{classmlpack_1_1neighbor_1_1LSHSearch_aa0534cdf7ea0bbdb607aa7bbdc0a1d19}


Inline function used by Get\+Additional\+Probing\+Bins. 

The vector expansion operation adds the element [1 + (largest\+\_\+element)] to a vector A, where largest\+\_\+element is the largest element of A. Returns true if resulting vector is valid, otherwise false.


\begin{DoxyParams}{Parameters}
{\em A} & perturbation set to expand. \\
\hline
\end{DoxyParams}


Referenced by mlpack\+::neighbor\+::\+L\+S\+H\+Search$<$ Sort\+Policy $>$\+::\+Projections().

\index{mlpack\+::neighbor\+::\+L\+S\+H\+Search@{mlpack\+::neighbor\+::\+L\+S\+H\+Search}!Perturbation\+Score@{Perturbation\+Score}}
\index{Perturbation\+Score@{Perturbation\+Score}!mlpack\+::neighbor\+::\+L\+S\+H\+Search@{mlpack\+::neighbor\+::\+L\+S\+H\+Search}}
\subsubsection[{Perturbation\+Score(const std\+::vector$<$ bool $>$ \&\+A, const arma\+::vec \&scores) const }]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename Sort\+Policy  = Nearest\+Neighbor\+Sort$>$ double {\bf mlpack\+::neighbor\+::\+L\+S\+H\+Search}$<$ Sort\+Policy $>$\+::Perturbation\+Score (
\begin{DoxyParamCaption}
\item[{const std\+::vector$<$ bool $>$ \&}]{A, }
\item[{const arma\+::vec \&}]{scores}
\end{DoxyParamCaption}
) const\hspace{0.3cm}{\ttfamily [private]}}\label{classmlpack_1_1neighbor_1_1LSHSearch_a300884ec85737aa4b202a34cf1c6738f}


Returns the score of a perturbation vector generated by perturbation set A. 

The score of a pertubation set (vector) is the sum of scores of the participating actions. 
\begin{DoxyParams}{Parameters}
{\em A} & perturbation set to compute the score of. \\
\hline
{\em scores} & vector containing score of each perturbation. \\
\hline
\end{DoxyParams}


Referenced by mlpack\+::neighbor\+::\+L\+S\+H\+Search$<$ Sort\+Policy $>$\+::\+Projections().

\index{mlpack\+::neighbor\+::\+L\+S\+H\+Search@{mlpack\+::neighbor\+::\+L\+S\+H\+Search}!Perturbation\+Shift@{Perturbation\+Shift}}
\index{Perturbation\+Shift@{Perturbation\+Shift}!mlpack\+::neighbor\+::\+L\+S\+H\+Search@{mlpack\+::neighbor\+::\+L\+S\+H\+Search}}
\subsubsection[{Perturbation\+Shift(std\+::vector$<$ bool $>$ \&\+A) const }]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename Sort\+Policy  = Nearest\+Neighbor\+Sort$>$ bool {\bf mlpack\+::neighbor\+::\+L\+S\+H\+Search}$<$ Sort\+Policy $>$\+::Perturbation\+Shift (
\begin{DoxyParamCaption}
\item[{std\+::vector$<$ bool $>$ \&}]{A}
\end{DoxyParamCaption}
) const\hspace{0.3cm}{\ttfamily [private]}}\label{classmlpack_1_1neighbor_1_1LSHSearch_a934d84eff8e9ae6135e2d61282cc46ee}


Inline function used by Get\+Additional\+Probing\+Bins. 

The vector shift operation replaces the largest element of a vector A with (largest element)
\begin{DoxyItemize}
\item 1. Returns true if resulting vector is valid, otherwise false.
\end{DoxyItemize}


\begin{DoxyParams}{Parameters}
{\em A} & perturbation set to shift. \\
\hline
\end{DoxyParams}


Referenced by mlpack\+::neighbor\+::\+L\+S\+H\+Search$<$ Sort\+Policy $>$\+::\+Projections().

\index{mlpack\+::neighbor\+::\+L\+S\+H\+Search@{mlpack\+::neighbor\+::\+L\+S\+H\+Search}!Perturbation\+Valid@{Perturbation\+Valid}}
\index{Perturbation\+Valid@{Perturbation\+Valid}!mlpack\+::neighbor\+::\+L\+S\+H\+Search@{mlpack\+::neighbor\+::\+L\+S\+H\+Search}}
\subsubsection[{Perturbation\+Valid(const std\+::vector$<$ bool $>$ \&\+A) const }]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename Sort\+Policy  = Nearest\+Neighbor\+Sort$>$ bool {\bf mlpack\+::neighbor\+::\+L\+S\+H\+Search}$<$ Sort\+Policy $>$\+::Perturbation\+Valid (
\begin{DoxyParamCaption}
\item[{const std\+::vector$<$ bool $>$ \&}]{A}
\end{DoxyParamCaption}
) const\hspace{0.3cm}{\ttfamily [private]}}\label{classmlpack_1_1neighbor_1_1LSHSearch_ae546118148bf557acc91d927de5961b9}


Return true if perturbation set A is valid. 

A perturbation set is invalid if it contains two (or more) actions for the same dimension or dimensions that are larger than the query\+Code\textquotesingle{}s dimensions.


\begin{DoxyParams}{Parameters}
{\em A} & perturbation set to validate. \\
\hline
\end{DoxyParams}


Referenced by mlpack\+::neighbor\+::\+L\+S\+H\+Search$<$ Sort\+Policy $>$\+::\+Projections().

\index{mlpack\+::neighbor\+::\+L\+S\+H\+Search@{mlpack\+::neighbor\+::\+L\+S\+H\+Search}!Projections@{Projections}}
\index{Projections@{Projections}!mlpack\+::neighbor\+::\+L\+S\+H\+Search@{mlpack\+::neighbor\+::\+L\+S\+H\+Search}}
\subsubsection[{Projections()}]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename Sort\+Policy  = Nearest\+Neighbor\+Sort$>$ const arma\+::cube\& {\bf mlpack\+::neighbor\+::\+L\+S\+H\+Search}$<$ Sort\+Policy $>$\+::Projections (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}}\label{classmlpack_1_1neighbor_1_1LSHSearch_a2f030442f07899615b2ca39b55bddc5e}


Get the projection tables. 



Definition at line 287 of file lsh\+\_\+search.\+hpp.



References mlpack\+::neighbor\+::\+L\+S\+H\+Search$<$ Sort\+Policy $>$\+::projections.

\index{mlpack\+::neighbor\+::\+L\+S\+H\+Search@{mlpack\+::neighbor\+::\+L\+S\+H\+Search}!Projections@{Projections}}
\index{Projections@{Projections}!mlpack\+::neighbor\+::\+L\+S\+H\+Search@{mlpack\+::neighbor\+::\+L\+S\+H\+Search}}
\subsubsection[{Projections(const arma\+::cube \&proj\+Tables)}]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename Sort\+Policy  = Nearest\+Neighbor\+Sort$>$ void {\bf mlpack\+::neighbor\+::\+L\+S\+H\+Search}$<$ Sort\+Policy $>$\+::Projections (
\begin{DoxyParamCaption}
\item[{const arma\+::cube \&}]{proj\+Tables}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}}\label{classmlpack_1_1neighbor_1_1LSHSearch_abbfc3d50967c7907dc755ce0925a4522}


Change the projection tables (this retrains the L\+SH model). 



Definition at line 290 of file lsh\+\_\+search.\+hpp.



References mlpack\+::neighbor\+::\+L\+S\+H\+Search$<$ Sort\+Policy $>$\+::\+Base\+Case(), mlpack\+::neighbor\+::\+L\+S\+H\+Search$<$ Sort\+Policy $>$\+::bucket\+Size, mlpack\+::neighbor\+::\+L\+S\+H\+Search$<$ Sort\+Policy $>$\+::\+Get\+Additional\+Probing\+Bins(), mlpack\+::neighbor\+::\+L\+S\+H\+Search$<$ Sort\+Policy $>$\+::hash\+Width, mlpack\+::neighbor\+::\+L\+S\+H\+Search$<$ Sort\+Policy $>$\+::\+Perturbation\+Expand(), mlpack\+::neighbor\+::\+L\+S\+H\+Search$<$ Sort\+Policy $>$\+::\+Perturbation\+Score(), mlpack\+::neighbor\+::\+L\+S\+H\+Search$<$ Sort\+Policy $>$\+::\+Perturbation\+Shift(), mlpack\+::neighbor\+::\+L\+S\+H\+Search$<$ Sort\+Policy $>$\+::\+Perturbation\+Valid(), mlpack\+::neighbor\+::\+L\+S\+H\+Search$<$ Sort\+Policy $>$\+::\+Return\+Indices\+From\+Table(), mlpack\+::neighbor\+::\+L\+S\+H\+Search$<$ Sort\+Policy $>$\+::second\+Hash\+Size, and mlpack\+::neighbor\+::\+L\+S\+H\+Search$<$ Sort\+Policy $>$\+::\+Train().

\index{mlpack\+::neighbor\+::\+L\+S\+H\+Search@{mlpack\+::neighbor\+::\+L\+S\+H\+Search}!Reference\+Set@{Reference\+Set}}
\index{Reference\+Set@{Reference\+Set}!mlpack\+::neighbor\+::\+L\+S\+H\+Search@{mlpack\+::neighbor\+::\+L\+S\+H\+Search}}
\subsubsection[{Reference\+Set() const }]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename Sort\+Policy  = Nearest\+Neighbor\+Sort$>$ const arma\+::mat\& {\bf mlpack\+::neighbor\+::\+L\+S\+H\+Search}$<$ Sort\+Policy $>$\+::Reference\+Set (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
) const\hspace{0.3cm}{\ttfamily [inline]}}\label{classmlpack_1_1neighbor_1_1LSHSearch_ab3080a9c8940e0740b3bae3a287a6087}


Return the reference dataset. 



Definition at line 268 of file lsh\+\_\+search.\+hpp.



References mlpack\+::neighbor\+::\+L\+S\+H\+Search$<$ Sort\+Policy $>$\+::reference\+Set.

\index{mlpack\+::neighbor\+::\+L\+S\+H\+Search@{mlpack\+::neighbor\+::\+L\+S\+H\+Search}!Return\+Indices\+From\+Table@{Return\+Indices\+From\+Table}}
\index{Return\+Indices\+From\+Table@{Return\+Indices\+From\+Table}!mlpack\+::neighbor\+::\+L\+S\+H\+Search@{mlpack\+::neighbor\+::\+L\+S\+H\+Search}}
\subsubsection[{Return\+Indices\+From\+Table(const Vec\+Type \&query\+Point, arma\+::uvec \&reference\+Indices, size\+\_\+t num\+Tables\+To\+Search, const size\+\_\+t T) const }]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename Sort\+Policy  = Nearest\+Neighbor\+Sort$>$ template$<$typename Vec\+Type $>$ void {\bf mlpack\+::neighbor\+::\+L\+S\+H\+Search}$<$ Sort\+Policy $>$\+::Return\+Indices\+From\+Table (
\begin{DoxyParamCaption}
\item[{const Vec\+Type \&}]{query\+Point, }
\item[{arma\+::uvec \&}]{reference\+Indices, }
\item[{size\+\_\+t}]{num\+Tables\+To\+Search, }
\item[{const size\+\_\+t}]{T}
\end{DoxyParamCaption}
) const\hspace{0.3cm}{\ttfamily [private]}}\label{classmlpack_1_1neighbor_1_1LSHSearch_a263e7065ecf300787fc3403182217150}


This function takes a query and hashes it into each of the hash tables to get keys for the query and then the key is hashed to a bucket of the second hash table and all the points (if any) in those buckets are collected as the potential neighbor candidates. 


\begin{DoxyParams}{Parameters}
{\em query\+Point} & The query point currently being processed. \\
\hline
{\em reference\+Indices} & The list of neighbor candidates obtained from hashing the query into all the hash tables and eventually into multiple buckets of the second hash table. \\
\hline
{\em num\+Tables\+To\+Search} & The number of tables to perform the search in. If 0, all tables are searched. \\
\hline
{\em T} & The number of additional probing bins for multiprobe L\+SH. If 0, single-\/probe is used. \\
\hline
\end{DoxyParams}


Referenced by mlpack\+::neighbor\+::\+L\+S\+H\+Search$<$ Sort\+Policy $>$\+::\+Projections().

\index{mlpack\+::neighbor\+::\+L\+S\+H\+Search@{mlpack\+::neighbor\+::\+L\+S\+H\+Search}!Search@{Search}}
\index{Search@{Search}!mlpack\+::neighbor\+::\+L\+S\+H\+Search@{mlpack\+::neighbor\+::\+L\+S\+H\+Search}}
\subsubsection[{Search(const arma\+::mat \&query\+Set, const size\+\_\+t k, arma\+::\+Mat$<$ size\+\_\+t $>$ \&resulting\+Neighbors, arma\+::mat \&distances, const size\+\_\+t num\+Tables\+To\+Search=0, const size\+\_\+t T=0)}]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename Sort\+Policy  = Nearest\+Neighbor\+Sort$>$ void {\bf mlpack\+::neighbor\+::\+L\+S\+H\+Search}$<$ Sort\+Policy $>$\+::Search (
\begin{DoxyParamCaption}
\item[{const arma\+::mat \&}]{query\+Set, }
\item[{const size\+\_\+t}]{k, }
\item[{arma\+::\+Mat$<$ size\+\_\+t $>$ \&}]{resulting\+Neighbors, }
\item[{arma\+::mat \&}]{distances, }
\item[{const size\+\_\+t}]{num\+Tables\+To\+Search = {\ttfamily 0}, }
\item[{const size\+\_\+t}]{T = {\ttfamily 0}}
\end{DoxyParamCaption}
)}\label{classmlpack_1_1neighbor_1_1LSHSearch_a6544db04dfac2ee9b81a4ca029c6f223}


Compute the nearest neighbors of the points in the given query set and store the output in the given matrices. 

The matrices will be set to the size of n columns by k rows, where n is the number of points in the query dataset and k is the number of neighbors being searched for.


\begin{DoxyParams}{Parameters}
{\em query\+Set} & Set of query points. \\
\hline
{\em k} & Number of neighbors to search for. \\
\hline
{\em resulting\+Neighbors} & Matrix storing lists of neighbors for each query point. \\
\hline
{\em distances} & Matrix storing distances of neighbors for each query point. \\
\hline
{\em num\+Tables\+To\+Search} & This parameter allows the user to have control over the number of hash tables to be searched. This allows the user to pick the number of tables it can afford for the time available without having to build hashing for every table size. By default, this is set to zero in which case all tables are considered. \\
\hline
{\em T} & The number of additional probing bins to examine with multiprobe L\+SH. If T = 0, classic single-\/probe L\+SH is run (default). \\
\hline
\end{DoxyParams}
\index{mlpack\+::neighbor\+::\+L\+S\+H\+Search@{mlpack\+::neighbor\+::\+L\+S\+H\+Search}!Search@{Search}}
\index{Search@{Search}!mlpack\+::neighbor\+::\+L\+S\+H\+Search@{mlpack\+::neighbor\+::\+L\+S\+H\+Search}}
\subsubsection[{Search(const size\+\_\+t k, arma\+::\+Mat$<$ size\+\_\+t $>$ \&resulting\+Neighbors, arma\+::mat \&distances, const size\+\_\+t num\+Tables\+To\+Search=0, size\+\_\+t T=0)}]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename Sort\+Policy  = Nearest\+Neighbor\+Sort$>$ void {\bf mlpack\+::neighbor\+::\+L\+S\+H\+Search}$<$ Sort\+Policy $>$\+::Search (
\begin{DoxyParamCaption}
\item[{const size\+\_\+t}]{k, }
\item[{arma\+::\+Mat$<$ size\+\_\+t $>$ \&}]{resulting\+Neighbors, }
\item[{arma\+::mat \&}]{distances, }
\item[{const size\+\_\+t}]{num\+Tables\+To\+Search = {\ttfamily 0}, }
\item[{size\+\_\+t}]{T = {\ttfamily 0}}
\end{DoxyParamCaption}
)}\label{classmlpack_1_1neighbor_1_1LSHSearch_a50718c600e219c50673806335e067639}


Compute the nearest neighbors and store the output in the given matrices. 

The matrices will be set to the size of n columns by k rows, where n is the number of points in the query dataset and k is the number of neighbors being searched for.


\begin{DoxyParams}{Parameters}
{\em k} & Number of neighbors to search for. \\
\hline
{\em resulting\+Neighbors} & Matrix storing lists of neighbors for each query point. \\
\hline
{\em distances} & Matrix storing distances of neighbors for each query point. \\
\hline
{\em num\+Tables\+To\+Search} & This parameter allows the user to have control over the number of hash tables to be searched. This allows the user to pick the number of tables it can afford for the time available without having to build hashing for every table size. By default, this is set to zero in which case all tables are considered. \\
\hline
\end{DoxyParams}
\index{mlpack\+::neighbor\+::\+L\+S\+H\+Search@{mlpack\+::neighbor\+::\+L\+S\+H\+Search}!Second\+Hash\+Table@{Second\+Hash\+Table}}
\index{Second\+Hash\+Table@{Second\+Hash\+Table}!mlpack\+::neighbor\+::\+L\+S\+H\+Search@{mlpack\+::neighbor\+::\+L\+S\+H\+Search}}
\subsubsection[{Second\+Hash\+Table() const }]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename Sort\+Policy  = Nearest\+Neighbor\+Sort$>$ const std\+::vector$<$arma\+::\+Col$<$size\+\_\+t$>$ $>$\& {\bf mlpack\+::neighbor\+::\+L\+S\+H\+Search}$<$ Sort\+Policy $>$\+::Second\+Hash\+Table (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
) const\hspace{0.3cm}{\ttfamily [inline]}}\label{classmlpack_1_1neighbor_1_1LSHSearch_a7d8f7cb8e60dfa71c79a9c5062176f29}


Get the second hash table. 



Definition at line 283 of file lsh\+\_\+search.\+hpp.



References mlpack\+::neighbor\+::\+L\+S\+H\+Search$<$ Sort\+Policy $>$\+::second\+Hash\+Table.

\index{mlpack\+::neighbor\+::\+L\+S\+H\+Search@{mlpack\+::neighbor\+::\+L\+S\+H\+Search}!Second\+Hash\+Weights@{Second\+Hash\+Weights}}
\index{Second\+Hash\+Weights@{Second\+Hash\+Weights}!mlpack\+::neighbor\+::\+L\+S\+H\+Search@{mlpack\+::neighbor\+::\+L\+S\+H\+Search}}
\subsubsection[{Second\+Hash\+Weights() const }]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename Sort\+Policy  = Nearest\+Neighbor\+Sort$>$ const arma\+::vec\& {\bf mlpack\+::neighbor\+::\+L\+S\+H\+Search}$<$ Sort\+Policy $>$\+::Second\+Hash\+Weights (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
) const\hspace{0.3cm}{\ttfamily [inline]}}\label{classmlpack_1_1neighbor_1_1LSHSearch_a2ad10d1a5d5ed1eeb9fac80153f732d8}


Get the weights of the second hash. 



Definition at line 277 of file lsh\+\_\+search.\+hpp.



References mlpack\+::neighbor\+::\+L\+S\+H\+Search$<$ Sort\+Policy $>$\+::second\+Hash\+Weights.

\index{mlpack\+::neighbor\+::\+L\+S\+H\+Search@{mlpack\+::neighbor\+::\+L\+S\+H\+Search}!Serialize@{Serialize}}
\index{Serialize@{Serialize}!mlpack\+::neighbor\+::\+L\+S\+H\+Search@{mlpack\+::neighbor\+::\+L\+S\+H\+Search}}
\subsubsection[{Serialize(\+Archive \&ar, const unsigned int version)}]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename Sort\+Policy  = Nearest\+Neighbor\+Sort$>$ template$<$typename Archive $>$ void {\bf mlpack\+::neighbor\+::\+L\+S\+H\+Search}$<$ Sort\+Policy $>$\+::Serialize (
\begin{DoxyParamCaption}
\item[{Archive \&}]{ar, }
\item[{const unsigned int}]{version}
\end{DoxyParamCaption}
)}\label{classmlpack_1_1neighbor_1_1LSHSearch_ac9eaae49e102152a9dc5a9c793c6e6ef}


Serialize the L\+SH model. 


\begin{DoxyParams}{Parameters}
{\em ar} & Archive to serialize to. \\
\hline
\end{DoxyParams}
\index{mlpack\+::neighbor\+::\+L\+S\+H\+Search@{mlpack\+::neighbor\+::\+L\+S\+H\+Search}!Train@{Train}}
\index{Train@{Train}!mlpack\+::neighbor\+::\+L\+S\+H\+Search@{mlpack\+::neighbor\+::\+L\+S\+H\+Search}}
\subsubsection[{Train(const arma\+::mat \&reference\+Set, const size\+\_\+t num\+Proj, const size\+\_\+t num\+Tables, const double hash\+Width=0.\+0, const size\+\_\+t second\+Hash\+Size=99901, const size\+\_\+t bucket\+Size=500, const arma\+::cube \&projection=arma\+::cube())}]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename Sort\+Policy  = Nearest\+Neighbor\+Sort$>$ void {\bf mlpack\+::neighbor\+::\+L\+S\+H\+Search}$<$ Sort\+Policy $>$\+::Train (
\begin{DoxyParamCaption}
\item[{const arma\+::mat \&}]{reference\+Set, }
\item[{const size\+\_\+t}]{num\+Proj, }
\item[{const size\+\_\+t}]{num\+Tables, }
\item[{const double}]{hash\+Width = {\ttfamily 0.0}, }
\item[{const size\+\_\+t}]{second\+Hash\+Size = {\ttfamily 99901}, }
\item[{const size\+\_\+t}]{bucket\+Size = {\ttfamily 500}, }
\item[{const arma\+::cube \&}]{projection = {\ttfamily arma\+:\+:cube()}}
\end{DoxyParamCaption}
)}\label{classmlpack_1_1neighbor_1_1LSHSearch_a059328483c99eef38fd5855214a25f4a}


Train the L\+SH model on the given dataset. 

If a correctly-\/sized projection cube is not provided, this means building new hash tables. Otherwise, we use the projections provided by the user.


\begin{DoxyParams}{Parameters}
{\em reference\+Set} & Set of reference points and the set of queries. \\
\hline
{\em num\+Proj} & Number of projections in each hash table (anything between 10-\/50 might be a decent choice). \\
\hline
{\em num\+Tables} & Total number of hash tables (anything between 10-\/20 should suffice). \\
\hline
{\em hash\+Width} & The width of hash for every table. If 0 (the default) is provided, then the hash width is automatically obtained by computing the average pairwise distance of 25 pairs. This should be a reasonable upper bound on the nearest-\/neighbor distance in general. \\
\hline
{\em second\+Hash\+Size} & The size of the second hash table. This should be a large prime number. \\
\hline
{\em bucket\+Size} & The size of the bucket in the second hash table. This is the maximum number of points that can be hashed into single bucket. A value of 0 indicates that there is no limit (so the second hash table can be arbitrarily large---be careful!). \\
\hline
{\em projections} & Cube of projection tables. For a cube of size (a, b, c) we set num\+Proj = a, num\+Tables = c. b is the reference set dimensionality. \\
\hline
\end{DoxyParams}


Referenced by mlpack\+::neighbor\+::\+L\+S\+H\+Search$<$ Sort\+Policy $>$\+::\+Projections().



\subsection{Member Data Documentation}
\index{mlpack\+::neighbor\+::\+L\+S\+H\+Search@{mlpack\+::neighbor\+::\+L\+S\+H\+Search}!bucket\+Content\+Size@{bucket\+Content\+Size}}
\index{bucket\+Content\+Size@{bucket\+Content\+Size}!mlpack\+::neighbor\+::\+L\+S\+H\+Search@{mlpack\+::neighbor\+::\+L\+S\+H\+Search}}
\subsubsection[{bucket\+Content\+Size}]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename Sort\+Policy  = Nearest\+Neighbor\+Sort$>$ arma\+::\+Col$<$size\+\_\+t$>$ {\bf mlpack\+::neighbor\+::\+L\+S\+H\+Search}$<$ Sort\+Policy $>$\+::bucket\+Content\+Size\hspace{0.3cm}{\ttfamily [private]}}\label{classmlpack_1_1neighbor_1_1LSHSearch_a4a19df9419a4d0c13840754dc32c133e}


The number of elements present in each hash bucket; should be second\+Hash\+Size. 



Definition at line 450 of file lsh\+\_\+search.\+hpp.

\index{mlpack\+::neighbor\+::\+L\+S\+H\+Search@{mlpack\+::neighbor\+::\+L\+S\+H\+Search}!bucket\+Row\+In\+Hash\+Table@{bucket\+Row\+In\+Hash\+Table}}
\index{bucket\+Row\+In\+Hash\+Table@{bucket\+Row\+In\+Hash\+Table}!mlpack\+::neighbor\+::\+L\+S\+H\+Search@{mlpack\+::neighbor\+::\+L\+S\+H\+Search}}
\subsubsection[{bucket\+Row\+In\+Hash\+Table}]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename Sort\+Policy  = Nearest\+Neighbor\+Sort$>$ arma\+::\+Col$<$size\+\_\+t$>$ {\bf mlpack\+::neighbor\+::\+L\+S\+H\+Search}$<$ Sort\+Policy $>$\+::bucket\+Row\+In\+Hash\+Table\hspace{0.3cm}{\ttfamily [private]}}\label{classmlpack_1_1neighbor_1_1LSHSearch_a0a3799ccf59d8b450c4695670a500835}


For a particular hash value, points to the row in second\+Hash\+Table corresponding to this value. 

Length second\+Hash\+Size. 

Definition at line 454 of file lsh\+\_\+search.\+hpp.

\index{mlpack\+::neighbor\+::\+L\+S\+H\+Search@{mlpack\+::neighbor\+::\+L\+S\+H\+Search}!bucket\+Size@{bucket\+Size}}
\index{bucket\+Size@{bucket\+Size}!mlpack\+::neighbor\+::\+L\+S\+H\+Search@{mlpack\+::neighbor\+::\+L\+S\+H\+Search}}
\subsubsection[{bucket\+Size}]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename Sort\+Policy  = Nearest\+Neighbor\+Sort$>$ size\+\_\+t {\bf mlpack\+::neighbor\+::\+L\+S\+H\+Search}$<$ Sort\+Policy $>$\+::bucket\+Size\hspace{0.3cm}{\ttfamily [private]}}\label{classmlpack_1_1neighbor_1_1LSHSearch_a9cfd125d3b1abbe53c1d5fafec722814}


The bucket size of the second hash. 



Definition at line 442 of file lsh\+\_\+search.\+hpp.



Referenced by mlpack\+::neighbor\+::\+L\+S\+H\+Search$<$ Sort\+Policy $>$\+::\+Bucket\+Size(), and mlpack\+::neighbor\+::\+L\+S\+H\+Search$<$ Sort\+Policy $>$\+::\+Projections().

\index{mlpack\+::neighbor\+::\+L\+S\+H\+Search@{mlpack\+::neighbor\+::\+L\+S\+H\+Search}!distance\+Evaluations@{distance\+Evaluations}}
\index{distance\+Evaluations@{distance\+Evaluations}!mlpack\+::neighbor\+::\+L\+S\+H\+Search@{mlpack\+::neighbor\+::\+L\+S\+H\+Search}}
\subsubsection[{distance\+Evaluations}]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename Sort\+Policy  = Nearest\+Neighbor\+Sort$>$ size\+\_\+t {\bf mlpack\+::neighbor\+::\+L\+S\+H\+Search}$<$ Sort\+Policy $>$\+::distance\+Evaluations\hspace{0.3cm}{\ttfamily [private]}}\label{classmlpack_1_1neighbor_1_1LSHSearch_af88898b3e73bef9e6b1ba37b0f458918}


The number of distance evaluations. 



Definition at line 457 of file lsh\+\_\+search.\+hpp.



Referenced by mlpack\+::neighbor\+::\+L\+S\+H\+Search$<$ Sort\+Policy $>$\+::\+Distance\+Evaluations().

\index{mlpack\+::neighbor\+::\+L\+S\+H\+Search@{mlpack\+::neighbor\+::\+L\+S\+H\+Search}!hash\+Width@{hash\+Width}}
\index{hash\+Width@{hash\+Width}!mlpack\+::neighbor\+::\+L\+S\+H\+Search@{mlpack\+::neighbor\+::\+L\+S\+H\+Search}}
\subsubsection[{hash\+Width}]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename Sort\+Policy  = Nearest\+Neighbor\+Sort$>$ double {\bf mlpack\+::neighbor\+::\+L\+S\+H\+Search}$<$ Sort\+Policy $>$\+::hash\+Width\hspace{0.3cm}{\ttfamily [private]}}\label{classmlpack_1_1neighbor_1_1LSHSearch_ac765c095b3b77eb485f801bc3fbd7ca8}


The hash width. 



Definition at line 433 of file lsh\+\_\+search.\+hpp.



Referenced by mlpack\+::neighbor\+::\+L\+S\+H\+Search$<$ Sort\+Policy $>$\+::\+Projections().

\index{mlpack\+::neighbor\+::\+L\+S\+H\+Search@{mlpack\+::neighbor\+::\+L\+S\+H\+Search}!num\+Proj@{num\+Proj}}
\index{num\+Proj@{num\+Proj}!mlpack\+::neighbor\+::\+L\+S\+H\+Search@{mlpack\+::neighbor\+::\+L\+S\+H\+Search}}
\subsubsection[{num\+Proj}]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename Sort\+Policy  = Nearest\+Neighbor\+Sort$>$ size\+\_\+t {\bf mlpack\+::neighbor\+::\+L\+S\+H\+Search}$<$ Sort\+Policy $>$\+::num\+Proj\hspace{0.3cm}{\ttfamily [private]}}\label{classmlpack_1_1neighbor_1_1LSHSearch_ade500324c9dac3e002300b1ce94b31ee}


The number of projections. 



Definition at line 422 of file lsh\+\_\+search.\+hpp.

\index{mlpack\+::neighbor\+::\+L\+S\+H\+Search@{mlpack\+::neighbor\+::\+L\+S\+H\+Search}!num\+Tables@{num\+Tables}}
\index{num\+Tables@{num\+Tables}!mlpack\+::neighbor\+::\+L\+S\+H\+Search@{mlpack\+::neighbor\+::\+L\+S\+H\+Search}}
\subsubsection[{num\+Tables}]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename Sort\+Policy  = Nearest\+Neighbor\+Sort$>$ size\+\_\+t {\bf mlpack\+::neighbor\+::\+L\+S\+H\+Search}$<$ Sort\+Policy $>$\+::num\+Tables\hspace{0.3cm}{\ttfamily [private]}}\label{classmlpack_1_1neighbor_1_1LSHSearch_a3d7a6952a9fd15e58fc81878c741a2a2}


The number of hash tables. 



Definition at line 424 of file lsh\+\_\+search.\+hpp.

\index{mlpack\+::neighbor\+::\+L\+S\+H\+Search@{mlpack\+::neighbor\+::\+L\+S\+H\+Search}!offsets@{offsets}}
\index{offsets@{offsets}!mlpack\+::neighbor\+::\+L\+S\+H\+Search@{mlpack\+::neighbor\+::\+L\+S\+H\+Search}}
\subsubsection[{offsets}]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename Sort\+Policy  = Nearest\+Neighbor\+Sort$>$ arma\+::mat {\bf mlpack\+::neighbor\+::\+L\+S\+H\+Search}$<$ Sort\+Policy $>$\+::offsets\hspace{0.3cm}{\ttfamily [private]}}\label{classmlpack_1_1neighbor_1_1LSHSearch_af4596a8eab77eb80e1c549471211ed9a}


The list of the offsets \textquotesingle{}b\textquotesingle{} for each of the projection for each table. 



Definition at line 430 of file lsh\+\_\+search.\+hpp.



Referenced by mlpack\+::neighbor\+::\+L\+S\+H\+Search$<$ Sort\+Policy $>$\+::\+Offsets().

\index{mlpack\+::neighbor\+::\+L\+S\+H\+Search@{mlpack\+::neighbor\+::\+L\+S\+H\+Search}!owns\+Set@{owns\+Set}}
\index{owns\+Set@{owns\+Set}!mlpack\+::neighbor\+::\+L\+S\+H\+Search@{mlpack\+::neighbor\+::\+L\+S\+H\+Search}}
\subsubsection[{owns\+Set}]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename Sort\+Policy  = Nearest\+Neighbor\+Sort$>$ bool {\bf mlpack\+::neighbor\+::\+L\+S\+H\+Search}$<$ Sort\+Policy $>$\+::owns\+Set\hspace{0.3cm}{\ttfamily [private]}}\label{classmlpack_1_1neighbor_1_1LSHSearch_a366edfae78c37d16b86322a3bca42027}


If true, we own the reference set. 



Definition at line 419 of file lsh\+\_\+search.\+hpp.

\index{mlpack\+::neighbor\+::\+L\+S\+H\+Search@{mlpack\+::neighbor\+::\+L\+S\+H\+Search}!projections@{projections}}
\index{projections@{projections}!mlpack\+::neighbor\+::\+L\+S\+H\+Search@{mlpack\+::neighbor\+::\+L\+S\+H\+Search}}
\subsubsection[{projections}]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename Sort\+Policy  = Nearest\+Neighbor\+Sort$>$ arma\+::cube {\bf mlpack\+::neighbor\+::\+L\+S\+H\+Search}$<$ Sort\+Policy $>$\+::projections\hspace{0.3cm}{\ttfamily [private]}}\label{classmlpack_1_1neighbor_1_1LSHSearch_af28c150d1fbfe310cd7c04aecdff2c47}


The arma\+::cube containing the projection matrix of each table. 



Definition at line 427 of file lsh\+\_\+search.\+hpp.



Referenced by mlpack\+::neighbor\+::\+L\+S\+H\+Search$<$ Sort\+Policy $>$\+::\+Projections().

\index{mlpack\+::neighbor\+::\+L\+S\+H\+Search@{mlpack\+::neighbor\+::\+L\+S\+H\+Search}!reference\+Set@{reference\+Set}}
\index{reference\+Set@{reference\+Set}!mlpack\+::neighbor\+::\+L\+S\+H\+Search@{mlpack\+::neighbor\+::\+L\+S\+H\+Search}}
\subsubsection[{reference\+Set}]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename Sort\+Policy  = Nearest\+Neighbor\+Sort$>$ const arma\+::mat$\ast$ {\bf mlpack\+::neighbor\+::\+L\+S\+H\+Search}$<$ Sort\+Policy $>$\+::reference\+Set\hspace{0.3cm}{\ttfamily [private]}}\label{classmlpack_1_1neighbor_1_1LSHSearch_ab131bc24b9ad07ee9ff9eb7e4c600e62}


Reference dataset. 



Definition at line 417 of file lsh\+\_\+search.\+hpp.



Referenced by mlpack\+::neighbor\+::\+L\+S\+H\+Search$<$ Sort\+Policy $>$\+::\+Reference\+Set().

\index{mlpack\+::neighbor\+::\+L\+S\+H\+Search@{mlpack\+::neighbor\+::\+L\+S\+H\+Search}!second\+Hash\+Size@{second\+Hash\+Size}}
\index{second\+Hash\+Size@{second\+Hash\+Size}!mlpack\+::neighbor\+::\+L\+S\+H\+Search@{mlpack\+::neighbor\+::\+L\+S\+H\+Search}}
\subsubsection[{second\+Hash\+Size}]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename Sort\+Policy  = Nearest\+Neighbor\+Sort$>$ size\+\_\+t {\bf mlpack\+::neighbor\+::\+L\+S\+H\+Search}$<$ Sort\+Policy $>$\+::second\+Hash\+Size\hspace{0.3cm}{\ttfamily [private]}}\label{classmlpack_1_1neighbor_1_1LSHSearch_a23a181b89e6a7a6024bc4c941acdc3a4}


The big prime representing the size of the second hash. 



Definition at line 436 of file lsh\+\_\+search.\+hpp.



Referenced by mlpack\+::neighbor\+::\+L\+S\+H\+Search$<$ Sort\+Policy $>$\+::\+Projections().

\index{mlpack\+::neighbor\+::\+L\+S\+H\+Search@{mlpack\+::neighbor\+::\+L\+S\+H\+Search}!second\+Hash\+Table@{second\+Hash\+Table}}
\index{second\+Hash\+Table@{second\+Hash\+Table}!mlpack\+::neighbor\+::\+L\+S\+H\+Search@{mlpack\+::neighbor\+::\+L\+S\+H\+Search}}
\subsubsection[{second\+Hash\+Table}]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename Sort\+Policy  = Nearest\+Neighbor\+Sort$>$ std\+::vector$<$arma\+::\+Col$<$size\+\_\+t$>$ $>$ {\bf mlpack\+::neighbor\+::\+L\+S\+H\+Search}$<$ Sort\+Policy $>$\+::second\+Hash\+Table\hspace{0.3cm}{\ttfamily [private]}}\label{classmlpack_1_1neighbor_1_1LSHSearch_a04fb9f531f1f9d5a2cc4ea54e2f6bc1d}


The final hash table; should be ($<$ second\+Hash\+Size) vectors each with ($<$= bucket\+Size) elements. 



Definition at line 446 of file lsh\+\_\+search.\+hpp.



Referenced by mlpack\+::neighbor\+::\+L\+S\+H\+Search$<$ Sort\+Policy $>$\+::\+Second\+Hash\+Table().

\index{mlpack\+::neighbor\+::\+L\+S\+H\+Search@{mlpack\+::neighbor\+::\+L\+S\+H\+Search}!second\+Hash\+Weights@{second\+Hash\+Weights}}
\index{second\+Hash\+Weights@{second\+Hash\+Weights}!mlpack\+::neighbor\+::\+L\+S\+H\+Search@{mlpack\+::neighbor\+::\+L\+S\+H\+Search}}
\subsubsection[{second\+Hash\+Weights}]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename Sort\+Policy  = Nearest\+Neighbor\+Sort$>$ arma\+::vec {\bf mlpack\+::neighbor\+::\+L\+S\+H\+Search}$<$ Sort\+Policy $>$\+::second\+Hash\+Weights\hspace{0.3cm}{\ttfamily [private]}}\label{classmlpack_1_1neighbor_1_1LSHSearch_aabdc27407c4c6d722b6b39fd8988dea6}


The weights of the second hash. 



Definition at line 439 of file lsh\+\_\+search.\+hpp.



Referenced by mlpack\+::neighbor\+::\+L\+S\+H\+Search$<$ Sort\+Policy $>$\+::\+Second\+Hash\+Weights().



The documentation for this class was generated from the following file\+:\begin{DoxyCompactItemize}
\item 
src/mlpack/methods/lsh/{\bf lsh\+\_\+search.\+hpp}\end{DoxyCompactItemize}
