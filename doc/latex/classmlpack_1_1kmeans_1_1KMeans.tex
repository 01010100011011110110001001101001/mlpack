\section{mlpack\+:\+:kmeans\+:\+:K\+Means$<$ Metric\+Type, Initial\+Partition\+Policy, Empty\+Cluster\+Policy, Lloyd\+Step\+Type, Mat\+Type $>$ Class Template Reference}
\label{classmlpack_1_1kmeans_1_1KMeans}\index{mlpack\+::kmeans\+::\+K\+Means$<$ Metric\+Type, Initial\+Partition\+Policy, Empty\+Cluster\+Policy, Lloyd\+Step\+Type, Mat\+Type $>$@{mlpack\+::kmeans\+::\+K\+Means$<$ Metric\+Type, Initial\+Partition\+Policy, Empty\+Cluster\+Policy, Lloyd\+Step\+Type, Mat\+Type $>$}}


This class implements K-\/\+Means clustering, using a variety of possible implementations of Lloyd\textquotesingle{}s algorithm.  


\subsection*{Public Member Functions}
\begin{DoxyCompactItemize}
\item 
{\bf K\+Means} (const size\+\_\+t {\bf max\+Iterations}=1000, const Metric\+Type {\bf metric}=Metric\+Type(), const Initial\+Partition\+Policy {\bf partitioner}=Initial\+Partition\+Policy(), const Empty\+Cluster\+Policy {\bf empty\+Cluster\+Action}=Empty\+Cluster\+Policy())
\begin{DoxyCompactList}\small\item\em Create a K-\/\+Means object and (optionally) set the parameters which K-\/\+Means will be run with. \end{DoxyCompactList}\item 
void {\bf Cluster} (const Mat\+Type \&data, const size\+\_\+t clusters, arma\+::\+Row$<$ size\+\_\+t $>$ \&assignments, const bool initial\+Guess=false)
\begin{DoxyCompactList}\small\item\em Perform k-\/means clustering on the data, returning a list of cluster assignments. \end{DoxyCompactList}\item 
void {\bf Cluster} (const Mat\+Type \&data, const size\+\_\+t clusters, arma\+::mat \&centroids, const bool initial\+Guess=false)
\begin{DoxyCompactList}\small\item\em Perform k-\/means clustering on the data, returning the centroids of each cluster in the centroids matrix. \end{DoxyCompactList}\item 
void {\bf Cluster} (const Mat\+Type \&data, const size\+\_\+t clusters, arma\+::\+Row$<$ size\+\_\+t $>$ \&assignments, arma\+::mat \&centroids, const bool initial\+Assignment\+Guess=false, const bool initial\+Centroid\+Guess=false)
\begin{DoxyCompactList}\small\item\em Perform k-\/means clustering on the data, returning a list of cluster assignments and also the centroids of each cluster. \end{DoxyCompactList}\item 
const Empty\+Cluster\+Policy \& {\bf Empty\+Cluster\+Action} () const 
\begin{DoxyCompactList}\small\item\em Get the empty cluster policy. \end{DoxyCompactList}\item 
Empty\+Cluster\+Policy \& {\bf Empty\+Cluster\+Action} ()
\begin{DoxyCompactList}\small\item\em Modify the empty cluster policy. \end{DoxyCompactList}\item 
size\+\_\+t {\bf Max\+Iterations} () const 
\begin{DoxyCompactList}\small\item\em Get the maximum number of iterations. \end{DoxyCompactList}\item 
size\+\_\+t \& {\bf Max\+Iterations} ()
\begin{DoxyCompactList}\small\item\em Set the maximum number of iterations. \end{DoxyCompactList}\item 
const Metric\+Type \& {\bf Metric} () const 
\begin{DoxyCompactList}\small\item\em Get the distance metric. \end{DoxyCompactList}\item 
Metric\+Type \& {\bf Metric} ()
\begin{DoxyCompactList}\small\item\em Modify the distance metric. \end{DoxyCompactList}\item 
const Initial\+Partition\+Policy \& {\bf Partitioner} () const 
\begin{DoxyCompactList}\small\item\em Get the initial partitioning policy. \end{DoxyCompactList}\item 
Initial\+Partition\+Policy \& {\bf Partitioner} ()
\begin{DoxyCompactList}\small\item\em Modify the initial partitioning policy. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename Archive $>$ }\\void {\bf Serialize} (Archive \&ar, const unsigned int version)
\begin{DoxyCompactList}\small\item\em Serialize the k-\/means object. \end{DoxyCompactList}\end{DoxyCompactItemize}
\subsection*{Private Attributes}
\begin{DoxyCompactItemize}
\item 
Empty\+Cluster\+Policy {\bf empty\+Cluster\+Action}
\begin{DoxyCompactList}\small\item\em Instantiated empty cluster policy. \end{DoxyCompactList}\item 
size\+\_\+t {\bf max\+Iterations}
\begin{DoxyCompactList}\small\item\em Maximum number of iterations before giving up. \end{DoxyCompactList}\item 
Metric\+Type {\bf metric}
\begin{DoxyCompactList}\small\item\em Instantiated distance metric. \end{DoxyCompactList}\item 
Initial\+Partition\+Policy {\bf partitioner}
\begin{DoxyCompactList}\small\item\em Instantiated initial partitioning policy. \end{DoxyCompactList}\end{DoxyCompactItemize}


\subsection{Detailed Description}
\subsubsection*{template$<$typename Metric\+Type = metric\+::\+Euclidean\+Distance, typename Initial\+Partition\+Policy = Sample\+Initialization, typename Empty\+Cluster\+Policy = Max\+Variance\+New\+Cluster, template$<$ class, class $>$ class Lloyd\+Step\+Type = Naive\+K\+Means, typename Mat\+Type = arma\+::mat$>$\\*
class mlpack\+::kmeans\+::\+K\+Means$<$ Metric\+Type, Initial\+Partition\+Policy, Empty\+Cluster\+Policy, Lloyd\+Step\+Type, Mat\+Type $>$}

This class implements K-\/\+Means clustering, using a variety of possible implementations of Lloyd\textquotesingle{}s algorithm. 

Four template parameters can (optionally) be supplied\+: the distance metric to use, the policy for how to find the initial partition of the data, the actions to be taken when an empty cluster is encountered, and the implementation of a single Lloyd step to use.

A simple example of how to run K-\/\+Means clustering is shown below.


\begin{DoxyCode}
\textcolor{keyword}{extern} arma::mat data; \textcolor{comment}{// Dataset we want to run K-Means on.}
arma::Row<size\_t> assignments; \textcolor{comment}{// Cluster assignments.}
arma::mat centroids; \textcolor{comment}{// Cluster centroids.}

KMeans<> k; \textcolor{comment}{// Default options.}
k.Cluster(data, 3, assignments, centroids); \textcolor{comment}{// 3 clusters.}

\textcolor{comment}{// Cluster using the Manhattan distance, 100 iterations maximum, saving only}
\textcolor{comment}{// the centroids.}
KMeans<metric::ManhattanDistance> k(100);
k.Cluster(data, 6, centroids); \textcolor{comment}{// 6 clusters.}
\end{DoxyCode}



\begin{DoxyTemplParams}{Template Parameters}
{\em Metric\+Type} & The distance metric to use for this \doxyref{K\+Means}{p.}{classmlpack_1_1kmeans_1_1KMeans}; see \doxyref{metric\+::\+L\+Metric}{p.}{classmlpack_1_1metric_1_1LMetric} for an example. \\
\hline
{\em Initial\+Partition\+Policy} & Initial partitioning policy; must implement a default constructor and either \textquotesingle{}void Cluster(const arma\+::mat\&, const size\+\_\+t, arma\+::\+Row$<$size\+\_\+t$>$\&)\textquotesingle{} or \textquotesingle{}void Cluster(const arma\+::mat\&, const size\+\_\+t, arma\+::mat\&)\textquotesingle{}. \\
\hline
{\em Empty\+Cluster\+Policy} & Policy for what to do on an empty cluster; must implement a default constructor and \textquotesingle{}void Empty\+Cluster(const arma\+::mat\& data, const size\+\_\+t empty\+Cluster, const arma\+::mat\& old\+Centroids, arma\+::mat\& new\+Centroids, arma\+::\+Col$<$size\+\_\+t$>$\& counts, Metric\+Type\& metric, const size\+\_\+t iteration)\textquotesingle{}. \\
\hline
{\em Lloyd\+Step\+Type} & Implementation of single Lloyd step to use.\\
\hline
\end{DoxyTemplParams}
\begin{DoxySeeAlso}{See also}
\doxyref{Random\+Partition}{p.}{classmlpack_1_1kmeans_1_1RandomPartition}, \doxyref{Sample\+Initialization}{p.}{classmlpack_1_1kmeans_1_1SampleInitialization}, \doxyref{Refined\+Start}{p.}{classmlpack_1_1kmeans_1_1RefinedStart}, \doxyref{Allow\+Empty\+Clusters}{p.}{classmlpack_1_1kmeans_1_1AllowEmptyClusters}, \doxyref{Max\+Variance\+New\+Cluster}{p.}{classmlpack_1_1kmeans_1_1MaxVarianceNewCluster}, \doxyref{Naive\+K\+Means}{p.}{classmlpack_1_1kmeans_1_1NaiveKMeans}, \doxyref{Elkan\+K\+Means}{p.}{classmlpack_1_1kmeans_1_1ElkanKMeans} 
\end{DoxySeeAlso}


Definition at line 73 of file kmeans.\+hpp.



\subsection{Constructor \& Destructor Documentation}
\index{mlpack\+::kmeans\+::\+K\+Means@{mlpack\+::kmeans\+::\+K\+Means}!K\+Means@{K\+Means}}
\index{K\+Means@{K\+Means}!mlpack\+::kmeans\+::\+K\+Means@{mlpack\+::kmeans\+::\+K\+Means}}
\subsubsection[{K\+Means(const size\+\_\+t max\+Iterations=1000, const Metric\+Type metric=\+Metric\+Type(), const Initial\+Partition\+Policy partitioner=\+Initial\+Partition\+Policy(), const Empty\+Cluster\+Policy empty\+Cluster\+Action=\+Empty\+Cluster\+Policy())}]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename Metric\+Type = metric\+::\+Euclidean\+Distance, typename Initial\+Partition\+Policy = Sample\+Initialization, typename Empty\+Cluster\+Policy = Max\+Variance\+New\+Cluster, template$<$ class, class $>$ class Lloyd\+Step\+Type = Naive\+K\+Means, typename Mat\+Type = arma\+::mat$>$ {\bf mlpack\+::kmeans\+::\+K\+Means}$<$ Metric\+Type, Initial\+Partition\+Policy, Empty\+Cluster\+Policy, Lloyd\+Step\+Type, Mat\+Type $>$\+::{\bf K\+Means} (
\begin{DoxyParamCaption}
\item[{const size\+\_\+t}]{max\+Iterations = {\ttfamily 1000}, }
\item[{const Metric\+Type}]{metric = {\ttfamily MetricType()}, }
\item[{const Initial\+Partition\+Policy}]{partitioner = {\ttfamily InitialPartitionPolicy()}, }
\item[{const Empty\+Cluster\+Policy}]{empty\+Cluster\+Action = {\ttfamily EmptyClusterPolicy()}}
\end{DoxyParamCaption}
)}\label{classmlpack_1_1kmeans_1_1KMeans_affcec7ef6583964a4afda7c70a29e4da}


Create a K-\/\+Means object and (optionally) set the parameters which K-\/\+Means will be run with. 


\begin{DoxyParams}{Parameters}
{\em max\+Iterations} & Maximum number of iterations allowed before giving up (0 is valid, but the algorithm may never terminate). \\
\hline
{\em metric} & Optional Metric\+Type object; for when the metric has state it needs to store. \\
\hline
{\em partitioner} & Optional Initial\+Partition\+Policy object; for when a specially initialized partitioning policy is required. \\
\hline
{\em empty\+Cluster\+Action} & Optional Empty\+Cluster\+Policy object; for when a specially initialized empty cluster policy is required. \\
\hline
\end{DoxyParams}


\subsection{Member Function Documentation}
\index{mlpack\+::kmeans\+::\+K\+Means@{mlpack\+::kmeans\+::\+K\+Means}!Cluster@{Cluster}}
\index{Cluster@{Cluster}!mlpack\+::kmeans\+::\+K\+Means@{mlpack\+::kmeans\+::\+K\+Means}}
\subsubsection[{Cluster(const Mat\+Type \&data, const size\+\_\+t clusters, arma\+::\+Row$<$ size\+\_\+t $>$ \&assignments, const bool initial\+Guess=false)}]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename Metric\+Type = metric\+::\+Euclidean\+Distance, typename Initial\+Partition\+Policy = Sample\+Initialization, typename Empty\+Cluster\+Policy = Max\+Variance\+New\+Cluster, template$<$ class, class $>$ class Lloyd\+Step\+Type = Naive\+K\+Means, typename Mat\+Type = arma\+::mat$>$ void {\bf mlpack\+::kmeans\+::\+K\+Means}$<$ Metric\+Type, Initial\+Partition\+Policy, Empty\+Cluster\+Policy, Lloyd\+Step\+Type, Mat\+Type $>$\+::Cluster (
\begin{DoxyParamCaption}
\item[{const Mat\+Type \&}]{data, }
\item[{const size\+\_\+t}]{clusters, }
\item[{arma\+::\+Row$<$ size\+\_\+t $>$ \&}]{assignments, }
\item[{const bool}]{initial\+Guess = {\ttfamily false}}
\end{DoxyParamCaption}
)}\label{classmlpack_1_1kmeans_1_1KMeans_a4acb46f121570f776571ba8771fe512c}


Perform k-\/means clustering on the data, returning a list of cluster assignments. 

Optionally, the vector of assignments can be set to an initial guess of the cluster assignments; to do this, set initial\+Guess to true.


\begin{DoxyTemplParams}{Template Parameters}
{\em Mat\+Type} & Type of matrix (arma\+::mat or arma\+::sp\+\_\+mat). \\
\hline
\end{DoxyTemplParams}

\begin{DoxyParams}{Parameters}
{\em data} & Dataset to cluster. \\
\hline
{\em clusters} & Number of clusters to compute. \\
\hline
{\em assignments} & Vector to store cluster assignments in. \\
\hline
{\em initial\+Guess} & If true, then it is assumed that assignments has a list of initial cluster assignments. \\
\hline
\end{DoxyParams}
\index{mlpack\+::kmeans\+::\+K\+Means@{mlpack\+::kmeans\+::\+K\+Means}!Cluster@{Cluster}}
\index{Cluster@{Cluster}!mlpack\+::kmeans\+::\+K\+Means@{mlpack\+::kmeans\+::\+K\+Means}}
\subsubsection[{Cluster(const Mat\+Type \&data, const size\+\_\+t clusters, arma\+::mat \&centroids, const bool initial\+Guess=false)}]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename Metric\+Type = metric\+::\+Euclidean\+Distance, typename Initial\+Partition\+Policy = Sample\+Initialization, typename Empty\+Cluster\+Policy = Max\+Variance\+New\+Cluster, template$<$ class, class $>$ class Lloyd\+Step\+Type = Naive\+K\+Means, typename Mat\+Type = arma\+::mat$>$ void {\bf mlpack\+::kmeans\+::\+K\+Means}$<$ Metric\+Type, Initial\+Partition\+Policy, Empty\+Cluster\+Policy, Lloyd\+Step\+Type, Mat\+Type $>$\+::Cluster (
\begin{DoxyParamCaption}
\item[{const Mat\+Type \&}]{data, }
\item[{const size\+\_\+t}]{clusters, }
\item[{arma\+::mat \&}]{centroids, }
\item[{const bool}]{initial\+Guess = {\ttfamily false}}
\end{DoxyParamCaption}
)}\label{classmlpack_1_1kmeans_1_1KMeans_a5fa29de0157992a38d0111446ce37c4e}


Perform k-\/means clustering on the data, returning the centroids of each cluster in the centroids matrix. 

Optionally, the initial centroids can be specified by filling the centroids matrix with the initial centroids and specifying initial\+Guess = true.


\begin{DoxyTemplParams}{Template Parameters}
{\em Mat\+Type} & Type of matrix (arma\+::mat or arma\+::sp\+\_\+mat). \\
\hline
\end{DoxyTemplParams}

\begin{DoxyParams}{Parameters}
{\em data} & Dataset to cluster. \\
\hline
{\em clusters} & Number of clusters to compute. \\
\hline
{\em centroids} & Matrix in which centroids are stored. \\
\hline
{\em initial\+Guess} & If true, then it is assumed that centroids contains the initial cluster centroids. \\
\hline
\end{DoxyParams}
\index{mlpack\+::kmeans\+::\+K\+Means@{mlpack\+::kmeans\+::\+K\+Means}!Cluster@{Cluster}}
\index{Cluster@{Cluster}!mlpack\+::kmeans\+::\+K\+Means@{mlpack\+::kmeans\+::\+K\+Means}}
\subsubsection[{Cluster(const Mat\+Type \&data, const size\+\_\+t clusters, arma\+::\+Row$<$ size\+\_\+t $>$ \&assignments, arma\+::mat \&centroids, const bool initial\+Assignment\+Guess=false, const bool initial\+Centroid\+Guess=false)}]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename Metric\+Type = metric\+::\+Euclidean\+Distance, typename Initial\+Partition\+Policy = Sample\+Initialization, typename Empty\+Cluster\+Policy = Max\+Variance\+New\+Cluster, template$<$ class, class $>$ class Lloyd\+Step\+Type = Naive\+K\+Means, typename Mat\+Type = arma\+::mat$>$ void {\bf mlpack\+::kmeans\+::\+K\+Means}$<$ Metric\+Type, Initial\+Partition\+Policy, Empty\+Cluster\+Policy, Lloyd\+Step\+Type, Mat\+Type $>$\+::Cluster (
\begin{DoxyParamCaption}
\item[{const Mat\+Type \&}]{data, }
\item[{const size\+\_\+t}]{clusters, }
\item[{arma\+::\+Row$<$ size\+\_\+t $>$ \&}]{assignments, }
\item[{arma\+::mat \&}]{centroids, }
\item[{const bool}]{initial\+Assignment\+Guess = {\ttfamily false}, }
\item[{const bool}]{initial\+Centroid\+Guess = {\ttfamily false}}
\end{DoxyParamCaption}
)}\label{classmlpack_1_1kmeans_1_1KMeans_af232d4db65f7410656de2384775be129}


Perform k-\/means clustering on the data, returning a list of cluster assignments and also the centroids of each cluster. 

Optionally, the vector of assignments can be set to an initial guess of the cluster assignments; to do this, set initial\+Assignment\+Guess to true. Another way to set initial cluster guesses is to fill the centroids matrix with the centroid guesses, and then set initial\+Centroid\+Guess to true. initial\+Assignment\+Guess supersedes initial\+Centroid\+Guess, so if both are set to true, the assignments vector is used.


\begin{DoxyTemplParams}{Template Parameters}
{\em Mat\+Type} & Type of matrix (arma\+::mat or arma\+::sp\+\_\+mat). \\
\hline
\end{DoxyTemplParams}

\begin{DoxyParams}{Parameters}
{\em data} & Dataset to cluster. \\
\hline
{\em clusters} & Number of clusters to compute. \\
\hline
{\em assignments} & Vector to store cluster assignments in. \\
\hline
{\em centroids} & Matrix in which centroids are stored. \\
\hline
{\em initial\+Assignment\+Guess} & If true, then it is assumed that assignments has a list of initial cluster assignments. \\
\hline
{\em initial\+Centroid\+Guess} & If true, then it is assumed that centroids contains the initial centroids of each cluster. \\
\hline
\end{DoxyParams}
\index{mlpack\+::kmeans\+::\+K\+Means@{mlpack\+::kmeans\+::\+K\+Means}!Empty\+Cluster\+Action@{Empty\+Cluster\+Action}}
\index{Empty\+Cluster\+Action@{Empty\+Cluster\+Action}!mlpack\+::kmeans\+::\+K\+Means@{mlpack\+::kmeans\+::\+K\+Means}}
\subsubsection[{Empty\+Cluster\+Action() const }]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename Metric\+Type = metric\+::\+Euclidean\+Distance, typename Initial\+Partition\+Policy = Sample\+Initialization, typename Empty\+Cluster\+Policy = Max\+Variance\+New\+Cluster, template$<$ class, class $>$ class Lloyd\+Step\+Type = Naive\+K\+Means, typename Mat\+Type = arma\+::mat$>$ const Empty\+Cluster\+Policy\& {\bf mlpack\+::kmeans\+::\+K\+Means}$<$ Metric\+Type, Initial\+Partition\+Policy, Empty\+Cluster\+Policy, Lloyd\+Step\+Type, Mat\+Type $>$\+::Empty\+Cluster\+Action (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
) const\hspace{0.3cm}{\ttfamily [inline]}}\label{classmlpack_1_1kmeans_1_1KMeans_a7ae0154a5246f06aeec06fffa85ba23b}


Get the empty cluster policy. 



Definition at line 174 of file kmeans.\+hpp.



References mlpack\+::kmeans\+::\+K\+Means$<$ Metric\+Type, Initial\+Partition\+Policy, Empty\+Cluster\+Policy, Lloyd\+Step\+Type, Mat\+Type $>$\+::empty\+Cluster\+Action.

\index{mlpack\+::kmeans\+::\+K\+Means@{mlpack\+::kmeans\+::\+K\+Means}!Empty\+Cluster\+Action@{Empty\+Cluster\+Action}}
\index{Empty\+Cluster\+Action@{Empty\+Cluster\+Action}!mlpack\+::kmeans\+::\+K\+Means@{mlpack\+::kmeans\+::\+K\+Means}}
\subsubsection[{Empty\+Cluster\+Action()}]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename Metric\+Type = metric\+::\+Euclidean\+Distance, typename Initial\+Partition\+Policy = Sample\+Initialization, typename Empty\+Cluster\+Policy = Max\+Variance\+New\+Cluster, template$<$ class, class $>$ class Lloyd\+Step\+Type = Naive\+K\+Means, typename Mat\+Type = arma\+::mat$>$ Empty\+Cluster\+Policy\& {\bf mlpack\+::kmeans\+::\+K\+Means}$<$ Metric\+Type, Initial\+Partition\+Policy, Empty\+Cluster\+Policy, Lloyd\+Step\+Type, Mat\+Type $>$\+::Empty\+Cluster\+Action (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}}\label{classmlpack_1_1kmeans_1_1KMeans_afd1af6204831b30517f590287ec36ef9}


Modify the empty cluster policy. 



Definition at line 177 of file kmeans.\+hpp.



References mlpack\+::kmeans\+::\+K\+Means$<$ Metric\+Type, Initial\+Partition\+Policy, Empty\+Cluster\+Policy, Lloyd\+Step\+Type, Mat\+Type $>$\+::empty\+Cluster\+Action, and mlpack\+::kmeans\+::\+K\+Means$<$ Metric\+Type, Initial\+Partition\+Policy, Empty\+Cluster\+Policy, Lloyd\+Step\+Type, Mat\+Type $>$\+::\+Serialize().

\index{mlpack\+::kmeans\+::\+K\+Means@{mlpack\+::kmeans\+::\+K\+Means}!Max\+Iterations@{Max\+Iterations}}
\index{Max\+Iterations@{Max\+Iterations}!mlpack\+::kmeans\+::\+K\+Means@{mlpack\+::kmeans\+::\+K\+Means}}
\subsubsection[{Max\+Iterations() const }]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename Metric\+Type = metric\+::\+Euclidean\+Distance, typename Initial\+Partition\+Policy = Sample\+Initialization, typename Empty\+Cluster\+Policy = Max\+Variance\+New\+Cluster, template$<$ class, class $>$ class Lloyd\+Step\+Type = Naive\+K\+Means, typename Mat\+Type = arma\+::mat$>$ size\+\_\+t {\bf mlpack\+::kmeans\+::\+K\+Means}$<$ Metric\+Type, Initial\+Partition\+Policy, Empty\+Cluster\+Policy, Lloyd\+Step\+Type, Mat\+Type $>$\+::Max\+Iterations (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
) const\hspace{0.3cm}{\ttfamily [inline]}}\label{classmlpack_1_1kmeans_1_1KMeans_a01b24902c64bbf045491d69c746d6a50}


Get the maximum number of iterations. 



Definition at line 159 of file kmeans.\+hpp.



References mlpack\+::kmeans\+::\+K\+Means$<$ Metric\+Type, Initial\+Partition\+Policy, Empty\+Cluster\+Policy, Lloyd\+Step\+Type, Mat\+Type $>$\+::max\+Iterations.

\index{mlpack\+::kmeans\+::\+K\+Means@{mlpack\+::kmeans\+::\+K\+Means}!Max\+Iterations@{Max\+Iterations}}
\index{Max\+Iterations@{Max\+Iterations}!mlpack\+::kmeans\+::\+K\+Means@{mlpack\+::kmeans\+::\+K\+Means}}
\subsubsection[{Max\+Iterations()}]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename Metric\+Type = metric\+::\+Euclidean\+Distance, typename Initial\+Partition\+Policy = Sample\+Initialization, typename Empty\+Cluster\+Policy = Max\+Variance\+New\+Cluster, template$<$ class, class $>$ class Lloyd\+Step\+Type = Naive\+K\+Means, typename Mat\+Type = arma\+::mat$>$ size\+\_\+t\& {\bf mlpack\+::kmeans\+::\+K\+Means}$<$ Metric\+Type, Initial\+Partition\+Policy, Empty\+Cluster\+Policy, Lloyd\+Step\+Type, Mat\+Type $>$\+::Max\+Iterations (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}}\label{classmlpack_1_1kmeans_1_1KMeans_a9a2c68696852406ad2748bb0fa44eedf}


Set the maximum number of iterations. 



Definition at line 161 of file kmeans.\+hpp.



References mlpack\+::kmeans\+::\+K\+Means$<$ Metric\+Type, Initial\+Partition\+Policy, Empty\+Cluster\+Policy, Lloyd\+Step\+Type, Mat\+Type $>$\+::max\+Iterations.

\index{mlpack\+::kmeans\+::\+K\+Means@{mlpack\+::kmeans\+::\+K\+Means}!Metric@{Metric}}
\index{Metric@{Metric}!mlpack\+::kmeans\+::\+K\+Means@{mlpack\+::kmeans\+::\+K\+Means}}
\subsubsection[{Metric() const }]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename Metric\+Type = metric\+::\+Euclidean\+Distance, typename Initial\+Partition\+Policy = Sample\+Initialization, typename Empty\+Cluster\+Policy = Max\+Variance\+New\+Cluster, template$<$ class, class $>$ class Lloyd\+Step\+Type = Naive\+K\+Means, typename Mat\+Type = arma\+::mat$>$ const Metric\+Type\& {\bf mlpack\+::kmeans\+::\+K\+Means}$<$ Metric\+Type, Initial\+Partition\+Policy, Empty\+Cluster\+Policy, Lloyd\+Step\+Type, Mat\+Type $>$\+::Metric (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
) const\hspace{0.3cm}{\ttfamily [inline]}}\label{classmlpack_1_1kmeans_1_1KMeans_ada82dc0c553d651916714832e5c16f9c}


Get the distance metric. 



Definition at line 164 of file kmeans.\+hpp.



References mlpack\+::kmeans\+::\+K\+Means$<$ Metric\+Type, Initial\+Partition\+Policy, Empty\+Cluster\+Policy, Lloyd\+Step\+Type, Mat\+Type $>$\+::metric.

\index{mlpack\+::kmeans\+::\+K\+Means@{mlpack\+::kmeans\+::\+K\+Means}!Metric@{Metric}}
\index{Metric@{Metric}!mlpack\+::kmeans\+::\+K\+Means@{mlpack\+::kmeans\+::\+K\+Means}}
\subsubsection[{Metric()}]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename Metric\+Type = metric\+::\+Euclidean\+Distance, typename Initial\+Partition\+Policy = Sample\+Initialization, typename Empty\+Cluster\+Policy = Max\+Variance\+New\+Cluster, template$<$ class, class $>$ class Lloyd\+Step\+Type = Naive\+K\+Means, typename Mat\+Type = arma\+::mat$>$ Metric\+Type\& {\bf mlpack\+::kmeans\+::\+K\+Means}$<$ Metric\+Type, Initial\+Partition\+Policy, Empty\+Cluster\+Policy, Lloyd\+Step\+Type, Mat\+Type $>$\+::Metric (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}}\label{classmlpack_1_1kmeans_1_1KMeans_ab6991f9bff882d8c50be0f350993dbf0}


Modify the distance metric. 



Definition at line 166 of file kmeans.\+hpp.



References mlpack\+::kmeans\+::\+K\+Means$<$ Metric\+Type, Initial\+Partition\+Policy, Empty\+Cluster\+Policy, Lloyd\+Step\+Type, Mat\+Type $>$\+::metric.

\index{mlpack\+::kmeans\+::\+K\+Means@{mlpack\+::kmeans\+::\+K\+Means}!Partitioner@{Partitioner}}
\index{Partitioner@{Partitioner}!mlpack\+::kmeans\+::\+K\+Means@{mlpack\+::kmeans\+::\+K\+Means}}
\subsubsection[{Partitioner() const }]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename Metric\+Type = metric\+::\+Euclidean\+Distance, typename Initial\+Partition\+Policy = Sample\+Initialization, typename Empty\+Cluster\+Policy = Max\+Variance\+New\+Cluster, template$<$ class, class $>$ class Lloyd\+Step\+Type = Naive\+K\+Means, typename Mat\+Type = arma\+::mat$>$ const Initial\+Partition\+Policy\& {\bf mlpack\+::kmeans\+::\+K\+Means}$<$ Metric\+Type, Initial\+Partition\+Policy, Empty\+Cluster\+Policy, Lloyd\+Step\+Type, Mat\+Type $>$\+::Partitioner (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
) const\hspace{0.3cm}{\ttfamily [inline]}}\label{classmlpack_1_1kmeans_1_1KMeans_a6b6845b04dfef81863cd2ca3f609d0d5}


Get the initial partitioning policy. 



Definition at line 169 of file kmeans.\+hpp.



References mlpack\+::kmeans\+::\+K\+Means$<$ Metric\+Type, Initial\+Partition\+Policy, Empty\+Cluster\+Policy, Lloyd\+Step\+Type, Mat\+Type $>$\+::partitioner.

\index{mlpack\+::kmeans\+::\+K\+Means@{mlpack\+::kmeans\+::\+K\+Means}!Partitioner@{Partitioner}}
\index{Partitioner@{Partitioner}!mlpack\+::kmeans\+::\+K\+Means@{mlpack\+::kmeans\+::\+K\+Means}}
\subsubsection[{Partitioner()}]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename Metric\+Type = metric\+::\+Euclidean\+Distance, typename Initial\+Partition\+Policy = Sample\+Initialization, typename Empty\+Cluster\+Policy = Max\+Variance\+New\+Cluster, template$<$ class, class $>$ class Lloyd\+Step\+Type = Naive\+K\+Means, typename Mat\+Type = arma\+::mat$>$ Initial\+Partition\+Policy\& {\bf mlpack\+::kmeans\+::\+K\+Means}$<$ Metric\+Type, Initial\+Partition\+Policy, Empty\+Cluster\+Policy, Lloyd\+Step\+Type, Mat\+Type $>$\+::Partitioner (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}}\label{classmlpack_1_1kmeans_1_1KMeans_a103b87719a3ac5ef4879633c1c5d4bb4}


Modify the initial partitioning policy. 



Definition at line 171 of file kmeans.\+hpp.



References mlpack\+::kmeans\+::\+K\+Means$<$ Metric\+Type, Initial\+Partition\+Policy, Empty\+Cluster\+Policy, Lloyd\+Step\+Type, Mat\+Type $>$\+::partitioner.

\index{mlpack\+::kmeans\+::\+K\+Means@{mlpack\+::kmeans\+::\+K\+Means}!Serialize@{Serialize}}
\index{Serialize@{Serialize}!mlpack\+::kmeans\+::\+K\+Means@{mlpack\+::kmeans\+::\+K\+Means}}
\subsubsection[{Serialize(\+Archive \&ar, const unsigned int version)}]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename Metric\+Type = metric\+::\+Euclidean\+Distance, typename Initial\+Partition\+Policy = Sample\+Initialization, typename Empty\+Cluster\+Policy = Max\+Variance\+New\+Cluster, template$<$ class, class $>$ class Lloyd\+Step\+Type = Naive\+K\+Means, typename Mat\+Type = arma\+::mat$>$ template$<$typename Archive $>$ void {\bf mlpack\+::kmeans\+::\+K\+Means}$<$ Metric\+Type, Initial\+Partition\+Policy, Empty\+Cluster\+Policy, Lloyd\+Step\+Type, Mat\+Type $>$\+::Serialize (
\begin{DoxyParamCaption}
\item[{Archive \&}]{ar, }
\item[{const unsigned int}]{version}
\end{DoxyParamCaption}
)}\label{classmlpack_1_1kmeans_1_1KMeans_afba744b80f7b960f3eea494b07dc87f0}


Serialize the k-\/means object. 



Referenced by mlpack\+::kmeans\+::\+K\+Means$<$ Metric\+Type, Initial\+Partition\+Policy, Empty\+Cluster\+Policy, Lloyd\+Step\+Type, Mat\+Type $>$\+::\+Empty\+Cluster\+Action().



\subsection{Member Data Documentation}
\index{mlpack\+::kmeans\+::\+K\+Means@{mlpack\+::kmeans\+::\+K\+Means}!empty\+Cluster\+Action@{empty\+Cluster\+Action}}
\index{empty\+Cluster\+Action@{empty\+Cluster\+Action}!mlpack\+::kmeans\+::\+K\+Means@{mlpack\+::kmeans\+::\+K\+Means}}
\subsubsection[{empty\+Cluster\+Action}]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename Metric\+Type = metric\+::\+Euclidean\+Distance, typename Initial\+Partition\+Policy = Sample\+Initialization, typename Empty\+Cluster\+Policy = Max\+Variance\+New\+Cluster, template$<$ class, class $>$ class Lloyd\+Step\+Type = Naive\+K\+Means, typename Mat\+Type = arma\+::mat$>$ Empty\+Cluster\+Policy {\bf mlpack\+::kmeans\+::\+K\+Means}$<$ Metric\+Type, Initial\+Partition\+Policy, Empty\+Cluster\+Policy, Lloyd\+Step\+Type, Mat\+Type $>$\+::empty\+Cluster\+Action\hspace{0.3cm}{\ttfamily [private]}}\label{classmlpack_1_1kmeans_1_1KMeans_ae6b9eb8f0b802c347b59147d0682dd84}


Instantiated empty cluster policy. 



Definition at line 191 of file kmeans.\+hpp.



Referenced by mlpack\+::kmeans\+::\+K\+Means$<$ Metric\+Type, Initial\+Partition\+Policy, Empty\+Cluster\+Policy, Lloyd\+Step\+Type, Mat\+Type $>$\+::\+Empty\+Cluster\+Action().

\index{mlpack\+::kmeans\+::\+K\+Means@{mlpack\+::kmeans\+::\+K\+Means}!max\+Iterations@{max\+Iterations}}
\index{max\+Iterations@{max\+Iterations}!mlpack\+::kmeans\+::\+K\+Means@{mlpack\+::kmeans\+::\+K\+Means}}
\subsubsection[{max\+Iterations}]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename Metric\+Type = metric\+::\+Euclidean\+Distance, typename Initial\+Partition\+Policy = Sample\+Initialization, typename Empty\+Cluster\+Policy = Max\+Variance\+New\+Cluster, template$<$ class, class $>$ class Lloyd\+Step\+Type = Naive\+K\+Means, typename Mat\+Type = arma\+::mat$>$ size\+\_\+t {\bf mlpack\+::kmeans\+::\+K\+Means}$<$ Metric\+Type, Initial\+Partition\+Policy, Empty\+Cluster\+Policy, Lloyd\+Step\+Type, Mat\+Type $>$\+::max\+Iterations\hspace{0.3cm}{\ttfamily [private]}}\label{classmlpack_1_1kmeans_1_1KMeans_a6266e8621059f1c9c7069de2eec231d2}


Maximum number of iterations before giving up. 



Definition at line 185 of file kmeans.\+hpp.



Referenced by mlpack\+::kmeans\+::\+K\+Means$<$ Metric\+Type, Initial\+Partition\+Policy, Empty\+Cluster\+Policy, Lloyd\+Step\+Type, Mat\+Type $>$\+::\+Max\+Iterations().

\index{mlpack\+::kmeans\+::\+K\+Means@{mlpack\+::kmeans\+::\+K\+Means}!metric@{metric}}
\index{metric@{metric}!mlpack\+::kmeans\+::\+K\+Means@{mlpack\+::kmeans\+::\+K\+Means}}
\subsubsection[{metric}]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename Metric\+Type = metric\+::\+Euclidean\+Distance, typename Initial\+Partition\+Policy = Sample\+Initialization, typename Empty\+Cluster\+Policy = Max\+Variance\+New\+Cluster, template$<$ class, class $>$ class Lloyd\+Step\+Type = Naive\+K\+Means, typename Mat\+Type = arma\+::mat$>$ Metric\+Type {\bf mlpack\+::kmeans\+::\+K\+Means}$<$ Metric\+Type, Initial\+Partition\+Policy, Empty\+Cluster\+Policy, Lloyd\+Step\+Type, Mat\+Type $>$\+::metric\hspace{0.3cm}{\ttfamily [private]}}\label{classmlpack_1_1kmeans_1_1KMeans_a1dfcaa33234c8334804840754d82927d}


Instantiated distance metric. 



Definition at line 187 of file kmeans.\+hpp.



Referenced by mlpack\+::kmeans\+::\+K\+Means$<$ Metric\+Type, Initial\+Partition\+Policy, Empty\+Cluster\+Policy, Lloyd\+Step\+Type, Mat\+Type $>$\+::\+Metric().

\index{mlpack\+::kmeans\+::\+K\+Means@{mlpack\+::kmeans\+::\+K\+Means}!partitioner@{partitioner}}
\index{partitioner@{partitioner}!mlpack\+::kmeans\+::\+K\+Means@{mlpack\+::kmeans\+::\+K\+Means}}
\subsubsection[{partitioner}]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename Metric\+Type = metric\+::\+Euclidean\+Distance, typename Initial\+Partition\+Policy = Sample\+Initialization, typename Empty\+Cluster\+Policy = Max\+Variance\+New\+Cluster, template$<$ class, class $>$ class Lloyd\+Step\+Type = Naive\+K\+Means, typename Mat\+Type = arma\+::mat$>$ Initial\+Partition\+Policy {\bf mlpack\+::kmeans\+::\+K\+Means}$<$ Metric\+Type, Initial\+Partition\+Policy, Empty\+Cluster\+Policy, Lloyd\+Step\+Type, Mat\+Type $>$\+::partitioner\hspace{0.3cm}{\ttfamily [private]}}\label{classmlpack_1_1kmeans_1_1KMeans_aac89d410ac613a9f845992af40d41483}


Instantiated initial partitioning policy. 



Definition at line 189 of file kmeans.\+hpp.



Referenced by mlpack\+::kmeans\+::\+K\+Means$<$ Metric\+Type, Initial\+Partition\+Policy, Empty\+Cluster\+Policy, Lloyd\+Step\+Type, Mat\+Type $>$\+::\+Partitioner().



The documentation for this class was generated from the following file\+:\begin{DoxyCompactItemize}
\item 
src/mlpack/methods/kmeans/{\bf kmeans.\+hpp}\end{DoxyCompactItemize}
