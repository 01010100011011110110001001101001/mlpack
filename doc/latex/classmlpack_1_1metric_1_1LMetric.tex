\section{mlpack\+:\+:metric\+:\+:L\+Metric$<$ T\+Power, T\+Take\+Root $>$ Class Template Reference}
\label{classmlpack_1_1metric_1_1LMetric}\index{mlpack\+::metric\+::\+L\+Metric$<$ T\+Power, T\+Take\+Root $>$@{mlpack\+::metric\+::\+L\+Metric$<$ T\+Power, T\+Take\+Root $>$}}


The L\+\_\+p metric for arbitrary integer p, with an option to take the root.  


\subsection*{Public Member Functions}
\begin{DoxyCompactItemize}
\item 
{\bf L\+Metric} ()
\item 
{\footnotesize template$<$typename Archive $>$ }\\void {\bf Serialize} (Archive \&, const unsigned int)
\begin{DoxyCompactList}\small\item\em Serialize the metric (nothing to do). \end{DoxyCompactList}\end{DoxyCompactItemize}
\subsection*{Static Public Member Functions}
\begin{DoxyCompactItemize}
\item 
{\footnotesize template$<$typename Vec\+TypeA , typename Vec\+TypeB $>$ }\\static Vec\+Type\+A\+::elem\+\_\+type {\bf Evaluate} (const Vec\+TypeA \&a, const Vec\+TypeB \&b)
\begin{DoxyCompactList}\small\item\em Computes the distance between two points. \end{DoxyCompactList}\end{DoxyCompactItemize}
\subsection*{Static Public Attributes}
\begin{DoxyCompactItemize}
\item 
static const int {\bf Power} = T\+Power
\begin{DoxyCompactList}\small\item\em The power of the metric. \end{DoxyCompactList}\item 
static const bool {\bf Take\+Root} = T\+Take\+Root
\begin{DoxyCompactList}\small\item\em Whether or not the root is taken. \end{DoxyCompactList}\end{DoxyCompactItemize}


\subsection{Detailed Description}
\subsubsection*{template$<$int T\+Power, bool T\+Take\+Root = true$>$\\*
class mlpack\+::metric\+::\+L\+Metric$<$ T\+Power, T\+Take\+Root $>$}

The L\+\_\+p metric for arbitrary integer p, with an option to take the root. 

This class implements the standard L\+\_\+p metric for two arbitrary vectors $ x $ and $ y $ of dimensionality $ n $\+:

\[ d(x, y) = \left( \sum_{i = 1}^{n} | x_i - y_i |^p \right)^{\frac{1}{p}}. \]

The value of p is given as a template parameter.

In addition, the function $ d(x, y) $ can be simplified, neglecting the p-\/root calculation. This is done by specifying the Take\+Root template parameter to be false. Then,

\[ d(x, y) = \sum_{i = 1}^{n} | x_i - y_i |^p \]

It is faster to compute that distance, so Take\+Root is by default off. However, when Take\+Root is false, the distance given is not actually a true metric -- it does not satisfy the triangle inequality. Some mlpack methods do not require the triangle inequality to operate correctly (such as the Binary\+Space\+Tree), but setting Take\+Root = false in some cases will cause incorrect results.

A few convenience typedefs are given\+:


\begin{DoxyItemize}
\item Manhattan\+Distance
\item Euclidean\+Distance
\item Squared\+Euclidean\+Distance
\end{DoxyItemize}


\begin{DoxyTemplParams}{Template Parameters}
{\em Power} & Power of metric; i.\+e. Power = 1 gives the L1-\/norm (Manhattan distance). \\
\hline
{\em Take\+Root} & If true, the Power\textquotesingle{}th root of the result is taken before it is returned. Setting this to false causes the metric to not satisfy the Triangle Inequality (be careful!). \\
\hline
\end{DoxyTemplParams}


Definition at line 63 of file lmetric.\+hpp.



\subsection{Constructor \& Destructor Documentation}
\index{mlpack\+::metric\+::\+L\+Metric@{mlpack\+::metric\+::\+L\+Metric}!L\+Metric@{L\+Metric}}
\index{L\+Metric@{L\+Metric}!mlpack\+::metric\+::\+L\+Metric@{mlpack\+::metric\+::\+L\+Metric}}
\subsubsection[{L\+Metric()}]{\setlength{\rightskip}{0pt plus 5cm}template$<$int T\+Power, bool T\+Take\+Root = true$>$ {\bf mlpack\+::metric\+::\+L\+Metric}$<$ T\+Power, T\+Take\+Root $>$\+::{\bf L\+Metric} (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}}\label{classmlpack_1_1metric_1_1LMetric_aacb79ee507f830c1e9e2793520959aff}


Definition at line 70 of file lmetric.\+hpp.



References mlpack\+::metric\+::\+L\+Metric$<$ T\+Power, T\+Take\+Root $>$\+::\+Evaluate().



\subsection{Member Function Documentation}
\index{mlpack\+::metric\+::\+L\+Metric@{mlpack\+::metric\+::\+L\+Metric}!Evaluate@{Evaluate}}
\index{Evaluate@{Evaluate}!mlpack\+::metric\+::\+L\+Metric@{mlpack\+::metric\+::\+L\+Metric}}
\subsubsection[{Evaluate(const Vec\+Type\+A \&a, const Vec\+Type\+B \&b)}]{\setlength{\rightskip}{0pt plus 5cm}template$<$int T\+Power, bool T\+Take\+Root = true$>$ template$<$typename Vec\+TypeA , typename Vec\+TypeB $>$ static Vec\+Type\+A\+::elem\+\_\+type {\bf mlpack\+::metric\+::\+L\+Metric}$<$ T\+Power, T\+Take\+Root $>$\+::Evaluate (
\begin{DoxyParamCaption}
\item[{const Vec\+TypeA \&}]{a, }
\item[{const Vec\+TypeB \&}]{b}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [static]}}\label{classmlpack_1_1metric_1_1LMetric_ac55458730b8e36f51d2f2a3741b77181}


Computes the distance between two points. 


\begin{DoxyTemplParams}{Template Parameters}
{\em Vec\+TypeA} & Type of first vector (generally arma\+::vec or arma\+::sp\+\_\+vec). \\
\hline
{\em Vec\+TypeB} & Type of second vector. \\
\hline
\end{DoxyTemplParams}

\begin{DoxyParams}{Parameters}
{\em a} & First vector. \\
\hline
{\em b} & Second vector. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
Distance between vectors a and b. 
\end{DoxyReturn}


Referenced by mlpack\+::kernel\+::\+Spherical\+Kernel\+::\+Convolution\+Integral(), mlpack\+::kernel\+::\+Gaussian\+Kernel\+::\+Convolution\+Integral(), mlpack\+::kernel\+::\+Spherical\+Kernel\+::\+Evaluate(), mlpack\+::kernel\+::\+Triangular\+Kernel\+::\+Evaluate(), mlpack\+::kernel\+::\+Laplacian\+Kernel\+::\+Evaluate(), mlpack\+::kernel\+::\+Gaussian\+Kernel\+::\+Evaluate(), and mlpack\+::metric\+::\+L\+Metric$<$ T\+Power, T\+Take\+Root $>$\+::\+L\+Metric().

\index{mlpack\+::metric\+::\+L\+Metric@{mlpack\+::metric\+::\+L\+Metric}!Serialize@{Serialize}}
\index{Serialize@{Serialize}!mlpack\+::metric\+::\+L\+Metric@{mlpack\+::metric\+::\+L\+Metric}}
\subsubsection[{Serialize(\+Archive \&, const unsigned int)}]{\setlength{\rightskip}{0pt plus 5cm}template$<$int T\+Power, bool T\+Take\+Root = true$>$ template$<$typename Archive $>$ void {\bf mlpack\+::metric\+::\+L\+Metric}$<$ T\+Power, T\+Take\+Root $>$\+::Serialize (
\begin{DoxyParamCaption}
\item[{Archive \&}]{, }
\item[{const unsigned}]{int}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}}\label{classmlpack_1_1metric_1_1LMetric_aa20f06986d77d8e177f3c8f5435bbabf}


Serialize the metric (nothing to do). 



Definition at line 88 of file lmetric.\+hpp.



\subsection{Member Data Documentation}
\index{mlpack\+::metric\+::\+L\+Metric@{mlpack\+::metric\+::\+L\+Metric}!Power@{Power}}
\index{Power@{Power}!mlpack\+::metric\+::\+L\+Metric@{mlpack\+::metric\+::\+L\+Metric}}
\subsubsection[{Power}]{\setlength{\rightskip}{0pt plus 5cm}template$<$int T\+Power, bool T\+Take\+Root = true$>$ const int {\bf mlpack\+::metric\+::\+L\+Metric}$<$ T\+Power, T\+Take\+Root $>$\+::Power = T\+Power\hspace{0.3cm}{\ttfamily [static]}}\label{classmlpack_1_1metric_1_1LMetric_a069e1dc018315ab1eb5be08e153221c3}


The power of the metric. 



Definition at line 91 of file lmetric.\+hpp.

\index{mlpack\+::metric\+::\+L\+Metric@{mlpack\+::metric\+::\+L\+Metric}!Take\+Root@{Take\+Root}}
\index{Take\+Root@{Take\+Root}!mlpack\+::metric\+::\+L\+Metric@{mlpack\+::metric\+::\+L\+Metric}}
\subsubsection[{Take\+Root}]{\setlength{\rightskip}{0pt plus 5cm}template$<$int T\+Power, bool T\+Take\+Root = true$>$ const bool {\bf mlpack\+::metric\+::\+L\+Metric}$<$ T\+Power, T\+Take\+Root $>$\+::Take\+Root = T\+Take\+Root\hspace{0.3cm}{\ttfamily [static]}}\label{classmlpack_1_1metric_1_1LMetric_af3775490c1d930cf45d660d8052ee6db}


Whether or not the root is taken. 



Definition at line 93 of file lmetric.\+hpp.



The documentation for this class was generated from the following file\+:\begin{DoxyCompactItemize}
\item 
src/mlpack/core/metrics/{\bf lmetric.\+hpp}\end{DoxyCompactItemize}
