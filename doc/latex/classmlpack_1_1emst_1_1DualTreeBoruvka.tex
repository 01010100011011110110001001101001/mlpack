\section{mlpack\+:\+:emst\+:\+:Dual\+Tree\+Boruvka$<$ Metric\+Type, Mat\+Type, Tree\+Type $>$ Class Template Reference}
\label{classmlpack_1_1emst_1_1DualTreeBoruvka}\index{mlpack\+::emst\+::\+Dual\+Tree\+Boruvka$<$ Metric\+Type, Mat\+Type, Tree\+Type $>$@{mlpack\+::emst\+::\+Dual\+Tree\+Boruvka$<$ Metric\+Type, Mat\+Type, Tree\+Type $>$}}


Performs the M\+ST calculation using the Dual-\/\+Tree Boruvka algorithm, using any type of tree.  


\subsection*{Classes}
\begin{DoxyCompactItemize}
\item 
struct {\bf Sort\+Edges\+Helper}
\begin{DoxyCompactList}\small\item\em For sorting the edge list after the computation. \end{DoxyCompactList}\end{DoxyCompactItemize}
\subsection*{Public Types}
\begin{DoxyCompactItemize}
\item 
typedef Tree\+Type$<$ Metric\+Type, {\bf D\+T\+B\+Stat}, Mat\+Type $>$ {\bf Tree}
\begin{DoxyCompactList}\small\item\em Convenience typedef. \end{DoxyCompactList}\end{DoxyCompactItemize}
\subsection*{Public Member Functions}
\begin{DoxyCompactItemize}
\item 
{\bf Dual\+Tree\+Boruvka} (const Mat\+Type \&dataset, const bool {\bf naive}=false, const Metric\+Type {\bf metric}=Metric\+Type())
\begin{DoxyCompactList}\small\item\em Create the tree from the given dataset. \end{DoxyCompactList}\item 
{\bf Dual\+Tree\+Boruvka} ({\bf Tree} $\ast${\bf tree}, const Metric\+Type {\bf metric}=Metric\+Type())
\begin{DoxyCompactList}\small\item\em Create the \doxyref{Dual\+Tree\+Boruvka}{p.}{classmlpack_1_1emst_1_1DualTreeBoruvka} object with an already initialized tree. \end{DoxyCompactList}\item 
{\bf $\sim$\+Dual\+Tree\+Boruvka} ()
\begin{DoxyCompactList}\small\item\em Delete the tree, if it was created inside the object. \end{DoxyCompactList}\item 
void {\bf Compute\+M\+ST} (arma\+::mat \&results)
\begin{DoxyCompactList}\small\item\em Iteratively find the nearest neighbor of each component until the M\+ST is complete. \end{DoxyCompactList}\end{DoxyCompactItemize}
\subsection*{Private Member Functions}
\begin{DoxyCompactItemize}
\item 
void {\bf Add\+All\+Edges} ()
\begin{DoxyCompactList}\small\item\em Adds all the edges found in one iteration to the list of neighbors. \end{DoxyCompactList}\item 
void {\bf Add\+Edge} (const size\+\_\+t e1, const size\+\_\+t e2, const double distance)
\begin{DoxyCompactList}\small\item\em Adds a single edge to the edge list. \end{DoxyCompactList}\item 
void {\bf Cleanup} ()
\begin{DoxyCompactList}\small\item\em The values stored in the tree must be reset on each iteration. \end{DoxyCompactList}\item 
void {\bf Cleanup\+Helper} ({\bf Tree} $\ast${\bf tree})
\begin{DoxyCompactList}\small\item\em This function resets the values in the nodes of the tree nearest neighbor distance, and checks for fully connected nodes. \end{DoxyCompactList}\item 
void {\bf Emit\+Results} (arma\+::mat \&results)
\begin{DoxyCompactList}\small\item\em Unpermute the edge list and output it to results. \end{DoxyCompactList}\end{DoxyCompactItemize}
\subsection*{Private Attributes}
\begin{DoxyCompactItemize}
\item 
{\bf Union\+Find} {\bf connections}
\begin{DoxyCompactList}\small\item\em Connections. \end{DoxyCompactList}\item 
const Mat\+Type \& {\bf data}
\begin{DoxyCompactList}\small\item\em Reference to the data (this is what should be used for accessing data). \end{DoxyCompactList}\item 
std\+::vector$<$ {\bf Edge\+Pair} $>$ {\bf edges}
\begin{DoxyCompactList}\small\item\em Edges. \end{DoxyCompactList}\item 
Metric\+Type {\bf metric}
\begin{DoxyCompactList}\small\item\em The instantiated metric. \end{DoxyCompactList}\item 
bool {\bf naive}
\begin{DoxyCompactList}\small\item\em Indicates whether or not O(n$^\wedge$2) naive mode will be used. \end{DoxyCompactList}\item 
arma\+::vec {\bf neighbors\+Distances}
\begin{DoxyCompactList}\small\item\em List of edge distances. \end{DoxyCompactList}\item 
arma\+::\+Col$<$ size\+\_\+t $>$ {\bf neighbors\+In\+Component}
\begin{DoxyCompactList}\small\item\em List of edge nodes. \end{DoxyCompactList}\item 
arma\+::\+Col$<$ size\+\_\+t $>$ {\bf neighbors\+Out\+Component}
\begin{DoxyCompactList}\small\item\em List of edge nodes. \end{DoxyCompactList}\item 
std\+::vector$<$ size\+\_\+t $>$ {\bf old\+From\+New}
\begin{DoxyCompactList}\small\item\em Permutations of points during tree building. \end{DoxyCompactList}\item 
bool {\bf own\+Tree}
\begin{DoxyCompactList}\small\item\em Indicates whether or not we \char`\"{}own\char`\"{} the tree. \end{DoxyCompactList}\item 
struct {\bf mlpack\+::emst\+::\+Dual\+Tree\+Boruvka\+::\+Sort\+Edges\+Helper} {\bf Sort\+Fun}
\item 
double {\bf total\+Dist}
\begin{DoxyCompactList}\small\item\em Total distance of the tree. \end{DoxyCompactList}\item 
{\bf Tree} $\ast$ {\bf tree}
\begin{DoxyCompactList}\small\item\em Pointer to the root of the tree. \end{DoxyCompactList}\end{DoxyCompactItemize}


\subsection{Detailed Description}
\subsubsection*{template$<$typename Metric\+Type = metric\+::\+Euclidean\+Distance, typename Mat\+Type = arma\+::mat, template$<$ typename Tree\+Metric\+Type, typename Tree\+Stat\+Type, typename Tree\+Mat\+Type $>$ class Tree\+Type = tree\+::\+K\+D\+Tree$>$\\*
class mlpack\+::emst\+::\+Dual\+Tree\+Boruvka$<$ Metric\+Type, Mat\+Type, Tree\+Type $>$}

Performs the M\+ST calculation using the Dual-\/\+Tree Boruvka algorithm, using any type of tree. 

For more information on the algorithm, see the following citation\+:


\begin{DoxyCode}
@inproceedings\{
  author = \{March, W.B., Ram, P., and Gray, A.G.\},
  title = \{\{Fast Euclidean Minimum Spanning Tree: Algorithm, Analysis,
     Applications.\}\},
  booktitle = \{Proceedings of the 16th ACM SIGKDD International Conference
     on Knowledge Discovery and Data Mining\}
  series = \{KDD 2010\},
  year = \{2010\}
\}
\end{DoxyCode}


General usage of this class might be like this\+:


\begin{DoxyCode}
\textcolor{keyword}{extern} arma::mat data; \textcolor{comment}{// We want to find the MST of this dataset.}
DualTreeBoruvka<> dtb(data); \textcolor{comment}{// Create the tree with default options.}

\textcolor{comment}{// Find the MST.}
arma::mat mstResults;
dtb.ComputeMST(mstResults);
\end{DoxyCode}


More advanced usage of the class can use different types of trees, pass in an already-\/built tree, or compute the M\+ST using the O(n$^\wedge$2) naive algorithm.


\begin{DoxyTemplParams}{Template Parameters}
{\em Metric\+Type} & The metric to use. \\
\hline
{\em Mat\+Type} & The type of data matrix to use. \\
\hline
{\em Tree\+Type} & Type of tree to use. This should follow the Tree\+Type policy A\+PI. \\
\hline
\end{DoxyTemplParams}


Definition at line 83 of file dtb.\+hpp.



\subsection{Member Typedef Documentation}
\index{mlpack\+::emst\+::\+Dual\+Tree\+Boruvka@{mlpack\+::emst\+::\+Dual\+Tree\+Boruvka}!Tree@{Tree}}
\index{Tree@{Tree}!mlpack\+::emst\+::\+Dual\+Tree\+Boruvka@{mlpack\+::emst\+::\+Dual\+Tree\+Boruvka}}
\subsubsection[{Tree}]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename Metric\+Type  = metric\+::\+Euclidean\+Distance, typename Mat\+Type  = arma\+::mat, template$<$ typename Tree\+Metric\+Type, typename Tree\+Stat\+Type, typename Tree\+Mat\+Type $>$ class Tree\+Type = tree\+::\+K\+D\+Tree$>$ typedef Tree\+Type$<$Metric\+Type, {\bf D\+T\+B\+Stat}, Mat\+Type$>$ {\bf mlpack\+::emst\+::\+Dual\+Tree\+Boruvka}$<$ Metric\+Type, Mat\+Type, Tree\+Type $>$\+::{\bf Tree}}\label{classmlpack_1_1emst_1_1DualTreeBoruvka_a5f615f6c61816ecd32e67a0109ae2b1a}


Convenience typedef. 



Definition at line 87 of file dtb.\+hpp.



\subsection{Constructor \& Destructor Documentation}
\index{mlpack\+::emst\+::\+Dual\+Tree\+Boruvka@{mlpack\+::emst\+::\+Dual\+Tree\+Boruvka}!Dual\+Tree\+Boruvka@{Dual\+Tree\+Boruvka}}
\index{Dual\+Tree\+Boruvka@{Dual\+Tree\+Boruvka}!mlpack\+::emst\+::\+Dual\+Tree\+Boruvka@{mlpack\+::emst\+::\+Dual\+Tree\+Boruvka}}
\subsubsection[{Dual\+Tree\+Boruvka(const Mat\+Type \&dataset, const bool naive=false, const Metric\+Type metric=\+Metric\+Type())}]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename Metric\+Type  = metric\+::\+Euclidean\+Distance, typename Mat\+Type  = arma\+::mat, template$<$ typename Tree\+Metric\+Type, typename Tree\+Stat\+Type, typename Tree\+Mat\+Type $>$ class Tree\+Type = tree\+::\+K\+D\+Tree$>$ {\bf mlpack\+::emst\+::\+Dual\+Tree\+Boruvka}$<$ Metric\+Type, Mat\+Type, Tree\+Type $>$\+::{\bf Dual\+Tree\+Boruvka} (
\begin{DoxyParamCaption}
\item[{const Mat\+Type \&}]{dataset, }
\item[{const bool}]{naive = {\ttfamily false}, }
\item[{const Metric\+Type}]{metric = {\ttfamily MetricType()}}
\end{DoxyParamCaption}
)}\label{classmlpack_1_1emst_1_1DualTreeBoruvka_a85ee2a291ca5f2f81ef7ff612a67bfca}


Create the tree from the given dataset. 

This copies the dataset to an internal copy, because tree-\/building modifies the dataset.


\begin{DoxyParams}{Parameters}
{\em data} & Dataset to build a tree for. \\
\hline
{\em naive} & Whether the computation should be done in O(n$^\wedge$2) naive mode. \\
\hline
{\em metric} & An optional instantiated metric to use. \\
\hline
\end{DoxyParams}


Referenced by mlpack\+::emst\+::\+Dual\+Tree\+Boruvka$<$ Metric\+Type, Mat\+Type, Tree\+Type $>$\+::\+Sort\+Edges\+Helper\+::operator()().

\index{mlpack\+::emst\+::\+Dual\+Tree\+Boruvka@{mlpack\+::emst\+::\+Dual\+Tree\+Boruvka}!Dual\+Tree\+Boruvka@{Dual\+Tree\+Boruvka}}
\index{Dual\+Tree\+Boruvka@{Dual\+Tree\+Boruvka}!mlpack\+::emst\+::\+Dual\+Tree\+Boruvka@{mlpack\+::emst\+::\+Dual\+Tree\+Boruvka}}
\subsubsection[{Dual\+Tree\+Boruvka(\+Tree $\ast$tree, const Metric\+Type metric=\+Metric\+Type())}]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename Metric\+Type  = metric\+::\+Euclidean\+Distance, typename Mat\+Type  = arma\+::mat, template$<$ typename Tree\+Metric\+Type, typename Tree\+Stat\+Type, typename Tree\+Mat\+Type $>$ class Tree\+Type = tree\+::\+K\+D\+Tree$>$ {\bf mlpack\+::emst\+::\+Dual\+Tree\+Boruvka}$<$ Metric\+Type, Mat\+Type, Tree\+Type $>$\+::{\bf Dual\+Tree\+Boruvka} (
\begin{DoxyParamCaption}
\item[{{\bf Tree} $\ast$}]{tree, }
\item[{const Metric\+Type}]{metric = {\ttfamily MetricType()}}
\end{DoxyParamCaption}
)}\label{classmlpack_1_1emst_1_1DualTreeBoruvka_aab8ee208a3b3ddfe2a1648920bf84242}


Create the \doxyref{Dual\+Tree\+Boruvka}{p.}{classmlpack_1_1emst_1_1DualTreeBoruvka} object with an already initialized tree. 

This will not copy the dataset, and can save a little processing power. Naive mode is not available as an option for this constructor; instead, to run naive computation, construct a tree with all the points in one leaf (i.\+e. leaf\+Size = number of points).

\begin{DoxyNote}{Note}
Because tree-\/building (at least with Binary\+Space\+Tree) modifies the ordering of a matrix, be sure you pass the modified matrix to this object! In addition, mapping the points of the matrix back to their original indices is not done when this constructor is used. 
\end{DoxyNote}

\begin{DoxyParams}{Parameters}
{\em tree} & Pre-\/built tree. \\
\hline
{\em metric} & An optional instantiated metric to use. \\
\hline
\end{DoxyParams}
\index{mlpack\+::emst\+::\+Dual\+Tree\+Boruvka@{mlpack\+::emst\+::\+Dual\+Tree\+Boruvka}!````~Dual\+Tree\+Boruvka@{$\sim$\+Dual\+Tree\+Boruvka}}
\index{````~Dual\+Tree\+Boruvka@{$\sim$\+Dual\+Tree\+Boruvka}!mlpack\+::emst\+::\+Dual\+Tree\+Boruvka@{mlpack\+::emst\+::\+Dual\+Tree\+Boruvka}}
\subsubsection[{$\sim$\+Dual\+Tree\+Boruvka()}]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename Metric\+Type  = metric\+::\+Euclidean\+Distance, typename Mat\+Type  = arma\+::mat, template$<$ typename Tree\+Metric\+Type, typename Tree\+Stat\+Type, typename Tree\+Mat\+Type $>$ class Tree\+Type = tree\+::\+K\+D\+Tree$>$ {\bf mlpack\+::emst\+::\+Dual\+Tree\+Boruvka}$<$ Metric\+Type, Mat\+Type, Tree\+Type $>$\+::$\sim${\bf Dual\+Tree\+Boruvka} (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)}\label{classmlpack_1_1emst_1_1DualTreeBoruvka_ad44ef8a348f014b67a4593650a544450}


Delete the tree, if it was created inside the object. 



Referenced by mlpack\+::emst\+::\+Dual\+Tree\+Boruvka$<$ Metric\+Type, Mat\+Type, Tree\+Type $>$\+::\+Sort\+Edges\+Helper\+::operator()().



\subsection{Member Function Documentation}
\index{mlpack\+::emst\+::\+Dual\+Tree\+Boruvka@{mlpack\+::emst\+::\+Dual\+Tree\+Boruvka}!Add\+All\+Edges@{Add\+All\+Edges}}
\index{Add\+All\+Edges@{Add\+All\+Edges}!mlpack\+::emst\+::\+Dual\+Tree\+Boruvka@{mlpack\+::emst\+::\+Dual\+Tree\+Boruvka}}
\subsubsection[{Add\+All\+Edges()}]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename Metric\+Type  = metric\+::\+Euclidean\+Distance, typename Mat\+Type  = arma\+::mat, template$<$ typename Tree\+Metric\+Type, typename Tree\+Stat\+Type, typename Tree\+Mat\+Type $>$ class Tree\+Type = tree\+::\+K\+D\+Tree$>$ void {\bf mlpack\+::emst\+::\+Dual\+Tree\+Boruvka}$<$ Metric\+Type, Mat\+Type, Tree\+Type $>$\+::Add\+All\+Edges (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [private]}}\label{classmlpack_1_1emst_1_1DualTreeBoruvka_a85226a9b312f2e7ac51d5b0292aa5513}


Adds all the edges found in one iteration to the list of neighbors. 



Referenced by mlpack\+::emst\+::\+Dual\+Tree\+Boruvka$<$ Metric\+Type, Mat\+Type, Tree\+Type $>$\+::\+Sort\+Edges\+Helper\+::operator()().

\index{mlpack\+::emst\+::\+Dual\+Tree\+Boruvka@{mlpack\+::emst\+::\+Dual\+Tree\+Boruvka}!Add\+Edge@{Add\+Edge}}
\index{Add\+Edge@{Add\+Edge}!mlpack\+::emst\+::\+Dual\+Tree\+Boruvka@{mlpack\+::emst\+::\+Dual\+Tree\+Boruvka}}
\subsubsection[{Add\+Edge(const size\+\_\+t e1, const size\+\_\+t e2, const double distance)}]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename Metric\+Type  = metric\+::\+Euclidean\+Distance, typename Mat\+Type  = arma\+::mat, template$<$ typename Tree\+Metric\+Type, typename Tree\+Stat\+Type, typename Tree\+Mat\+Type $>$ class Tree\+Type = tree\+::\+K\+D\+Tree$>$ void {\bf mlpack\+::emst\+::\+Dual\+Tree\+Boruvka}$<$ Metric\+Type, Mat\+Type, Tree\+Type $>$\+::Add\+Edge (
\begin{DoxyParamCaption}
\item[{const size\+\_\+t}]{e1, }
\item[{const size\+\_\+t}]{e2, }
\item[{const double}]{distance}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [private]}}\label{classmlpack_1_1emst_1_1DualTreeBoruvka_a5f821d770877de04a9d77a08ef8a9b55}


Adds a single edge to the edge list. 



Referenced by mlpack\+::emst\+::\+Dual\+Tree\+Boruvka$<$ Metric\+Type, Mat\+Type, Tree\+Type $>$\+::\+Sort\+Edges\+Helper\+::operator()().

\index{mlpack\+::emst\+::\+Dual\+Tree\+Boruvka@{mlpack\+::emst\+::\+Dual\+Tree\+Boruvka}!Cleanup@{Cleanup}}
\index{Cleanup@{Cleanup}!mlpack\+::emst\+::\+Dual\+Tree\+Boruvka@{mlpack\+::emst\+::\+Dual\+Tree\+Boruvka}}
\subsubsection[{Cleanup()}]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename Metric\+Type  = metric\+::\+Euclidean\+Distance, typename Mat\+Type  = arma\+::mat, template$<$ typename Tree\+Metric\+Type, typename Tree\+Stat\+Type, typename Tree\+Mat\+Type $>$ class Tree\+Type = tree\+::\+K\+D\+Tree$>$ void {\bf mlpack\+::emst\+::\+Dual\+Tree\+Boruvka}$<$ Metric\+Type, Mat\+Type, Tree\+Type $>$\+::Cleanup (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [private]}}\label{classmlpack_1_1emst_1_1DualTreeBoruvka_ad0cc9a95c04a9efab7cbf5de072047fb}


The values stored in the tree must be reset on each iteration. 



Referenced by mlpack\+::emst\+::\+Dual\+Tree\+Boruvka$<$ Metric\+Type, Mat\+Type, Tree\+Type $>$\+::\+Sort\+Edges\+Helper\+::operator()().

\index{mlpack\+::emst\+::\+Dual\+Tree\+Boruvka@{mlpack\+::emst\+::\+Dual\+Tree\+Boruvka}!Cleanup\+Helper@{Cleanup\+Helper}}
\index{Cleanup\+Helper@{Cleanup\+Helper}!mlpack\+::emst\+::\+Dual\+Tree\+Boruvka@{mlpack\+::emst\+::\+Dual\+Tree\+Boruvka}}
\subsubsection[{Cleanup\+Helper(\+Tree $\ast$tree)}]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename Metric\+Type  = metric\+::\+Euclidean\+Distance, typename Mat\+Type  = arma\+::mat, template$<$ typename Tree\+Metric\+Type, typename Tree\+Stat\+Type, typename Tree\+Mat\+Type $>$ class Tree\+Type = tree\+::\+K\+D\+Tree$>$ void {\bf mlpack\+::emst\+::\+Dual\+Tree\+Boruvka}$<$ Metric\+Type, Mat\+Type, Tree\+Type $>$\+::Cleanup\+Helper (
\begin{DoxyParamCaption}
\item[{{\bf Tree} $\ast$}]{tree}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [private]}}\label{classmlpack_1_1emst_1_1DualTreeBoruvka_aeeb40f0f7c771ae046f73c577a1bf17c}


This function resets the values in the nodes of the tree nearest neighbor distance, and checks for fully connected nodes. 



Referenced by mlpack\+::emst\+::\+Dual\+Tree\+Boruvka$<$ Metric\+Type, Mat\+Type, Tree\+Type $>$\+::\+Sort\+Edges\+Helper\+::operator()().

\index{mlpack\+::emst\+::\+Dual\+Tree\+Boruvka@{mlpack\+::emst\+::\+Dual\+Tree\+Boruvka}!Compute\+M\+ST@{Compute\+M\+ST}}
\index{Compute\+M\+ST@{Compute\+M\+ST}!mlpack\+::emst\+::\+Dual\+Tree\+Boruvka@{mlpack\+::emst\+::\+Dual\+Tree\+Boruvka}}
\subsubsection[{Compute\+M\+S\+T(arma\+::mat \&results)}]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename Metric\+Type  = metric\+::\+Euclidean\+Distance, typename Mat\+Type  = arma\+::mat, template$<$ typename Tree\+Metric\+Type, typename Tree\+Stat\+Type, typename Tree\+Mat\+Type $>$ class Tree\+Type = tree\+::\+K\+D\+Tree$>$ void {\bf mlpack\+::emst\+::\+Dual\+Tree\+Boruvka}$<$ Metric\+Type, Mat\+Type, Tree\+Type $>$\+::Compute\+M\+ST (
\begin{DoxyParamCaption}
\item[{arma\+::mat \&}]{results}
\end{DoxyParamCaption}
)}\label{classmlpack_1_1emst_1_1DualTreeBoruvka_aecb1291111d532cf2b7f7e2794b6fa6e}


Iteratively find the nearest neighbor of each component until the M\+ST is complete. 

The results will be a 3xN matrix (with N equal to the number of edges in the minimum spanning tree). The first row will contain the lesser index of the edge; the second row will contain the greater index of the edge; and the third row will contain the distance between the two edges.


\begin{DoxyParams}{Parameters}
{\em results} & Matrix which results will be stored in. \\
\hline
\end{DoxyParams}


Referenced by mlpack\+::emst\+::\+Dual\+Tree\+Boruvka$<$ Metric\+Type, Mat\+Type, Tree\+Type $>$\+::\+Sort\+Edges\+Helper\+::operator()().

\index{mlpack\+::emst\+::\+Dual\+Tree\+Boruvka@{mlpack\+::emst\+::\+Dual\+Tree\+Boruvka}!Emit\+Results@{Emit\+Results}}
\index{Emit\+Results@{Emit\+Results}!mlpack\+::emst\+::\+Dual\+Tree\+Boruvka@{mlpack\+::emst\+::\+Dual\+Tree\+Boruvka}}
\subsubsection[{Emit\+Results(arma\+::mat \&results)}]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename Metric\+Type  = metric\+::\+Euclidean\+Distance, typename Mat\+Type  = arma\+::mat, template$<$ typename Tree\+Metric\+Type, typename Tree\+Stat\+Type, typename Tree\+Mat\+Type $>$ class Tree\+Type = tree\+::\+K\+D\+Tree$>$ void {\bf mlpack\+::emst\+::\+Dual\+Tree\+Boruvka}$<$ Metric\+Type, Mat\+Type, Tree\+Type $>$\+::Emit\+Results (
\begin{DoxyParamCaption}
\item[{arma\+::mat \&}]{results}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [private]}}\label{classmlpack_1_1emst_1_1DualTreeBoruvka_a3ed2614667d4a8b0097be4ef6d74d085}


Unpermute the edge list and output it to results. 



Referenced by mlpack\+::emst\+::\+Dual\+Tree\+Boruvka$<$ Metric\+Type, Mat\+Type, Tree\+Type $>$\+::\+Sort\+Edges\+Helper\+::operator()().



\subsection{Member Data Documentation}
\index{mlpack\+::emst\+::\+Dual\+Tree\+Boruvka@{mlpack\+::emst\+::\+Dual\+Tree\+Boruvka}!connections@{connections}}
\index{connections@{connections}!mlpack\+::emst\+::\+Dual\+Tree\+Boruvka@{mlpack\+::emst\+::\+Dual\+Tree\+Boruvka}}
\subsubsection[{connections}]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename Metric\+Type  = metric\+::\+Euclidean\+Distance, typename Mat\+Type  = arma\+::mat, template$<$ typename Tree\+Metric\+Type, typename Tree\+Stat\+Type, typename Tree\+Mat\+Type $>$ class Tree\+Type = tree\+::\+K\+D\+Tree$>$ {\bf Union\+Find} {\bf mlpack\+::emst\+::\+Dual\+Tree\+Boruvka}$<$ Metric\+Type, Mat\+Type, Tree\+Type $>$\+::connections\hspace{0.3cm}{\ttfamily [private]}}\label{classmlpack_1_1emst_1_1DualTreeBoruvka_a35cfa905c7e32c05b60da15e0ba9b55a}


Connections. 



Definition at line 106 of file dtb.\+hpp.

\index{mlpack\+::emst\+::\+Dual\+Tree\+Boruvka@{mlpack\+::emst\+::\+Dual\+Tree\+Boruvka}!data@{data}}
\index{data@{data}!mlpack\+::emst\+::\+Dual\+Tree\+Boruvka@{mlpack\+::emst\+::\+Dual\+Tree\+Boruvka}}
\subsubsection[{data}]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename Metric\+Type  = metric\+::\+Euclidean\+Distance, typename Mat\+Type  = arma\+::mat, template$<$ typename Tree\+Metric\+Type, typename Tree\+Stat\+Type, typename Tree\+Mat\+Type $>$ class Tree\+Type = tree\+::\+K\+D\+Tree$>$ const Mat\+Type\& {\bf mlpack\+::emst\+::\+Dual\+Tree\+Boruvka}$<$ Metric\+Type, Mat\+Type, Tree\+Type $>$\+::data\hspace{0.3cm}{\ttfamily [private]}}\label{classmlpack_1_1emst_1_1DualTreeBoruvka_a8d6c0f627f9b08b29fb8aa071c4d3021}


Reference to the data (this is what should be used for accessing data). 



Definition at line 95 of file dtb.\+hpp.

\index{mlpack\+::emst\+::\+Dual\+Tree\+Boruvka@{mlpack\+::emst\+::\+Dual\+Tree\+Boruvka}!edges@{edges}}
\index{edges@{edges}!mlpack\+::emst\+::\+Dual\+Tree\+Boruvka@{mlpack\+::emst\+::\+Dual\+Tree\+Boruvka}}
\subsubsection[{edges}]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename Metric\+Type  = metric\+::\+Euclidean\+Distance, typename Mat\+Type  = arma\+::mat, template$<$ typename Tree\+Metric\+Type, typename Tree\+Stat\+Type, typename Tree\+Mat\+Type $>$ class Tree\+Type = tree\+::\+K\+D\+Tree$>$ std\+::vector$<${\bf Edge\+Pair}$>$ {\bf mlpack\+::emst\+::\+Dual\+Tree\+Boruvka}$<$ Metric\+Type, Mat\+Type, Tree\+Type $>$\+::edges\hspace{0.3cm}{\ttfamily [private]}}\label{classmlpack_1_1emst_1_1DualTreeBoruvka_afec77d07d8b76613618c6c5fe031236f}


Edges. 



Definition at line 103 of file dtb.\+hpp.

\index{mlpack\+::emst\+::\+Dual\+Tree\+Boruvka@{mlpack\+::emst\+::\+Dual\+Tree\+Boruvka}!metric@{metric}}
\index{metric@{metric}!mlpack\+::emst\+::\+Dual\+Tree\+Boruvka@{mlpack\+::emst\+::\+Dual\+Tree\+Boruvka}}
\subsubsection[{metric}]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename Metric\+Type  = metric\+::\+Euclidean\+Distance, typename Mat\+Type  = arma\+::mat, template$<$ typename Tree\+Metric\+Type, typename Tree\+Stat\+Type, typename Tree\+Mat\+Type $>$ class Tree\+Type = tree\+::\+K\+D\+Tree$>$ Metric\+Type {\bf mlpack\+::emst\+::\+Dual\+Tree\+Boruvka}$<$ Metric\+Type, Mat\+Type, Tree\+Type $>$\+::metric\hspace{0.3cm}{\ttfamily [private]}}\label{classmlpack_1_1emst_1_1DualTreeBoruvka_acb55e193272478f5aa9912efcea2e2b0}


The instantiated metric. 



Definition at line 119 of file dtb.\+hpp.

\index{mlpack\+::emst\+::\+Dual\+Tree\+Boruvka@{mlpack\+::emst\+::\+Dual\+Tree\+Boruvka}!naive@{naive}}
\index{naive@{naive}!mlpack\+::emst\+::\+Dual\+Tree\+Boruvka@{mlpack\+::emst\+::\+Dual\+Tree\+Boruvka}}
\subsubsection[{naive}]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename Metric\+Type  = metric\+::\+Euclidean\+Distance, typename Mat\+Type  = arma\+::mat, template$<$ typename Tree\+Metric\+Type, typename Tree\+Stat\+Type, typename Tree\+Mat\+Type $>$ class Tree\+Type = tree\+::\+K\+D\+Tree$>$ bool {\bf mlpack\+::emst\+::\+Dual\+Tree\+Boruvka}$<$ Metric\+Type, Mat\+Type, Tree\+Type $>$\+::naive\hspace{0.3cm}{\ttfamily [private]}}\label{classmlpack_1_1emst_1_1DualTreeBoruvka_a13299b692bd1ace7201ceb928361d636}


Indicates whether or not O(n$^\wedge$2) naive mode will be used. 



Definition at line 100 of file dtb.\+hpp.

\index{mlpack\+::emst\+::\+Dual\+Tree\+Boruvka@{mlpack\+::emst\+::\+Dual\+Tree\+Boruvka}!neighbors\+Distances@{neighbors\+Distances}}
\index{neighbors\+Distances@{neighbors\+Distances}!mlpack\+::emst\+::\+Dual\+Tree\+Boruvka@{mlpack\+::emst\+::\+Dual\+Tree\+Boruvka}}
\subsubsection[{neighbors\+Distances}]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename Metric\+Type  = metric\+::\+Euclidean\+Distance, typename Mat\+Type  = arma\+::mat, template$<$ typename Tree\+Metric\+Type, typename Tree\+Stat\+Type, typename Tree\+Mat\+Type $>$ class Tree\+Type = tree\+::\+K\+D\+Tree$>$ arma\+::vec {\bf mlpack\+::emst\+::\+Dual\+Tree\+Boruvka}$<$ Metric\+Type, Mat\+Type, Tree\+Type $>$\+::neighbors\+Distances\hspace{0.3cm}{\ttfamily [private]}}\label{classmlpack_1_1emst_1_1DualTreeBoruvka_afbeeba70c53eeaaf7159e9d087563ccf}


List of edge distances. 



Definition at line 113 of file dtb.\+hpp.

\index{mlpack\+::emst\+::\+Dual\+Tree\+Boruvka@{mlpack\+::emst\+::\+Dual\+Tree\+Boruvka}!neighbors\+In\+Component@{neighbors\+In\+Component}}
\index{neighbors\+In\+Component@{neighbors\+In\+Component}!mlpack\+::emst\+::\+Dual\+Tree\+Boruvka@{mlpack\+::emst\+::\+Dual\+Tree\+Boruvka}}
\subsubsection[{neighbors\+In\+Component}]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename Metric\+Type  = metric\+::\+Euclidean\+Distance, typename Mat\+Type  = arma\+::mat, template$<$ typename Tree\+Metric\+Type, typename Tree\+Stat\+Type, typename Tree\+Mat\+Type $>$ class Tree\+Type = tree\+::\+K\+D\+Tree$>$ arma\+::\+Col$<$size\+\_\+t$>$ {\bf mlpack\+::emst\+::\+Dual\+Tree\+Boruvka}$<$ Metric\+Type, Mat\+Type, Tree\+Type $>$\+::neighbors\+In\+Component\hspace{0.3cm}{\ttfamily [private]}}\label{classmlpack_1_1emst_1_1DualTreeBoruvka_ad3ffd81fdd8ae5fb72e7efb61c5fd363}


List of edge nodes. 



Definition at line 109 of file dtb.\+hpp.

\index{mlpack\+::emst\+::\+Dual\+Tree\+Boruvka@{mlpack\+::emst\+::\+Dual\+Tree\+Boruvka}!neighbors\+Out\+Component@{neighbors\+Out\+Component}}
\index{neighbors\+Out\+Component@{neighbors\+Out\+Component}!mlpack\+::emst\+::\+Dual\+Tree\+Boruvka@{mlpack\+::emst\+::\+Dual\+Tree\+Boruvka}}
\subsubsection[{neighbors\+Out\+Component}]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename Metric\+Type  = metric\+::\+Euclidean\+Distance, typename Mat\+Type  = arma\+::mat, template$<$ typename Tree\+Metric\+Type, typename Tree\+Stat\+Type, typename Tree\+Mat\+Type $>$ class Tree\+Type = tree\+::\+K\+D\+Tree$>$ arma\+::\+Col$<$size\+\_\+t$>$ {\bf mlpack\+::emst\+::\+Dual\+Tree\+Boruvka}$<$ Metric\+Type, Mat\+Type, Tree\+Type $>$\+::neighbors\+Out\+Component\hspace{0.3cm}{\ttfamily [private]}}\label{classmlpack_1_1emst_1_1DualTreeBoruvka_a3d5930536cb9667ecc1433973a685568}


List of edge nodes. 



Definition at line 111 of file dtb.\+hpp.

\index{mlpack\+::emst\+::\+Dual\+Tree\+Boruvka@{mlpack\+::emst\+::\+Dual\+Tree\+Boruvka}!old\+From\+New@{old\+From\+New}}
\index{old\+From\+New@{old\+From\+New}!mlpack\+::emst\+::\+Dual\+Tree\+Boruvka@{mlpack\+::emst\+::\+Dual\+Tree\+Boruvka}}
\subsubsection[{old\+From\+New}]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename Metric\+Type  = metric\+::\+Euclidean\+Distance, typename Mat\+Type  = arma\+::mat, template$<$ typename Tree\+Metric\+Type, typename Tree\+Stat\+Type, typename Tree\+Mat\+Type $>$ class Tree\+Type = tree\+::\+K\+D\+Tree$>$ std\+::vector$<$size\+\_\+t$>$ {\bf mlpack\+::emst\+::\+Dual\+Tree\+Boruvka}$<$ Metric\+Type, Mat\+Type, Tree\+Type $>$\+::old\+From\+New\hspace{0.3cm}{\ttfamily [private]}}\label{classmlpack_1_1emst_1_1DualTreeBoruvka_ad10861347501bad532adc2eb0f64a370}


Permutations of points during tree building. 



Definition at line 91 of file dtb.\+hpp.

\index{mlpack\+::emst\+::\+Dual\+Tree\+Boruvka@{mlpack\+::emst\+::\+Dual\+Tree\+Boruvka}!own\+Tree@{own\+Tree}}
\index{own\+Tree@{own\+Tree}!mlpack\+::emst\+::\+Dual\+Tree\+Boruvka@{mlpack\+::emst\+::\+Dual\+Tree\+Boruvka}}
\subsubsection[{own\+Tree}]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename Metric\+Type  = metric\+::\+Euclidean\+Distance, typename Mat\+Type  = arma\+::mat, template$<$ typename Tree\+Metric\+Type, typename Tree\+Stat\+Type, typename Tree\+Mat\+Type $>$ class Tree\+Type = tree\+::\+K\+D\+Tree$>$ bool {\bf mlpack\+::emst\+::\+Dual\+Tree\+Boruvka}$<$ Metric\+Type, Mat\+Type, Tree\+Type $>$\+::own\+Tree\hspace{0.3cm}{\ttfamily [private]}}\label{classmlpack_1_1emst_1_1DualTreeBoruvka_a2380633b6b42334c76fea1a965b01beb}


Indicates whether or not we \char`\"{}own\char`\"{} the tree. 



Definition at line 97 of file dtb.\+hpp.

\index{mlpack\+::emst\+::\+Dual\+Tree\+Boruvka@{mlpack\+::emst\+::\+Dual\+Tree\+Boruvka}!Sort\+Fun@{Sort\+Fun}}
\index{Sort\+Fun@{Sort\+Fun}!mlpack\+::emst\+::\+Dual\+Tree\+Boruvka@{mlpack\+::emst\+::\+Dual\+Tree\+Boruvka}}
\subsubsection[{Sort\+Fun}]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename Metric\+Type  = metric\+::\+Euclidean\+Distance, typename Mat\+Type  = arma\+::mat, template$<$ typename Tree\+Metric\+Type, typename Tree\+Stat\+Type, typename Tree\+Mat\+Type $>$ class Tree\+Type = tree\+::\+K\+D\+Tree$>$ struct {\bf mlpack\+::emst\+::\+Dual\+Tree\+Boruvka\+::\+Sort\+Edges\+Helper}  {\bf mlpack\+::emst\+::\+Dual\+Tree\+Boruvka}$<$ Metric\+Type, Mat\+Type, Tree\+Type $>$\+::Sort\+Fun\hspace{0.3cm}{\ttfamily [private]}}\label{classmlpack_1_1emst_1_1DualTreeBoruvka_a17778a5cad95de702c67acfec7e4b379}


Referenced by mlpack\+::emst\+::\+Dual\+Tree\+Boruvka$<$ Metric\+Type, Mat\+Type, Tree\+Type $>$\+::\+Sort\+Edges\+Helper\+::operator()().

\index{mlpack\+::emst\+::\+Dual\+Tree\+Boruvka@{mlpack\+::emst\+::\+Dual\+Tree\+Boruvka}!total\+Dist@{total\+Dist}}
\index{total\+Dist@{total\+Dist}!mlpack\+::emst\+::\+Dual\+Tree\+Boruvka@{mlpack\+::emst\+::\+Dual\+Tree\+Boruvka}}
\subsubsection[{total\+Dist}]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename Metric\+Type  = metric\+::\+Euclidean\+Distance, typename Mat\+Type  = arma\+::mat, template$<$ typename Tree\+Metric\+Type, typename Tree\+Stat\+Type, typename Tree\+Mat\+Type $>$ class Tree\+Type = tree\+::\+K\+D\+Tree$>$ double {\bf mlpack\+::emst\+::\+Dual\+Tree\+Boruvka}$<$ Metric\+Type, Mat\+Type, Tree\+Type $>$\+::total\+Dist\hspace{0.3cm}{\ttfamily [private]}}\label{classmlpack_1_1emst_1_1DualTreeBoruvka_aafed0204dfc6411879183ac43b7b049d}


Total distance of the tree. 



Definition at line 116 of file dtb.\+hpp.

\index{mlpack\+::emst\+::\+Dual\+Tree\+Boruvka@{mlpack\+::emst\+::\+Dual\+Tree\+Boruvka}!tree@{tree}}
\index{tree@{tree}!mlpack\+::emst\+::\+Dual\+Tree\+Boruvka@{mlpack\+::emst\+::\+Dual\+Tree\+Boruvka}}
\subsubsection[{tree}]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename Metric\+Type  = metric\+::\+Euclidean\+Distance, typename Mat\+Type  = arma\+::mat, template$<$ typename Tree\+Metric\+Type, typename Tree\+Stat\+Type, typename Tree\+Mat\+Type $>$ class Tree\+Type = tree\+::\+K\+D\+Tree$>$ {\bf Tree}$\ast$ {\bf mlpack\+::emst\+::\+Dual\+Tree\+Boruvka}$<$ Metric\+Type, Mat\+Type, Tree\+Type $>$\+::tree\hspace{0.3cm}{\ttfamily [private]}}\label{classmlpack_1_1emst_1_1DualTreeBoruvka_ae890e735213aeb763aa74872f840b5b0}


Pointer to the root of the tree. 



Definition at line 93 of file dtb.\+hpp.



The documentation for this class was generated from the following file\+:\begin{DoxyCompactItemize}
\item 
src/mlpack/methods/emst/{\bf dtb.\+hpp}\end{DoxyCompactItemize}
