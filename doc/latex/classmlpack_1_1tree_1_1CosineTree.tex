\section{mlpack\+:\+:tree\+:\+:Cosine\+Tree Class Reference}
\label{classmlpack_1_1tree_1_1CosineTree}\index{mlpack\+::tree\+::\+Cosine\+Tree@{mlpack\+::tree\+::\+Cosine\+Tree}}
\subsection*{Public Member Functions}
\begin{DoxyCompactItemize}
\item 
{\bf Cosine\+Tree} (const arma\+::mat \&{\bf dataset})
\begin{DoxyCompactList}\small\item\em \doxyref{Cosine\+Tree}{p.}{classmlpack_1_1tree_1_1CosineTree} constructor for the root node of the tree. \end{DoxyCompactList}\item 
{\bf Cosine\+Tree} ({\bf Cosine\+Tree} \&parent\+Node, const std\+::vector$<$ size\+\_\+t $>$ \&sub\+Indices)
\begin{DoxyCompactList}\small\item\em \doxyref{Cosine\+Tree}{p.}{classmlpack_1_1tree_1_1CosineTree} constructor for nodes other than the root node of the tree. \end{DoxyCompactList}\item 
{\bf Cosine\+Tree} (const arma\+::mat \&{\bf dataset}, const double epsilon, const double {\bf delta})
\begin{DoxyCompactList}\small\item\em Construct the \doxyref{Cosine\+Tree}{p.}{classmlpack_1_1tree_1_1CosineTree} and the basis for the given matrix, and passed \textquotesingle{}epsilon\textquotesingle{} and \textquotesingle{}delta\textquotesingle{} parameters. \end{DoxyCompactList}\item 
{\bf $\sim$\+Cosine\+Tree} ()
\begin{DoxyCompactList}\small\item\em Clean up the \doxyref{Cosine\+Tree}{p.}{classmlpack_1_1tree_1_1CosineTree}\+: release allocated memory (including children). \end{DoxyCompactList}\item 
void {\bf Basis\+Vector} (arma\+::vec \&b\+Vector)
\begin{DoxyCompactList}\small\item\em Set the basis vector of the node. \end{DoxyCompactList}\item 
arma\+::vec \& {\bf Basis\+Vector} ()
\begin{DoxyCompactList}\small\item\em Get the basis vector of the node. \end{DoxyCompactList}\item 
size\+\_\+t {\bf Binary\+Search} (arma\+::vec \&c\+Distribution, double value, size\+\_\+t start, size\+\_\+t end)
\begin{DoxyCompactList}\small\item\em Sample a column based on the cumulative Length-\/\+Squared distribution of the cosine node, and a randomly generated value in the range [0, 1]. \end{DoxyCompactList}\item 
void {\bf Calculate\+Centroid} ()
\begin{DoxyCompactList}\small\item\em Calculate centroid of the columns present in the node. \end{DoxyCompactList}\item 
void {\bf Calculate\+Cosines} (arma\+::vec \&cosines)
\begin{DoxyCompactList}\small\item\em Calculate cosines of the columns present in the node, with respect to the sampled splitting point. \end{DoxyCompactList}\item 
arma\+::vec \& {\bf Centroid} ()
\begin{DoxyCompactList}\small\item\em Get pointer to the centroid vector. \end{DoxyCompactList}\item 
size\+\_\+t {\bf Column\+Sample\+LS} ()
\begin{DoxyCompactList}\small\item\em Sample a point from the Length-\/\+Squared distribution of the cosine node. \end{DoxyCompactList}\item 
void {\bf Column\+Samples\+LS} (std\+::vector$<$ size\+\_\+t $>$ \&sampled\+Indices, arma\+::vec \&probabilities, size\+\_\+t num\+Samples)
\begin{DoxyCompactList}\small\item\em Sample \textquotesingle{}num\+Samples\textquotesingle{} points from the Length-\/\+Squared distribution of the cosine node. \end{DoxyCompactList}\item 
void {\bf Construct\+Basis} ({\bf Cosine\+Node\+Queue} \&tree\+Queue)
\begin{DoxyCompactList}\small\item\em Constructs the final basis matrix, after the cosine tree construction. \end{DoxyCompactList}\item 
void {\bf Cosine\+Node\+Split} ()
\begin{DoxyCompactList}\small\item\em This function splits the cosine node into two children based on the cosines of the columns contained in the node, with respect to the sampled splitting point. \end{DoxyCompactList}\item 
double {\bf Frob\+Norm\+Squared} () const 
\begin{DoxyCompactList}\small\item\em Get the Frobenius norm squared of columns in the node. \end{DoxyCompactList}\item 
const arma\+::mat \& {\bf Get\+Dataset} () const 
\begin{DoxyCompactList}\small\item\em Get pointer to the dataset matrix. \end{DoxyCompactList}\item 
void {\bf Get\+Final\+Basis} (arma\+::mat \&final\+Basis)
\begin{DoxyCompactList}\small\item\em Returns the basis of the constructed subspace. \end{DoxyCompactList}\item 
void {\bf L2\+Error} (const double error)
\begin{DoxyCompactList}\small\item\em Set the Monte Carlo error. \end{DoxyCompactList}\item 
double {\bf L2\+Error} () const 
\begin{DoxyCompactList}\small\item\em Get the Monte Carlo error. \end{DoxyCompactList}\item 
{\bf Cosine\+Tree} $\ast$ {\bf Left} () const 
\begin{DoxyCompactList}\small\item\em Get pointer to the left child of the node. \end{DoxyCompactList}\item 
{\bf Cosine\+Tree} $\ast$\& {\bf Left} ()
\begin{DoxyCompactList}\small\item\em Modify the pointer to the left child of the node. \end{DoxyCompactList}\item 
void {\bf Modified\+Gram\+Schmidt} ({\bf Cosine\+Node\+Queue} \&tree\+Queue, arma\+::vec \&{\bf centroid}, arma\+::vec \&new\+Basis\+Vector, arma\+::vec $\ast$add\+Basis\+Vector=N\+U\+LL)
\begin{DoxyCompactList}\small\item\em Calculates the orthonormalization of the passed centroid, with respect to the current vector subspace. \end{DoxyCompactList}\item 
double {\bf Monte\+Carlo\+Error} ({\bf Cosine\+Tree} $\ast$node, {\bf Cosine\+Node\+Queue} \&tree\+Queue, arma\+::vec $\ast$add\+Basis\+Vector1=N\+U\+LL, arma\+::vec $\ast$add\+Basis\+Vector2=N\+U\+LL)
\begin{DoxyCompactList}\small\item\em Estimates the squared error of the projection of the input node\textquotesingle{}s matrix onto the current vector subspace. \end{DoxyCompactList}\item 
size\+\_\+t {\bf Num\+Columns} () const 
\begin{DoxyCompactList}\small\item\em Get number of columns of input matrix in the node. \end{DoxyCompactList}\item 
{\bf Cosine\+Tree} $\ast$ {\bf Parent} () const 
\begin{DoxyCompactList}\small\item\em Get pointer to the parent node. \end{DoxyCompactList}\item 
{\bf Cosine\+Tree} $\ast$\& {\bf Parent} ()
\begin{DoxyCompactList}\small\item\em Modify the pointer to the parent node. \end{DoxyCompactList}\item 
{\bf Cosine\+Tree} $\ast$ {\bf Right} () const 
\begin{DoxyCompactList}\small\item\em Get pointer to the right child of the node. \end{DoxyCompactList}\item 
{\bf Cosine\+Tree} $\ast$\& {\bf Right} ()
\begin{DoxyCompactList}\small\item\em Modify the pointer to the left child of the node. \end{DoxyCompactList}\item 
size\+\_\+t {\bf Split\+Point\+Index} () const 
\begin{DoxyCompactList}\small\item\em Get the column index of split point of the node. \end{DoxyCompactList}\item 
std\+::vector$<$ size\+\_\+t $>$ \& {\bf Vector\+Indices} ()
\begin{DoxyCompactList}\small\item\em Get the indices of columns in the node. \end{DoxyCompactList}\end{DoxyCompactItemize}
\subsection*{Private Attributes}
\begin{DoxyCompactItemize}
\item 
arma\+::mat {\bf basis}
\begin{DoxyCompactList}\small\item\em Subspace basis of the input dataset. \end{DoxyCompactList}\item 
arma\+::vec {\bf basis\+Vector}
\begin{DoxyCompactList}\small\item\em Orthonormalized basis vector of the node. \end{DoxyCompactList}\item 
arma\+::vec {\bf centroid}
\begin{DoxyCompactList}\small\item\em Centroid of columns of input matrix in the node. \end{DoxyCompactList}\item 
const arma\+::mat \& {\bf dataset}
\begin{DoxyCompactList}\small\item\em Matrix for which cosine tree is constructed. \end{DoxyCompactList}\item 
double {\bf delta}
\begin{DoxyCompactList}\small\item\em Cumulative probability for Monte Carlo error lower bound. \end{DoxyCompactList}\item 
double {\bf frob\+Norm\+Squared}
\begin{DoxyCompactList}\small\item\em Frobenius norm squared of columns in the node. \end{DoxyCompactList}\item 
std\+::vector$<$ size\+\_\+t $>$ {\bf indices}
\begin{DoxyCompactList}\small\item\em Indices of columns of input matrix in the node. \end{DoxyCompactList}\item 
double {\bf l2\+Error}
\begin{DoxyCompactList}\small\item\em Monte Carlo error for this node. \end{DoxyCompactList}\item 
arma\+::vec {\bf l2\+Norms\+Squared}
\begin{DoxyCompactList}\small\item\em L2-\/norm squared of columns in the node. \end{DoxyCompactList}\item 
{\bf Cosine\+Tree} $\ast$ {\bf left}
\begin{DoxyCompactList}\small\item\em Left child of the node. \end{DoxyCompactList}\item 
size\+\_\+t {\bf num\+Columns}
\begin{DoxyCompactList}\small\item\em Number of columns of input matrix in the node. \end{DoxyCompactList}\item 
{\bf Cosine\+Tree} $\ast$ {\bf parent}
\begin{DoxyCompactList}\small\item\em Parent of the node. \end{DoxyCompactList}\item 
{\bf Cosine\+Tree} $\ast$ {\bf right}
\begin{DoxyCompactList}\small\item\em Right child of the node. \end{DoxyCompactList}\item 
size\+\_\+t {\bf split\+Point\+Index}
\begin{DoxyCompactList}\small\item\em Index of split point of cosine node. \end{DoxyCompactList}\end{DoxyCompactItemize}


\subsection{Detailed Description}


Definition at line 29 of file cosine\+\_\+tree.\+hpp.



\subsection{Constructor \& Destructor Documentation}
\index{mlpack\+::tree\+::\+Cosine\+Tree@{mlpack\+::tree\+::\+Cosine\+Tree}!Cosine\+Tree@{Cosine\+Tree}}
\index{Cosine\+Tree@{Cosine\+Tree}!mlpack\+::tree\+::\+Cosine\+Tree@{mlpack\+::tree\+::\+Cosine\+Tree}}
\subsubsection[{Cosine\+Tree(const arma\+::mat \&dataset)}]{\setlength{\rightskip}{0pt plus 5cm}mlpack\+::tree\+::\+Cosine\+Tree\+::\+Cosine\+Tree (
\begin{DoxyParamCaption}
\item[{const arma\+::mat \&}]{dataset}
\end{DoxyParamCaption}
)}\label{classmlpack_1_1tree_1_1CosineTree_a620e8df484ae1137e14747cf8d393c1c}


\doxyref{Cosine\+Tree}{p.}{classmlpack_1_1tree_1_1CosineTree} constructor for the root node of the tree. 

It initializes the necessary variables required for splitting of the node, and building the tree further. It takes a pointer to the input matrix and calculates the relevant variables using it.


\begin{DoxyParams}{Parameters}
{\em dataset} & Matrix for which cosine tree is constructed. \\
\hline
\end{DoxyParams}
\index{mlpack\+::tree\+::\+Cosine\+Tree@{mlpack\+::tree\+::\+Cosine\+Tree}!Cosine\+Tree@{Cosine\+Tree}}
\index{Cosine\+Tree@{Cosine\+Tree}!mlpack\+::tree\+::\+Cosine\+Tree@{mlpack\+::tree\+::\+Cosine\+Tree}}
\subsubsection[{Cosine\+Tree(\+Cosine\+Tree \&parent\+Node, const std\+::vector$<$ size\+\_\+t $>$ \&sub\+Indices)}]{\setlength{\rightskip}{0pt plus 5cm}mlpack\+::tree\+::\+Cosine\+Tree\+::\+Cosine\+Tree (
\begin{DoxyParamCaption}
\item[{{\bf Cosine\+Tree} \&}]{parent\+Node, }
\item[{const std\+::vector$<$ size\+\_\+t $>$ \&}]{sub\+Indices}
\end{DoxyParamCaption}
)}\label{classmlpack_1_1tree_1_1CosineTree_a9852c0101777e18dda9d573a508c7e4a}


\doxyref{Cosine\+Tree}{p.}{classmlpack_1_1tree_1_1CosineTree} constructor for nodes other than the root node of the tree. 

It takes in a pointer to the parent node and a list of column indices which mentions the columns to be included in the node. The function calculate the relevant variables just like the constructor above.


\begin{DoxyParams}{Parameters}
{\em parent\+Node} & Pointer to the parent cosine node. \\
\hline
{\em sub\+Indices} & Pointer to vector of column indices to be included. \\
\hline
\end{DoxyParams}
\index{mlpack\+::tree\+::\+Cosine\+Tree@{mlpack\+::tree\+::\+Cosine\+Tree}!Cosine\+Tree@{Cosine\+Tree}}
\index{Cosine\+Tree@{Cosine\+Tree}!mlpack\+::tree\+::\+Cosine\+Tree@{mlpack\+::tree\+::\+Cosine\+Tree}}
\subsubsection[{Cosine\+Tree(const arma\+::mat \&dataset, const double epsilon, const double delta)}]{\setlength{\rightskip}{0pt plus 5cm}mlpack\+::tree\+::\+Cosine\+Tree\+::\+Cosine\+Tree (
\begin{DoxyParamCaption}
\item[{const arma\+::mat \&}]{dataset, }
\item[{const double}]{epsilon, }
\item[{const double}]{delta}
\end{DoxyParamCaption}
)}\label{classmlpack_1_1tree_1_1CosineTree_aa4b0aac9d5c68220b20088ecd7996425}


Construct the \doxyref{Cosine\+Tree}{p.}{classmlpack_1_1tree_1_1CosineTree} and the basis for the given matrix, and passed \textquotesingle{}epsilon\textquotesingle{} and \textquotesingle{}delta\textquotesingle{} parameters. 

The \doxyref{Cosine\+Tree}{p.}{classmlpack_1_1tree_1_1CosineTree} is constructed by splitting nodes in the direction of maximum error, stored using a priority queue. Basis vectors are added from the left and right children of the split node. The basis vector from a node is the orthonormalized centroid of its columns. The splitting continues till the Monte Carlo estimate of the input matrix\textquotesingle{}s projection on the obtained subspace is less than a fraction of the norm of the input matrix.


\begin{DoxyParams}{Parameters}
{\em dataset} & Matrix for which the \doxyref{Cosine\+Tree}{p.}{classmlpack_1_1tree_1_1CosineTree} is constructed. \\
\hline
{\em epsilon} & Error tolerance fraction for calculated subspace. \\
\hline
{\em delta} & Cumulative probability for Monte Carlo error lower bound. \\
\hline
\end{DoxyParams}
\index{mlpack\+::tree\+::\+Cosine\+Tree@{mlpack\+::tree\+::\+Cosine\+Tree}!````~Cosine\+Tree@{$\sim$\+Cosine\+Tree}}
\index{````~Cosine\+Tree@{$\sim$\+Cosine\+Tree}!mlpack\+::tree\+::\+Cosine\+Tree@{mlpack\+::tree\+::\+Cosine\+Tree}}
\subsubsection[{$\sim$\+Cosine\+Tree()}]{\setlength{\rightskip}{0pt plus 5cm}mlpack\+::tree\+::\+Cosine\+Tree\+::$\sim$\+Cosine\+Tree (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)}\label{classmlpack_1_1tree_1_1CosineTree_aa56ec4e53efe931b166b7a9ae5aadf61}


Clean up the \doxyref{Cosine\+Tree}{p.}{classmlpack_1_1tree_1_1CosineTree}\+: release allocated memory (including children). 



\subsection{Member Function Documentation}
\index{mlpack\+::tree\+::\+Cosine\+Tree@{mlpack\+::tree\+::\+Cosine\+Tree}!Basis\+Vector@{Basis\+Vector}}
\index{Basis\+Vector@{Basis\+Vector}!mlpack\+::tree\+::\+Cosine\+Tree@{mlpack\+::tree\+::\+Cosine\+Tree}}
\subsubsection[{Basis\+Vector(arma\+::vec \&b\+Vector)}]{\setlength{\rightskip}{0pt plus 5cm}void mlpack\+::tree\+::\+Cosine\+Tree\+::\+Basis\+Vector (
\begin{DoxyParamCaption}
\item[{arma\+::vec \&}]{b\+Vector}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}}\label{classmlpack_1_1tree_1_1CosineTree_ade89fb5bbfd026f88049b7f5763e218a}


Set the basis vector of the node. 



Definition at line 186 of file cosine\+\_\+tree.\+hpp.



References basis\+Vector.

\index{mlpack\+::tree\+::\+Cosine\+Tree@{mlpack\+::tree\+::\+Cosine\+Tree}!Basis\+Vector@{Basis\+Vector}}
\index{Basis\+Vector@{Basis\+Vector}!mlpack\+::tree\+::\+Cosine\+Tree@{mlpack\+::tree\+::\+Cosine\+Tree}}
\subsubsection[{Basis\+Vector()}]{\setlength{\rightskip}{0pt plus 5cm}arma\+::vec\& mlpack\+::tree\+::\+Cosine\+Tree\+::\+Basis\+Vector (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}}\label{classmlpack_1_1tree_1_1CosineTree_ab44b3a8d993cc5654d0da5b8b2407413}


Get the basis vector of the node. 



Definition at line 189 of file cosine\+\_\+tree.\+hpp.



References basis\+Vector.

\index{mlpack\+::tree\+::\+Cosine\+Tree@{mlpack\+::tree\+::\+Cosine\+Tree}!Binary\+Search@{Binary\+Search}}
\index{Binary\+Search@{Binary\+Search}!mlpack\+::tree\+::\+Cosine\+Tree@{mlpack\+::tree\+::\+Cosine\+Tree}}
\subsubsection[{Binary\+Search(arma\+::vec \&c\+Distribution, double value, size\+\_\+t start, size\+\_\+t end)}]{\setlength{\rightskip}{0pt plus 5cm}size\+\_\+t mlpack\+::tree\+::\+Cosine\+Tree\+::\+Binary\+Search (
\begin{DoxyParamCaption}
\item[{arma\+::vec \&}]{c\+Distribution, }
\item[{double}]{value, }
\item[{size\+\_\+t}]{start, }
\item[{size\+\_\+t}]{end}
\end{DoxyParamCaption}
)}\label{classmlpack_1_1tree_1_1CosineTree_afa8865f4f586781f9b15d890bf22ab5b}


Sample a column based on the cumulative Length-\/\+Squared distribution of the cosine node, and a randomly generated value in the range [0, 1]. 

Binary search is more efficient than searching linearly for the same. This leads a significant speedup when there are large number of columns to choose from and when a number of samples are to be drawn from the distribution.


\begin{DoxyParams}{Parameters}
{\em c\+Distribution} & Cumulative LS distribution of columns in the node. \\
\hline
{\em value} & Randomly generated value in the range [0, 1]. \\
\hline
{\em start} & Starting index of the distribution interval to search in. \\
\hline
{\em end} & Ending index of the distribution interval to search in. \\
\hline
\end{DoxyParams}
\index{mlpack\+::tree\+::\+Cosine\+Tree@{mlpack\+::tree\+::\+Cosine\+Tree}!Calculate\+Centroid@{Calculate\+Centroid}}
\index{Calculate\+Centroid@{Calculate\+Centroid}!mlpack\+::tree\+::\+Cosine\+Tree@{mlpack\+::tree\+::\+Cosine\+Tree}}
\subsubsection[{Calculate\+Centroid()}]{\setlength{\rightskip}{0pt plus 5cm}void mlpack\+::tree\+::\+Cosine\+Tree\+::\+Calculate\+Centroid (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)}\label{classmlpack_1_1tree_1_1CosineTree_a5d4871493ac6da4d49d7bb8c43fffd24}


Calculate centroid of the columns present in the node. 

The calculated centroid is used as a basis vector for the cosine tree being constructed. \index{mlpack\+::tree\+::\+Cosine\+Tree@{mlpack\+::tree\+::\+Cosine\+Tree}!Calculate\+Cosines@{Calculate\+Cosines}}
\index{Calculate\+Cosines@{Calculate\+Cosines}!mlpack\+::tree\+::\+Cosine\+Tree@{mlpack\+::tree\+::\+Cosine\+Tree}}
\subsubsection[{Calculate\+Cosines(arma\+::vec \&cosines)}]{\setlength{\rightskip}{0pt plus 5cm}void mlpack\+::tree\+::\+Cosine\+Tree\+::\+Calculate\+Cosines (
\begin{DoxyParamCaption}
\item[{arma\+::vec \&}]{cosines}
\end{DoxyParamCaption}
)}\label{classmlpack_1_1tree_1_1CosineTree_a5fc5fbcdfe2566da6fab94edcec6a785}


Calculate cosines of the columns present in the node, with respect to the sampled splitting point. 

The calculated cosine values are useful for splitting the node into its children.


\begin{DoxyParams}{Parameters}
{\em cosines} & Vector to store the cosine values in. \\
\hline
\end{DoxyParams}
\index{mlpack\+::tree\+::\+Cosine\+Tree@{mlpack\+::tree\+::\+Cosine\+Tree}!Centroid@{Centroid}}
\index{Centroid@{Centroid}!mlpack\+::tree\+::\+Cosine\+Tree@{mlpack\+::tree\+::\+Cosine\+Tree}}
\subsubsection[{Centroid()}]{\setlength{\rightskip}{0pt plus 5cm}arma\+::vec\& mlpack\+::tree\+::\+Cosine\+Tree\+::\+Centroid (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}}\label{classmlpack_1_1tree_1_1CosineTree_a1f96dd6bc7b9ddcae4ab410084277d99}


Get pointer to the centroid vector. 



Definition at line 183 of file cosine\+\_\+tree.\+hpp.



References centroid.

\index{mlpack\+::tree\+::\+Cosine\+Tree@{mlpack\+::tree\+::\+Cosine\+Tree}!Column\+Sample\+LS@{Column\+Sample\+LS}}
\index{Column\+Sample\+LS@{Column\+Sample\+LS}!mlpack\+::tree\+::\+Cosine\+Tree@{mlpack\+::tree\+::\+Cosine\+Tree}}
\subsubsection[{Column\+Sample\+L\+S()}]{\setlength{\rightskip}{0pt plus 5cm}size\+\_\+t mlpack\+::tree\+::\+Cosine\+Tree\+::\+Column\+Sample\+LS (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)}\label{classmlpack_1_1tree_1_1CosineTree_a18b3ab187c5b76afeda59411ab1957f7}


Sample a point from the Length-\/\+Squared distribution of the cosine node. 

The function uses \textquotesingle{}l2\+Norms\+Squared\textquotesingle{} to calculate the cumulative probability distribution of the column vectors. The sampling is based on a randomly generated value in the range [0, 1]. \index{mlpack\+::tree\+::\+Cosine\+Tree@{mlpack\+::tree\+::\+Cosine\+Tree}!Column\+Samples\+LS@{Column\+Samples\+LS}}
\index{Column\+Samples\+LS@{Column\+Samples\+LS}!mlpack\+::tree\+::\+Cosine\+Tree@{mlpack\+::tree\+::\+Cosine\+Tree}}
\subsubsection[{Column\+Samples\+L\+S(std\+::vector$<$ size\+\_\+t $>$ \&sampled\+Indices, arma\+::vec \&probabilities, size\+\_\+t num\+Samples)}]{\setlength{\rightskip}{0pt plus 5cm}void mlpack\+::tree\+::\+Cosine\+Tree\+::\+Column\+Samples\+LS (
\begin{DoxyParamCaption}
\item[{std\+::vector$<$ size\+\_\+t $>$ \&}]{sampled\+Indices, }
\item[{arma\+::vec \&}]{probabilities, }
\item[{size\+\_\+t}]{num\+Samples}
\end{DoxyParamCaption}
)}\label{classmlpack_1_1tree_1_1CosineTree_ac62e11a04ed81d0b58461f398cab9540}


Sample \textquotesingle{}num\+Samples\textquotesingle{} points from the Length-\/\+Squared distribution of the cosine node. 

The function uses \textquotesingle{}l2\+Norms\+Squared\textquotesingle{} to calculate the cumulative probability distribution of the column vectors. The sampling is based on a randomly generated values in the range [0, 1]. \index{mlpack\+::tree\+::\+Cosine\+Tree@{mlpack\+::tree\+::\+Cosine\+Tree}!Construct\+Basis@{Construct\+Basis}}
\index{Construct\+Basis@{Construct\+Basis}!mlpack\+::tree\+::\+Cosine\+Tree@{mlpack\+::tree\+::\+Cosine\+Tree}}
\subsubsection[{Construct\+Basis(\+Cosine\+Node\+Queue \&tree\+Queue)}]{\setlength{\rightskip}{0pt plus 5cm}void mlpack\+::tree\+::\+Cosine\+Tree\+::\+Construct\+Basis (
\begin{DoxyParamCaption}
\item[{{\bf Cosine\+Node\+Queue} \&}]{tree\+Queue}
\end{DoxyParamCaption}
)}\label{classmlpack_1_1tree_1_1CosineTree_ad41fd59c39b877eb65b0e9fa83cf9bbc}


Constructs the final basis matrix, after the cosine tree construction. 


\begin{DoxyParams}{Parameters}
{\em tree\+Queue} & Priority queue of cosine nodes. \\
\hline
\end{DoxyParams}
\index{mlpack\+::tree\+::\+Cosine\+Tree@{mlpack\+::tree\+::\+Cosine\+Tree}!Cosine\+Node\+Split@{Cosine\+Node\+Split}}
\index{Cosine\+Node\+Split@{Cosine\+Node\+Split}!mlpack\+::tree\+::\+Cosine\+Tree@{mlpack\+::tree\+::\+Cosine\+Tree}}
\subsubsection[{Cosine\+Node\+Split()}]{\setlength{\rightskip}{0pt plus 5cm}void mlpack\+::tree\+::\+Cosine\+Tree\+::\+Cosine\+Node\+Split (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)}\label{classmlpack_1_1tree_1_1CosineTree_a26e06926122678981c4a33cb7770a67e}


This function splits the cosine node into two children based on the cosines of the columns contained in the node, with respect to the sampled splitting point. 

The function also calls the \doxyref{Cosine\+Tree}{p.}{classmlpack_1_1tree_1_1CosineTree} constructor for the children. \index{mlpack\+::tree\+::\+Cosine\+Tree@{mlpack\+::tree\+::\+Cosine\+Tree}!Frob\+Norm\+Squared@{Frob\+Norm\+Squared}}
\index{Frob\+Norm\+Squared@{Frob\+Norm\+Squared}!mlpack\+::tree\+::\+Cosine\+Tree@{mlpack\+::tree\+::\+Cosine\+Tree}}
\subsubsection[{Frob\+Norm\+Squared() const }]{\setlength{\rightskip}{0pt plus 5cm}double mlpack\+::tree\+::\+Cosine\+Tree\+::\+Frob\+Norm\+Squared (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
) const\hspace{0.3cm}{\ttfamily [inline]}}\label{classmlpack_1_1tree_1_1CosineTree_af6cce7142f25d1c83b4f0aad130bed4b}


Get the Frobenius norm squared of columns in the node. 



Definition at line 210 of file cosine\+\_\+tree.\+hpp.



References frob\+Norm\+Squared.

\index{mlpack\+::tree\+::\+Cosine\+Tree@{mlpack\+::tree\+::\+Cosine\+Tree}!Get\+Dataset@{Get\+Dataset}}
\index{Get\+Dataset@{Get\+Dataset}!mlpack\+::tree\+::\+Cosine\+Tree@{mlpack\+::tree\+::\+Cosine\+Tree}}
\subsubsection[{Get\+Dataset() const }]{\setlength{\rightskip}{0pt plus 5cm}const arma\+::mat\& mlpack\+::tree\+::\+Cosine\+Tree\+::\+Get\+Dataset (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
) const\hspace{0.3cm}{\ttfamily [inline]}}\label{classmlpack_1_1tree_1_1CosineTree_a72bfd69dddb5522e514b55134e552ee7}


Get pointer to the dataset matrix. 



Definition at line 172 of file cosine\+\_\+tree.\+hpp.



References dataset.

\index{mlpack\+::tree\+::\+Cosine\+Tree@{mlpack\+::tree\+::\+Cosine\+Tree}!Get\+Final\+Basis@{Get\+Final\+Basis}}
\index{Get\+Final\+Basis@{Get\+Final\+Basis}!mlpack\+::tree\+::\+Cosine\+Tree@{mlpack\+::tree\+::\+Cosine\+Tree}}
\subsubsection[{Get\+Final\+Basis(arma\+::mat \&final\+Basis)}]{\setlength{\rightskip}{0pt plus 5cm}void mlpack\+::tree\+::\+Cosine\+Tree\+::\+Get\+Final\+Basis (
\begin{DoxyParamCaption}
\item[{arma\+::mat \&}]{final\+Basis}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}}\label{classmlpack_1_1tree_1_1CosineTree_a047e7e10072a9d88b0cfc2c0bc1b059c}


Returns the basis of the constructed subspace. 



Definition at line 169 of file cosine\+\_\+tree.\+hpp.



References basis.

\index{mlpack\+::tree\+::\+Cosine\+Tree@{mlpack\+::tree\+::\+Cosine\+Tree}!L2\+Error@{L2\+Error}}
\index{L2\+Error@{L2\+Error}!mlpack\+::tree\+::\+Cosine\+Tree@{mlpack\+::tree\+::\+Cosine\+Tree}}
\subsubsection[{L2\+Error(const double error)}]{\setlength{\rightskip}{0pt plus 5cm}void mlpack\+::tree\+::\+Cosine\+Tree\+::\+L2\+Error (
\begin{DoxyParamCaption}
\item[{const double}]{error}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}}\label{classmlpack_1_1tree_1_1CosineTree_ac1cba40f0504fc2fddb25dc9b603f965}


Set the Monte Carlo error. 



Definition at line 178 of file cosine\+\_\+tree.\+hpp.



References l2\+Error.



Referenced by mlpack\+::tree\+::\+Compare\+Cosine\+Node\+::operator()().

\index{mlpack\+::tree\+::\+Cosine\+Tree@{mlpack\+::tree\+::\+Cosine\+Tree}!L2\+Error@{L2\+Error}}
\index{L2\+Error@{L2\+Error}!mlpack\+::tree\+::\+Cosine\+Tree@{mlpack\+::tree\+::\+Cosine\+Tree}}
\subsubsection[{L2\+Error() const }]{\setlength{\rightskip}{0pt plus 5cm}double mlpack\+::tree\+::\+Cosine\+Tree\+::\+L2\+Error (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
) const\hspace{0.3cm}{\ttfamily [inline]}}\label{classmlpack_1_1tree_1_1CosineTree_a67be528336b40266704e760c525de9eb}


Get the Monte Carlo error. 



Definition at line 180 of file cosine\+\_\+tree.\+hpp.



References l2\+Error.

\index{mlpack\+::tree\+::\+Cosine\+Tree@{mlpack\+::tree\+::\+Cosine\+Tree}!Left@{Left}}
\index{Left@{Left}!mlpack\+::tree\+::\+Cosine\+Tree@{mlpack\+::tree\+::\+Cosine\+Tree}}
\subsubsection[{Left() const }]{\setlength{\rightskip}{0pt plus 5cm}{\bf Cosine\+Tree}$\ast$ mlpack\+::tree\+::\+Cosine\+Tree\+::\+Left (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
) const\hspace{0.3cm}{\ttfamily [inline]}}\label{classmlpack_1_1tree_1_1CosineTree_a728f226c207b35f4b83ab856bf8e6cd7}


Get pointer to the left child of the node. 



Definition at line 197 of file cosine\+\_\+tree.\+hpp.



References left.

\index{mlpack\+::tree\+::\+Cosine\+Tree@{mlpack\+::tree\+::\+Cosine\+Tree}!Left@{Left}}
\index{Left@{Left}!mlpack\+::tree\+::\+Cosine\+Tree@{mlpack\+::tree\+::\+Cosine\+Tree}}
\subsubsection[{Left()}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Cosine\+Tree}$\ast$\& mlpack\+::tree\+::\+Cosine\+Tree\+::\+Left (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}}\label{classmlpack_1_1tree_1_1CosineTree_ae6fc04bd566783542113f5b2a47b5a37}


Modify the pointer to the left child of the node. 



Definition at line 199 of file cosine\+\_\+tree.\+hpp.



References left.

\index{mlpack\+::tree\+::\+Cosine\+Tree@{mlpack\+::tree\+::\+Cosine\+Tree}!Modified\+Gram\+Schmidt@{Modified\+Gram\+Schmidt}}
\index{Modified\+Gram\+Schmidt@{Modified\+Gram\+Schmidt}!mlpack\+::tree\+::\+Cosine\+Tree@{mlpack\+::tree\+::\+Cosine\+Tree}}
\subsubsection[{Modified\+Gram\+Schmidt(\+Cosine\+Node\+Queue \&tree\+Queue, arma\+::vec \&centroid, arma\+::vec \&new\+Basis\+Vector, arma\+::vec $\ast$add\+Basis\+Vector=\+N\+U\+L\+L)}]{\setlength{\rightskip}{0pt plus 5cm}void mlpack\+::tree\+::\+Cosine\+Tree\+::\+Modified\+Gram\+Schmidt (
\begin{DoxyParamCaption}
\item[{{\bf Cosine\+Node\+Queue} \&}]{tree\+Queue, }
\item[{arma\+::vec \&}]{centroid, }
\item[{arma\+::vec \&}]{new\+Basis\+Vector, }
\item[{arma\+::vec $\ast$}]{add\+Basis\+Vector = {\ttfamily NULL}}
\end{DoxyParamCaption}
)}\label{classmlpack_1_1tree_1_1CosineTree_a7fc34f5ecf6641f5b1585e6aa8909285}


Calculates the orthonormalization of the passed centroid, with respect to the current vector subspace. 


\begin{DoxyParams}{Parameters}
{\em tree\+Queue} & Priority queue of cosine nodes. \\
\hline
{\em centroid} & Centroid of the node being added to the basis. \\
\hline
{\em new\+Basis\+Vector} & Orthonormalized centroid of the node. \\
\hline
{\em add\+Basis\+Vector} & Address to additional basis vector. \\
\hline
\end{DoxyParams}
\index{mlpack\+::tree\+::\+Cosine\+Tree@{mlpack\+::tree\+::\+Cosine\+Tree}!Monte\+Carlo\+Error@{Monte\+Carlo\+Error}}
\index{Monte\+Carlo\+Error@{Monte\+Carlo\+Error}!mlpack\+::tree\+::\+Cosine\+Tree@{mlpack\+::tree\+::\+Cosine\+Tree}}
\subsubsection[{Monte\+Carlo\+Error(\+Cosine\+Tree $\ast$node, Cosine\+Node\+Queue \&tree\+Queue, arma\+::vec $\ast$add\+Basis\+Vector1=\+N\+U\+L\+L, arma\+::vec $\ast$add\+Basis\+Vector2=\+N\+U\+L\+L)}]{\setlength{\rightskip}{0pt plus 5cm}double mlpack\+::tree\+::\+Cosine\+Tree\+::\+Monte\+Carlo\+Error (
\begin{DoxyParamCaption}
\item[{{\bf Cosine\+Tree} $\ast$}]{node, }
\item[{{\bf Cosine\+Node\+Queue} \&}]{tree\+Queue, }
\item[{arma\+::vec $\ast$}]{add\+Basis\+Vector1 = {\ttfamily NULL}, }
\item[{arma\+::vec $\ast$}]{add\+Basis\+Vector2 = {\ttfamily NULL}}
\end{DoxyParamCaption}
)}\label{classmlpack_1_1tree_1_1CosineTree_a6e253238c8eef0a5908978a07f4b8e5c}


Estimates the squared error of the projection of the input node\textquotesingle{}s matrix onto the current vector subspace. 

A normal distribution is fit using weighted norms of projections of samples drawn from the input node\textquotesingle{}s matrix columns. The error is calculated as the difference between the Frobenius norm of the input node\textquotesingle{}s matrix and lower bound of the normal distribution.


\begin{DoxyParams}{Parameters}
{\em node} & Node for which Monte Carlo estimate is calculated. \\
\hline
{\em tree\+Queue} & Priority queue of cosine nodes. \\
\hline
{\em add\+Basis\+Vector1} & Address to first additional basis vector. \\
\hline
{\em add\+Basis\+Vector2} & Address to second additional basis vector. \\
\hline
\end{DoxyParams}
\index{mlpack\+::tree\+::\+Cosine\+Tree@{mlpack\+::tree\+::\+Cosine\+Tree}!Num\+Columns@{Num\+Columns}}
\index{Num\+Columns@{Num\+Columns}!mlpack\+::tree\+::\+Cosine\+Tree@{mlpack\+::tree\+::\+Cosine\+Tree}}
\subsubsection[{Num\+Columns() const }]{\setlength{\rightskip}{0pt plus 5cm}size\+\_\+t mlpack\+::tree\+::\+Cosine\+Tree\+::\+Num\+Columns (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
) const\hspace{0.3cm}{\ttfamily [inline]}}\label{classmlpack_1_1tree_1_1CosineTree_a8f7aaaa1d736e6fa5f09596998795246}


Get number of columns of input matrix in the node. 



Definition at line 207 of file cosine\+\_\+tree.\+hpp.



References num\+Columns.

\index{mlpack\+::tree\+::\+Cosine\+Tree@{mlpack\+::tree\+::\+Cosine\+Tree}!Parent@{Parent}}
\index{Parent@{Parent}!mlpack\+::tree\+::\+Cosine\+Tree@{mlpack\+::tree\+::\+Cosine\+Tree}}
\subsubsection[{Parent() const }]{\setlength{\rightskip}{0pt plus 5cm}{\bf Cosine\+Tree}$\ast$ mlpack\+::tree\+::\+Cosine\+Tree\+::\+Parent (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
) const\hspace{0.3cm}{\ttfamily [inline]}}\label{classmlpack_1_1tree_1_1CosineTree_ac91909960fc1e92cf083c073c5903c52}


Get pointer to the parent node. 



Definition at line 192 of file cosine\+\_\+tree.\+hpp.



References parent.

\index{mlpack\+::tree\+::\+Cosine\+Tree@{mlpack\+::tree\+::\+Cosine\+Tree}!Parent@{Parent}}
\index{Parent@{Parent}!mlpack\+::tree\+::\+Cosine\+Tree@{mlpack\+::tree\+::\+Cosine\+Tree}}
\subsubsection[{Parent()}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Cosine\+Tree}$\ast$\& mlpack\+::tree\+::\+Cosine\+Tree\+::\+Parent (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}}\label{classmlpack_1_1tree_1_1CosineTree_a4baa05035e458d8e09a5ccee0fae9f68}


Modify the pointer to the parent node. 



Definition at line 194 of file cosine\+\_\+tree.\+hpp.



References parent.

\index{mlpack\+::tree\+::\+Cosine\+Tree@{mlpack\+::tree\+::\+Cosine\+Tree}!Right@{Right}}
\index{Right@{Right}!mlpack\+::tree\+::\+Cosine\+Tree@{mlpack\+::tree\+::\+Cosine\+Tree}}
\subsubsection[{Right() const }]{\setlength{\rightskip}{0pt plus 5cm}{\bf Cosine\+Tree}$\ast$ mlpack\+::tree\+::\+Cosine\+Tree\+::\+Right (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
) const\hspace{0.3cm}{\ttfamily [inline]}}\label{classmlpack_1_1tree_1_1CosineTree_aec829bd377937345ab31964c141972c2}


Get pointer to the right child of the node. 



Definition at line 202 of file cosine\+\_\+tree.\+hpp.



References right.

\index{mlpack\+::tree\+::\+Cosine\+Tree@{mlpack\+::tree\+::\+Cosine\+Tree}!Right@{Right}}
\index{Right@{Right}!mlpack\+::tree\+::\+Cosine\+Tree@{mlpack\+::tree\+::\+Cosine\+Tree}}
\subsubsection[{Right()}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Cosine\+Tree}$\ast$\& mlpack\+::tree\+::\+Cosine\+Tree\+::\+Right (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}}\label{classmlpack_1_1tree_1_1CosineTree_ad6d68d74021f6ee4d0c0765e323b6cf2}


Modify the pointer to the left child of the node. 



Definition at line 204 of file cosine\+\_\+tree.\+hpp.



References right.

\index{mlpack\+::tree\+::\+Cosine\+Tree@{mlpack\+::tree\+::\+Cosine\+Tree}!Split\+Point\+Index@{Split\+Point\+Index}}
\index{Split\+Point\+Index@{Split\+Point\+Index}!mlpack\+::tree\+::\+Cosine\+Tree@{mlpack\+::tree\+::\+Cosine\+Tree}}
\subsubsection[{Split\+Point\+Index() const }]{\setlength{\rightskip}{0pt plus 5cm}size\+\_\+t mlpack\+::tree\+::\+Cosine\+Tree\+::\+Split\+Point\+Index (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
) const\hspace{0.3cm}{\ttfamily [inline]}}\label{classmlpack_1_1tree_1_1CosineTree_a2f130352bda9417a9cfa5dcc53eb0c23}


Get the column index of split point of the node. 



Definition at line 213 of file cosine\+\_\+tree.\+hpp.



References indices, and split\+Point\+Index.

\index{mlpack\+::tree\+::\+Cosine\+Tree@{mlpack\+::tree\+::\+Cosine\+Tree}!Vector\+Indices@{Vector\+Indices}}
\index{Vector\+Indices@{Vector\+Indices}!mlpack\+::tree\+::\+Cosine\+Tree@{mlpack\+::tree\+::\+Cosine\+Tree}}
\subsubsection[{Vector\+Indices()}]{\setlength{\rightskip}{0pt plus 5cm}std\+::vector$<$size\+\_\+t$>$\& mlpack\+::tree\+::\+Cosine\+Tree\+::\+Vector\+Indices (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}}\label{classmlpack_1_1tree_1_1CosineTree_a0f80789d3cf00249d6cf2d2c8b0a7a8f}


Get the indices of columns in the node. 



Definition at line 175 of file cosine\+\_\+tree.\+hpp.



References indices.



\subsection{Member Data Documentation}
\index{mlpack\+::tree\+::\+Cosine\+Tree@{mlpack\+::tree\+::\+Cosine\+Tree}!basis@{basis}}
\index{basis@{basis}!mlpack\+::tree\+::\+Cosine\+Tree@{mlpack\+::tree\+::\+Cosine\+Tree}}
\subsubsection[{basis}]{\setlength{\rightskip}{0pt plus 5cm}arma\+::mat mlpack\+::tree\+::\+Cosine\+Tree\+::basis\hspace{0.3cm}{\ttfamily [private]}}\label{classmlpack_1_1tree_1_1CosineTree_aa6350375ea4f9c5cecd97efaa1fc5f87}


Subspace basis of the input dataset. 



Definition at line 221 of file cosine\+\_\+tree.\+hpp.



Referenced by Get\+Final\+Basis().

\index{mlpack\+::tree\+::\+Cosine\+Tree@{mlpack\+::tree\+::\+Cosine\+Tree}!basis\+Vector@{basis\+Vector}}
\index{basis\+Vector@{basis\+Vector}!mlpack\+::tree\+::\+Cosine\+Tree@{mlpack\+::tree\+::\+Cosine\+Tree}}
\subsubsection[{basis\+Vector}]{\setlength{\rightskip}{0pt plus 5cm}arma\+::vec mlpack\+::tree\+::\+Cosine\+Tree\+::basis\+Vector\hspace{0.3cm}{\ttfamily [private]}}\label{classmlpack_1_1tree_1_1CosineTree_af087a35ed741d7d8ada8921159527aa7}


Orthonormalized basis vector of the node. 



Definition at line 235 of file cosine\+\_\+tree.\+hpp.



Referenced by Basis\+Vector().

\index{mlpack\+::tree\+::\+Cosine\+Tree@{mlpack\+::tree\+::\+Cosine\+Tree}!centroid@{centroid}}
\index{centroid@{centroid}!mlpack\+::tree\+::\+Cosine\+Tree@{mlpack\+::tree\+::\+Cosine\+Tree}}
\subsubsection[{centroid}]{\setlength{\rightskip}{0pt plus 5cm}arma\+::vec mlpack\+::tree\+::\+Cosine\+Tree\+::centroid\hspace{0.3cm}{\ttfamily [private]}}\label{classmlpack_1_1tree_1_1CosineTree_a0f7bb5e3afb23ecf291587ec207cabd7}


Centroid of columns of input matrix in the node. 



Definition at line 233 of file cosine\+\_\+tree.\+hpp.



Referenced by Centroid().

\index{mlpack\+::tree\+::\+Cosine\+Tree@{mlpack\+::tree\+::\+Cosine\+Tree}!dataset@{dataset}}
\index{dataset@{dataset}!mlpack\+::tree\+::\+Cosine\+Tree@{mlpack\+::tree\+::\+Cosine\+Tree}}
\subsubsection[{dataset}]{\setlength{\rightskip}{0pt plus 5cm}const arma\+::mat\& mlpack\+::tree\+::\+Cosine\+Tree\+::dataset\hspace{0.3cm}{\ttfamily [private]}}\label{classmlpack_1_1tree_1_1CosineTree_a18a066969b47858bc098512419c2a251}


Matrix for which cosine tree is constructed. 



Definition at line 217 of file cosine\+\_\+tree.\+hpp.



Referenced by Get\+Dataset().

\index{mlpack\+::tree\+::\+Cosine\+Tree@{mlpack\+::tree\+::\+Cosine\+Tree}!delta@{delta}}
\index{delta@{delta}!mlpack\+::tree\+::\+Cosine\+Tree@{mlpack\+::tree\+::\+Cosine\+Tree}}
\subsubsection[{delta}]{\setlength{\rightskip}{0pt plus 5cm}double mlpack\+::tree\+::\+Cosine\+Tree\+::delta\hspace{0.3cm}{\ttfamily [private]}}\label{classmlpack_1_1tree_1_1CosineTree_a8fbf6ec7008383e08a4532a9e1a9b1ba}


Cumulative probability for Monte Carlo error lower bound. 



Definition at line 219 of file cosine\+\_\+tree.\+hpp.

\index{mlpack\+::tree\+::\+Cosine\+Tree@{mlpack\+::tree\+::\+Cosine\+Tree}!frob\+Norm\+Squared@{frob\+Norm\+Squared}}
\index{frob\+Norm\+Squared@{frob\+Norm\+Squared}!mlpack\+::tree\+::\+Cosine\+Tree@{mlpack\+::tree\+::\+Cosine\+Tree}}
\subsubsection[{frob\+Norm\+Squared}]{\setlength{\rightskip}{0pt plus 5cm}double mlpack\+::tree\+::\+Cosine\+Tree\+::frob\+Norm\+Squared\hspace{0.3cm}{\ttfamily [private]}}\label{classmlpack_1_1tree_1_1CosineTree_aaec5d90fe58890259e4d1a6fd59ddcb2}


Frobenius norm squared of columns in the node. 



Definition at line 243 of file cosine\+\_\+tree.\+hpp.



Referenced by Frob\+Norm\+Squared().

\index{mlpack\+::tree\+::\+Cosine\+Tree@{mlpack\+::tree\+::\+Cosine\+Tree}!indices@{indices}}
\index{indices@{indices}!mlpack\+::tree\+::\+Cosine\+Tree@{mlpack\+::tree\+::\+Cosine\+Tree}}
\subsubsection[{indices}]{\setlength{\rightskip}{0pt plus 5cm}std\+::vector$<$size\+\_\+t$>$ mlpack\+::tree\+::\+Cosine\+Tree\+::indices\hspace{0.3cm}{\ttfamily [private]}}\label{classmlpack_1_1tree_1_1CosineTree_ac1b92a187dcb787e9c410e5192562772}


Indices of columns of input matrix in the node. 



Definition at line 229 of file cosine\+\_\+tree.\+hpp.



Referenced by Split\+Point\+Index(), and Vector\+Indices().

\index{mlpack\+::tree\+::\+Cosine\+Tree@{mlpack\+::tree\+::\+Cosine\+Tree}!l2\+Error@{l2\+Error}}
\index{l2\+Error@{l2\+Error}!mlpack\+::tree\+::\+Cosine\+Tree@{mlpack\+::tree\+::\+Cosine\+Tree}}
\subsubsection[{l2\+Error}]{\setlength{\rightskip}{0pt plus 5cm}double mlpack\+::tree\+::\+Cosine\+Tree\+::l2\+Error\hspace{0.3cm}{\ttfamily [private]}}\label{classmlpack_1_1tree_1_1CosineTree_aef135dcfc07a26f8af0f6e24ca07d739}


Monte Carlo error for this node. 



Definition at line 241 of file cosine\+\_\+tree.\+hpp.



Referenced by L2\+Error().

\index{mlpack\+::tree\+::\+Cosine\+Tree@{mlpack\+::tree\+::\+Cosine\+Tree}!l2\+Norms\+Squared@{l2\+Norms\+Squared}}
\index{l2\+Norms\+Squared@{l2\+Norms\+Squared}!mlpack\+::tree\+::\+Cosine\+Tree@{mlpack\+::tree\+::\+Cosine\+Tree}}
\subsubsection[{l2\+Norms\+Squared}]{\setlength{\rightskip}{0pt plus 5cm}arma\+::vec mlpack\+::tree\+::\+Cosine\+Tree\+::l2\+Norms\+Squared\hspace{0.3cm}{\ttfamily [private]}}\label{classmlpack_1_1tree_1_1CosineTree_aa07de1621f98ecfb03b9f3f1ec60a2e2}


L2-\/norm squared of columns in the node. 



Definition at line 231 of file cosine\+\_\+tree.\+hpp.

\index{mlpack\+::tree\+::\+Cosine\+Tree@{mlpack\+::tree\+::\+Cosine\+Tree}!left@{left}}
\index{left@{left}!mlpack\+::tree\+::\+Cosine\+Tree@{mlpack\+::tree\+::\+Cosine\+Tree}}
\subsubsection[{left}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Cosine\+Tree}$\ast$ mlpack\+::tree\+::\+Cosine\+Tree\+::left\hspace{0.3cm}{\ttfamily [private]}}\label{classmlpack_1_1tree_1_1CosineTree_a74fc023dcf26c0fed4db61ea0a9a44eb}


Left child of the node. 



Definition at line 225 of file cosine\+\_\+tree.\+hpp.



Referenced by Left().

\index{mlpack\+::tree\+::\+Cosine\+Tree@{mlpack\+::tree\+::\+Cosine\+Tree}!num\+Columns@{num\+Columns}}
\index{num\+Columns@{num\+Columns}!mlpack\+::tree\+::\+Cosine\+Tree@{mlpack\+::tree\+::\+Cosine\+Tree}}
\subsubsection[{num\+Columns}]{\setlength{\rightskip}{0pt plus 5cm}size\+\_\+t mlpack\+::tree\+::\+Cosine\+Tree\+::num\+Columns\hspace{0.3cm}{\ttfamily [private]}}\label{classmlpack_1_1tree_1_1CosineTree_af745e768b85f075e5263e2530bbe01c7}


Number of columns of input matrix in the node. 



Definition at line 239 of file cosine\+\_\+tree.\+hpp.



Referenced by Num\+Columns().

\index{mlpack\+::tree\+::\+Cosine\+Tree@{mlpack\+::tree\+::\+Cosine\+Tree}!parent@{parent}}
\index{parent@{parent}!mlpack\+::tree\+::\+Cosine\+Tree@{mlpack\+::tree\+::\+Cosine\+Tree}}
\subsubsection[{parent}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Cosine\+Tree}$\ast$ mlpack\+::tree\+::\+Cosine\+Tree\+::parent\hspace{0.3cm}{\ttfamily [private]}}\label{classmlpack_1_1tree_1_1CosineTree_a37f0d9e5e0f12807f8ffc8f179d1d3ef}


Parent of the node. 



Definition at line 223 of file cosine\+\_\+tree.\+hpp.



Referenced by Parent().

\index{mlpack\+::tree\+::\+Cosine\+Tree@{mlpack\+::tree\+::\+Cosine\+Tree}!right@{right}}
\index{right@{right}!mlpack\+::tree\+::\+Cosine\+Tree@{mlpack\+::tree\+::\+Cosine\+Tree}}
\subsubsection[{right}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Cosine\+Tree}$\ast$ mlpack\+::tree\+::\+Cosine\+Tree\+::right\hspace{0.3cm}{\ttfamily [private]}}\label{classmlpack_1_1tree_1_1CosineTree_a7c4ac86fd0091c1cd67ce1c45afd9315}


Right child of the node. 



Definition at line 227 of file cosine\+\_\+tree.\+hpp.



Referenced by Right().

\index{mlpack\+::tree\+::\+Cosine\+Tree@{mlpack\+::tree\+::\+Cosine\+Tree}!split\+Point\+Index@{split\+Point\+Index}}
\index{split\+Point\+Index@{split\+Point\+Index}!mlpack\+::tree\+::\+Cosine\+Tree@{mlpack\+::tree\+::\+Cosine\+Tree}}
\subsubsection[{split\+Point\+Index}]{\setlength{\rightskip}{0pt plus 5cm}size\+\_\+t mlpack\+::tree\+::\+Cosine\+Tree\+::split\+Point\+Index\hspace{0.3cm}{\ttfamily [private]}}\label{classmlpack_1_1tree_1_1CosineTree_ab5fa61c11e0a2899e66ae90b35c4e82c}


Index of split point of cosine node. 



Definition at line 237 of file cosine\+\_\+tree.\+hpp.



Referenced by Split\+Point\+Index().



The documentation for this class was generated from the following file\+:\begin{DoxyCompactItemize}
\item 
src/mlpack/core/tree/cosine\+\_\+tree/{\bf cosine\+\_\+tree.\+hpp}\end{DoxyCompactItemize}
