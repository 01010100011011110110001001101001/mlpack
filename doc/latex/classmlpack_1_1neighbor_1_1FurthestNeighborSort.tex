\section{mlpack\+:\+:neighbor\+:\+:Furthest\+Neighbor\+Sort Class Reference}
\label{classmlpack_1_1neighbor_1_1FurthestNeighborSort}\index{mlpack\+::neighbor\+::\+Furthest\+Neighbor\+Sort@{mlpack\+::neighbor\+::\+Furthest\+Neighbor\+Sort}}


This class implements the necessary methods for the Sort\+Policy template parameter of the \doxyref{Neighbor\+Search}{p.}{classmlpack_1_1neighbor_1_1NeighborSearch} class.  


\subsection*{Static Public Member Functions}
\begin{DoxyCompactItemize}
\item 
static double {\bf Best\+Distance} ()
\begin{DoxyCompactList}\small\item\em Return what should represent the best possible distance with this particular sort policy. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename Tree\+Type $>$ }\\static double {\bf Best\+Node\+To\+Node\+Distance} (const Tree\+Type $\ast$query\+Node, const Tree\+Type $\ast$reference\+Node)
\begin{DoxyCompactList}\small\item\em Return the best possible distance between two nodes. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename Tree\+Type $>$ }\\static double {\bf Best\+Node\+To\+Node\+Distance} (const Tree\+Type $\ast$query\+Node, const Tree\+Type $\ast$reference\+Node, const double center\+To\+Center\+Distance)
\begin{DoxyCompactList}\small\item\em Return the best possible distance between two nodes, given that the distance between the centers of the two nodes has already been calculated. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename Tree\+Type $>$ }\\static double {\bf Best\+Node\+To\+Node\+Distance} (const Tree\+Type $\ast$query\+Node, const Tree\+Type $\ast$reference\+Node, const Tree\+Type $\ast$reference\+Child\+Node, const double center\+To\+Center\+Distance)
\begin{DoxyCompactList}\small\item\em Return the best possible distance between the query node and the reference child node given the base case distance between the query node and the reference node. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename Vec\+Type , typename Tree\+Type $>$ }\\static double {\bf Best\+Point\+To\+Node\+Distance} (const Vec\+Type \&query\+Point, const Tree\+Type $\ast$reference\+Node)
\begin{DoxyCompactList}\small\item\em Return the best possible distance between a node and a point. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename Vec\+Type , typename Tree\+Type $>$ }\\static double {\bf Best\+Point\+To\+Node\+Distance} (const Vec\+Type \&query\+Point, const Tree\+Type $\ast$reference\+Node, const double point\+To\+Center\+Distance)
\begin{DoxyCompactList}\small\item\em Return the best possible distance between a point and a node, given that the distance between the point and the center of the node has already been calculated. \end{DoxyCompactList}\item 
static double {\bf Combine\+Best} (const double a, const double b)
\begin{DoxyCompactList}\small\item\em Return the best combination of the two distances. \end{DoxyCompactList}\item 
static double {\bf Combine\+Worst} (const double a, const double b)
\begin{DoxyCompactList}\small\item\em Return the worst combination of the two distances. \end{DoxyCompactList}\item 
static double {\bf Convert\+To\+Distance} (const double score)
\begin{DoxyCompactList}\small\item\em Convert the given score back to a distance. \end{DoxyCompactList}\item 
static double {\bf Convert\+To\+Score} (const double distance)
\begin{DoxyCompactList}\small\item\em Convert the given distance to a score. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename Vec\+Type , typename Tree\+Type $>$ }\\static size\+\_\+t {\bf Get\+Best\+Child} (const Vec\+Type \&query\+Point, Tree\+Type \&reference\+Node)
\begin{DoxyCompactList}\small\item\em Return the best child according to this sort policy. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename Tree\+Type $>$ }\\static size\+\_\+t {\bf Get\+Best\+Child} (const Tree\+Type \&query\+Node, Tree\+Type \&reference\+Node)
\begin{DoxyCompactList}\small\item\em Return the best child according to this sort policy. \end{DoxyCompactList}\item 
static bool {\bf Is\+Better} (const double value, const double ref)
\begin{DoxyCompactList}\small\item\em Return whether or not value is \char`\"{}better\char`\"{} than ref. \end{DoxyCompactList}\item 
static double {\bf Relax} (const double value, const double epsilon)
\begin{DoxyCompactList}\small\item\em Return the given value relaxed. \end{DoxyCompactList}\item 
static double {\bf Worst\+Distance} ()
\begin{DoxyCompactList}\small\item\em Return what should represent the worst possible distance with this particular sort policy. \end{DoxyCompactList}\end{DoxyCompactItemize}


\subsection{Detailed Description}
This class implements the necessary methods for the Sort\+Policy template parameter of the \doxyref{Neighbor\+Search}{p.}{classmlpack_1_1neighbor_1_1NeighborSearch} class. 

The sorting policy here is that the minimum distance is the best (so, when used with \doxyref{Neighbor\+Search}{p.}{classmlpack_1_1neighbor_1_1NeighborSearch}, the output is furthest neighbors). 

Definition at line 27 of file furthest\+\_\+neighbor\+\_\+sort.\+hpp.



\subsection{Member Function Documentation}
\index{mlpack\+::neighbor\+::\+Furthest\+Neighbor\+Sort@{mlpack\+::neighbor\+::\+Furthest\+Neighbor\+Sort}!Best\+Distance@{Best\+Distance}}
\index{Best\+Distance@{Best\+Distance}!mlpack\+::neighbor\+::\+Furthest\+Neighbor\+Sort@{mlpack\+::neighbor\+::\+Furthest\+Neighbor\+Sort}}
\subsubsection[{Best\+Distance()}]{\setlength{\rightskip}{0pt plus 5cm}static double mlpack\+::neighbor\+::\+Furthest\+Neighbor\+Sort\+::\+Best\+Distance (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [static]}}\label{classmlpack_1_1neighbor_1_1FurthestNeighborSort_a24e85dec805cc1f264a138501ee24731}


Return what should represent the best possible distance with this particular sort policy. 

In our case, this should be the maximum possible distance, D\+B\+L\+\_\+\+M\+AX.

\begin{DoxyReturn}{Returns}
D\+B\+L\+\_\+\+M\+AX 
\end{DoxyReturn}


Definition at line 138 of file furthest\+\_\+neighbor\+\_\+sort.\+hpp.

\index{mlpack\+::neighbor\+::\+Furthest\+Neighbor\+Sort@{mlpack\+::neighbor\+::\+Furthest\+Neighbor\+Sort}!Best\+Node\+To\+Node\+Distance@{Best\+Node\+To\+Node\+Distance}}
\index{Best\+Node\+To\+Node\+Distance@{Best\+Node\+To\+Node\+Distance}!mlpack\+::neighbor\+::\+Furthest\+Neighbor\+Sort@{mlpack\+::neighbor\+::\+Furthest\+Neighbor\+Sort}}
\subsubsection[{Best\+Node\+To\+Node\+Distance(const Tree\+Type $\ast$query\+Node, const Tree\+Type $\ast$reference\+Node)}]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename Tree\+Type $>$ static double mlpack\+::neighbor\+::\+Furthest\+Neighbor\+Sort\+::\+Best\+Node\+To\+Node\+Distance (
\begin{DoxyParamCaption}
\item[{const Tree\+Type $\ast$}]{query\+Node, }
\item[{const Tree\+Type $\ast$}]{reference\+Node}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [static]}}\label{classmlpack_1_1neighbor_1_1FurthestNeighborSort_aae51f34ae4b6cc8e680e11419ecbefe2}


Return the best possible distance between two nodes. 

In our case, this is the maximum distance between the two tree nodes using the given distance function. 

Referenced by Is\+Better().

\index{mlpack\+::neighbor\+::\+Furthest\+Neighbor\+Sort@{mlpack\+::neighbor\+::\+Furthest\+Neighbor\+Sort}!Best\+Node\+To\+Node\+Distance@{Best\+Node\+To\+Node\+Distance}}
\index{Best\+Node\+To\+Node\+Distance@{Best\+Node\+To\+Node\+Distance}!mlpack\+::neighbor\+::\+Furthest\+Neighbor\+Sort@{mlpack\+::neighbor\+::\+Furthest\+Neighbor\+Sort}}
\subsubsection[{Best\+Node\+To\+Node\+Distance(const Tree\+Type $\ast$query\+Node, const Tree\+Type $\ast$reference\+Node, const double center\+To\+Center\+Distance)}]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename Tree\+Type $>$ static double mlpack\+::neighbor\+::\+Furthest\+Neighbor\+Sort\+::\+Best\+Node\+To\+Node\+Distance (
\begin{DoxyParamCaption}
\item[{const Tree\+Type $\ast$}]{query\+Node, }
\item[{const Tree\+Type $\ast$}]{reference\+Node, }
\item[{const double}]{center\+To\+Center\+Distance}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [static]}}\label{classmlpack_1_1neighbor_1_1FurthestNeighborSort_ac33c263a2ad24c6aa1b1f812b1328200}


Return the best possible distance between two nodes, given that the distance between the centers of the two nodes has already been calculated. 

This is used in conjunction with trees that have self-\/children (like cover trees). \index{mlpack\+::neighbor\+::\+Furthest\+Neighbor\+Sort@{mlpack\+::neighbor\+::\+Furthest\+Neighbor\+Sort}!Best\+Node\+To\+Node\+Distance@{Best\+Node\+To\+Node\+Distance}}
\index{Best\+Node\+To\+Node\+Distance@{Best\+Node\+To\+Node\+Distance}!mlpack\+::neighbor\+::\+Furthest\+Neighbor\+Sort@{mlpack\+::neighbor\+::\+Furthest\+Neighbor\+Sort}}
\subsubsection[{Best\+Node\+To\+Node\+Distance(const Tree\+Type $\ast$query\+Node, const Tree\+Type $\ast$reference\+Node, const Tree\+Type $\ast$reference\+Child\+Node, const double center\+To\+Center\+Distance)}]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename Tree\+Type $>$ static double mlpack\+::neighbor\+::\+Furthest\+Neighbor\+Sort\+::\+Best\+Node\+To\+Node\+Distance (
\begin{DoxyParamCaption}
\item[{const Tree\+Type $\ast$}]{query\+Node, }
\item[{const Tree\+Type $\ast$}]{reference\+Node, }
\item[{const Tree\+Type $\ast$}]{reference\+Child\+Node, }
\item[{const double}]{center\+To\+Center\+Distance}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [static]}}\label{classmlpack_1_1neighbor_1_1FurthestNeighborSort_a2723d2714fb8ef4eb2823f8f0e1d236f}


Return the best possible distance between the query node and the reference child node given the base case distance between the query node and the reference node. 

Tree\+Type\+::\+Parent\+Distance() must be implemented to use this.


\begin{DoxyParams}{Parameters}
{\em query\+Node} & Query node. \\
\hline
{\em reference\+Node} & Reference node. \\
\hline
{\em reference\+Child\+Node} & Child of reference node which is being inspected. \\
\hline
{\em center\+To\+Center\+Distance} & Distance between centers of query node and reference node. \\
\hline
\end{DoxyParams}
\index{mlpack\+::neighbor\+::\+Furthest\+Neighbor\+Sort@{mlpack\+::neighbor\+::\+Furthest\+Neighbor\+Sort}!Best\+Point\+To\+Node\+Distance@{Best\+Point\+To\+Node\+Distance}}
\index{Best\+Point\+To\+Node\+Distance@{Best\+Point\+To\+Node\+Distance}!mlpack\+::neighbor\+::\+Furthest\+Neighbor\+Sort@{mlpack\+::neighbor\+::\+Furthest\+Neighbor\+Sort}}
\subsubsection[{Best\+Point\+To\+Node\+Distance(const Vec\+Type \&query\+Point, const Tree\+Type $\ast$reference\+Node)}]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename Vec\+Type , typename Tree\+Type $>$ static double mlpack\+::neighbor\+::\+Furthest\+Neighbor\+Sort\+::\+Best\+Point\+To\+Node\+Distance (
\begin{DoxyParamCaption}
\item[{const Vec\+Type \&}]{query\+Point, }
\item[{const Tree\+Type $\ast$}]{reference\+Node}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [static]}}\label{classmlpack_1_1neighbor_1_1FurthestNeighborSort_a34bb0125bd76ce88e8667beda05999ca}


Return the best possible distance between a node and a point. 

In our case, this is the maximum distance between the tree node and the point using the given distance function. 

Referenced by Is\+Better().

\index{mlpack\+::neighbor\+::\+Furthest\+Neighbor\+Sort@{mlpack\+::neighbor\+::\+Furthest\+Neighbor\+Sort}!Best\+Point\+To\+Node\+Distance@{Best\+Point\+To\+Node\+Distance}}
\index{Best\+Point\+To\+Node\+Distance@{Best\+Point\+To\+Node\+Distance}!mlpack\+::neighbor\+::\+Furthest\+Neighbor\+Sort@{mlpack\+::neighbor\+::\+Furthest\+Neighbor\+Sort}}
\subsubsection[{Best\+Point\+To\+Node\+Distance(const Vec\+Type \&query\+Point, const Tree\+Type $\ast$reference\+Node, const double point\+To\+Center\+Distance)}]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename Vec\+Type , typename Tree\+Type $>$ static double mlpack\+::neighbor\+::\+Furthest\+Neighbor\+Sort\+::\+Best\+Point\+To\+Node\+Distance (
\begin{DoxyParamCaption}
\item[{const Vec\+Type \&}]{query\+Point, }
\item[{const Tree\+Type $\ast$}]{reference\+Node, }
\item[{const double}]{point\+To\+Center\+Distance}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [static]}}\label{classmlpack_1_1neighbor_1_1FurthestNeighborSort_ae0693c24eebbc8e2434a66fc23846b29}


Return the best possible distance between a point and a node, given that the distance between the point and the center of the node has already been calculated. 

This is used in conjunction with trees that have self-\/children (like cover trees). \index{mlpack\+::neighbor\+::\+Furthest\+Neighbor\+Sort@{mlpack\+::neighbor\+::\+Furthest\+Neighbor\+Sort}!Combine\+Best@{Combine\+Best}}
\index{Combine\+Best@{Combine\+Best}!mlpack\+::neighbor\+::\+Furthest\+Neighbor\+Sort@{mlpack\+::neighbor\+::\+Furthest\+Neighbor\+Sort}}
\subsubsection[{Combine\+Best(const double a, const double b)}]{\setlength{\rightskip}{0pt plus 5cm}static double mlpack\+::neighbor\+::\+Furthest\+Neighbor\+Sort\+::\+Combine\+Best (
\begin{DoxyParamCaption}
\item[{const double}]{a, }
\item[{const double}]{b}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [static]}}\label{classmlpack_1_1neighbor_1_1FurthestNeighborSort_af18ff3e6418df212e4183053e16f0e53}


Return the best combination of the two distances. 



Definition at line 143 of file furthest\+\_\+neighbor\+\_\+sort.\+hpp.

\index{mlpack\+::neighbor\+::\+Furthest\+Neighbor\+Sort@{mlpack\+::neighbor\+::\+Furthest\+Neighbor\+Sort}!Combine\+Worst@{Combine\+Worst}}
\index{Combine\+Worst@{Combine\+Worst}!mlpack\+::neighbor\+::\+Furthest\+Neighbor\+Sort@{mlpack\+::neighbor\+::\+Furthest\+Neighbor\+Sort}}
\subsubsection[{Combine\+Worst(const double a, const double b)}]{\setlength{\rightskip}{0pt plus 5cm}static double mlpack\+::neighbor\+::\+Furthest\+Neighbor\+Sort\+::\+Combine\+Worst (
\begin{DoxyParamCaption}
\item[{const double}]{a, }
\item[{const double}]{b}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [static]}}\label{classmlpack_1_1neighbor_1_1FurthestNeighborSort_a047b9d3ccb95d1735442bffbfee0482d}


Return the worst combination of the two distances. 



Definition at line 153 of file furthest\+\_\+neighbor\+\_\+sort.\+hpp.

\index{mlpack\+::neighbor\+::\+Furthest\+Neighbor\+Sort@{mlpack\+::neighbor\+::\+Furthest\+Neighbor\+Sort}!Convert\+To\+Distance@{Convert\+To\+Distance}}
\index{Convert\+To\+Distance@{Convert\+To\+Distance}!mlpack\+::neighbor\+::\+Furthest\+Neighbor\+Sort@{mlpack\+::neighbor\+::\+Furthest\+Neighbor\+Sort}}
\subsubsection[{Convert\+To\+Distance(const double score)}]{\setlength{\rightskip}{0pt plus 5cm}static double mlpack\+::neighbor\+::\+Furthest\+Neighbor\+Sort\+::\+Convert\+To\+Distance (
\begin{DoxyParamCaption}
\item[{const double}]{score}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [static]}}\label{classmlpack_1_1neighbor_1_1FurthestNeighborSort_a208751cd6ff98429009bc0583e6d3086}


Convert the given score back to a distance. 

This is the inverse of the operation of converting a distance to a score, and again, for furthest neighbor search, corresponds to inverting the value. 

Definition at line 193 of file furthest\+\_\+neighbor\+\_\+sort.\+hpp.



References Convert\+To\+Score().

\index{mlpack\+::neighbor\+::\+Furthest\+Neighbor\+Sort@{mlpack\+::neighbor\+::\+Furthest\+Neighbor\+Sort}!Convert\+To\+Score@{Convert\+To\+Score}}
\index{Convert\+To\+Score@{Convert\+To\+Score}!mlpack\+::neighbor\+::\+Furthest\+Neighbor\+Sort@{mlpack\+::neighbor\+::\+Furthest\+Neighbor\+Sort}}
\subsubsection[{Convert\+To\+Score(const double distance)}]{\setlength{\rightskip}{0pt plus 5cm}static double mlpack\+::neighbor\+::\+Furthest\+Neighbor\+Sort\+::\+Convert\+To\+Score (
\begin{DoxyParamCaption}
\item[{const double}]{distance}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [static]}}\label{classmlpack_1_1neighbor_1_1FurthestNeighborSort_a9fb94f962f9a231ced472ae9286faff4}


Convert the given distance to a score. 

Lower scores are better, but for furthest neighbor search, larger distances are better. Therefore we must invert the given distance. 

Definition at line 178 of file furthest\+\_\+neighbor\+\_\+sort.\+hpp.



Referenced by Convert\+To\+Distance().

\index{mlpack\+::neighbor\+::\+Furthest\+Neighbor\+Sort@{mlpack\+::neighbor\+::\+Furthest\+Neighbor\+Sort}!Get\+Best\+Child@{Get\+Best\+Child}}
\index{Get\+Best\+Child@{Get\+Best\+Child}!mlpack\+::neighbor\+::\+Furthest\+Neighbor\+Sort@{mlpack\+::neighbor\+::\+Furthest\+Neighbor\+Sort}}
\subsubsection[{Get\+Best\+Child(const Vec\+Type \&query\+Point, Tree\+Type \&reference\+Node)}]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename Vec\+Type , typename Tree\+Type $>$ static size\+\_\+t mlpack\+::neighbor\+::\+Furthest\+Neighbor\+Sort\+::\+Get\+Best\+Child (
\begin{DoxyParamCaption}
\item[{const Vec\+Type \&}]{query\+Point, }
\item[{Tree\+Type \&}]{reference\+Node}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [static]}}\label{classmlpack_1_1neighbor_1_1FurthestNeighborSort_a6c342c104ea5a45133336f62393e50b8}


Return the best child according to this sort policy. 

In this case it will return the one with the maximum distance. 

Definition at line 107 of file furthest\+\_\+neighbor\+\_\+sort.\+hpp.

\index{mlpack\+::neighbor\+::\+Furthest\+Neighbor\+Sort@{mlpack\+::neighbor\+::\+Furthest\+Neighbor\+Sort}!Get\+Best\+Child@{Get\+Best\+Child}}
\index{Get\+Best\+Child@{Get\+Best\+Child}!mlpack\+::neighbor\+::\+Furthest\+Neighbor\+Sort@{mlpack\+::neighbor\+::\+Furthest\+Neighbor\+Sort}}
\subsubsection[{Get\+Best\+Child(const Tree\+Type \&query\+Node, Tree\+Type \&reference\+Node)}]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename Tree\+Type $>$ static size\+\_\+t mlpack\+::neighbor\+::\+Furthest\+Neighbor\+Sort\+::\+Get\+Best\+Child (
\begin{DoxyParamCaption}
\item[{const Tree\+Type \&}]{query\+Node, }
\item[{Tree\+Type \&}]{reference\+Node}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [static]}}\label{classmlpack_1_1neighbor_1_1FurthestNeighborSort_a740d5dde928a00b8d69470b5d432c4f3}


Return the best child according to this sort policy. 

In this case it will return the one with the maximum distance. 

Definition at line 117 of file furthest\+\_\+neighbor\+\_\+sort.\+hpp.

\index{mlpack\+::neighbor\+::\+Furthest\+Neighbor\+Sort@{mlpack\+::neighbor\+::\+Furthest\+Neighbor\+Sort}!Is\+Better@{Is\+Better}}
\index{Is\+Better@{Is\+Better}!mlpack\+::neighbor\+::\+Furthest\+Neighbor\+Sort@{mlpack\+::neighbor\+::\+Furthest\+Neighbor\+Sort}}
\subsubsection[{Is\+Better(const double value, const double ref)}]{\setlength{\rightskip}{0pt plus 5cm}static bool mlpack\+::neighbor\+::\+Furthest\+Neighbor\+Sort\+::\+Is\+Better (
\begin{DoxyParamCaption}
\item[{const double}]{value, }
\item[{const double}]{ref}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [static]}}\label{classmlpack_1_1neighbor_1_1FurthestNeighborSort_ad958c571e89184874ef8cd8675d563e7}


Return whether or not value is \char`\"{}better\char`\"{} than ref. 

In this case, that means that the value is greater than or equal to the reference.


\begin{DoxyParams}{Parameters}
{\em value} & Value to compare \\
\hline
{\em ref} & Value to compare with\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
bool indicating whether or not (value $>$= ref). 
\end{DoxyReturn}


Definition at line 39 of file furthest\+\_\+neighbor\+\_\+sort.\+hpp.



References Best\+Node\+To\+Node\+Distance(), and Best\+Point\+To\+Node\+Distance().

\index{mlpack\+::neighbor\+::\+Furthest\+Neighbor\+Sort@{mlpack\+::neighbor\+::\+Furthest\+Neighbor\+Sort}!Relax@{Relax}}
\index{Relax@{Relax}!mlpack\+::neighbor\+::\+Furthest\+Neighbor\+Sort@{mlpack\+::neighbor\+::\+Furthest\+Neighbor\+Sort}}
\subsubsection[{Relax(const double value, const double epsilon)}]{\setlength{\rightskip}{0pt plus 5cm}static double mlpack\+::neighbor\+::\+Furthest\+Neighbor\+Sort\+::\+Relax (
\begin{DoxyParamCaption}
\item[{const double}]{value, }
\item[{const double}]{epsilon}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [static]}}\label{classmlpack_1_1neighbor_1_1FurthestNeighborSort_ad7a36c4c393e76b2b36622f92e106069}


Return the given value relaxed. 


\begin{DoxyParams}{Parameters}
{\em value} & Value to relax. \\
\hline
{\em epsilon} & Relative error (non-\/negative).\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
double Value relaxed. 
\end{DoxyReturn}


Definition at line 164 of file furthest\+\_\+neighbor\+\_\+sort.\+hpp.

\index{mlpack\+::neighbor\+::\+Furthest\+Neighbor\+Sort@{mlpack\+::neighbor\+::\+Furthest\+Neighbor\+Sort}!Worst\+Distance@{Worst\+Distance}}
\index{Worst\+Distance@{Worst\+Distance}!mlpack\+::neighbor\+::\+Furthest\+Neighbor\+Sort@{mlpack\+::neighbor\+::\+Furthest\+Neighbor\+Sort}}
\subsubsection[{Worst\+Distance()}]{\setlength{\rightskip}{0pt plus 5cm}static double mlpack\+::neighbor\+::\+Furthest\+Neighbor\+Sort\+::\+Worst\+Distance (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [static]}}\label{classmlpack_1_1neighbor_1_1FurthestNeighborSort_aba7d6c7a4077d3573e4e4b39c9f190d9}


Return what should represent the worst possible distance with this particular sort policy. 

In our case, this should be the minimum possible distance, 0.

\begin{DoxyReturn}{Returns}
0 
\end{DoxyReturn}


Definition at line 129 of file furthest\+\_\+neighbor\+\_\+sort.\+hpp.



The documentation for this class was generated from the following file\+:\begin{DoxyCompactItemize}
\item 
src/mlpack/methods/neighbor\+\_\+search/sort\+\_\+policies/{\bf furthest\+\_\+neighbor\+\_\+sort.\+hpp}\end{DoxyCompactItemize}
