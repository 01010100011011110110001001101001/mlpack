\section{mlpack\+:\+:neighbor\+:\+:R\+A\+Search$<$ Sort\+Policy, Metric\+Type, Mat\+Type, Tree\+Type $>$ Class Template Reference}
\label{classmlpack_1_1neighbor_1_1RASearch}\index{mlpack\+::neighbor\+::\+R\+A\+Search$<$ Sort\+Policy, Metric\+Type, Mat\+Type, Tree\+Type $>$@{mlpack\+::neighbor\+::\+R\+A\+Search$<$ Sort\+Policy, Metric\+Type, Mat\+Type, Tree\+Type $>$}}


The \doxyref{R\+A\+Search}{p.}{classmlpack_1_1neighbor_1_1RASearch} class\+: This class provides a generic manner to perform rank-\/approximate search via random-\/sampling.  




Inheritance diagram for mlpack\+:\+:neighbor\+:\+:R\+A\+Search$<$ Sort\+Policy, Metric\+Type, Mat\+Type, Tree\+Type $>$\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{classmlpack_1_1neighbor_1_1RASearch__inherit__graph}
\end{center}
\end{figure}
\subsection*{Public Types}
\begin{DoxyCompactItemize}
\item 
typedef Tree\+Type$<$ Metric\+Type, {\bf R\+A\+Query\+Stat}$<$ Sort\+Policy $>$, Mat\+Type $>$ {\bf Tree}
\begin{DoxyCompactList}\small\item\em Convenience typedef. \end{DoxyCompactList}\end{DoxyCompactItemize}
\subsection*{Public Member Functions}
\begin{DoxyCompactItemize}
\item 
{\bf R\+A\+Search} (const Mat\+Type \&{\bf reference\+Set}, const bool {\bf naive}=false, const bool {\bf single\+Mode}=false, const double {\bf tau}=5, const double {\bf alpha}=0.\+95, const bool {\bf sample\+At\+Leaves}=false, const bool {\bf first\+Leaf\+Exact}=false, const size\+\_\+t {\bf single\+Sample\+Limit}=20, const Metric\+Type {\bf metric}=Metric\+Type())
\begin{DoxyCompactList}\small\item\em Initialize the \doxyref{R\+A\+Search}{p.}{classmlpack_1_1neighbor_1_1RASearch} object, passing both a reference dataset (this is the dataset that will be searched). \end{DoxyCompactList}\item 
{\bf R\+A\+Search} (Mat\+Type \&\&{\bf reference\+Set}, const bool {\bf naive}=false, const bool {\bf single\+Mode}=false, const double {\bf tau}=5, const double {\bf alpha}=0.\+95, const bool {\bf sample\+At\+Leaves}=false, const bool {\bf first\+Leaf\+Exact}=false, const size\+\_\+t {\bf single\+Sample\+Limit}=20, const Metric\+Type {\bf metric}=Metric\+Type())
\begin{DoxyCompactList}\small\item\em Initialize the \doxyref{R\+A\+Search}{p.}{classmlpack_1_1neighbor_1_1RASearch} object, passing both a reference dataset (this is the dataset that will be searched). \end{DoxyCompactList}\item 
{\bf R\+A\+Search} ({\bf Tree} $\ast${\bf reference\+Tree}, const bool {\bf single\+Mode}=false, const double {\bf tau}=5, const double {\bf alpha}=0.\+95, const bool {\bf sample\+At\+Leaves}=false, const bool {\bf first\+Leaf\+Exact}=false, const size\+\_\+t {\bf single\+Sample\+Limit}=20, const Metric\+Type {\bf metric}=Metric\+Type())
\begin{DoxyCompactList}\small\item\em Initialize the \doxyref{R\+A\+Search}{p.}{classmlpack_1_1neighbor_1_1RASearch} object with the given pre-\/constructed reference tree. \end{DoxyCompactList}\item 
{\bf R\+A\+Search} (const bool {\bf naive}=false, const bool {\bf single\+Mode}=false, const double {\bf tau}=5, const double {\bf alpha}=0.\+95, const bool {\bf sample\+At\+Leaves}=false, const bool {\bf first\+Leaf\+Exact}=false, const size\+\_\+t {\bf single\+Sample\+Limit}=20, const Metric\+Type {\bf metric}=Metric\+Type())
\begin{DoxyCompactList}\small\item\em Create an \doxyref{R\+A\+Search}{p.}{classmlpack_1_1neighbor_1_1RASearch} object with no reference data. \end{DoxyCompactList}\item 
{\bf $\sim$\+R\+A\+Search} ()
\begin{DoxyCompactList}\small\item\em Delete the \doxyref{R\+A\+Search}{p.}{classmlpack_1_1neighbor_1_1RASearch} object. \end{DoxyCompactList}\item 
double {\bf Alpha} () const 
\begin{DoxyCompactList}\small\item\em Get the desired success probability. \end{DoxyCompactList}\item 
double \& {\bf Alpha} ()
\begin{DoxyCompactList}\small\item\em Modify the desired success probability. \end{DoxyCompactList}\item 
bool {\bf First\+Leaf\+Exact} () const 
\begin{DoxyCompactList}\small\item\em Get whether or not we traverse to the first leaf without approximation. \end{DoxyCompactList}\item 
bool \& {\bf First\+Leaf\+Exact} ()
\begin{DoxyCompactList}\small\item\em Modify whether or not we traverse to the first leaf without approximation. \end{DoxyCompactList}\item 
bool {\bf Naive} () const 
\begin{DoxyCompactList}\small\item\em Get whether or not naive (brute-\/force) search is used. \end{DoxyCompactList}\item 
bool \& {\bf Naive} ()
\begin{DoxyCompactList}\small\item\em Modify whether or not naive (brute-\/force) search is used. \end{DoxyCompactList}\item 
const Mat\+Type \& {\bf Reference\+Set} () const 
\begin{DoxyCompactList}\small\item\em Access the reference set. \end{DoxyCompactList}\item 
void {\bf Reset\+Query\+Tree} ({\bf Tree} $\ast$query\+Tree) const 
\begin{DoxyCompactList}\small\item\em This function recursively resets the \doxyref{R\+A\+Query\+Stat}{p.}{classmlpack_1_1neighbor_1_1RAQueryStat} of the given query tree to set \textquotesingle{}bound\textquotesingle{} to Sort\+Policy\+::\+Worst\+Distance and \textquotesingle{}num\+Samples\+Made\textquotesingle{} to 0. \end{DoxyCompactList}\item 
bool {\bf Sample\+At\+Leaves} () const 
\begin{DoxyCompactList}\small\item\em Get whether or not sampling is done at the leaves. \end{DoxyCompactList}\item 
bool \& {\bf Sample\+At\+Leaves} ()
\begin{DoxyCompactList}\small\item\em Modify whether or not sampling is done at the leaves. \end{DoxyCompactList}\item 
void {\bf Search} (const Mat\+Type \&query\+Set, const size\+\_\+t k, arma\+::\+Mat$<$ size\+\_\+t $>$ \&neighbors, arma\+::mat \&distances)
\begin{DoxyCompactList}\small\item\em Compute the rank approximate nearest neighbors of each query point in the query set and store the output in the given matrices. \end{DoxyCompactList}\item 
void {\bf Search} ({\bf Tree} $\ast$query\+Tree, const size\+\_\+t k, arma\+::\+Mat$<$ size\+\_\+t $>$ \&neighbors, arma\+::mat \&distances)
\begin{DoxyCompactList}\small\item\em Compute the rank approximate nearest neighbors of each point in the pre-\/built query tree and store the output in the given matrices. \end{DoxyCompactList}\item 
void {\bf Search} (const size\+\_\+t k, arma\+::\+Mat$<$ size\+\_\+t $>$ \&neighbors, arma\+::mat \&distances)
\begin{DoxyCompactList}\small\item\em Compute the rank approximate nearest neighbors of each point in the reference set (that is, the query set is taken to be the reference set), and store the output in the given matrices. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename Archive $>$ }\\void {\bf Serialize} (Archive \&ar, const unsigned int)
\begin{DoxyCompactList}\small\item\em Serialize the object. \end{DoxyCompactList}\item 
bool {\bf Single\+Mode} () const 
\begin{DoxyCompactList}\small\item\em Get whether or not single-\/tree search is used. \end{DoxyCompactList}\item 
bool \& {\bf Single\+Mode} ()
\begin{DoxyCompactList}\small\item\em Modify whether or not single-\/tree search is used. \end{DoxyCompactList}\item 
size\+\_\+t {\bf Single\+Sample\+Limit} () const 
\begin{DoxyCompactList}\small\item\em Get the limit on the size of a node that can be approximated. \end{DoxyCompactList}\item 
size\+\_\+t \& {\bf Single\+Sample\+Limit} ()
\begin{DoxyCompactList}\small\item\em Modify the limit on the size of a node that can be approximation. \end{DoxyCompactList}\item 
double {\bf Tau} () const 
\begin{DoxyCompactList}\small\item\em Get the rank-\/approximation in percentile of the data. \end{DoxyCompactList}\item 
double \& {\bf Tau} ()
\begin{DoxyCompactList}\small\item\em Modify the rank-\/approximation in percentile of the data. \end{DoxyCompactList}\item 
void {\bf Train} (const Mat\+Type \&{\bf reference\+Set})
\begin{DoxyCompactList}\small\item\em \char`\"{}\+Train\char`\"{} the model on the given reference set. \end{DoxyCompactList}\item 
void {\bf Train} (Mat\+Type \&\&{\bf reference\+Set})
\begin{DoxyCompactList}\small\item\em \char`\"{}\+Train\char`\"{} the model on the given reference set, taking ownership of the data matrix. \end{DoxyCompactList}\end{DoxyCompactItemize}
\subsection*{Private Attributes}
\begin{DoxyCompactItemize}
\item 
double {\bf alpha}
\begin{DoxyCompactList}\small\item\em The desired success probability (between 0 and 1). \end{DoxyCompactList}\item 
bool {\bf first\+Leaf\+Exact}
\begin{DoxyCompactList}\small\item\em If true, we will traverse to the first leaf without approximation. \end{DoxyCompactList}\item 
Metric\+Type {\bf metric}
\begin{DoxyCompactList}\small\item\em Instantiation of kernel. \end{DoxyCompactList}\item 
bool {\bf naive}
\begin{DoxyCompactList}\small\item\em Indicates if naive random sampling on the set is being used. \end{DoxyCompactList}\item 
std\+::vector$<$ size\+\_\+t $>$ {\bf old\+From\+New\+References}
\begin{DoxyCompactList}\small\item\em Permutations of reference points during tree building. \end{DoxyCompactList}\item 
const Mat\+Type $\ast$ {\bf reference\+Set}
\begin{DoxyCompactList}\small\item\em Reference dataset. In some situations we may own this dataset. \end{DoxyCompactList}\item 
{\bf Tree} $\ast$ {\bf reference\+Tree}
\begin{DoxyCompactList}\small\item\em Pointer to the root of the reference tree. \end{DoxyCompactList}\item 
bool {\bf sample\+At\+Leaves}
\begin{DoxyCompactList}\small\item\em Whether or not sampling is done at the leaves. Faster, but less accurate. \end{DoxyCompactList}\item 
bool {\bf set\+Owner}
\begin{DoxyCompactList}\small\item\em If true, we are responsible for deleting the dataset. \end{DoxyCompactList}\item 
bool {\bf single\+Mode}
\begin{DoxyCompactList}\small\item\em Indicates if single-\/tree search is being used (opposed to dual-\/tree). \end{DoxyCompactList}\item 
size\+\_\+t {\bf single\+Sample\+Limit}
\begin{DoxyCompactList}\small\item\em The limit on the number of points in the largest node that can be approximated by sampling. \end{DoxyCompactList}\item 
double {\bf tau}
\begin{DoxyCompactList}\small\item\em The rank-\/approximation in percentile of the data (between 0 and 100). \end{DoxyCompactList}\item 
bool {\bf tree\+Owner}
\begin{DoxyCompactList}\small\item\em If true, this object created the trees and is responsible for them. \end{DoxyCompactList}\end{DoxyCompactItemize}


\subsection{Detailed Description}
\subsubsection*{template$<$typename Sort\+Policy = Nearest\+Neighbor\+Sort, typename Metric\+Type = metric\+::\+Euclidean\+Distance, typename Mat\+Type = arma\+::mat, template$<$ typename Tree\+Metric\+Type, typename Tree\+Stat\+Type, typename Tree\+Mat\+Type $>$ class Tree\+Type = tree\+::\+K\+D\+Tree$>$\\*
class mlpack\+::neighbor\+::\+R\+A\+Search$<$ Sort\+Policy, Metric\+Type, Mat\+Type, Tree\+Type $>$}

The \doxyref{R\+A\+Search}{p.}{classmlpack_1_1neighbor_1_1RASearch} class\+: This class provides a generic manner to perform rank-\/approximate search via random-\/sampling. 

If the \textquotesingle{}naive\textquotesingle{} option is chosen, this rank-\/approximate search will be done by randomly sampling from the whole set. If the \textquotesingle{}naive\textquotesingle{} option is not chosen, the sampling is done in a stratified manner in the tree as mentioned in the algorithms in Figure 2 of the following paper\+:

\{ram2009rank, title=\{\{Rank-\/\+Approximate Nearest Neighbor Search\+: Retaining Meaning and Speed in High Dimensions\}\}, author=\{\{Ram, P. and Lee, D. and Ouyang, H. and Gray, A. G.\}\}, booktitle=\{\{Advances of Neural Information Processing Systems\}\}, year=\{2009\} \}

\doxyref{R\+A\+Search}{p.}{classmlpack_1_1neighbor_1_1RASearch} is currently known to not work with ball trees (\#356).


\begin{DoxyTemplParams}{Template Parameters}
{\em Sort\+Policy} & The sort policy for distances; see \doxyref{Nearest\+Neighbor\+Sort}{p.}{classmlpack_1_1neighbor_1_1NearestNeighborSort}. \\
\hline
{\em Metric\+Type} & The metric to use for computation. \\
\hline
{\em Tree\+Type} & The tree type to use. \\
\hline
\end{DoxyTemplParams}


Definition at line 71 of file ra\+\_\+search.\+hpp.



\subsection{Member Typedef Documentation}
\index{mlpack\+::neighbor\+::\+R\+A\+Search@{mlpack\+::neighbor\+::\+R\+A\+Search}!Tree@{Tree}}
\index{Tree@{Tree}!mlpack\+::neighbor\+::\+R\+A\+Search@{mlpack\+::neighbor\+::\+R\+A\+Search}}
\subsubsection[{Tree}]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename Sort\+Policy = Nearest\+Neighbor\+Sort, typename Metric\+Type = metric\+::\+Euclidean\+Distance, typename Mat\+Type = arma\+::mat, template$<$ typename Tree\+Metric\+Type, typename Tree\+Stat\+Type, typename Tree\+Mat\+Type $>$ class Tree\+Type = tree\+::\+K\+D\+Tree$>$ typedef Tree\+Type$<$Metric\+Type, {\bf R\+A\+Query\+Stat}$<$Sort\+Policy$>$, Mat\+Type$>$ {\bf mlpack\+::neighbor\+::\+R\+A\+Search}$<$ Sort\+Policy, Metric\+Type, Mat\+Type, Tree\+Type $>$\+::{\bf Tree}}\label{classmlpack_1_1neighbor_1_1RASearch_a3e13ae35dd37f14be6ca36b8a8e9f07f}


Convenience typedef. 



Definition at line 75 of file ra\+\_\+search.\+hpp.



\subsection{Constructor \& Destructor Documentation}
\index{mlpack\+::neighbor\+::\+R\+A\+Search@{mlpack\+::neighbor\+::\+R\+A\+Search}!R\+A\+Search@{R\+A\+Search}}
\index{R\+A\+Search@{R\+A\+Search}!mlpack\+::neighbor\+::\+R\+A\+Search@{mlpack\+::neighbor\+::\+R\+A\+Search}}
\subsubsection[{R\+A\+Search(const Mat\+Type \&reference\+Set, const bool naive=false, const bool single\+Mode=false, const double tau=5, const double alpha=0.\+95, const bool sample\+At\+Leaves=false, const bool first\+Leaf\+Exact=false, const size\+\_\+t single\+Sample\+Limit=20, const Metric\+Type metric=\+Metric\+Type())}]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename Sort\+Policy = Nearest\+Neighbor\+Sort, typename Metric\+Type = metric\+::\+Euclidean\+Distance, typename Mat\+Type = arma\+::mat, template$<$ typename Tree\+Metric\+Type, typename Tree\+Stat\+Type, typename Tree\+Mat\+Type $>$ class Tree\+Type = tree\+::\+K\+D\+Tree$>$ {\bf mlpack\+::neighbor\+::\+R\+A\+Search}$<$ Sort\+Policy, Metric\+Type, Mat\+Type, Tree\+Type $>$\+::{\bf R\+A\+Search} (
\begin{DoxyParamCaption}
\item[{const Mat\+Type \&}]{reference\+Set, }
\item[{const bool}]{naive = {\ttfamily false}, }
\item[{const bool}]{single\+Mode = {\ttfamily false}, }
\item[{const double}]{tau = {\ttfamily 5}, }
\item[{const double}]{alpha = {\ttfamily 0.95}, }
\item[{const bool}]{sample\+At\+Leaves = {\ttfamily false}, }
\item[{const bool}]{first\+Leaf\+Exact = {\ttfamily false}, }
\item[{const size\+\_\+t}]{single\+Sample\+Limit = {\ttfamily 20}, }
\item[{const Metric\+Type}]{metric = {\ttfamily MetricType()}}
\end{DoxyParamCaption}
)}\label{classmlpack_1_1neighbor_1_1RASearch_af7f0d946743c6966010e21c90ea88086}


Initialize the \doxyref{R\+A\+Search}{p.}{classmlpack_1_1neighbor_1_1RASearch} object, passing both a reference dataset (this is the dataset that will be searched). 

Optionally, perform the computation in naive mode or single-\/tree mode. An initialized distance metric can be given, for cases where the metric has internal data (i.\+e. the distance\+::\+Mahalanobis\+Distance class).

This method will copy the matrices to internal copies, which are rearranged during tree-\/building. You can avoid this extra copy by pre-\/constructing the trees and using the appropriate constructor, or by using the constructor that takes an rvalue reference to the data with std\+::move().

tau, the rank-\/approximation parameter, specifies that we are looking for k neighbors with probability alpha of being in the top tau percent of nearest neighbors. So, as an example, if our dataset has 1000 points, and we want 5 nearest neighbors with 95\% probability of being in the top 5\% of nearest neighbors (or, the top 50 nearest neighbors), we set k = 5, tau = 5, and alpha = 0.\+95.

The method will fail (and throw a std\+::invalid\+\_\+argument exception) if the value of tau is too low\+: tau must be set such that the number of points in the corresponding percentile of the data is greater than k. Thus, if we choose tau = 0.\+1 with a dataset of 1000 points and k = 5, then we are attempting to choose 5 nearest neighbors out of the closest 1 point -- this is invalid.


\begin{DoxyParams}{Parameters}
{\em reference\+Set} & Set of reference points. \\
\hline
{\em naive} & If true, the rank-\/approximate search will be performed by directly sampling the whole set instead of using the stratified sampling on the tree. \\
\hline
{\em single\+Mode} & If true, single-\/tree search will be used (as opposed to dual-\/tree search). This is useful when \doxyref{Search()}{p.}{classmlpack_1_1neighbor_1_1RASearch_addedd4f8a4ac50ad6fe306b4b9fc25a3} will be called with few query points. \\
\hline
{\em metric} & An optional instance of the Metric\+Type class. \\
\hline
{\em tau} & The rank-\/approximation in percentile of the data. The default value is 5\%. \\
\hline
{\em alpha} & The desired success probability. The default value is 0.\+95. \\
\hline
{\em sample\+At\+Leaves} & Sample at leaves for faster but less accurate computation. This defaults to \textquotesingle{}false\textquotesingle{}. \\
\hline
{\em first\+Leaf\+Exact} & Traverse to the first leaf without approximation. This can ensure that the query definitely finds its (near) duplicate if there exists one. This defaults to \textquotesingle{}false\textquotesingle{} for now. \\
\hline
{\em single\+Sample\+Limit} & The limit on the largest node that can be approximated by sampling. This defaults to 20. \\
\hline
\end{DoxyParams}
\index{mlpack\+::neighbor\+::\+R\+A\+Search@{mlpack\+::neighbor\+::\+R\+A\+Search}!R\+A\+Search@{R\+A\+Search}}
\index{R\+A\+Search@{R\+A\+Search}!mlpack\+::neighbor\+::\+R\+A\+Search@{mlpack\+::neighbor\+::\+R\+A\+Search}}
\subsubsection[{R\+A\+Search(\+Mat\+Type \&\&reference\+Set, const bool naive=false, const bool single\+Mode=false, const double tau=5, const double alpha=0.\+95, const bool sample\+At\+Leaves=false, const bool first\+Leaf\+Exact=false, const size\+\_\+t single\+Sample\+Limit=20, const Metric\+Type metric=\+Metric\+Type())}]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename Sort\+Policy = Nearest\+Neighbor\+Sort, typename Metric\+Type = metric\+::\+Euclidean\+Distance, typename Mat\+Type = arma\+::mat, template$<$ typename Tree\+Metric\+Type, typename Tree\+Stat\+Type, typename Tree\+Mat\+Type $>$ class Tree\+Type = tree\+::\+K\+D\+Tree$>$ {\bf mlpack\+::neighbor\+::\+R\+A\+Search}$<$ Sort\+Policy, Metric\+Type, Mat\+Type, Tree\+Type $>$\+::{\bf R\+A\+Search} (
\begin{DoxyParamCaption}
\item[{Mat\+Type \&\&}]{reference\+Set, }
\item[{const bool}]{naive = {\ttfamily false}, }
\item[{const bool}]{single\+Mode = {\ttfamily false}, }
\item[{const double}]{tau = {\ttfamily 5}, }
\item[{const double}]{alpha = {\ttfamily 0.95}, }
\item[{const bool}]{sample\+At\+Leaves = {\ttfamily false}, }
\item[{const bool}]{first\+Leaf\+Exact = {\ttfamily false}, }
\item[{const size\+\_\+t}]{single\+Sample\+Limit = {\ttfamily 20}, }
\item[{const Metric\+Type}]{metric = {\ttfamily MetricType()}}
\end{DoxyParamCaption}
)}\label{classmlpack_1_1neighbor_1_1RASearch_a01baf882b92153be07e1faea4c123d1f}


Initialize the \doxyref{R\+A\+Search}{p.}{classmlpack_1_1neighbor_1_1RASearch} object, passing both a reference dataset (this is the dataset that will be searched). 

Optionally, perform the computation in naive mode or single-\/tree mode. An initialized distance metric can be given, for cases where the metric has internal data (i.\+e. the distance\+::\+Mahalanobis\+Distance class).

This method will take ownership of the given reference set, avoiding a copy. If you need to use the reference set for other purposes, too, consider using the constructor that takes a const reference.

tau, the rank-\/approximation parameter, specifies that we are looking for k neighbors with probability alpha of being in the top tau percent of nearest neighbors. So, as an example, if our dataset has 1000 points, and we want 5 nearest neighbors with 95\% probability of being in the top 5\% of nearest neighbors (or, the top 50 nearest neighbors), we set k = 5, tau = 5, and alpha = 0.\+95.

The method will fail (and throw a std\+::invalid\+\_\+argument exception) if the value of tau is too low\+: tau must be set such that the number of points in the corresponding percentile of the data is greater than k. Thus, if we choose tau = 0.\+1 with a dataset of 1000 points and k = 5, then we are attempting to choose 5 nearest neighbors out of the closest 1 point -- this is invalid.


\begin{DoxyParams}{Parameters}
{\em reference\+Set} & Set of reference points. \\
\hline
{\em naive} & If true, the rank-\/approximate search will be performed by directly sampling the whole set instead of using the stratified sampling on the tree. \\
\hline
{\em single\+Mode} & If true, single-\/tree search will be used (as opposed to dual-\/tree search). This is useful when \doxyref{Search()}{p.}{classmlpack_1_1neighbor_1_1RASearch_addedd4f8a4ac50ad6fe306b4b9fc25a3} will be called with few query points. \\
\hline
{\em metric} & An optional instance of the Metric\+Type class. \\
\hline
{\em tau} & The rank-\/approximation in percentile of the data. The default value is 5\%. \\
\hline
{\em alpha} & The desired success probability. The default value is 0.\+95. \\
\hline
{\em sample\+At\+Leaves} & Sample at leaves for faster but less accurate computation. This defaults to \textquotesingle{}false\textquotesingle{}. \\
\hline
{\em first\+Leaf\+Exact} & Traverse to the first leaf without approximation. This can ensure that the query definitely finds its (near) duplicate if there exists one. This defaults to \textquotesingle{}false\textquotesingle{} for now. \\
\hline
{\em single\+Sample\+Limit} & The limit on the largest node that can be approximated by sampling. This defaults to 20. \\
\hline
\end{DoxyParams}
\index{mlpack\+::neighbor\+::\+R\+A\+Search@{mlpack\+::neighbor\+::\+R\+A\+Search}!R\+A\+Search@{R\+A\+Search}}
\index{R\+A\+Search@{R\+A\+Search}!mlpack\+::neighbor\+::\+R\+A\+Search@{mlpack\+::neighbor\+::\+R\+A\+Search}}
\subsubsection[{R\+A\+Search(\+Tree $\ast$reference\+Tree, const bool single\+Mode=false, const double tau=5, const double alpha=0.\+95, const bool sample\+At\+Leaves=false, const bool first\+Leaf\+Exact=false, const size\+\_\+t single\+Sample\+Limit=20, const Metric\+Type metric=\+Metric\+Type())}]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename Sort\+Policy = Nearest\+Neighbor\+Sort, typename Metric\+Type = metric\+::\+Euclidean\+Distance, typename Mat\+Type = arma\+::mat, template$<$ typename Tree\+Metric\+Type, typename Tree\+Stat\+Type, typename Tree\+Mat\+Type $>$ class Tree\+Type = tree\+::\+K\+D\+Tree$>$ {\bf mlpack\+::neighbor\+::\+R\+A\+Search}$<$ Sort\+Policy, Metric\+Type, Mat\+Type, Tree\+Type $>$\+::{\bf R\+A\+Search} (
\begin{DoxyParamCaption}
\item[{{\bf Tree} $\ast$}]{reference\+Tree, }
\item[{const bool}]{single\+Mode = {\ttfamily false}, }
\item[{const double}]{tau = {\ttfamily 5}, }
\item[{const double}]{alpha = {\ttfamily 0.95}, }
\item[{const bool}]{sample\+At\+Leaves = {\ttfamily false}, }
\item[{const bool}]{first\+Leaf\+Exact = {\ttfamily false}, }
\item[{const size\+\_\+t}]{single\+Sample\+Limit = {\ttfamily 20}, }
\item[{const Metric\+Type}]{metric = {\ttfamily MetricType()}}
\end{DoxyParamCaption}
)}\label{classmlpack_1_1neighbor_1_1RASearch_a9f4b2be116e579b216db532e8b9d2945}


Initialize the \doxyref{R\+A\+Search}{p.}{classmlpack_1_1neighbor_1_1RASearch} object with the given pre-\/constructed reference tree. 

It is assumed that the points in the tree\textquotesingle{}s dataset correspond to the reference set. Optionally, choose to use single-\/tree mode. Naive mode is not available as an option for this constructor; instead, to run naive computation, use a different constructor. Additionally, an instantiated distance metric can be given, for cases where the distance metric holds data.

There is no copying of the data matrices in this constructor (because tree-\/building is not necessary), so this is the constructor to use when copies absolutely must be avoided.

tau, the rank-\/approximation parameter, specifies that we are looking for k neighbors with probability alpha of being in the top tau percent of nearest neighbors. So, as an example, if our dataset has 1000 points, and we want 5 nearest neighbors with 95\% probability of being in the top 5\% of nearest neighbors (or, the top 50 nearest neighbors), we set k = 5, tau = 5, and alpha = 0.\+95.

The method will fail (and throw a std\+::invalid\+\_\+argument exception) if the value of tau is too low\+: tau must be set such that the number of points in the corresponding percentile of the data is greater than k. Thus, if we choose tau = 0.\+1 with a dataset of 1000 points and k = 5, then we are attempting to choose 5 nearest neighbors out of the closest 1 point -- this is invalid.

\begin{DoxyNote}{Note}
Tree-\/building may (at least with Binary\+Space\+Tree) modify the ordering of a matrix, so be aware that the results you get from \doxyref{Search()}{p.}{classmlpack_1_1neighbor_1_1RASearch_addedd4f8a4ac50ad6fe306b4b9fc25a3} will correspond to the modified matrix. 
\end{DoxyNote}

\begin{DoxyParams}{Parameters}
{\em reference\+Tree} & Pre-\/built tree for reference points. \\
\hline
{\em single\+Mode} & Whether single-\/tree computation should be used (as opposed to dual-\/tree computation). \\
\hline
{\em tau} & The rank-\/approximation in percentile of the data. The default value is 5\%. \\
\hline
{\em alpha} & The desired success probability. The default value is 0.\+95. \\
\hline
{\em sample\+At\+Leaves} & Sample at leaves for faster but less accurate computation. This defaults to \textquotesingle{}false\textquotesingle{}. \\
\hline
{\em first\+Leaf\+Exact} & Traverse to the first leaf without approximation. This can ensure that the query definitely finds its (near) duplicate if there exists one. This defaults to \textquotesingle{}false\textquotesingle{} for now. \\
\hline
{\em single\+Sample\+Limit} & The limit on the largest node that can be approximated by sampling. This defaults to 20. \\
\hline
{\em metric} & Instantiated distance metric. \\
\hline
\end{DoxyParams}
\index{mlpack\+::neighbor\+::\+R\+A\+Search@{mlpack\+::neighbor\+::\+R\+A\+Search}!R\+A\+Search@{R\+A\+Search}}
\index{R\+A\+Search@{R\+A\+Search}!mlpack\+::neighbor\+::\+R\+A\+Search@{mlpack\+::neighbor\+::\+R\+A\+Search}}
\subsubsection[{R\+A\+Search(const bool naive=false, const bool single\+Mode=false, const double tau=5, const double alpha=0.\+95, const bool sample\+At\+Leaves=false, const bool first\+Leaf\+Exact=false, const size\+\_\+t single\+Sample\+Limit=20, const Metric\+Type metric=\+Metric\+Type())}]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename Sort\+Policy = Nearest\+Neighbor\+Sort, typename Metric\+Type = metric\+::\+Euclidean\+Distance, typename Mat\+Type = arma\+::mat, template$<$ typename Tree\+Metric\+Type, typename Tree\+Stat\+Type, typename Tree\+Mat\+Type $>$ class Tree\+Type = tree\+::\+K\+D\+Tree$>$ {\bf mlpack\+::neighbor\+::\+R\+A\+Search}$<$ Sort\+Policy, Metric\+Type, Mat\+Type, Tree\+Type $>$\+::{\bf R\+A\+Search} (
\begin{DoxyParamCaption}
\item[{const bool}]{naive = {\ttfamily false}, }
\item[{const bool}]{single\+Mode = {\ttfamily false}, }
\item[{const double}]{tau = {\ttfamily 5}, }
\item[{const double}]{alpha = {\ttfamily 0.95}, }
\item[{const bool}]{sample\+At\+Leaves = {\ttfamily false}, }
\item[{const bool}]{first\+Leaf\+Exact = {\ttfamily false}, }
\item[{const size\+\_\+t}]{single\+Sample\+Limit = {\ttfamily 20}, }
\item[{const Metric\+Type}]{metric = {\ttfamily MetricType()}}
\end{DoxyParamCaption}
)}\label{classmlpack_1_1neighbor_1_1RASearch_a738d3a4f1eb63be4888dcebbc2ba7888}


Create an \doxyref{R\+A\+Search}{p.}{classmlpack_1_1neighbor_1_1RASearch} object with no reference data. 

If \doxyref{Search()}{p.}{classmlpack_1_1neighbor_1_1RASearch_addedd4f8a4ac50ad6fe306b4b9fc25a3} is called before a reference set is set with \doxyref{Train()}{p.}{classmlpack_1_1neighbor_1_1RASearch_aa1b583c83313263deb6e37053a933b71}, an exception will be thrown.


\begin{DoxyParams}{Parameters}
{\em naive} & Whether naive (brute-\/force) search should be used. \\
\hline
{\em single\+Mode} & Whether single-\/tree computation should be used (as opposed to dual-\/tree computation). \\
\hline
{\em tau} & The rank-\/approximation in percentile of the data. The default value is 5\%. \\
\hline
{\em alpha} & The desired success probability. The default value is 0.\+95. \\
\hline
{\em sample\+At\+Leaves} & Sample at leaves for faster but less accurate computation. This defaults to \textquotesingle{}false\textquotesingle{}. \\
\hline
{\em first\+Leaf\+Exact} & Traverse to the first leaf without approximation. This can ensure that the query definitely finds its (near) duplicate if there exists one. This defaults to \textquotesingle{}false\textquotesingle{} for now. \\
\hline
{\em single\+Sample\+Limit} & The limit on the largest node that can be approximated by sampling. This defaults to 20. \\
\hline
{\em metric} & Instantiated distance metric. \\
\hline
\end{DoxyParams}
\index{mlpack\+::neighbor\+::\+R\+A\+Search@{mlpack\+::neighbor\+::\+R\+A\+Search}!````~R\+A\+Search@{$\sim$\+R\+A\+Search}}
\index{````~R\+A\+Search@{$\sim$\+R\+A\+Search}!mlpack\+::neighbor\+::\+R\+A\+Search@{mlpack\+::neighbor\+::\+R\+A\+Search}}
\subsubsection[{$\sim$\+R\+A\+Search()}]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename Sort\+Policy = Nearest\+Neighbor\+Sort, typename Metric\+Type = metric\+::\+Euclidean\+Distance, typename Mat\+Type = arma\+::mat, template$<$ typename Tree\+Metric\+Type, typename Tree\+Stat\+Type, typename Tree\+Mat\+Type $>$ class Tree\+Type = tree\+::\+K\+D\+Tree$>$ {\bf mlpack\+::neighbor\+::\+R\+A\+Search}$<$ Sort\+Policy, Metric\+Type, Mat\+Type, Tree\+Type $>$\+::$\sim${\bf R\+A\+Search} (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)}\label{classmlpack_1_1neighbor_1_1RASearch_a779381aa3d6e01f90b86b8227925c421}


Delete the \doxyref{R\+A\+Search}{p.}{classmlpack_1_1neighbor_1_1RASearch} object. 

The tree is the only member we are responsible for deleting. The others will take care of themselves. 

\subsection{Member Function Documentation}
\index{mlpack\+::neighbor\+::\+R\+A\+Search@{mlpack\+::neighbor\+::\+R\+A\+Search}!Alpha@{Alpha}}
\index{Alpha@{Alpha}!mlpack\+::neighbor\+::\+R\+A\+Search@{mlpack\+::neighbor\+::\+R\+A\+Search}}
\subsubsection[{Alpha() const }]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename Sort\+Policy = Nearest\+Neighbor\+Sort, typename Metric\+Type = metric\+::\+Euclidean\+Distance, typename Mat\+Type = arma\+::mat, template$<$ typename Tree\+Metric\+Type, typename Tree\+Stat\+Type, typename Tree\+Mat\+Type $>$ class Tree\+Type = tree\+::\+K\+D\+Tree$>$ double {\bf mlpack\+::neighbor\+::\+R\+A\+Search}$<$ Sort\+Policy, Metric\+Type, Mat\+Type, Tree\+Type $>$\+::Alpha (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
) const\hspace{0.3cm}{\ttfamily [inline]}}\label{classmlpack_1_1neighbor_1_1RASearch_a925cb3cdbb9677cf658e07e3382ec1b5}


Get the desired success probability. 



Definition at line 398 of file ra\+\_\+search.\+hpp.

\index{mlpack\+::neighbor\+::\+R\+A\+Search@{mlpack\+::neighbor\+::\+R\+A\+Search}!Alpha@{Alpha}}
\index{Alpha@{Alpha}!mlpack\+::neighbor\+::\+R\+A\+Search@{mlpack\+::neighbor\+::\+R\+A\+Search}}
\subsubsection[{Alpha()}]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename Sort\+Policy = Nearest\+Neighbor\+Sort, typename Metric\+Type = metric\+::\+Euclidean\+Distance, typename Mat\+Type = arma\+::mat, template$<$ typename Tree\+Metric\+Type, typename Tree\+Stat\+Type, typename Tree\+Mat\+Type $>$ class Tree\+Type = tree\+::\+K\+D\+Tree$>$ double\& {\bf mlpack\+::neighbor\+::\+R\+A\+Search}$<$ Sort\+Policy, Metric\+Type, Mat\+Type, Tree\+Type $>$\+::Alpha (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}}\label{classmlpack_1_1neighbor_1_1RASearch_a9cfa93a9ff2cdc866309af708e423e9a}


Modify the desired success probability. 



Definition at line 400 of file ra\+\_\+search.\+hpp.

\index{mlpack\+::neighbor\+::\+R\+A\+Search@{mlpack\+::neighbor\+::\+R\+A\+Search}!First\+Leaf\+Exact@{First\+Leaf\+Exact}}
\index{First\+Leaf\+Exact@{First\+Leaf\+Exact}!mlpack\+::neighbor\+::\+R\+A\+Search@{mlpack\+::neighbor\+::\+R\+A\+Search}}
\subsubsection[{First\+Leaf\+Exact() const }]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename Sort\+Policy = Nearest\+Neighbor\+Sort, typename Metric\+Type = metric\+::\+Euclidean\+Distance, typename Mat\+Type = arma\+::mat, template$<$ typename Tree\+Metric\+Type, typename Tree\+Stat\+Type, typename Tree\+Mat\+Type $>$ class Tree\+Type = tree\+::\+K\+D\+Tree$>$ bool {\bf mlpack\+::neighbor\+::\+R\+A\+Search}$<$ Sort\+Policy, Metric\+Type, Mat\+Type, Tree\+Type $>$\+::First\+Leaf\+Exact (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
) const\hspace{0.3cm}{\ttfamily [inline]}}\label{classmlpack_1_1neighbor_1_1RASearch_a41645e5ea9490ea5f07a4f2fb1c702e8}


Get whether or not we traverse to the first leaf without approximation. 



Definition at line 408 of file ra\+\_\+search.\+hpp.

\index{mlpack\+::neighbor\+::\+R\+A\+Search@{mlpack\+::neighbor\+::\+R\+A\+Search}!First\+Leaf\+Exact@{First\+Leaf\+Exact}}
\index{First\+Leaf\+Exact@{First\+Leaf\+Exact}!mlpack\+::neighbor\+::\+R\+A\+Search@{mlpack\+::neighbor\+::\+R\+A\+Search}}
\subsubsection[{First\+Leaf\+Exact()}]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename Sort\+Policy = Nearest\+Neighbor\+Sort, typename Metric\+Type = metric\+::\+Euclidean\+Distance, typename Mat\+Type = arma\+::mat, template$<$ typename Tree\+Metric\+Type, typename Tree\+Stat\+Type, typename Tree\+Mat\+Type $>$ class Tree\+Type = tree\+::\+K\+D\+Tree$>$ bool\& {\bf mlpack\+::neighbor\+::\+R\+A\+Search}$<$ Sort\+Policy, Metric\+Type, Mat\+Type, Tree\+Type $>$\+::First\+Leaf\+Exact (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}}\label{classmlpack_1_1neighbor_1_1RASearch_ab7224f28cae2c82aeaad61fa7fd53861}


Modify whether or not we traverse to the first leaf without approximation. 



Definition at line 410 of file ra\+\_\+search.\+hpp.

\index{mlpack\+::neighbor\+::\+R\+A\+Search@{mlpack\+::neighbor\+::\+R\+A\+Search}!Naive@{Naive}}
\index{Naive@{Naive}!mlpack\+::neighbor\+::\+R\+A\+Search@{mlpack\+::neighbor\+::\+R\+A\+Search}}
\subsubsection[{Naive() const }]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename Sort\+Policy = Nearest\+Neighbor\+Sort, typename Metric\+Type = metric\+::\+Euclidean\+Distance, typename Mat\+Type = arma\+::mat, template$<$ typename Tree\+Metric\+Type, typename Tree\+Stat\+Type, typename Tree\+Mat\+Type $>$ class Tree\+Type = tree\+::\+K\+D\+Tree$>$ bool {\bf mlpack\+::neighbor\+::\+R\+A\+Search}$<$ Sort\+Policy, Metric\+Type, Mat\+Type, Tree\+Type $>$\+::Naive (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
) const\hspace{0.3cm}{\ttfamily [inline]}}\label{classmlpack_1_1neighbor_1_1RASearch_ae02311b938eeb67b5088e11366b943e1}


Get whether or not naive (brute-\/force) search is used. 



Definition at line 383 of file ra\+\_\+search.\+hpp.

\index{mlpack\+::neighbor\+::\+R\+A\+Search@{mlpack\+::neighbor\+::\+R\+A\+Search}!Naive@{Naive}}
\index{Naive@{Naive}!mlpack\+::neighbor\+::\+R\+A\+Search@{mlpack\+::neighbor\+::\+R\+A\+Search}}
\subsubsection[{Naive()}]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename Sort\+Policy = Nearest\+Neighbor\+Sort, typename Metric\+Type = metric\+::\+Euclidean\+Distance, typename Mat\+Type = arma\+::mat, template$<$ typename Tree\+Metric\+Type, typename Tree\+Stat\+Type, typename Tree\+Mat\+Type $>$ class Tree\+Type = tree\+::\+K\+D\+Tree$>$ bool\& {\bf mlpack\+::neighbor\+::\+R\+A\+Search}$<$ Sort\+Policy, Metric\+Type, Mat\+Type, Tree\+Type $>$\+::Naive (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}}\label{classmlpack_1_1neighbor_1_1RASearch_aadc93f6a2cc809f9ae06a877baf3561b}


Modify whether or not naive (brute-\/force) search is used. 



Definition at line 385 of file ra\+\_\+search.\+hpp.

\index{mlpack\+::neighbor\+::\+R\+A\+Search@{mlpack\+::neighbor\+::\+R\+A\+Search}!Reference\+Set@{Reference\+Set}}
\index{Reference\+Set@{Reference\+Set}!mlpack\+::neighbor\+::\+R\+A\+Search@{mlpack\+::neighbor\+::\+R\+A\+Search}}
\subsubsection[{Reference\+Set() const }]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename Sort\+Policy = Nearest\+Neighbor\+Sort, typename Metric\+Type = metric\+::\+Euclidean\+Distance, typename Mat\+Type = arma\+::mat, template$<$ typename Tree\+Metric\+Type, typename Tree\+Stat\+Type, typename Tree\+Mat\+Type $>$ class Tree\+Type = tree\+::\+K\+D\+Tree$>$ const Mat\+Type\& {\bf mlpack\+::neighbor\+::\+R\+A\+Search}$<$ Sort\+Policy, Metric\+Type, Mat\+Type, Tree\+Type $>$\+::Reference\+Set (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
) const\hspace{0.3cm}{\ttfamily [inline]}}\label{classmlpack_1_1neighbor_1_1RASearch_aee7ef452f19c9b7aae1f829605d893f7}


Access the reference set. 



Definition at line 380 of file ra\+\_\+search.\+hpp.

\index{mlpack\+::neighbor\+::\+R\+A\+Search@{mlpack\+::neighbor\+::\+R\+A\+Search}!Reset\+Query\+Tree@{Reset\+Query\+Tree}}
\index{Reset\+Query\+Tree@{Reset\+Query\+Tree}!mlpack\+::neighbor\+::\+R\+A\+Search@{mlpack\+::neighbor\+::\+R\+A\+Search}}
\subsubsection[{Reset\+Query\+Tree(\+Tree $\ast$query\+Tree) const }]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename Sort\+Policy = Nearest\+Neighbor\+Sort, typename Metric\+Type = metric\+::\+Euclidean\+Distance, typename Mat\+Type = arma\+::mat, template$<$ typename Tree\+Metric\+Type, typename Tree\+Stat\+Type, typename Tree\+Mat\+Type $>$ class Tree\+Type = tree\+::\+K\+D\+Tree$>$ void {\bf mlpack\+::neighbor\+::\+R\+A\+Search}$<$ Sort\+Policy, Metric\+Type, Mat\+Type, Tree\+Type $>$\+::Reset\+Query\+Tree (
\begin{DoxyParamCaption}
\item[{{\bf Tree} $\ast$}]{query\+Tree}
\end{DoxyParamCaption}
) const}\label{classmlpack_1_1neighbor_1_1RASearch_aed5063a3a67627e28220e3c6234b6643}


This function recursively resets the \doxyref{R\+A\+Query\+Stat}{p.}{classmlpack_1_1neighbor_1_1RAQueryStat} of the given query tree to set \textquotesingle{}bound\textquotesingle{} to Sort\+Policy\+::\+Worst\+Distance and \textquotesingle{}num\+Samples\+Made\textquotesingle{} to 0. 

This allows a user to perform multiple searches with the same query tree, possibly with different levels of approximation without requiring to build a new pair of trees for every new (approximate) search.

If \doxyref{Search()}{p.}{classmlpack_1_1neighbor_1_1RASearch_addedd4f8a4ac50ad6fe306b4b9fc25a3} is called multiple times with the same query tree without calling \doxyref{Reset\+Query\+Tree()}{p.}{classmlpack_1_1neighbor_1_1RASearch_aed5063a3a67627e28220e3c6234b6643}, the results may not satisfy the theoretical guarantees provided by the rank-\/approximate neighbor search algorithm.


\begin{DoxyParams}{Parameters}
{\em query\+Tree} & Tree whose statistics should be reset. \\
\hline
\end{DoxyParams}
\index{mlpack\+::neighbor\+::\+R\+A\+Search@{mlpack\+::neighbor\+::\+R\+A\+Search}!Sample\+At\+Leaves@{Sample\+At\+Leaves}}
\index{Sample\+At\+Leaves@{Sample\+At\+Leaves}!mlpack\+::neighbor\+::\+R\+A\+Search@{mlpack\+::neighbor\+::\+R\+A\+Search}}
\subsubsection[{Sample\+At\+Leaves() const }]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename Sort\+Policy = Nearest\+Neighbor\+Sort, typename Metric\+Type = metric\+::\+Euclidean\+Distance, typename Mat\+Type = arma\+::mat, template$<$ typename Tree\+Metric\+Type, typename Tree\+Stat\+Type, typename Tree\+Mat\+Type $>$ class Tree\+Type = tree\+::\+K\+D\+Tree$>$ bool {\bf mlpack\+::neighbor\+::\+R\+A\+Search}$<$ Sort\+Policy, Metric\+Type, Mat\+Type, Tree\+Type $>$\+::Sample\+At\+Leaves (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
) const\hspace{0.3cm}{\ttfamily [inline]}}\label{classmlpack_1_1neighbor_1_1RASearch_a6b93f87c1c6050cee864eb2d292bef39}


Get whether or not sampling is done at the leaves. 



Definition at line 403 of file ra\+\_\+search.\+hpp.

\index{mlpack\+::neighbor\+::\+R\+A\+Search@{mlpack\+::neighbor\+::\+R\+A\+Search}!Sample\+At\+Leaves@{Sample\+At\+Leaves}}
\index{Sample\+At\+Leaves@{Sample\+At\+Leaves}!mlpack\+::neighbor\+::\+R\+A\+Search@{mlpack\+::neighbor\+::\+R\+A\+Search}}
\subsubsection[{Sample\+At\+Leaves()}]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename Sort\+Policy = Nearest\+Neighbor\+Sort, typename Metric\+Type = metric\+::\+Euclidean\+Distance, typename Mat\+Type = arma\+::mat, template$<$ typename Tree\+Metric\+Type, typename Tree\+Stat\+Type, typename Tree\+Mat\+Type $>$ class Tree\+Type = tree\+::\+K\+D\+Tree$>$ bool\& {\bf mlpack\+::neighbor\+::\+R\+A\+Search}$<$ Sort\+Policy, Metric\+Type, Mat\+Type, Tree\+Type $>$\+::Sample\+At\+Leaves (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}}\label{classmlpack_1_1neighbor_1_1RASearch_a76669072a65439054d000c2f55db58cf}


Modify whether or not sampling is done at the leaves. 



Definition at line 405 of file ra\+\_\+search.\+hpp.

\index{mlpack\+::neighbor\+::\+R\+A\+Search@{mlpack\+::neighbor\+::\+R\+A\+Search}!Search@{Search}}
\index{Search@{Search}!mlpack\+::neighbor\+::\+R\+A\+Search@{mlpack\+::neighbor\+::\+R\+A\+Search}}
\subsubsection[{Search(const Mat\+Type \&query\+Set, const size\+\_\+t k, arma\+::\+Mat$<$ size\+\_\+t $>$ \&neighbors, arma\+::mat \&distances)}]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename Sort\+Policy = Nearest\+Neighbor\+Sort, typename Metric\+Type = metric\+::\+Euclidean\+Distance, typename Mat\+Type = arma\+::mat, template$<$ typename Tree\+Metric\+Type, typename Tree\+Stat\+Type, typename Tree\+Mat\+Type $>$ class Tree\+Type = tree\+::\+K\+D\+Tree$>$ void {\bf mlpack\+::neighbor\+::\+R\+A\+Search}$<$ Sort\+Policy, Metric\+Type, Mat\+Type, Tree\+Type $>$\+::Search (
\begin{DoxyParamCaption}
\item[{const Mat\+Type \&}]{query\+Set, }
\item[{const size\+\_\+t}]{k, }
\item[{arma\+::\+Mat$<$ size\+\_\+t $>$ \&}]{neighbors, }
\item[{arma\+::mat \&}]{distances}
\end{DoxyParamCaption}
)}\label{classmlpack_1_1neighbor_1_1RASearch_addedd4f8a4ac50ad6fe306b4b9fc25a3}


Compute the rank approximate nearest neighbors of each query point in the query set and store the output in the given matrices. 

The matrices will be set to the size of n columns by k rows, where n is the number of points in the query dataset and k is the number of neighbors being searched for.

If query\+Set is small or only contains one point, it can be faster to do single-\/tree search; single-\/tree search can be set with the \doxyref{Single\+Mode()}{p.}{classmlpack_1_1neighbor_1_1RASearch_a99af3e5d6684cb938d586bb145f9c5a2} function or in the constructor.


\begin{DoxyParams}{Parameters}
{\em query\+Set} & Set of query points (can be a single point). \\
\hline
{\em k} & Number of neighbors to search for. \\
\hline
{\em neighbors} & Matrix storing lists of neighbors for each query point. \\
\hline
{\em distances} & Matrix storing distances of neighbors for each query point. \\
\hline
\end{DoxyParams}
\index{mlpack\+::neighbor\+::\+R\+A\+Search@{mlpack\+::neighbor\+::\+R\+A\+Search}!Search@{Search}}
\index{Search@{Search}!mlpack\+::neighbor\+::\+R\+A\+Search@{mlpack\+::neighbor\+::\+R\+A\+Search}}
\subsubsection[{Search(\+Tree $\ast$query\+Tree, const size\+\_\+t k, arma\+::\+Mat$<$ size\+\_\+t $>$ \&neighbors, arma\+::mat \&distances)}]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename Sort\+Policy = Nearest\+Neighbor\+Sort, typename Metric\+Type = metric\+::\+Euclidean\+Distance, typename Mat\+Type = arma\+::mat, template$<$ typename Tree\+Metric\+Type, typename Tree\+Stat\+Type, typename Tree\+Mat\+Type $>$ class Tree\+Type = tree\+::\+K\+D\+Tree$>$ void {\bf mlpack\+::neighbor\+::\+R\+A\+Search}$<$ Sort\+Policy, Metric\+Type, Mat\+Type, Tree\+Type $>$\+::Search (
\begin{DoxyParamCaption}
\item[{{\bf Tree} $\ast$}]{query\+Tree, }
\item[{const size\+\_\+t}]{k, }
\item[{arma\+::\+Mat$<$ size\+\_\+t $>$ \&}]{neighbors, }
\item[{arma\+::mat \&}]{distances}
\end{DoxyParamCaption}
)}\label{classmlpack_1_1neighbor_1_1RASearch_a10c7e537734e3c4204d115450ae586a1}


Compute the rank approximate nearest neighbors of each point in the pre-\/built query tree and store the output in the given matrices. 

The matrices will be set to the size of n columns by k rows, where n is the number of points in the query dataset and k is the number of neighbors being searched for.

If single\+Mode or naive is enabled, then this method will throw a std\+::invalid\+\_\+argument exception; calling this function implies a dual-\/tree algorithm.

\begin{DoxyNote}{Note}
If the tree type you are using modifies the data matrix, be aware that the results returned from this function will be with respect to the modified data matrix. 
\end{DoxyNote}

\begin{DoxyParams}{Parameters}
{\em query\+Tree} & Tree built on query points. \\
\hline
{\em k} & Number of neighbors to search for. \\
\hline
{\em neighbors} & Matrix storing lists of neighbors for each query point. \\
\hline
{\em distances} & Matrix storing distances of neighbors for each query point. \\
\hline
\end{DoxyParams}
\index{mlpack\+::neighbor\+::\+R\+A\+Search@{mlpack\+::neighbor\+::\+R\+A\+Search}!Search@{Search}}
\index{Search@{Search}!mlpack\+::neighbor\+::\+R\+A\+Search@{mlpack\+::neighbor\+::\+R\+A\+Search}}
\subsubsection[{Search(const size\+\_\+t k, arma\+::\+Mat$<$ size\+\_\+t $>$ \&neighbors, arma\+::mat \&distances)}]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename Sort\+Policy = Nearest\+Neighbor\+Sort, typename Metric\+Type = metric\+::\+Euclidean\+Distance, typename Mat\+Type = arma\+::mat, template$<$ typename Tree\+Metric\+Type, typename Tree\+Stat\+Type, typename Tree\+Mat\+Type $>$ class Tree\+Type = tree\+::\+K\+D\+Tree$>$ void {\bf mlpack\+::neighbor\+::\+R\+A\+Search}$<$ Sort\+Policy, Metric\+Type, Mat\+Type, Tree\+Type $>$\+::Search (
\begin{DoxyParamCaption}
\item[{const size\+\_\+t}]{k, }
\item[{arma\+::\+Mat$<$ size\+\_\+t $>$ \&}]{neighbors, }
\item[{arma\+::mat \&}]{distances}
\end{DoxyParamCaption}
)}\label{classmlpack_1_1neighbor_1_1RASearch_a1c4ae4eefa5e1e058a879a906f0d4794}


Compute the rank approximate nearest neighbors of each point in the reference set (that is, the query set is taken to be the reference set), and store the output in the given matrices. 

The matrices will be set to the size of n columns by k rows, where n is the number of points in the query dataset and k is the number of neighbors being searched for.


\begin{DoxyParams}{Parameters}
{\em k} & Number of neighbors to search for. \\
\hline
{\em neighbors} & Matrix storing lists of neighbors for each point. \\
\hline
{\em distances} & Matrix storing distances of neighbors for each query point. \\
\hline
\end{DoxyParams}
\index{mlpack\+::neighbor\+::\+R\+A\+Search@{mlpack\+::neighbor\+::\+R\+A\+Search}!Serialize@{Serialize}}
\index{Serialize@{Serialize}!mlpack\+::neighbor\+::\+R\+A\+Search@{mlpack\+::neighbor\+::\+R\+A\+Search}}
\subsubsection[{Serialize(\+Archive \&ar, const unsigned int)}]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename Sort\+Policy = Nearest\+Neighbor\+Sort, typename Metric\+Type = metric\+::\+Euclidean\+Distance, typename Mat\+Type = arma\+::mat, template$<$ typename Tree\+Metric\+Type, typename Tree\+Stat\+Type, typename Tree\+Mat\+Type $>$ class Tree\+Type = tree\+::\+K\+D\+Tree$>$ template$<$typename Archive $>$ void {\bf mlpack\+::neighbor\+::\+R\+A\+Search}$<$ Sort\+Policy, Metric\+Type, Mat\+Type, Tree\+Type $>$\+::Serialize (
\begin{DoxyParamCaption}
\item[{Archive \&}]{ar, }
\item[{const unsigned}]{int}
\end{DoxyParamCaption}
)}\label{classmlpack_1_1neighbor_1_1RASearch_ad195b6eb6ce63de9f552f20afc5560ab}


Serialize the object. 



Referenced by mlpack\+::neighbor\+::\+R\+A\+Search$<$ tree\+::\+R\+Star\+Tree $>$\+::\+Single\+Sample\+Limit().

\index{mlpack\+::neighbor\+::\+R\+A\+Search@{mlpack\+::neighbor\+::\+R\+A\+Search}!Single\+Mode@{Single\+Mode}}
\index{Single\+Mode@{Single\+Mode}!mlpack\+::neighbor\+::\+R\+A\+Search@{mlpack\+::neighbor\+::\+R\+A\+Search}}
\subsubsection[{Single\+Mode() const }]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename Sort\+Policy = Nearest\+Neighbor\+Sort, typename Metric\+Type = metric\+::\+Euclidean\+Distance, typename Mat\+Type = arma\+::mat, template$<$ typename Tree\+Metric\+Type, typename Tree\+Stat\+Type, typename Tree\+Mat\+Type $>$ class Tree\+Type = tree\+::\+K\+D\+Tree$>$ bool {\bf mlpack\+::neighbor\+::\+R\+A\+Search}$<$ Sort\+Policy, Metric\+Type, Mat\+Type, Tree\+Type $>$\+::Single\+Mode (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
) const\hspace{0.3cm}{\ttfamily [inline]}}\label{classmlpack_1_1neighbor_1_1RASearch_a7a6e15542c59421db3211082f8d0b534}


Get whether or not single-\/tree search is used. 



Definition at line 388 of file ra\+\_\+search.\+hpp.

\index{mlpack\+::neighbor\+::\+R\+A\+Search@{mlpack\+::neighbor\+::\+R\+A\+Search}!Single\+Mode@{Single\+Mode}}
\index{Single\+Mode@{Single\+Mode}!mlpack\+::neighbor\+::\+R\+A\+Search@{mlpack\+::neighbor\+::\+R\+A\+Search}}
\subsubsection[{Single\+Mode()}]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename Sort\+Policy = Nearest\+Neighbor\+Sort, typename Metric\+Type = metric\+::\+Euclidean\+Distance, typename Mat\+Type = arma\+::mat, template$<$ typename Tree\+Metric\+Type, typename Tree\+Stat\+Type, typename Tree\+Mat\+Type $>$ class Tree\+Type = tree\+::\+K\+D\+Tree$>$ bool\& {\bf mlpack\+::neighbor\+::\+R\+A\+Search}$<$ Sort\+Policy, Metric\+Type, Mat\+Type, Tree\+Type $>$\+::Single\+Mode (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}}\label{classmlpack_1_1neighbor_1_1RASearch_a99af3e5d6684cb938d586bb145f9c5a2}


Modify whether or not single-\/tree search is used. 



Definition at line 390 of file ra\+\_\+search.\+hpp.

\index{mlpack\+::neighbor\+::\+R\+A\+Search@{mlpack\+::neighbor\+::\+R\+A\+Search}!Single\+Sample\+Limit@{Single\+Sample\+Limit}}
\index{Single\+Sample\+Limit@{Single\+Sample\+Limit}!mlpack\+::neighbor\+::\+R\+A\+Search@{mlpack\+::neighbor\+::\+R\+A\+Search}}
\subsubsection[{Single\+Sample\+Limit() const }]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename Sort\+Policy = Nearest\+Neighbor\+Sort, typename Metric\+Type = metric\+::\+Euclidean\+Distance, typename Mat\+Type = arma\+::mat, template$<$ typename Tree\+Metric\+Type, typename Tree\+Stat\+Type, typename Tree\+Mat\+Type $>$ class Tree\+Type = tree\+::\+K\+D\+Tree$>$ size\+\_\+t {\bf mlpack\+::neighbor\+::\+R\+A\+Search}$<$ Sort\+Policy, Metric\+Type, Mat\+Type, Tree\+Type $>$\+::Single\+Sample\+Limit (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
) const\hspace{0.3cm}{\ttfamily [inline]}}\label{classmlpack_1_1neighbor_1_1RASearch_aff287aa05faa9c7a7dabb4fc70dfe269}


Get the limit on the size of a node that can be approximated. 



Definition at line 413 of file ra\+\_\+search.\+hpp.

\index{mlpack\+::neighbor\+::\+R\+A\+Search@{mlpack\+::neighbor\+::\+R\+A\+Search}!Single\+Sample\+Limit@{Single\+Sample\+Limit}}
\index{Single\+Sample\+Limit@{Single\+Sample\+Limit}!mlpack\+::neighbor\+::\+R\+A\+Search@{mlpack\+::neighbor\+::\+R\+A\+Search}}
\subsubsection[{Single\+Sample\+Limit()}]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename Sort\+Policy = Nearest\+Neighbor\+Sort, typename Metric\+Type = metric\+::\+Euclidean\+Distance, typename Mat\+Type = arma\+::mat, template$<$ typename Tree\+Metric\+Type, typename Tree\+Stat\+Type, typename Tree\+Mat\+Type $>$ class Tree\+Type = tree\+::\+K\+D\+Tree$>$ size\+\_\+t\& {\bf mlpack\+::neighbor\+::\+R\+A\+Search}$<$ Sort\+Policy, Metric\+Type, Mat\+Type, Tree\+Type $>$\+::Single\+Sample\+Limit (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}}\label{classmlpack_1_1neighbor_1_1RASearch_a7b2c078bc40611c43db8e7e28af933c7}


Modify the limit on the size of a node that can be approximation. 



Definition at line 415 of file ra\+\_\+search.\+hpp.

\index{mlpack\+::neighbor\+::\+R\+A\+Search@{mlpack\+::neighbor\+::\+R\+A\+Search}!Tau@{Tau}}
\index{Tau@{Tau}!mlpack\+::neighbor\+::\+R\+A\+Search@{mlpack\+::neighbor\+::\+R\+A\+Search}}
\subsubsection[{Tau() const }]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename Sort\+Policy = Nearest\+Neighbor\+Sort, typename Metric\+Type = metric\+::\+Euclidean\+Distance, typename Mat\+Type = arma\+::mat, template$<$ typename Tree\+Metric\+Type, typename Tree\+Stat\+Type, typename Tree\+Mat\+Type $>$ class Tree\+Type = tree\+::\+K\+D\+Tree$>$ double {\bf mlpack\+::neighbor\+::\+R\+A\+Search}$<$ Sort\+Policy, Metric\+Type, Mat\+Type, Tree\+Type $>$\+::Tau (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
) const\hspace{0.3cm}{\ttfamily [inline]}}\label{classmlpack_1_1neighbor_1_1RASearch_a89da1168110015b04b8c4a3806df6037}


Get the rank-\/approximation in percentile of the data. 



Definition at line 393 of file ra\+\_\+search.\+hpp.

\index{mlpack\+::neighbor\+::\+R\+A\+Search@{mlpack\+::neighbor\+::\+R\+A\+Search}!Tau@{Tau}}
\index{Tau@{Tau}!mlpack\+::neighbor\+::\+R\+A\+Search@{mlpack\+::neighbor\+::\+R\+A\+Search}}
\subsubsection[{Tau()}]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename Sort\+Policy = Nearest\+Neighbor\+Sort, typename Metric\+Type = metric\+::\+Euclidean\+Distance, typename Mat\+Type = arma\+::mat, template$<$ typename Tree\+Metric\+Type, typename Tree\+Stat\+Type, typename Tree\+Mat\+Type $>$ class Tree\+Type = tree\+::\+K\+D\+Tree$>$ double\& {\bf mlpack\+::neighbor\+::\+R\+A\+Search}$<$ Sort\+Policy, Metric\+Type, Mat\+Type, Tree\+Type $>$\+::Tau (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}}\label{classmlpack_1_1neighbor_1_1RASearch_a713a46af14d5df94e2504704b9e88a19}


Modify the rank-\/approximation in percentile of the data. 



Definition at line 395 of file ra\+\_\+search.\+hpp.

\index{mlpack\+::neighbor\+::\+R\+A\+Search@{mlpack\+::neighbor\+::\+R\+A\+Search}!Train@{Train}}
\index{Train@{Train}!mlpack\+::neighbor\+::\+R\+A\+Search@{mlpack\+::neighbor\+::\+R\+A\+Search}}
\subsubsection[{Train(const Mat\+Type \&reference\+Set)}]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename Sort\+Policy = Nearest\+Neighbor\+Sort, typename Metric\+Type = metric\+::\+Euclidean\+Distance, typename Mat\+Type = arma\+::mat, template$<$ typename Tree\+Metric\+Type, typename Tree\+Stat\+Type, typename Tree\+Mat\+Type $>$ class Tree\+Type = tree\+::\+K\+D\+Tree$>$ void {\bf mlpack\+::neighbor\+::\+R\+A\+Search}$<$ Sort\+Policy, Metric\+Type, Mat\+Type, Tree\+Type $>$\+::Train (
\begin{DoxyParamCaption}
\item[{const Mat\+Type \&}]{reference\+Set}
\end{DoxyParamCaption}
)}\label{classmlpack_1_1neighbor_1_1RASearch_aa1b583c83313263deb6e37053a933b71}


\char`\"{}\+Train\char`\"{} the model on the given reference set. 

If tree-\/based search is being used (if \doxyref{Naive()}{p.}{classmlpack_1_1neighbor_1_1RASearch_aadc93f6a2cc809f9ae06a877baf3561b} is false), this means rebuilding the reference tree. This particular method will make a copy of the given reference data. To avoid that copy, use the \doxyref{Train()}{p.}{classmlpack_1_1neighbor_1_1RASearch_aa1b583c83313263deb6e37053a933b71} method that takes an rvalue reference with std\+::move().


\begin{DoxyParams}{Parameters}
{\em reference\+Set} & New reference set to use. \\
\hline
\end{DoxyParams}
\index{mlpack\+::neighbor\+::\+R\+A\+Search@{mlpack\+::neighbor\+::\+R\+A\+Search}!Train@{Train}}
\index{Train@{Train}!mlpack\+::neighbor\+::\+R\+A\+Search@{mlpack\+::neighbor\+::\+R\+A\+Search}}
\subsubsection[{Train(\+Mat\+Type \&\&reference\+Set)}]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename Sort\+Policy = Nearest\+Neighbor\+Sort, typename Metric\+Type = metric\+::\+Euclidean\+Distance, typename Mat\+Type = arma\+::mat, template$<$ typename Tree\+Metric\+Type, typename Tree\+Stat\+Type, typename Tree\+Mat\+Type $>$ class Tree\+Type = tree\+::\+K\+D\+Tree$>$ void {\bf mlpack\+::neighbor\+::\+R\+A\+Search}$<$ Sort\+Policy, Metric\+Type, Mat\+Type, Tree\+Type $>$\+::Train (
\begin{DoxyParamCaption}
\item[{Mat\+Type \&\&}]{reference\+Set}
\end{DoxyParamCaption}
)}\label{classmlpack_1_1neighbor_1_1RASearch_a41a4ce71b49279f6177bc4c83e8f4742}


\char`\"{}\+Train\char`\"{} the model on the given reference set, taking ownership of the data matrix. 

If tree-\/based search is being used (if \doxyref{Naive()}{p.}{classmlpack_1_1neighbor_1_1RASearch_aadc93f6a2cc809f9ae06a877baf3561b} is false), this also means rebuilding the reference tree. If you need to keep a copy of the reference data, use the \doxyref{Train()}{p.}{classmlpack_1_1neighbor_1_1RASearch_aa1b583c83313263deb6e37053a933b71} method that takes a const reference to the data.


\begin{DoxyParams}{Parameters}
{\em reference\+Set} & New reference set to use. \\
\hline
\end{DoxyParams}


\subsection{Member Data Documentation}
\index{mlpack\+::neighbor\+::\+R\+A\+Search@{mlpack\+::neighbor\+::\+R\+A\+Search}!alpha@{alpha}}
\index{alpha@{alpha}!mlpack\+::neighbor\+::\+R\+A\+Search@{mlpack\+::neighbor\+::\+R\+A\+Search}}
\subsubsection[{alpha}]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename Sort\+Policy = Nearest\+Neighbor\+Sort, typename Metric\+Type = metric\+::\+Euclidean\+Distance, typename Mat\+Type = arma\+::mat, template$<$ typename Tree\+Metric\+Type, typename Tree\+Stat\+Type, typename Tree\+Mat\+Type $>$ class Tree\+Type = tree\+::\+K\+D\+Tree$>$ double {\bf mlpack\+::neighbor\+::\+R\+A\+Search}$<$ Sort\+Policy, Metric\+Type, Mat\+Type, Tree\+Type $>$\+::alpha\hspace{0.3cm}{\ttfamily [private]}}\label{classmlpack_1_1neighbor_1_1RASearch_a93ec20d349723ac74c3f29540448609a}


The desired success probability (between 0 and 1). 



Definition at line 442 of file ra\+\_\+search.\+hpp.



Referenced by mlpack\+::neighbor\+::\+R\+A\+Search$<$ tree\+::\+R\+Star\+Tree $>$\+::\+Alpha().

\index{mlpack\+::neighbor\+::\+R\+A\+Search@{mlpack\+::neighbor\+::\+R\+A\+Search}!first\+Leaf\+Exact@{first\+Leaf\+Exact}}
\index{first\+Leaf\+Exact@{first\+Leaf\+Exact}!mlpack\+::neighbor\+::\+R\+A\+Search@{mlpack\+::neighbor\+::\+R\+A\+Search}}
\subsubsection[{first\+Leaf\+Exact}]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename Sort\+Policy = Nearest\+Neighbor\+Sort, typename Metric\+Type = metric\+::\+Euclidean\+Distance, typename Mat\+Type = arma\+::mat, template$<$ typename Tree\+Metric\+Type, typename Tree\+Stat\+Type, typename Tree\+Mat\+Type $>$ class Tree\+Type = tree\+::\+K\+D\+Tree$>$ bool {\bf mlpack\+::neighbor\+::\+R\+A\+Search}$<$ Sort\+Policy, Metric\+Type, Mat\+Type, Tree\+Type $>$\+::first\+Leaf\+Exact\hspace{0.3cm}{\ttfamily [private]}}\label{classmlpack_1_1neighbor_1_1RASearch_a35f9759c372e2b775b3fffb1e8134da2}


If true, we will traverse to the first leaf without approximation. 



Definition at line 446 of file ra\+\_\+search.\+hpp.



Referenced by mlpack\+::neighbor\+::\+R\+A\+Search$<$ tree\+::\+R\+Star\+Tree $>$\+::\+First\+Leaf\+Exact().

\index{mlpack\+::neighbor\+::\+R\+A\+Search@{mlpack\+::neighbor\+::\+R\+A\+Search}!metric@{metric}}
\index{metric@{metric}!mlpack\+::neighbor\+::\+R\+A\+Search@{mlpack\+::neighbor\+::\+R\+A\+Search}}
\subsubsection[{metric}]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename Sort\+Policy = Nearest\+Neighbor\+Sort, typename Metric\+Type = metric\+::\+Euclidean\+Distance, typename Mat\+Type = arma\+::mat, template$<$ typename Tree\+Metric\+Type, typename Tree\+Stat\+Type, typename Tree\+Mat\+Type $>$ class Tree\+Type = tree\+::\+K\+D\+Tree$>$ Metric\+Type {\bf mlpack\+::neighbor\+::\+R\+A\+Search}$<$ Sort\+Policy, Metric\+Type, Mat\+Type, Tree\+Type $>$\+::metric\hspace{0.3cm}{\ttfamily [private]}}\label{classmlpack_1_1neighbor_1_1RASearch_a1be053d8441397ed562c44abf676edf7}


Instantiation of kernel. 



Definition at line 452 of file ra\+\_\+search.\+hpp.

\index{mlpack\+::neighbor\+::\+R\+A\+Search@{mlpack\+::neighbor\+::\+R\+A\+Search}!naive@{naive}}
\index{naive@{naive}!mlpack\+::neighbor\+::\+R\+A\+Search@{mlpack\+::neighbor\+::\+R\+A\+Search}}
\subsubsection[{naive}]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename Sort\+Policy = Nearest\+Neighbor\+Sort, typename Metric\+Type = metric\+::\+Euclidean\+Distance, typename Mat\+Type = arma\+::mat, template$<$ typename Tree\+Metric\+Type, typename Tree\+Stat\+Type, typename Tree\+Mat\+Type $>$ class Tree\+Type = tree\+::\+K\+D\+Tree$>$ bool {\bf mlpack\+::neighbor\+::\+R\+A\+Search}$<$ Sort\+Policy, Metric\+Type, Mat\+Type, Tree\+Type $>$\+::naive\hspace{0.3cm}{\ttfamily [private]}}\label{classmlpack_1_1neighbor_1_1RASearch_a18f2c93069e148e5e315b13aadb21ed6}


Indicates if naive random sampling on the set is being used. 



Definition at line 435 of file ra\+\_\+search.\+hpp.



Referenced by mlpack\+::neighbor\+::\+R\+A\+Search$<$ tree\+::\+R\+Star\+Tree $>$\+::\+Naive().

\index{mlpack\+::neighbor\+::\+R\+A\+Search@{mlpack\+::neighbor\+::\+R\+A\+Search}!old\+From\+New\+References@{old\+From\+New\+References}}
\index{old\+From\+New\+References@{old\+From\+New\+References}!mlpack\+::neighbor\+::\+R\+A\+Search@{mlpack\+::neighbor\+::\+R\+A\+Search}}
\subsubsection[{old\+From\+New\+References}]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename Sort\+Policy = Nearest\+Neighbor\+Sort, typename Metric\+Type = metric\+::\+Euclidean\+Distance, typename Mat\+Type = arma\+::mat, template$<$ typename Tree\+Metric\+Type, typename Tree\+Stat\+Type, typename Tree\+Mat\+Type $>$ class Tree\+Type = tree\+::\+K\+D\+Tree$>$ std\+::vector$<$size\+\_\+t$>$ {\bf mlpack\+::neighbor\+::\+R\+A\+Search}$<$ Sort\+Policy, Metric\+Type, Mat\+Type, Tree\+Type $>$\+::old\+From\+New\+References\hspace{0.3cm}{\ttfamily [private]}}\label{classmlpack_1_1neighbor_1_1RASearch_a0dddad8b7aede5b9fc6fc8976abf6bcb}


Permutations of reference points during tree building. 



Definition at line 423 of file ra\+\_\+search.\+hpp.

\index{mlpack\+::neighbor\+::\+R\+A\+Search@{mlpack\+::neighbor\+::\+R\+A\+Search}!reference\+Set@{reference\+Set}}
\index{reference\+Set@{reference\+Set}!mlpack\+::neighbor\+::\+R\+A\+Search@{mlpack\+::neighbor\+::\+R\+A\+Search}}
\subsubsection[{reference\+Set}]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename Sort\+Policy = Nearest\+Neighbor\+Sort, typename Metric\+Type = metric\+::\+Euclidean\+Distance, typename Mat\+Type = arma\+::mat, template$<$ typename Tree\+Metric\+Type, typename Tree\+Stat\+Type, typename Tree\+Mat\+Type $>$ class Tree\+Type = tree\+::\+K\+D\+Tree$>$ const Mat\+Type$\ast$ {\bf mlpack\+::neighbor\+::\+R\+A\+Search}$<$ Sort\+Policy, Metric\+Type, Mat\+Type, Tree\+Type $>$\+::reference\+Set\hspace{0.3cm}{\ttfamily [private]}}\label{classmlpack_1_1neighbor_1_1RASearch_a662a805197694ee1341c0ef7800e0ee1}


Reference dataset. In some situations we may own this dataset. 



Definition at line 427 of file ra\+\_\+search.\+hpp.



Referenced by mlpack\+::neighbor\+::\+R\+A\+Search$<$ tree\+::\+R\+Star\+Tree $>$\+::\+Reference\+Set().

\index{mlpack\+::neighbor\+::\+R\+A\+Search@{mlpack\+::neighbor\+::\+R\+A\+Search}!reference\+Tree@{reference\+Tree}}
\index{reference\+Tree@{reference\+Tree}!mlpack\+::neighbor\+::\+R\+A\+Search@{mlpack\+::neighbor\+::\+R\+A\+Search}}
\subsubsection[{reference\+Tree}]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename Sort\+Policy = Nearest\+Neighbor\+Sort, typename Metric\+Type = metric\+::\+Euclidean\+Distance, typename Mat\+Type = arma\+::mat, template$<$ typename Tree\+Metric\+Type, typename Tree\+Stat\+Type, typename Tree\+Mat\+Type $>$ class Tree\+Type = tree\+::\+K\+D\+Tree$>$ {\bf Tree}$\ast$ {\bf mlpack\+::neighbor\+::\+R\+A\+Search}$<$ Sort\+Policy, Metric\+Type, Mat\+Type, Tree\+Type $>$\+::reference\+Tree\hspace{0.3cm}{\ttfamily [private]}}\label{classmlpack_1_1neighbor_1_1RASearch_a1849f51e5de3bc8e1c84c0ebadfa7f35}


Pointer to the root of the reference tree. 



Definition at line 425 of file ra\+\_\+search.\+hpp.

\index{mlpack\+::neighbor\+::\+R\+A\+Search@{mlpack\+::neighbor\+::\+R\+A\+Search}!sample\+At\+Leaves@{sample\+At\+Leaves}}
\index{sample\+At\+Leaves@{sample\+At\+Leaves}!mlpack\+::neighbor\+::\+R\+A\+Search@{mlpack\+::neighbor\+::\+R\+A\+Search}}
\subsubsection[{sample\+At\+Leaves}]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename Sort\+Policy = Nearest\+Neighbor\+Sort, typename Metric\+Type = metric\+::\+Euclidean\+Distance, typename Mat\+Type = arma\+::mat, template$<$ typename Tree\+Metric\+Type, typename Tree\+Stat\+Type, typename Tree\+Mat\+Type $>$ class Tree\+Type = tree\+::\+K\+D\+Tree$>$ bool {\bf mlpack\+::neighbor\+::\+R\+A\+Search}$<$ Sort\+Policy, Metric\+Type, Mat\+Type, Tree\+Type $>$\+::sample\+At\+Leaves\hspace{0.3cm}{\ttfamily [private]}}\label{classmlpack_1_1neighbor_1_1RASearch_a7fb6d89326e1a1505841d26aba22796a}


Whether or not sampling is done at the leaves. Faster, but less accurate. 



Definition at line 444 of file ra\+\_\+search.\+hpp.



Referenced by mlpack\+::neighbor\+::\+R\+A\+Search$<$ tree\+::\+R\+Star\+Tree $>$\+::\+Sample\+At\+Leaves().

\index{mlpack\+::neighbor\+::\+R\+A\+Search@{mlpack\+::neighbor\+::\+R\+A\+Search}!set\+Owner@{set\+Owner}}
\index{set\+Owner@{set\+Owner}!mlpack\+::neighbor\+::\+R\+A\+Search@{mlpack\+::neighbor\+::\+R\+A\+Search}}
\subsubsection[{set\+Owner}]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename Sort\+Policy = Nearest\+Neighbor\+Sort, typename Metric\+Type = metric\+::\+Euclidean\+Distance, typename Mat\+Type = arma\+::mat, template$<$ typename Tree\+Metric\+Type, typename Tree\+Stat\+Type, typename Tree\+Mat\+Type $>$ class Tree\+Type = tree\+::\+K\+D\+Tree$>$ bool {\bf mlpack\+::neighbor\+::\+R\+A\+Search}$<$ Sort\+Policy, Metric\+Type, Mat\+Type, Tree\+Type $>$\+::set\+Owner\hspace{0.3cm}{\ttfamily [private]}}\label{classmlpack_1_1neighbor_1_1RASearch_a6055d7ab252c0819d8fdf7580ef4cca9}


If true, we are responsible for deleting the dataset. 



Definition at line 432 of file ra\+\_\+search.\+hpp.

\index{mlpack\+::neighbor\+::\+R\+A\+Search@{mlpack\+::neighbor\+::\+R\+A\+Search}!single\+Mode@{single\+Mode}}
\index{single\+Mode@{single\+Mode}!mlpack\+::neighbor\+::\+R\+A\+Search@{mlpack\+::neighbor\+::\+R\+A\+Search}}
\subsubsection[{single\+Mode}]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename Sort\+Policy = Nearest\+Neighbor\+Sort, typename Metric\+Type = metric\+::\+Euclidean\+Distance, typename Mat\+Type = arma\+::mat, template$<$ typename Tree\+Metric\+Type, typename Tree\+Stat\+Type, typename Tree\+Mat\+Type $>$ class Tree\+Type = tree\+::\+K\+D\+Tree$>$ bool {\bf mlpack\+::neighbor\+::\+R\+A\+Search}$<$ Sort\+Policy, Metric\+Type, Mat\+Type, Tree\+Type $>$\+::single\+Mode\hspace{0.3cm}{\ttfamily [private]}}\label{classmlpack_1_1neighbor_1_1RASearch_a56ce3cfd7a0141299f6a3c66914b50f6}


Indicates if single-\/tree search is being used (opposed to dual-\/tree). 



Definition at line 437 of file ra\+\_\+search.\+hpp.



Referenced by mlpack\+::neighbor\+::\+R\+A\+Search$<$ tree\+::\+R\+Star\+Tree $>$\+::\+Single\+Mode().

\index{mlpack\+::neighbor\+::\+R\+A\+Search@{mlpack\+::neighbor\+::\+R\+A\+Search}!single\+Sample\+Limit@{single\+Sample\+Limit}}
\index{single\+Sample\+Limit@{single\+Sample\+Limit}!mlpack\+::neighbor\+::\+R\+A\+Search@{mlpack\+::neighbor\+::\+R\+A\+Search}}
\subsubsection[{single\+Sample\+Limit}]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename Sort\+Policy = Nearest\+Neighbor\+Sort, typename Metric\+Type = metric\+::\+Euclidean\+Distance, typename Mat\+Type = arma\+::mat, template$<$ typename Tree\+Metric\+Type, typename Tree\+Stat\+Type, typename Tree\+Mat\+Type $>$ class Tree\+Type = tree\+::\+K\+D\+Tree$>$ size\+\_\+t {\bf mlpack\+::neighbor\+::\+R\+A\+Search}$<$ Sort\+Policy, Metric\+Type, Mat\+Type, Tree\+Type $>$\+::single\+Sample\+Limit\hspace{0.3cm}{\ttfamily [private]}}\label{classmlpack_1_1neighbor_1_1RASearch_a4d91160745e4683ff8f6361418c9b111}


The limit on the number of points in the largest node that can be approximated by sampling. 



Definition at line 449 of file ra\+\_\+search.\+hpp.



Referenced by mlpack\+::neighbor\+::\+R\+A\+Search$<$ tree\+::\+R\+Star\+Tree $>$\+::\+Single\+Sample\+Limit().

\index{mlpack\+::neighbor\+::\+R\+A\+Search@{mlpack\+::neighbor\+::\+R\+A\+Search}!tau@{tau}}
\index{tau@{tau}!mlpack\+::neighbor\+::\+R\+A\+Search@{mlpack\+::neighbor\+::\+R\+A\+Search}}
\subsubsection[{tau}]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename Sort\+Policy = Nearest\+Neighbor\+Sort, typename Metric\+Type = metric\+::\+Euclidean\+Distance, typename Mat\+Type = arma\+::mat, template$<$ typename Tree\+Metric\+Type, typename Tree\+Stat\+Type, typename Tree\+Mat\+Type $>$ class Tree\+Type = tree\+::\+K\+D\+Tree$>$ double {\bf mlpack\+::neighbor\+::\+R\+A\+Search}$<$ Sort\+Policy, Metric\+Type, Mat\+Type, Tree\+Type $>$\+::tau\hspace{0.3cm}{\ttfamily [private]}}\label{classmlpack_1_1neighbor_1_1RASearch_ac1fb9c1b7537ae23c71fc134d3b9424b}


The rank-\/approximation in percentile of the data (between 0 and 100). 



Definition at line 440 of file ra\+\_\+search.\+hpp.



Referenced by mlpack\+::neighbor\+::\+R\+A\+Search$<$ tree\+::\+R\+Star\+Tree $>$\+::\+Tau().

\index{mlpack\+::neighbor\+::\+R\+A\+Search@{mlpack\+::neighbor\+::\+R\+A\+Search}!tree\+Owner@{tree\+Owner}}
\index{tree\+Owner@{tree\+Owner}!mlpack\+::neighbor\+::\+R\+A\+Search@{mlpack\+::neighbor\+::\+R\+A\+Search}}
\subsubsection[{tree\+Owner}]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename Sort\+Policy = Nearest\+Neighbor\+Sort, typename Metric\+Type = metric\+::\+Euclidean\+Distance, typename Mat\+Type = arma\+::mat, template$<$ typename Tree\+Metric\+Type, typename Tree\+Stat\+Type, typename Tree\+Mat\+Type $>$ class Tree\+Type = tree\+::\+K\+D\+Tree$>$ bool {\bf mlpack\+::neighbor\+::\+R\+A\+Search}$<$ Sort\+Policy, Metric\+Type, Mat\+Type, Tree\+Type $>$\+::tree\+Owner\hspace{0.3cm}{\ttfamily [private]}}\label{classmlpack_1_1neighbor_1_1RASearch_ada78ea03de8ed12f078dd23727d231aa}


If true, this object created the trees and is responsible for them. 



Definition at line 430 of file ra\+\_\+search.\+hpp.



The documentation for this class was generated from the following file\+:\begin{DoxyCompactItemize}
\item 
src/mlpack/methods/rann/{\bf ra\+\_\+search.\+hpp}\end{DoxyCompactItemize}
