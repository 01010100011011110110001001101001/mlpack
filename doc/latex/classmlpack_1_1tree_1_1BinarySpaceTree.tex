\section{mlpack\+:\+:tree\+:\+:Binary\+Space\+Tree$<$ Metric\+Type, Statistic\+Type, Mat\+Type, Bound\+Type, Split\+Type $>$ Class Template Reference}
\label{classmlpack_1_1tree_1_1BinarySpaceTree}\index{mlpack\+::tree\+::\+Binary\+Space\+Tree$<$ Metric\+Type, Statistic\+Type, Mat\+Type, Bound\+Type, Split\+Type $>$@{mlpack\+::tree\+::\+Binary\+Space\+Tree$<$ Metric\+Type, Statistic\+Type, Mat\+Type, Bound\+Type, Split\+Type $>$}}


A binary space partitioning tree, such as a K\+D-\/tree or a ball tree.  


\subsection*{Classes}
\begin{DoxyCompactItemize}
\item 
class {\bf Breadth\+First\+Dual\+Tree\+Traverser}
\item 
class {\bf Dual\+Tree\+Traverser}
\begin{DoxyCompactList}\small\item\em A dual-\/tree traverser for binary space trees; see dual\+\_\+tree\+\_\+traverser.\+hpp. \end{DoxyCompactList}\item 
class {\bf Single\+Tree\+Traverser}
\begin{DoxyCompactList}\small\item\em A single-\/tree traverser for binary space trees; see single\+\_\+tree\+\_\+traverser.\+hpp for implementation. \end{DoxyCompactList}\end{DoxyCompactItemize}
\subsection*{Public Types}
\begin{DoxyCompactItemize}
\item 
typedef Mat\+Type\+::elem\+\_\+type {\bf Elem\+Type}
\begin{DoxyCompactList}\small\item\em The type of element held in Mat\+Type. \end{DoxyCompactList}\item 
typedef Mat\+Type {\bf Mat}
\begin{DoxyCompactList}\small\item\em So other classes can use Tree\+Type\+::\+Mat. \end{DoxyCompactList}\item 
typedef Split\+Type$<$ Bound\+Type$<$ Metric\+Type $>$, Mat\+Type $>$ {\bf Split}
\end{DoxyCompactItemize}
\subsection*{Public Member Functions}
\begin{DoxyCompactItemize}
\item 
{\bf Binary\+Space\+Tree} (const Mat\+Type \&data, const size\+\_\+t max\+Leaf\+Size=20)
\begin{DoxyCompactList}\small\item\em Construct this as the root node of a binary space tree using the given dataset. \end{DoxyCompactList}\item 
{\bf Binary\+Space\+Tree} (const Mat\+Type \&data, std\+::vector$<$ size\+\_\+t $>$ \&old\+From\+New, const size\+\_\+t max\+Leaf\+Size=20)
\begin{DoxyCompactList}\small\item\em Construct this as the root node of a binary space tree using the given dataset. \end{DoxyCompactList}\item 
{\bf Binary\+Space\+Tree} (const Mat\+Type \&data, std\+::vector$<$ size\+\_\+t $>$ \&old\+From\+New, std\+::vector$<$ size\+\_\+t $>$ \&new\+From\+Old, const size\+\_\+t max\+Leaf\+Size=20)
\begin{DoxyCompactList}\small\item\em Construct this as the root node of a binary space tree using the given dataset. \end{DoxyCompactList}\item 
{\bf Binary\+Space\+Tree} (Mat\+Type \&\&data, const size\+\_\+t max\+Leaf\+Size=20)
\begin{DoxyCompactList}\small\item\em Construct this as the root node of a binary space tree using the given dataset. \end{DoxyCompactList}\item 
{\bf Binary\+Space\+Tree} (Mat\+Type \&\&data, std\+::vector$<$ size\+\_\+t $>$ \&old\+From\+New, const size\+\_\+t max\+Leaf\+Size=20)
\begin{DoxyCompactList}\small\item\em Construct this as the root node of a binary space tree using the given dataset. \end{DoxyCompactList}\item 
{\bf Binary\+Space\+Tree} (Mat\+Type \&\&data, std\+::vector$<$ size\+\_\+t $>$ \&old\+From\+New, std\+::vector$<$ size\+\_\+t $>$ \&new\+From\+Old, const size\+\_\+t max\+Leaf\+Size=20)
\begin{DoxyCompactList}\small\item\em Construct this as the root node of a binary space tree using the given dataset. \end{DoxyCompactList}\item 
{\bf Binary\+Space\+Tree} ({\bf Binary\+Space\+Tree} $\ast${\bf parent}, const size\+\_\+t {\bf begin}, const size\+\_\+t {\bf count}, Split\+Type$<$ Bound\+Type$<$ Metric\+Type $>$, Mat\+Type $>$ \&splitter, const size\+\_\+t max\+Leaf\+Size=20)
\begin{DoxyCompactList}\small\item\em Construct this node as a child of the given parent, starting at column begin and using count points. \end{DoxyCompactList}\item 
{\bf Binary\+Space\+Tree} ({\bf Binary\+Space\+Tree} $\ast${\bf parent}, const size\+\_\+t {\bf begin}, const size\+\_\+t {\bf count}, std\+::vector$<$ size\+\_\+t $>$ \&old\+From\+New, Split\+Type$<$ Bound\+Type$<$ Metric\+Type $>$, Mat\+Type $>$ \&splitter, const size\+\_\+t max\+Leaf\+Size=20)
\begin{DoxyCompactList}\small\item\em Construct this node as a child of the given parent, starting at column begin and using count points. \end{DoxyCompactList}\item 
{\bf Binary\+Space\+Tree} ({\bf Binary\+Space\+Tree} $\ast${\bf parent}, const size\+\_\+t {\bf begin}, const size\+\_\+t {\bf count}, std\+::vector$<$ size\+\_\+t $>$ \&old\+From\+New, std\+::vector$<$ size\+\_\+t $>$ \&new\+From\+Old, Split\+Type$<$ Bound\+Type$<$ Metric\+Type $>$, Mat\+Type $>$ \&splitter, const size\+\_\+t max\+Leaf\+Size=20)
\begin{DoxyCompactList}\small\item\em Construct this node as a child of the given parent, starting at column begin and using count points. \end{DoxyCompactList}\item 
{\bf Binary\+Space\+Tree} (const {\bf Binary\+Space\+Tree} \&other)
\begin{DoxyCompactList}\small\item\em Create a binary space tree by copying the other tree. \end{DoxyCompactList}\item 
{\bf Binary\+Space\+Tree} ({\bf Binary\+Space\+Tree} \&\&other)
\begin{DoxyCompactList}\small\item\em Move constructor for a \doxyref{Binary\+Space\+Tree}{p.}{classmlpack_1_1tree_1_1BinarySpaceTree}; possess all the members of the given tree. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename Archive $>$ }\\{\bf Binary\+Space\+Tree} (Archive \&ar, const typename {\bf std\+::enable\+\_\+if\+\_\+t}$<$ Archive\+::is\+\_\+loading\+::value $>$ $\ast$=0)
\begin{DoxyCompactList}\small\item\em Initialize the tree from a \doxyref{boost\+::serialization}{p.}{namespaceboost_1_1serialization} archive. \end{DoxyCompactList}\item 
{\bf $\sim$\+Binary\+Space\+Tree} ()
\begin{DoxyCompactList}\small\item\em Deletes this node, deallocating the memory for the children and calling their destructors in turn. \end{DoxyCompactList}\item 
size\+\_\+t {\bf Begin} () const 
\begin{DoxyCompactList}\small\item\em Return the index of the beginning point of this subset. \end{DoxyCompactList}\item 
size\+\_\+t \& {\bf Begin} ()
\begin{DoxyCompactList}\small\item\em Modify the index of the beginning point of this subset. \end{DoxyCompactList}\item 
const Bound\+Type$<$ Metric\+Type $>$ \& {\bf Bound} () const 
\begin{DoxyCompactList}\small\item\em Return the bound object for this node. \end{DoxyCompactList}\item 
Bound\+Type$<$ Metric\+Type $>$ \& {\bf Bound} ()
\begin{DoxyCompactList}\small\item\em Return the bound object for this node. \end{DoxyCompactList}\item 
void {\bf Center} (arma\+::vec \&center) const 
\begin{DoxyCompactList}\small\item\em Store the center of the bounding region in the given vector. \end{DoxyCompactList}\item 
{\bf Binary\+Space\+Tree} \& {\bf Child} (const size\+\_\+t child) const 
\begin{DoxyCompactList}\small\item\em Return the specified child (0 will be left, 1 will be right). \end{DoxyCompactList}\item 
{\bf Binary\+Space\+Tree} $\ast$\& {\bf Child\+Ptr} (const size\+\_\+t child)
\item 
size\+\_\+t {\bf Count} () const 
\begin{DoxyCompactList}\small\item\em Return the number of points in this subset. \end{DoxyCompactList}\item 
size\+\_\+t \& {\bf Count} ()
\begin{DoxyCompactList}\small\item\em Modify the number of points in this subset. \end{DoxyCompactList}\item 
const Mat\+Type \& {\bf Dataset} () const 
\begin{DoxyCompactList}\small\item\em Get the dataset which the tree is built on. \end{DoxyCompactList}\item 
Mat\+Type \& {\bf Dataset} ()
\begin{DoxyCompactList}\small\item\em Modify the dataset which the tree is built on. Be careful! \end{DoxyCompactList}\item 
size\+\_\+t {\bf Descendant} (const size\+\_\+t index) const 
\begin{DoxyCompactList}\small\item\em Return the index (with reference to the dataset) of a particular descendant of this node. \end{DoxyCompactList}\item 
{\bf Elem\+Type} {\bf Furthest\+Descendant\+Distance} () const 
\begin{DoxyCompactList}\small\item\em Return the furthest possible descendant distance. \end{DoxyCompactList}\item 
{\bf Elem\+Type} {\bf Furthest\+Point\+Distance} () const 
\begin{DoxyCompactList}\small\item\em Return the furthest distance to a point held in this node. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename Vec\+Type $>$ }\\size\+\_\+t {\bf Get\+Furthest\+Child} (const Vec\+Type \&point, typename {\bf std\+::enable\+\_\+if\+\_\+t}$<$ {\bf Is\+Vector}$<$ Vec\+Type $>$\+::value $>$ $\ast$=0)
\begin{DoxyCompactList}\small\item\em Return the index of the furthest child node to the given query point. \end{DoxyCompactList}\item 
size\+\_\+t {\bf Get\+Furthest\+Child} (const {\bf Binary\+Space\+Tree} \&query\+Node)
\begin{DoxyCompactList}\small\item\em Return the index of the furthest child node to the given query node. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename Vec\+Type $>$ }\\size\+\_\+t {\bf Get\+Nearest\+Child} (const Vec\+Type \&point, typename {\bf std\+::enable\+\_\+if\+\_\+t}$<$ {\bf Is\+Vector}$<$ Vec\+Type $>$\+::value $>$ $\ast$=0)
\begin{DoxyCompactList}\small\item\em Return the index of the nearest child node to the given query point. \end{DoxyCompactList}\item 
size\+\_\+t {\bf Get\+Nearest\+Child} (const {\bf Binary\+Space\+Tree} \&query\+Node)
\begin{DoxyCompactList}\small\item\em Return the index of the nearest child node to the given query node. \end{DoxyCompactList}\item 
bool {\bf Is\+Leaf} () const 
\begin{DoxyCompactList}\small\item\em Return whether or not this node is a leaf (true if it has no children). \end{DoxyCompactList}\item 
{\bf Binary\+Space\+Tree} $\ast$ {\bf Left} () const 
\begin{DoxyCompactList}\small\item\em Gets the left child of this node. \end{DoxyCompactList}\item 
{\bf Binary\+Space\+Tree} $\ast$\& {\bf Left} ()
\begin{DoxyCompactList}\small\item\em Modify the left child of this node. \end{DoxyCompactList}\item 
{\bf Elem\+Type} {\bf Max\+Distance} (const {\bf Binary\+Space\+Tree} \&other) const 
\begin{DoxyCompactList}\small\item\em Return the maximum distance to another node. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename Vec\+Type $>$ }\\{\bf Elem\+Type} {\bf Max\+Distance} (const Vec\+Type \&point, typename {\bf std\+::enable\+\_\+if\+\_\+t}$<$ {\bf Is\+Vector}$<$ Vec\+Type $>$\+::value $>$ $\ast$=0) const 
\begin{DoxyCompactList}\small\item\em Return the maximum distance to another point. \end{DoxyCompactList}\item 
Metric\+Type {\bf Metric} () const 
\begin{DoxyCompactList}\small\item\em Get the metric that the tree uses. \end{DoxyCompactList}\item 
{\bf Elem\+Type} {\bf Min\+Distance} (const {\bf Binary\+Space\+Tree} \&other) const 
\begin{DoxyCompactList}\small\item\em Return the minimum distance to another node. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename Vec\+Type $>$ }\\{\bf Elem\+Type} {\bf Min\+Distance} (const Vec\+Type \&point, typename {\bf std\+::enable\+\_\+if\+\_\+t}$<$ {\bf Is\+Vector}$<$ Vec\+Type $>$\+::value $>$ $\ast$=0) const 
\begin{DoxyCompactList}\small\item\em Return the minimum distance to another point. \end{DoxyCompactList}\item 
{\bf Elem\+Type} {\bf Minimum\+Bound\+Distance} () const 
\begin{DoxyCompactList}\small\item\em Return the minimum distance from the center of the node to any bound edge. \end{DoxyCompactList}\item 
size\+\_\+t {\bf Num\+Children} () const 
\begin{DoxyCompactList}\small\item\em Return the number of children in this node. \end{DoxyCompactList}\item 
size\+\_\+t {\bf Num\+Descendants} () const 
\begin{DoxyCompactList}\small\item\em Return the number of descendants of this node. \end{DoxyCompactList}\item 
size\+\_\+t {\bf Num\+Points} () const 
\begin{DoxyCompactList}\small\item\em Return the number of points in this node (0 if not a leaf). \end{DoxyCompactList}\item 
{\bf Binary\+Space\+Tree} $\ast$ {\bf Parent} () const 
\begin{DoxyCompactList}\small\item\em Gets the parent of this node. \end{DoxyCompactList}\item 
{\bf Binary\+Space\+Tree} $\ast$\& {\bf Parent} ()
\begin{DoxyCompactList}\small\item\em Modify the parent of this node. \end{DoxyCompactList}\item 
{\bf Elem\+Type} {\bf Parent\+Distance} () const 
\begin{DoxyCompactList}\small\item\em Return the distance from the center of this node to the center of the parent node. \end{DoxyCompactList}\item 
{\bf Elem\+Type} \& {\bf Parent\+Distance} ()
\begin{DoxyCompactList}\small\item\em Modify the distance from the center of this node to the center of the parent node. \end{DoxyCompactList}\item 
size\+\_\+t {\bf Point} (const size\+\_\+t index) const 
\begin{DoxyCompactList}\small\item\em Return the index (with reference to the dataset) of a particular point in this node. \end{DoxyCompactList}\item 
{\bf math\+::\+Range\+Type}$<$ {\bf Elem\+Type} $>$ {\bf Range\+Distance} (const {\bf Binary\+Space\+Tree} \&other) const 
\begin{DoxyCompactList}\small\item\em Return the minimum and maximum distance to another node. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename Vec\+Type $>$ }\\{\bf math\+::\+Range\+Type}$<$ {\bf Elem\+Type} $>$ {\bf Range\+Distance} (const Vec\+Type \&point, typename {\bf std\+::enable\+\_\+if\+\_\+t}$<$ {\bf Is\+Vector}$<$ Vec\+Type $>$\+::value $>$ $\ast$=0) const 
\begin{DoxyCompactList}\small\item\em Return the minimum and maximum distance to another point. \end{DoxyCompactList}\item 
{\bf Binary\+Space\+Tree} $\ast$ {\bf Right} () const 
\begin{DoxyCompactList}\small\item\em Gets the right child of this node. \end{DoxyCompactList}\item 
{\bf Binary\+Space\+Tree} $\ast$\& {\bf Right} ()
\begin{DoxyCompactList}\small\item\em Modify the right child of this node. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename Archive $>$ }\\void {\bf Serialize} (Archive \&ar, const unsigned int version)
\begin{DoxyCompactList}\small\item\em Serialize the tree. \end{DoxyCompactList}\item 
const Statistic\+Type \& {\bf Stat} () const 
\begin{DoxyCompactList}\small\item\em Return the statistic object for this node. \end{DoxyCompactList}\item 
Statistic\+Type \& {\bf Stat} ()
\begin{DoxyCompactList}\small\item\em Return the statistic object for this node. \end{DoxyCompactList}\end{DoxyCompactItemize}
\subsection*{Protected Member Functions}
\begin{DoxyCompactItemize}
\item 
{\bf Binary\+Space\+Tree} ()
\begin{DoxyCompactList}\small\item\em A default constructor. \end{DoxyCompactList}\end{DoxyCompactItemize}
\subsection*{Private Member Functions}
\begin{DoxyCompactItemize}
\item 
void {\bf Split\+Node} (const size\+\_\+t max\+Leaf\+Size, Split\+Type$<$ Bound\+Type$<$ Metric\+Type $>$, Mat\+Type $>$ \&splitter)
\begin{DoxyCompactList}\small\item\em Splits the current node, assigning its left and right children recursively. \end{DoxyCompactList}\item 
void {\bf Split\+Node} (std\+::vector$<$ size\+\_\+t $>$ \&old\+From\+New, const size\+\_\+t max\+Leaf\+Size, Split\+Type$<$ Bound\+Type$<$ Metric\+Type $>$, Mat\+Type $>$ \&splitter)
\begin{DoxyCompactList}\small\item\em Splits the current node, assigning its left and right children recursively. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename Bound\+Type2 $>$ }\\void {\bf Update\+Bound} (Bound\+Type2 \&bound\+To\+Update)
\begin{DoxyCompactList}\small\item\em Update the bound of the current node. \end{DoxyCompactList}\item 
void {\bf Update\+Bound} ({\bf bound\+::\+Hollow\+Ball\+Bound}$<$ Metric\+Type $>$ \&bound\+To\+Update)
\begin{DoxyCompactList}\small\item\em Update the bound of the current node. \end{DoxyCompactList}\end{DoxyCompactItemize}
\subsection*{Private Attributes}
\begin{DoxyCompactItemize}
\item 
size\+\_\+t {\bf begin}
\begin{DoxyCompactList}\small\item\em The index of the first point in the dataset contained in this node (and its children). \end{DoxyCompactList}\item 
Bound\+Type$<$ Metric\+Type $>$ {\bf bound}
\begin{DoxyCompactList}\small\item\em The bound object for this node. \end{DoxyCompactList}\item 
size\+\_\+t {\bf count}
\begin{DoxyCompactList}\small\item\em The number of points of the dataset contained in this node (and its children). \end{DoxyCompactList}\item 
Mat\+Type $\ast$ {\bf dataset}
\begin{DoxyCompactList}\small\item\em The dataset. \end{DoxyCompactList}\item 
{\bf Elem\+Type} {\bf furthest\+Descendant\+Distance}
\begin{DoxyCompactList}\small\item\em The worst possible distance to the furthest descendant, cached to speed things up. \end{DoxyCompactList}\item 
{\bf Binary\+Space\+Tree} $\ast$ {\bf left}
\begin{DoxyCompactList}\small\item\em The left child node. \end{DoxyCompactList}\item 
{\bf Elem\+Type} {\bf minimum\+Bound\+Distance}
\begin{DoxyCompactList}\small\item\em The minimum distance from the center to any edge of the bound. \end{DoxyCompactList}\item 
{\bf Binary\+Space\+Tree} $\ast$ {\bf parent}
\begin{DoxyCompactList}\small\item\em The parent node (N\+U\+LL if this is the root of the tree). \end{DoxyCompactList}\item 
{\bf Elem\+Type} {\bf parent\+Distance}
\begin{DoxyCompactList}\small\item\em The distance from the centroid of this node to the centroid of the parent. \end{DoxyCompactList}\item 
{\bf Binary\+Space\+Tree} $\ast$ {\bf right}
\begin{DoxyCompactList}\small\item\em The right child node. \end{DoxyCompactList}\item 
Statistic\+Type {\bf stat}
\begin{DoxyCompactList}\small\item\em Any extra data contained in the node. \end{DoxyCompactList}\end{DoxyCompactItemize}


\subsection{Detailed Description}
\subsubsection*{template$<$typename Metric\+Type, typename Statistic\+Type = Empty\+Statistic, typename Mat\+Type = arma\+::mat, template$<$ typename Bound\+Metric\+Type, typename... $>$ class Bound\+Type = bound\+::\+H\+Rect\+Bound, template$<$ typename Split\+Bound\+Type, typename Split\+Mat\+Type $>$ class Split\+Type = Midpoint\+Split$>$\\*
class mlpack\+::tree\+::\+Binary\+Space\+Tree$<$ Metric\+Type, Statistic\+Type, Mat\+Type, Bound\+Type, Split\+Type $>$}

A binary space partitioning tree, such as a K\+D-\/tree or a ball tree. 

Once the bound and type of dataset is defined, the tree will construct itself. Call the constructor with the dataset to build the tree on, and the entire tree will be built.

This particular tree does not allow growth, so you cannot add or delete nodes from it. If you need to add or delete a node, the better procedure is to rebuild the tree entirely.

This tree does take one runtime parameter in the constructor, which is the max leaf size to be used.


\begin{DoxyTemplParams}{Template Parameters}
{\em Metric\+Type} & The metric used for tree-\/building. The Bound\+Type may place restrictions on the metrics that can be used. \\
\hline
{\em Statistic\+Type} & Extra data contained in the node. See \doxyref{statistic.\+hpp}{p.}{statistic_8hpp} for the necessary skeleton interface. \\
\hline
{\em Mat\+Type} & The dataset class. \\
\hline
{\em Bound\+Type} & The bound used for each node. H\+Rect\+Bound, the default, requires that an L\+Metric$<$$>$ is used for Metric\+Type (so, Euclidean\+Distance, Manhattan\+Distance, etc.). \\
\hline
{\em Split\+Type} & The class that partitions the dataset/points at a particular node into two parts. Its definition decides the way this split is done. \\
\hline
\end{DoxyTemplParams}


Definition at line 54 of file binary\+\_\+space\+\_\+tree.\+hpp.



\subsection{Member Typedef Documentation}
\index{mlpack\+::tree\+::\+Binary\+Space\+Tree@{mlpack\+::tree\+::\+Binary\+Space\+Tree}!Elem\+Type@{Elem\+Type}}
\index{Elem\+Type@{Elem\+Type}!mlpack\+::tree\+::\+Binary\+Space\+Tree@{mlpack\+::tree\+::\+Binary\+Space\+Tree}}
\subsubsection[{Elem\+Type}]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename Metric\+Type , typename Statistic\+Type  = Empty\+Statistic, typename Mat\+Type  = arma\+::mat, template$<$ typename Bound\+Metric\+Type, typename... $>$ class Bound\+Type = bound\+::\+H\+Rect\+Bound, template$<$ typename Split\+Bound\+Type, typename Split\+Mat\+Type $>$ class Split\+Type = Midpoint\+Split$>$ typedef Mat\+Type\+::elem\+\_\+type {\bf mlpack\+::tree\+::\+Binary\+Space\+Tree}$<$ Metric\+Type, Statistic\+Type, Mat\+Type, Bound\+Type, Split\+Type $>$\+::{\bf Elem\+Type}}\label{classmlpack_1_1tree_1_1BinarySpaceTree_a45c13c579558efc3210ea11dedc6f4ed}


The type of element held in Mat\+Type. 



Definition at line 60 of file binary\+\_\+space\+\_\+tree.\+hpp.

\index{mlpack\+::tree\+::\+Binary\+Space\+Tree@{mlpack\+::tree\+::\+Binary\+Space\+Tree}!Mat@{Mat}}
\index{Mat@{Mat}!mlpack\+::tree\+::\+Binary\+Space\+Tree@{mlpack\+::tree\+::\+Binary\+Space\+Tree}}
\subsubsection[{Mat}]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename Metric\+Type , typename Statistic\+Type  = Empty\+Statistic, typename Mat\+Type  = arma\+::mat, template$<$ typename Bound\+Metric\+Type, typename... $>$ class Bound\+Type = bound\+::\+H\+Rect\+Bound, template$<$ typename Split\+Bound\+Type, typename Split\+Mat\+Type $>$ class Split\+Type = Midpoint\+Split$>$ typedef Mat\+Type {\bf mlpack\+::tree\+::\+Binary\+Space\+Tree}$<$ Metric\+Type, Statistic\+Type, Mat\+Type, Bound\+Type, Split\+Type $>$\+::{\bf Mat}}\label{classmlpack_1_1tree_1_1BinarySpaceTree_acc0949ae4b589b4e90884419e3b08c38}


So other classes can use Tree\+Type\+::\+Mat. 



Definition at line 58 of file binary\+\_\+space\+\_\+tree.\+hpp.

\index{mlpack\+::tree\+::\+Binary\+Space\+Tree@{mlpack\+::tree\+::\+Binary\+Space\+Tree}!Split@{Split}}
\index{Split@{Split}!mlpack\+::tree\+::\+Binary\+Space\+Tree@{mlpack\+::tree\+::\+Binary\+Space\+Tree}}
\subsubsection[{Split}]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename Metric\+Type , typename Statistic\+Type  = Empty\+Statistic, typename Mat\+Type  = arma\+::mat, template$<$ typename Bound\+Metric\+Type, typename... $>$ class Bound\+Type = bound\+::\+H\+Rect\+Bound, template$<$ typename Split\+Bound\+Type, typename Split\+Mat\+Type $>$ class Split\+Type = Midpoint\+Split$>$ typedef Split\+Type$<$Bound\+Type$<$Metric\+Type$>$, Mat\+Type$>$ {\bf mlpack\+::tree\+::\+Binary\+Space\+Tree}$<$ Metric\+Type, Statistic\+Type, Mat\+Type, Bound\+Type, Split\+Type $>$\+::{\bf Split}}\label{classmlpack_1_1tree_1_1BinarySpaceTree_adf5bc9bf70878521afddfc0a64d9f1a8}


Definition at line 62 of file binary\+\_\+space\+\_\+tree.\+hpp.



\subsection{Constructor \& Destructor Documentation}
\index{mlpack\+::tree\+::\+Binary\+Space\+Tree@{mlpack\+::tree\+::\+Binary\+Space\+Tree}!Binary\+Space\+Tree@{Binary\+Space\+Tree}}
\index{Binary\+Space\+Tree@{Binary\+Space\+Tree}!mlpack\+::tree\+::\+Binary\+Space\+Tree@{mlpack\+::tree\+::\+Binary\+Space\+Tree}}
\subsubsection[{Binary\+Space\+Tree(const Mat\+Type \&data, const size\+\_\+t max\+Leaf\+Size=20)}]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename Metric\+Type , typename Statistic\+Type  = Empty\+Statistic, typename Mat\+Type  = arma\+::mat, template$<$ typename Bound\+Metric\+Type, typename... $>$ class Bound\+Type = bound\+::\+H\+Rect\+Bound, template$<$ typename Split\+Bound\+Type, typename Split\+Mat\+Type $>$ class Split\+Type = Midpoint\+Split$>$ {\bf mlpack\+::tree\+::\+Binary\+Space\+Tree}$<$ Metric\+Type, Statistic\+Type, Mat\+Type, Bound\+Type, Split\+Type $>$\+::{\bf Binary\+Space\+Tree} (
\begin{DoxyParamCaption}
\item[{const Mat\+Type \&}]{data, }
\item[{const size\+\_\+t}]{max\+Leaf\+Size = {\ttfamily 20}}
\end{DoxyParamCaption}
)}\label{classmlpack_1_1tree_1_1BinarySpaceTree_ab5a1d86417a1c0af92ba3a4f80ce96f7}


Construct this as the root node of a binary space tree using the given dataset. 

This will copy the input matrix; if you don\textquotesingle{}t want this, consider using the constructor that takes an rvalue reference and use std\+::move().


\begin{DoxyParams}{Parameters}
{\em data} & Dataset to create tree from. This will be copied! \\
\hline
{\em max\+Leaf\+Size} & Size of each leaf in the tree. \\
\hline
\end{DoxyParams}
\index{mlpack\+::tree\+::\+Binary\+Space\+Tree@{mlpack\+::tree\+::\+Binary\+Space\+Tree}!Binary\+Space\+Tree@{Binary\+Space\+Tree}}
\index{Binary\+Space\+Tree@{Binary\+Space\+Tree}!mlpack\+::tree\+::\+Binary\+Space\+Tree@{mlpack\+::tree\+::\+Binary\+Space\+Tree}}
\subsubsection[{Binary\+Space\+Tree(const Mat\+Type \&data, std\+::vector$<$ size\+\_\+t $>$ \&old\+From\+New, const size\+\_\+t max\+Leaf\+Size=20)}]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename Metric\+Type , typename Statistic\+Type  = Empty\+Statistic, typename Mat\+Type  = arma\+::mat, template$<$ typename Bound\+Metric\+Type, typename... $>$ class Bound\+Type = bound\+::\+H\+Rect\+Bound, template$<$ typename Split\+Bound\+Type, typename Split\+Mat\+Type $>$ class Split\+Type = Midpoint\+Split$>$ {\bf mlpack\+::tree\+::\+Binary\+Space\+Tree}$<$ Metric\+Type, Statistic\+Type, Mat\+Type, Bound\+Type, Split\+Type $>$\+::{\bf Binary\+Space\+Tree} (
\begin{DoxyParamCaption}
\item[{const Mat\+Type \&}]{data, }
\item[{std\+::vector$<$ size\+\_\+t $>$ \&}]{old\+From\+New, }
\item[{const size\+\_\+t}]{max\+Leaf\+Size = {\ttfamily 20}}
\end{DoxyParamCaption}
)}\label{classmlpack_1_1tree_1_1BinarySpaceTree_aaf777bf78844a1cfa0cd417fd79fe62e}


Construct this as the root node of a binary space tree using the given dataset. 

This will copy the input matrix and modify its ordering; a mapping of the old point indices to the new point indices is filled. If you don\textquotesingle{}t want the matrix to be copied, consider using the constructor that takes an rvalue reference and use std\+::move().


\begin{DoxyParams}{Parameters}
{\em data} & Dataset to create tree from. This will be copied! \\
\hline
{\em old\+From\+New} & Vector which will be filled with the old positions for each new point. \\
\hline
{\em max\+Leaf\+Size} & Size of each leaf in the tree. \\
\hline
\end{DoxyParams}
\index{mlpack\+::tree\+::\+Binary\+Space\+Tree@{mlpack\+::tree\+::\+Binary\+Space\+Tree}!Binary\+Space\+Tree@{Binary\+Space\+Tree}}
\index{Binary\+Space\+Tree@{Binary\+Space\+Tree}!mlpack\+::tree\+::\+Binary\+Space\+Tree@{mlpack\+::tree\+::\+Binary\+Space\+Tree}}
\subsubsection[{Binary\+Space\+Tree(const Mat\+Type \&data, std\+::vector$<$ size\+\_\+t $>$ \&old\+From\+New, std\+::vector$<$ size\+\_\+t $>$ \&new\+From\+Old, const size\+\_\+t max\+Leaf\+Size=20)}]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename Metric\+Type , typename Statistic\+Type  = Empty\+Statistic, typename Mat\+Type  = arma\+::mat, template$<$ typename Bound\+Metric\+Type, typename... $>$ class Bound\+Type = bound\+::\+H\+Rect\+Bound, template$<$ typename Split\+Bound\+Type, typename Split\+Mat\+Type $>$ class Split\+Type = Midpoint\+Split$>$ {\bf mlpack\+::tree\+::\+Binary\+Space\+Tree}$<$ Metric\+Type, Statistic\+Type, Mat\+Type, Bound\+Type, Split\+Type $>$\+::{\bf Binary\+Space\+Tree} (
\begin{DoxyParamCaption}
\item[{const Mat\+Type \&}]{data, }
\item[{std\+::vector$<$ size\+\_\+t $>$ \&}]{old\+From\+New, }
\item[{std\+::vector$<$ size\+\_\+t $>$ \&}]{new\+From\+Old, }
\item[{const size\+\_\+t}]{max\+Leaf\+Size = {\ttfamily 20}}
\end{DoxyParamCaption}
)}\label{classmlpack_1_1tree_1_1BinarySpaceTree_a8dee1f2c906e62c56bac004ffc45d26d}


Construct this as the root node of a binary space tree using the given dataset. 

This will copy the input matrix and modify its ordering; a mapping of the old point indices to the new point indices is filled, as well as a mapping of the new point indices to the old point indices. If you don\textquotesingle{}t want the matrix to be copied, consider using the constructor that takes an rvalue reference and use std\+::move().


\begin{DoxyParams}{Parameters}
{\em data} & Dataset to create tree from. This will be copied! \\
\hline
{\em old\+From\+New} & Vector which will be filled with the old positions for each new point. \\
\hline
{\em new\+From\+Old} & Vector which will be filled with the new positions for each old point. \\
\hline
{\em max\+Leaf\+Size} & Size of each leaf in the tree. \\
\hline
\end{DoxyParams}
\index{mlpack\+::tree\+::\+Binary\+Space\+Tree@{mlpack\+::tree\+::\+Binary\+Space\+Tree}!Binary\+Space\+Tree@{Binary\+Space\+Tree}}
\index{Binary\+Space\+Tree@{Binary\+Space\+Tree}!mlpack\+::tree\+::\+Binary\+Space\+Tree@{mlpack\+::tree\+::\+Binary\+Space\+Tree}}
\subsubsection[{Binary\+Space\+Tree(\+Mat\+Type \&\&data, const size\+\_\+t max\+Leaf\+Size=20)}]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename Metric\+Type , typename Statistic\+Type  = Empty\+Statistic, typename Mat\+Type  = arma\+::mat, template$<$ typename Bound\+Metric\+Type, typename... $>$ class Bound\+Type = bound\+::\+H\+Rect\+Bound, template$<$ typename Split\+Bound\+Type, typename Split\+Mat\+Type $>$ class Split\+Type = Midpoint\+Split$>$ {\bf mlpack\+::tree\+::\+Binary\+Space\+Tree}$<$ Metric\+Type, Statistic\+Type, Mat\+Type, Bound\+Type, Split\+Type $>$\+::{\bf Binary\+Space\+Tree} (
\begin{DoxyParamCaption}
\item[{Mat\+Type \&\&}]{data, }
\item[{const size\+\_\+t}]{max\+Leaf\+Size = {\ttfamily 20}}
\end{DoxyParamCaption}
)}\label{classmlpack_1_1tree_1_1BinarySpaceTree_ad0733134f50183f605e3df0eb784ceec}


Construct this as the root node of a binary space tree using the given dataset. 

This will take ownership of the data matrix; if you don\textquotesingle{}t want this, consider using the constructor that takes a const reference to a dataset.


\begin{DoxyParams}{Parameters}
{\em data} & Dataset to create tree from. \\
\hline
{\em max\+Leaf\+Size} & Size of each leaf in the tree. \\
\hline
\end{DoxyParams}
\index{mlpack\+::tree\+::\+Binary\+Space\+Tree@{mlpack\+::tree\+::\+Binary\+Space\+Tree}!Binary\+Space\+Tree@{Binary\+Space\+Tree}}
\index{Binary\+Space\+Tree@{Binary\+Space\+Tree}!mlpack\+::tree\+::\+Binary\+Space\+Tree@{mlpack\+::tree\+::\+Binary\+Space\+Tree}}
\subsubsection[{Binary\+Space\+Tree(\+Mat\+Type \&\&data, std\+::vector$<$ size\+\_\+t $>$ \&old\+From\+New, const size\+\_\+t max\+Leaf\+Size=20)}]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename Metric\+Type , typename Statistic\+Type  = Empty\+Statistic, typename Mat\+Type  = arma\+::mat, template$<$ typename Bound\+Metric\+Type, typename... $>$ class Bound\+Type = bound\+::\+H\+Rect\+Bound, template$<$ typename Split\+Bound\+Type, typename Split\+Mat\+Type $>$ class Split\+Type = Midpoint\+Split$>$ {\bf mlpack\+::tree\+::\+Binary\+Space\+Tree}$<$ Metric\+Type, Statistic\+Type, Mat\+Type, Bound\+Type, Split\+Type $>$\+::{\bf Binary\+Space\+Tree} (
\begin{DoxyParamCaption}
\item[{Mat\+Type \&\&}]{data, }
\item[{std\+::vector$<$ size\+\_\+t $>$ \&}]{old\+From\+New, }
\item[{const size\+\_\+t}]{max\+Leaf\+Size = {\ttfamily 20}}
\end{DoxyParamCaption}
)}\label{classmlpack_1_1tree_1_1BinarySpaceTree_ae620f2d1d16beafff047963954529f57}


Construct this as the root node of a binary space tree using the given dataset. 

This will take ownership of the data matrix; a mapping of the old point indices to the new point indices is filled. If you don\textquotesingle{}t want the matrix to have its ownership taken, consider using the constructor that takes a const reference to a dataset.


\begin{DoxyParams}{Parameters}
{\em data} & Dataset to create tree from. \\
\hline
{\em old\+From\+New} & Vector which will be filled with the old positions for each new point. \\
\hline
{\em max\+Leaf\+Size} & Size of each leaf in the tree. \\
\hline
\end{DoxyParams}
\index{mlpack\+::tree\+::\+Binary\+Space\+Tree@{mlpack\+::tree\+::\+Binary\+Space\+Tree}!Binary\+Space\+Tree@{Binary\+Space\+Tree}}
\index{Binary\+Space\+Tree@{Binary\+Space\+Tree}!mlpack\+::tree\+::\+Binary\+Space\+Tree@{mlpack\+::tree\+::\+Binary\+Space\+Tree}}
\subsubsection[{Binary\+Space\+Tree(\+Mat\+Type \&\&data, std\+::vector$<$ size\+\_\+t $>$ \&old\+From\+New, std\+::vector$<$ size\+\_\+t $>$ \&new\+From\+Old, const size\+\_\+t max\+Leaf\+Size=20)}]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename Metric\+Type , typename Statistic\+Type  = Empty\+Statistic, typename Mat\+Type  = arma\+::mat, template$<$ typename Bound\+Metric\+Type, typename... $>$ class Bound\+Type = bound\+::\+H\+Rect\+Bound, template$<$ typename Split\+Bound\+Type, typename Split\+Mat\+Type $>$ class Split\+Type = Midpoint\+Split$>$ {\bf mlpack\+::tree\+::\+Binary\+Space\+Tree}$<$ Metric\+Type, Statistic\+Type, Mat\+Type, Bound\+Type, Split\+Type $>$\+::{\bf Binary\+Space\+Tree} (
\begin{DoxyParamCaption}
\item[{Mat\+Type \&\&}]{data, }
\item[{std\+::vector$<$ size\+\_\+t $>$ \&}]{old\+From\+New, }
\item[{std\+::vector$<$ size\+\_\+t $>$ \&}]{new\+From\+Old, }
\item[{const size\+\_\+t}]{max\+Leaf\+Size = {\ttfamily 20}}
\end{DoxyParamCaption}
)}\label{classmlpack_1_1tree_1_1BinarySpaceTree_a1f2bbb50a854fdf9fae766f6deaeceb1}


Construct this as the root node of a binary space tree using the given dataset. 

This will take ownership of the data matrix; a mapping of the old point indices to the new point indices is filled, as well as a mapping of the new point indices to the old point indices. If you don\textquotesingle{}t want the matrix to have its ownership taken, consider using the constructor that takes a const reference to a dataset.


\begin{DoxyParams}{Parameters}
{\em data} & Dataset to create tree from. \\
\hline
{\em old\+From\+New} & Vector which will be filled with the old positions for each new point. \\
\hline
{\em new\+From\+Old} & Vector which will be filled with the new positions for each old point. \\
\hline
{\em max\+Leaf\+Size} & Size of each leaf in the tree. \\
\hline
\end{DoxyParams}
\index{mlpack\+::tree\+::\+Binary\+Space\+Tree@{mlpack\+::tree\+::\+Binary\+Space\+Tree}!Binary\+Space\+Tree@{Binary\+Space\+Tree}}
\index{Binary\+Space\+Tree@{Binary\+Space\+Tree}!mlpack\+::tree\+::\+Binary\+Space\+Tree@{mlpack\+::tree\+::\+Binary\+Space\+Tree}}
\subsubsection[{Binary\+Space\+Tree(\+Binary\+Space\+Tree $\ast$parent, const size\+\_\+t begin, const size\+\_\+t count, Split\+Type$<$ Bound\+Type$<$ Metric\+Type $>$, Mat\+Type $>$ \&splitter, const size\+\_\+t max\+Leaf\+Size=20)}]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename Metric\+Type , typename Statistic\+Type  = Empty\+Statistic, typename Mat\+Type  = arma\+::mat, template$<$ typename Bound\+Metric\+Type, typename... $>$ class Bound\+Type = bound\+::\+H\+Rect\+Bound, template$<$ typename Split\+Bound\+Type, typename Split\+Mat\+Type $>$ class Split\+Type = Midpoint\+Split$>$ {\bf mlpack\+::tree\+::\+Binary\+Space\+Tree}$<$ Metric\+Type, Statistic\+Type, Mat\+Type, Bound\+Type, Split\+Type $>$\+::{\bf Binary\+Space\+Tree} (
\begin{DoxyParamCaption}
\item[{{\bf Binary\+Space\+Tree}$<$ Metric\+Type, Statistic\+Type, Mat\+Type, Bound\+Type, Split\+Type $>$ $\ast$}]{parent, }
\item[{const size\+\_\+t}]{begin, }
\item[{const size\+\_\+t}]{count, }
\item[{Split\+Type$<$ Bound\+Type$<$ Metric\+Type $>$, Mat\+Type $>$ \&}]{splitter, }
\item[{const size\+\_\+t}]{max\+Leaf\+Size = {\ttfamily 20}}
\end{DoxyParamCaption}
)}\label{classmlpack_1_1tree_1_1BinarySpaceTree_a1edd4b2fe88a2b5a97e446593920fd14}


Construct this node as a child of the given parent, starting at column begin and using count points. 

The ordering of that subset of points in the parent\textquotesingle{}s data matrix will be modified! This is used for recursive tree-\/building by the other constructors which don\textquotesingle{}t specify point indices.


\begin{DoxyParams}{Parameters}
{\em parent} & Parent of this node. Its dataset will be modified! \\
\hline
{\em begin} & Index of point to start tree construction with. \\
\hline
{\em count} & Number of points to use to construct tree. \\
\hline
{\em splitter} & Instantiated node splitter object. \\
\hline
{\em max\+Leaf\+Size} & Size of each leaf in the tree. \\
\hline
\end{DoxyParams}
\index{mlpack\+::tree\+::\+Binary\+Space\+Tree@{mlpack\+::tree\+::\+Binary\+Space\+Tree}!Binary\+Space\+Tree@{Binary\+Space\+Tree}}
\index{Binary\+Space\+Tree@{Binary\+Space\+Tree}!mlpack\+::tree\+::\+Binary\+Space\+Tree@{mlpack\+::tree\+::\+Binary\+Space\+Tree}}
\subsubsection[{Binary\+Space\+Tree(\+Binary\+Space\+Tree $\ast$parent, const size\+\_\+t begin, const size\+\_\+t count, std\+::vector$<$ size\+\_\+t $>$ \&old\+From\+New, Split\+Type$<$ Bound\+Type$<$ Metric\+Type $>$, Mat\+Type $>$ \&splitter, const size\+\_\+t max\+Leaf\+Size=20)}]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename Metric\+Type , typename Statistic\+Type  = Empty\+Statistic, typename Mat\+Type  = arma\+::mat, template$<$ typename Bound\+Metric\+Type, typename... $>$ class Bound\+Type = bound\+::\+H\+Rect\+Bound, template$<$ typename Split\+Bound\+Type, typename Split\+Mat\+Type $>$ class Split\+Type = Midpoint\+Split$>$ {\bf mlpack\+::tree\+::\+Binary\+Space\+Tree}$<$ Metric\+Type, Statistic\+Type, Mat\+Type, Bound\+Type, Split\+Type $>$\+::{\bf Binary\+Space\+Tree} (
\begin{DoxyParamCaption}
\item[{{\bf Binary\+Space\+Tree}$<$ Metric\+Type, Statistic\+Type, Mat\+Type, Bound\+Type, Split\+Type $>$ $\ast$}]{parent, }
\item[{const size\+\_\+t}]{begin, }
\item[{const size\+\_\+t}]{count, }
\item[{std\+::vector$<$ size\+\_\+t $>$ \&}]{old\+From\+New, }
\item[{Split\+Type$<$ Bound\+Type$<$ Metric\+Type $>$, Mat\+Type $>$ \&}]{splitter, }
\item[{const size\+\_\+t}]{max\+Leaf\+Size = {\ttfamily 20}}
\end{DoxyParamCaption}
)}\label{classmlpack_1_1tree_1_1BinarySpaceTree_a400251078a497e334946b93067ba4174}


Construct this node as a child of the given parent, starting at column begin and using count points. 

The ordering of that subset of points in the parent\textquotesingle{}s data matrix will be modified! This is used for recursive tree-\/building by the other constructors which don\textquotesingle{}t specify point indices.

A mapping of the old point indices to the new point indices is filled, but it is expected that the vector is already allocated with size greater than or equal to (begin + count), and if that is not true, invalid memory reads (and writes) will occur.


\begin{DoxyParams}{Parameters}
{\em parent} & Parent of this node. Its dataset will be modified! \\
\hline
{\em begin} & Index of point to start tree construction with. \\
\hline
{\em count} & Number of points to use to construct tree. \\
\hline
{\em old\+From\+New} & Vector which will be filled with the old positions for each new point. \\
\hline
{\em splitter} & Instantiated node splitter object. \\
\hline
{\em max\+Leaf\+Size} & Size of each leaf in the tree. \\
\hline
\end{DoxyParams}
\index{mlpack\+::tree\+::\+Binary\+Space\+Tree@{mlpack\+::tree\+::\+Binary\+Space\+Tree}!Binary\+Space\+Tree@{Binary\+Space\+Tree}}
\index{Binary\+Space\+Tree@{Binary\+Space\+Tree}!mlpack\+::tree\+::\+Binary\+Space\+Tree@{mlpack\+::tree\+::\+Binary\+Space\+Tree}}
\subsubsection[{Binary\+Space\+Tree(\+Binary\+Space\+Tree $\ast$parent, const size\+\_\+t begin, const size\+\_\+t count, std\+::vector$<$ size\+\_\+t $>$ \&old\+From\+New, std\+::vector$<$ size\+\_\+t $>$ \&new\+From\+Old, Split\+Type$<$ Bound\+Type$<$ Metric\+Type $>$, Mat\+Type $>$ \&splitter, const size\+\_\+t max\+Leaf\+Size=20)}]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename Metric\+Type , typename Statistic\+Type  = Empty\+Statistic, typename Mat\+Type  = arma\+::mat, template$<$ typename Bound\+Metric\+Type, typename... $>$ class Bound\+Type = bound\+::\+H\+Rect\+Bound, template$<$ typename Split\+Bound\+Type, typename Split\+Mat\+Type $>$ class Split\+Type = Midpoint\+Split$>$ {\bf mlpack\+::tree\+::\+Binary\+Space\+Tree}$<$ Metric\+Type, Statistic\+Type, Mat\+Type, Bound\+Type, Split\+Type $>$\+::{\bf Binary\+Space\+Tree} (
\begin{DoxyParamCaption}
\item[{{\bf Binary\+Space\+Tree}$<$ Metric\+Type, Statistic\+Type, Mat\+Type, Bound\+Type, Split\+Type $>$ $\ast$}]{parent, }
\item[{const size\+\_\+t}]{begin, }
\item[{const size\+\_\+t}]{count, }
\item[{std\+::vector$<$ size\+\_\+t $>$ \&}]{old\+From\+New, }
\item[{std\+::vector$<$ size\+\_\+t $>$ \&}]{new\+From\+Old, }
\item[{Split\+Type$<$ Bound\+Type$<$ Metric\+Type $>$, Mat\+Type $>$ \&}]{splitter, }
\item[{const size\+\_\+t}]{max\+Leaf\+Size = {\ttfamily 20}}
\end{DoxyParamCaption}
)}\label{classmlpack_1_1tree_1_1BinarySpaceTree_ac95c0a50a1671ce97a5a7f34fad1eb2d}


Construct this node as a child of the given parent, starting at column begin and using count points. 

The ordering of that subset of points in the parent\textquotesingle{}s data matrix will be modified! This is used for recursive tree-\/building by the other constructors which don\textquotesingle{}t specify point indices.

A mapping of the old point indices to the new point indices is filled, as well as a mapping of the new point indices to the old point indices. It is expected that the vector is already allocated with size greater than or equal to (begin\+\_\+in + count\+\_\+in), and if that is not true, invalid memory reads (and writes) will occur.


\begin{DoxyParams}{Parameters}
{\em parent} & Parent of this node. Its dataset will be modified! \\
\hline
{\em begin} & Index of point to start tree construction with. \\
\hline
{\em count} & Number of points to use to construct tree. \\
\hline
{\em old\+From\+New} & Vector which will be filled with the old positions for each new point. \\
\hline
{\em new\+From\+Old} & Vector which will be filled with the new positions for each old point. \\
\hline
{\em max\+Leaf\+Size} & Size of each leaf in the tree. \\
\hline
\end{DoxyParams}
\index{mlpack\+::tree\+::\+Binary\+Space\+Tree@{mlpack\+::tree\+::\+Binary\+Space\+Tree}!Binary\+Space\+Tree@{Binary\+Space\+Tree}}
\index{Binary\+Space\+Tree@{Binary\+Space\+Tree}!mlpack\+::tree\+::\+Binary\+Space\+Tree@{mlpack\+::tree\+::\+Binary\+Space\+Tree}}
\subsubsection[{Binary\+Space\+Tree(const Binary\+Space\+Tree \&other)}]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename Metric\+Type , typename Statistic\+Type  = Empty\+Statistic, typename Mat\+Type  = arma\+::mat, template$<$ typename Bound\+Metric\+Type, typename... $>$ class Bound\+Type = bound\+::\+H\+Rect\+Bound, template$<$ typename Split\+Bound\+Type, typename Split\+Mat\+Type $>$ class Split\+Type = Midpoint\+Split$>$ {\bf mlpack\+::tree\+::\+Binary\+Space\+Tree}$<$ Metric\+Type, Statistic\+Type, Mat\+Type, Bound\+Type, Split\+Type $>$\+::{\bf Binary\+Space\+Tree} (
\begin{DoxyParamCaption}
\item[{const {\bf Binary\+Space\+Tree}$<$ Metric\+Type, Statistic\+Type, Mat\+Type, Bound\+Type, Split\+Type $>$ \&}]{other}
\end{DoxyParamCaption}
)}\label{classmlpack_1_1tree_1_1BinarySpaceTree_a409ca533ddcd1444cc0d28cdeaa4ad0f}


Create a binary space tree by copying the other tree. 

Be careful! This can take a long time and use a lot of memory.


\begin{DoxyParams}{Parameters}
{\em other} & Tree to be replicated. \\
\hline
\end{DoxyParams}
\index{mlpack\+::tree\+::\+Binary\+Space\+Tree@{mlpack\+::tree\+::\+Binary\+Space\+Tree}!Binary\+Space\+Tree@{Binary\+Space\+Tree}}
\index{Binary\+Space\+Tree@{Binary\+Space\+Tree}!mlpack\+::tree\+::\+Binary\+Space\+Tree@{mlpack\+::tree\+::\+Binary\+Space\+Tree}}
\subsubsection[{Binary\+Space\+Tree(\+Binary\+Space\+Tree \&\&other)}]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename Metric\+Type , typename Statistic\+Type  = Empty\+Statistic, typename Mat\+Type  = arma\+::mat, template$<$ typename Bound\+Metric\+Type, typename... $>$ class Bound\+Type = bound\+::\+H\+Rect\+Bound, template$<$ typename Split\+Bound\+Type, typename Split\+Mat\+Type $>$ class Split\+Type = Midpoint\+Split$>$ {\bf mlpack\+::tree\+::\+Binary\+Space\+Tree}$<$ Metric\+Type, Statistic\+Type, Mat\+Type, Bound\+Type, Split\+Type $>$\+::{\bf Binary\+Space\+Tree} (
\begin{DoxyParamCaption}
\item[{{\bf Binary\+Space\+Tree}$<$ Metric\+Type, Statistic\+Type, Mat\+Type, Bound\+Type, Split\+Type $>$ \&\&}]{other}
\end{DoxyParamCaption}
)}\label{classmlpack_1_1tree_1_1BinarySpaceTree_ab4854d2b181a38c7c066ef723c6ae6dd}


Move constructor for a \doxyref{Binary\+Space\+Tree}{p.}{classmlpack_1_1tree_1_1BinarySpaceTree}; possess all the members of the given tree. 

\index{mlpack\+::tree\+::\+Binary\+Space\+Tree@{mlpack\+::tree\+::\+Binary\+Space\+Tree}!Binary\+Space\+Tree@{Binary\+Space\+Tree}}
\index{Binary\+Space\+Tree@{Binary\+Space\+Tree}!mlpack\+::tree\+::\+Binary\+Space\+Tree@{mlpack\+::tree\+::\+Binary\+Space\+Tree}}
\subsubsection[{Binary\+Space\+Tree(\+Archive \&ar, const typename std\+::enable\+\_\+if\+\_\+t$<$ Archive\+::is\+\_\+loading\+::value $>$ $\ast$=0)}]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename Metric\+Type , typename Statistic\+Type  = Empty\+Statistic, typename Mat\+Type  = arma\+::mat, template$<$ typename Bound\+Metric\+Type, typename... $>$ class Bound\+Type = bound\+::\+H\+Rect\+Bound, template$<$ typename Split\+Bound\+Type, typename Split\+Mat\+Type $>$ class Split\+Type = Midpoint\+Split$>$ template$<$typename Archive $>$ {\bf mlpack\+::tree\+::\+Binary\+Space\+Tree}$<$ Metric\+Type, Statistic\+Type, Mat\+Type, Bound\+Type, Split\+Type $>$\+::{\bf Binary\+Space\+Tree} (
\begin{DoxyParamCaption}
\item[{Archive \&}]{ar, }
\item[{const typename {\bf std\+::enable\+\_\+if\+\_\+t}$<$ Archive\+::is\+\_\+loading\+::value $>$ $\ast$}]{ = {\ttfamily 0}}
\end{DoxyParamCaption}
)}\label{classmlpack_1_1tree_1_1BinarySpaceTree_a9b222cfd0020544e975be69ea911ee31}


Initialize the tree from a \doxyref{boost\+::serialization}{p.}{namespaceboost_1_1serialization} archive. 


\begin{DoxyParams}{Parameters}
{\em ar} & Archive to load tree from. Must be an iarchive, not an oarchive. \\
\hline
\end{DoxyParams}
\index{mlpack\+::tree\+::\+Binary\+Space\+Tree@{mlpack\+::tree\+::\+Binary\+Space\+Tree}!````~Binary\+Space\+Tree@{$\sim$\+Binary\+Space\+Tree}}
\index{````~Binary\+Space\+Tree@{$\sim$\+Binary\+Space\+Tree}!mlpack\+::tree\+::\+Binary\+Space\+Tree@{mlpack\+::tree\+::\+Binary\+Space\+Tree}}
\subsubsection[{$\sim$\+Binary\+Space\+Tree()}]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename Metric\+Type , typename Statistic\+Type  = Empty\+Statistic, typename Mat\+Type  = arma\+::mat, template$<$ typename Bound\+Metric\+Type, typename... $>$ class Bound\+Type = bound\+::\+H\+Rect\+Bound, template$<$ typename Split\+Bound\+Type, typename Split\+Mat\+Type $>$ class Split\+Type = Midpoint\+Split$>$ {\bf mlpack\+::tree\+::\+Binary\+Space\+Tree}$<$ Metric\+Type, Statistic\+Type, Mat\+Type, Bound\+Type, Split\+Type $>$\+::$\sim${\bf Binary\+Space\+Tree} (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)}\label{classmlpack_1_1tree_1_1BinarySpaceTree_a4ba93c930e6d12886eb42ff0a58e3058}


Deletes this node, deallocating the memory for the children and calling their destructors in turn. 

This will invalidate any pointers or references to any nodes which are children of this one. \index{mlpack\+::tree\+::\+Binary\+Space\+Tree@{mlpack\+::tree\+::\+Binary\+Space\+Tree}!Binary\+Space\+Tree@{Binary\+Space\+Tree}}
\index{Binary\+Space\+Tree@{Binary\+Space\+Tree}!mlpack\+::tree\+::\+Binary\+Space\+Tree@{mlpack\+::tree\+::\+Binary\+Space\+Tree}}
\subsubsection[{Binary\+Space\+Tree()}]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename Metric\+Type , typename Statistic\+Type  = Empty\+Statistic, typename Mat\+Type  = arma\+::mat, template$<$ typename Bound\+Metric\+Type, typename... $>$ class Bound\+Type = bound\+::\+H\+Rect\+Bound, template$<$ typename Split\+Bound\+Type, typename Split\+Mat\+Type $>$ class Split\+Type = Midpoint\+Split$>$ {\bf mlpack\+::tree\+::\+Binary\+Space\+Tree}$<$ Metric\+Type, Statistic\+Type, Mat\+Type, Bound\+Type, Split\+Type $>$\+::{\bf Binary\+Space\+Tree} (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [protected]}}\label{classmlpack_1_1tree_1_1BinarySpaceTree_afa70e3ce35ee7e4ee3e3e57d3a1b91ee}


A default constructor. 

This is meant to only be used with \doxyref{boost\+::serialization}{p.}{namespaceboost_1_1serialization}, which is allowed with the friend declaration below. This does not return a valid tree! The method must be protected, so that the serialization shim can work with the default constructor. 

Referenced by mlpack\+::tree\+::\+Binary\+Space\+Tree$<$ Metric\+Type, Statistic\+Type, Mat\+Type, Bound\+Type, Split\+Type $>$\+::\+Center().



\subsection{Member Function Documentation}
\index{mlpack\+::tree\+::\+Binary\+Space\+Tree@{mlpack\+::tree\+::\+Binary\+Space\+Tree}!Begin@{Begin}}
\index{Begin@{Begin}!mlpack\+::tree\+::\+Binary\+Space\+Tree@{mlpack\+::tree\+::\+Binary\+Space\+Tree}}
\subsubsection[{Begin() const }]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename Metric\+Type , typename Statistic\+Type  = Empty\+Statistic, typename Mat\+Type  = arma\+::mat, template$<$ typename Bound\+Metric\+Type, typename... $>$ class Bound\+Type = bound\+::\+H\+Rect\+Bound, template$<$ typename Split\+Bound\+Type, typename Split\+Mat\+Type $>$ class Split\+Type = Midpoint\+Split$>$ size\+\_\+t {\bf mlpack\+::tree\+::\+Binary\+Space\+Tree}$<$ Metric\+Type, Statistic\+Type, Mat\+Type, Bound\+Type, Split\+Type $>$\+::Begin (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
) const\hspace{0.3cm}{\ttfamily [inline]}}\label{classmlpack_1_1tree_1_1BinarySpaceTree_aedc996f347717b17eed76027db2d1743}


Return the index of the beginning point of this subset. 



Definition at line 483 of file binary\+\_\+space\+\_\+tree.\+hpp.



References mlpack\+::tree\+::\+Binary\+Space\+Tree$<$ Metric\+Type, Statistic\+Type, Mat\+Type, Bound\+Type, Split\+Type $>$\+::begin.

\index{mlpack\+::tree\+::\+Binary\+Space\+Tree@{mlpack\+::tree\+::\+Binary\+Space\+Tree}!Begin@{Begin}}
\index{Begin@{Begin}!mlpack\+::tree\+::\+Binary\+Space\+Tree@{mlpack\+::tree\+::\+Binary\+Space\+Tree}}
\subsubsection[{Begin()}]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename Metric\+Type , typename Statistic\+Type  = Empty\+Statistic, typename Mat\+Type  = arma\+::mat, template$<$ typename Bound\+Metric\+Type, typename... $>$ class Bound\+Type = bound\+::\+H\+Rect\+Bound, template$<$ typename Split\+Bound\+Type, typename Split\+Mat\+Type $>$ class Split\+Type = Midpoint\+Split$>$ size\+\_\+t\& {\bf mlpack\+::tree\+::\+Binary\+Space\+Tree}$<$ Metric\+Type, Statistic\+Type, Mat\+Type, Bound\+Type, Split\+Type $>$\+::Begin (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}}\label{classmlpack_1_1tree_1_1BinarySpaceTree_a2065dc4e92c96a508ca63a8ead4d838b}


Modify the index of the beginning point of this subset. 



Definition at line 485 of file binary\+\_\+space\+\_\+tree.\+hpp.



References mlpack\+::tree\+::\+Binary\+Space\+Tree$<$ Metric\+Type, Statistic\+Type, Mat\+Type, Bound\+Type, Split\+Type $>$\+::begin.

\index{mlpack\+::tree\+::\+Binary\+Space\+Tree@{mlpack\+::tree\+::\+Binary\+Space\+Tree}!Bound@{Bound}}
\index{Bound@{Bound}!mlpack\+::tree\+::\+Binary\+Space\+Tree@{mlpack\+::tree\+::\+Binary\+Space\+Tree}}
\subsubsection[{Bound() const }]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename Metric\+Type , typename Statistic\+Type  = Empty\+Statistic, typename Mat\+Type  = arma\+::mat, template$<$ typename Bound\+Metric\+Type, typename... $>$ class Bound\+Type = bound\+::\+H\+Rect\+Bound, template$<$ typename Split\+Bound\+Type, typename Split\+Mat\+Type $>$ class Split\+Type = Midpoint\+Split$>$ const Bound\+Type$<$Metric\+Type$>$\& {\bf mlpack\+::tree\+::\+Binary\+Space\+Tree}$<$ Metric\+Type, Statistic\+Type, Mat\+Type, Bound\+Type, Split\+Type $>$\+::Bound (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
) const\hspace{0.3cm}{\ttfamily [inline]}}\label{classmlpack_1_1tree_1_1BinarySpaceTree_ac138147e1721edb592e95a09d06d29bf}


Return the bound object for this node. 



Definition at line 304 of file binary\+\_\+space\+\_\+tree.\+hpp.



References mlpack\+::tree\+::\+Binary\+Space\+Tree$<$ Metric\+Type, Statistic\+Type, Mat\+Type, Bound\+Type, Split\+Type $>$\+::bound.



Referenced by mlpack\+::tree\+::\+Binary\+Space\+Tree$<$ Metric\+Type, Statistic\+Type, Mat\+Type, Bound\+Type, Split\+Type $>$\+::\+Max\+Distance(), mlpack\+::tree\+::\+Binary\+Space\+Tree$<$ Metric\+Type, Statistic\+Type, Mat\+Type, Bound\+Type, Split\+Type $>$\+::\+Min\+Distance(), and mlpack\+::tree\+::\+Binary\+Space\+Tree$<$ Metric\+Type, Statistic\+Type, Mat\+Type, Bound\+Type, Split\+Type $>$\+::\+Range\+Distance().

\index{mlpack\+::tree\+::\+Binary\+Space\+Tree@{mlpack\+::tree\+::\+Binary\+Space\+Tree}!Bound@{Bound}}
\index{Bound@{Bound}!mlpack\+::tree\+::\+Binary\+Space\+Tree@{mlpack\+::tree\+::\+Binary\+Space\+Tree}}
\subsubsection[{Bound()}]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename Metric\+Type , typename Statistic\+Type  = Empty\+Statistic, typename Mat\+Type  = arma\+::mat, template$<$ typename Bound\+Metric\+Type, typename... $>$ class Bound\+Type = bound\+::\+H\+Rect\+Bound, template$<$ typename Split\+Bound\+Type, typename Split\+Mat\+Type $>$ class Split\+Type = Midpoint\+Split$>$ Bound\+Type$<$Metric\+Type$>$\& {\bf mlpack\+::tree\+::\+Binary\+Space\+Tree}$<$ Metric\+Type, Statistic\+Type, Mat\+Type, Bound\+Type, Split\+Type $>$\+::Bound (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}}\label{classmlpack_1_1tree_1_1BinarySpaceTree_a9531508c09dde92158ea1327db1becc0}


Return the bound object for this node. 



Definition at line 306 of file binary\+\_\+space\+\_\+tree.\+hpp.



References mlpack\+::tree\+::\+Binary\+Space\+Tree$<$ Metric\+Type, Statistic\+Type, Mat\+Type, Bound\+Type, Split\+Type $>$\+::bound.

\index{mlpack\+::tree\+::\+Binary\+Space\+Tree@{mlpack\+::tree\+::\+Binary\+Space\+Tree}!Center@{Center}}
\index{Center@{Center}!mlpack\+::tree\+::\+Binary\+Space\+Tree@{mlpack\+::tree\+::\+Binary\+Space\+Tree}}
\subsubsection[{Center(arma\+::vec \&center) const }]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename Metric\+Type , typename Statistic\+Type  = Empty\+Statistic, typename Mat\+Type  = arma\+::mat, template$<$ typename Bound\+Metric\+Type, typename... $>$ class Bound\+Type = bound\+::\+H\+Rect\+Bound, template$<$ typename Split\+Bound\+Type, typename Split\+Mat\+Type $>$ class Split\+Type = Midpoint\+Split$>$ void {\bf mlpack\+::tree\+::\+Binary\+Space\+Tree}$<$ Metric\+Type, Statistic\+Type, Mat\+Type, Bound\+Type, Split\+Type $>$\+::Center (
\begin{DoxyParamCaption}
\item[{arma\+::vec \&}]{center}
\end{DoxyParamCaption}
) const\hspace{0.3cm}{\ttfamily [inline]}}\label{classmlpack_1_1tree_1_1BinarySpaceTree_a31b8200b28927b8c10cef76a7801c532}


Store the center of the bounding region in the given vector. 



Definition at line 493 of file binary\+\_\+space\+\_\+tree.\+hpp.



References mlpack\+::tree\+::\+Binary\+Space\+Tree$<$ Metric\+Type, Statistic\+Type, Mat\+Type, Bound\+Type, Split\+Type $>$\+::\+Binary\+Space\+Tree(), mlpack\+::tree\+::\+Binary\+Space\+Tree$<$ Metric\+Type, Statistic\+Type, Mat\+Type, Bound\+Type, Split\+Type $>$\+::\+Split\+Node(), and mlpack\+::tree\+::\+Binary\+Space\+Tree$<$ Metric\+Type, Statistic\+Type, Mat\+Type, Bound\+Type, Split\+Type $>$\+::\+Update\+Bound().

\index{mlpack\+::tree\+::\+Binary\+Space\+Tree@{mlpack\+::tree\+::\+Binary\+Space\+Tree}!Child@{Child}}
\index{Child@{Child}!mlpack\+::tree\+::\+Binary\+Space\+Tree@{mlpack\+::tree\+::\+Binary\+Space\+Tree}}
\subsubsection[{Child(const size\+\_\+t child) const }]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename Metric\+Type , typename Statistic\+Type  = Empty\+Statistic, typename Mat\+Type  = arma\+::mat, template$<$ typename Bound\+Metric\+Type, typename... $>$ class Bound\+Type = bound\+::\+H\+Rect\+Bound, template$<$ typename Split\+Bound\+Type, typename Split\+Mat\+Type $>$ class Split\+Type = Midpoint\+Split$>$ {\bf Binary\+Space\+Tree}\& {\bf mlpack\+::tree\+::\+Binary\+Space\+Tree}$<$ Metric\+Type, Statistic\+Type, Mat\+Type, Bound\+Type, Split\+Type $>$\+::Child (
\begin{DoxyParamCaption}
\item[{const size\+\_\+t}]{child}
\end{DoxyParamCaption}
) const}\label{classmlpack_1_1tree_1_1BinarySpaceTree_a88194ac086f2bb0f9a2a209d2a2a487f}


Return the specified child (0 will be left, 1 will be right). 

If the index is greater than 1, this will return the right child.


\begin{DoxyParams}{Parameters}
{\em child} & Index of child to return. \\
\hline
\end{DoxyParams}


Referenced by mlpack\+::tree\+::\+Binary\+Space\+Tree$<$ Metric\+Type, Statistic\+Type, Mat\+Type, Bound\+Type, Split\+Type $>$\+::\+Parent\+Distance().

\index{mlpack\+::tree\+::\+Binary\+Space\+Tree@{mlpack\+::tree\+::\+Binary\+Space\+Tree}!Child\+Ptr@{Child\+Ptr}}
\index{Child\+Ptr@{Child\+Ptr}!mlpack\+::tree\+::\+Binary\+Space\+Tree@{mlpack\+::tree\+::\+Binary\+Space\+Tree}}
\subsubsection[{Child\+Ptr(const size\+\_\+t child)}]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename Metric\+Type , typename Statistic\+Type  = Empty\+Statistic, typename Mat\+Type  = arma\+::mat, template$<$ typename Bound\+Metric\+Type, typename... $>$ class Bound\+Type = bound\+::\+H\+Rect\+Bound, template$<$ typename Split\+Bound\+Type, typename Split\+Mat\+Type $>$ class Split\+Type = Midpoint\+Split$>$ {\bf Binary\+Space\+Tree}$\ast$\& {\bf mlpack\+::tree\+::\+Binary\+Space\+Tree}$<$ Metric\+Type, Statistic\+Type, Mat\+Type, Bound\+Type, Split\+Type $>$\+::Child\+Ptr (
\begin{DoxyParamCaption}
\item[{const size\+\_\+t}]{child}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}}\label{classmlpack_1_1tree_1_1BinarySpaceTree_acbeb10c16b3249d0e1499ce8d5da5ac5}


Definition at line 405 of file binary\+\_\+space\+\_\+tree.\+hpp.



References mlpack\+::tree\+::\+Binary\+Space\+Tree$<$ Metric\+Type, Statistic\+Type, Mat\+Type, Bound\+Type, Split\+Type $>$\+::\+Descendant(), mlpack\+::tree\+::\+Binary\+Space\+Tree$<$ Metric\+Type, Statistic\+Type, Mat\+Type, Bound\+Type, Split\+Type $>$\+::\+Num\+Descendants(), mlpack\+::tree\+::\+Binary\+Space\+Tree$<$ Metric\+Type, Statistic\+Type, Mat\+Type, Bound\+Type, Split\+Type $>$\+::\+Num\+Points(), mlpack\+::tree\+::\+Binary\+Space\+Tree$<$ Metric\+Type, Statistic\+Type, Mat\+Type, Bound\+Type, Split\+Type $>$\+::\+Point(), and mlpack\+::tree\+::\+Binary\+Space\+Tree$<$ Metric\+Type, Statistic\+Type, Mat\+Type, Bound\+Type, Split\+Type $>$\+::right.

\index{mlpack\+::tree\+::\+Binary\+Space\+Tree@{mlpack\+::tree\+::\+Binary\+Space\+Tree}!Count@{Count}}
\index{Count@{Count}!mlpack\+::tree\+::\+Binary\+Space\+Tree@{mlpack\+::tree\+::\+Binary\+Space\+Tree}}
\subsubsection[{Count() const }]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename Metric\+Type , typename Statistic\+Type  = Empty\+Statistic, typename Mat\+Type  = arma\+::mat, template$<$ typename Bound\+Metric\+Type, typename... $>$ class Bound\+Type = bound\+::\+H\+Rect\+Bound, template$<$ typename Split\+Bound\+Type, typename Split\+Mat\+Type $>$ class Split\+Type = Midpoint\+Split$>$ size\+\_\+t {\bf mlpack\+::tree\+::\+Binary\+Space\+Tree}$<$ Metric\+Type, Statistic\+Type, Mat\+Type, Bound\+Type, Split\+Type $>$\+::Count (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
) const\hspace{0.3cm}{\ttfamily [inline]}}\label{classmlpack_1_1tree_1_1BinarySpaceTree_a9120977ee6db59619e52c1e6ca91a703}


Return the number of points in this subset. 



Definition at line 488 of file binary\+\_\+space\+\_\+tree.\+hpp.



References mlpack\+::tree\+::\+Binary\+Space\+Tree$<$ Metric\+Type, Statistic\+Type, Mat\+Type, Bound\+Type, Split\+Type $>$\+::count.

\index{mlpack\+::tree\+::\+Binary\+Space\+Tree@{mlpack\+::tree\+::\+Binary\+Space\+Tree}!Count@{Count}}
\index{Count@{Count}!mlpack\+::tree\+::\+Binary\+Space\+Tree@{mlpack\+::tree\+::\+Binary\+Space\+Tree}}
\subsubsection[{Count()}]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename Metric\+Type , typename Statistic\+Type  = Empty\+Statistic, typename Mat\+Type  = arma\+::mat, template$<$ typename Bound\+Metric\+Type, typename... $>$ class Bound\+Type = bound\+::\+H\+Rect\+Bound, template$<$ typename Split\+Bound\+Type, typename Split\+Mat\+Type $>$ class Split\+Type = Midpoint\+Split$>$ size\+\_\+t\& {\bf mlpack\+::tree\+::\+Binary\+Space\+Tree}$<$ Metric\+Type, Statistic\+Type, Mat\+Type, Bound\+Type, Split\+Type $>$\+::Count (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}}\label{classmlpack_1_1tree_1_1BinarySpaceTree_a29f2990b2407a32e328d787890fcc1eb}


Modify the number of points in this subset. 



Definition at line 490 of file binary\+\_\+space\+\_\+tree.\+hpp.



References mlpack\+::tree\+::\+Binary\+Space\+Tree$<$ Metric\+Type, Statistic\+Type, Mat\+Type, Bound\+Type, Split\+Type $>$\+::count.

\index{mlpack\+::tree\+::\+Binary\+Space\+Tree@{mlpack\+::tree\+::\+Binary\+Space\+Tree}!Dataset@{Dataset}}
\index{Dataset@{Dataset}!mlpack\+::tree\+::\+Binary\+Space\+Tree@{mlpack\+::tree\+::\+Binary\+Space\+Tree}}
\subsubsection[{Dataset() const }]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename Metric\+Type , typename Statistic\+Type  = Empty\+Statistic, typename Mat\+Type  = arma\+::mat, template$<$ typename Bound\+Metric\+Type, typename... $>$ class Bound\+Type = bound\+::\+H\+Rect\+Bound, template$<$ typename Split\+Bound\+Type, typename Split\+Mat\+Type $>$ class Split\+Type = Midpoint\+Split$>$ const Mat\+Type\& {\bf mlpack\+::tree\+::\+Binary\+Space\+Tree}$<$ Metric\+Type, Statistic\+Type, Mat\+Type, Bound\+Type, Split\+Type $>$\+::Dataset (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
) const\hspace{0.3cm}{\ttfamily [inline]}}\label{classmlpack_1_1tree_1_1BinarySpaceTree_a01a889397090893722c3e5a6fce99ad3}


Get the dataset which the tree is built on. 



Definition at line 332 of file binary\+\_\+space\+\_\+tree.\+hpp.



References mlpack\+::tree\+::\+Binary\+Space\+Tree$<$ Metric\+Type, Statistic\+Type, Mat\+Type, Bound\+Type, Split\+Type $>$\+::dataset.

\index{mlpack\+::tree\+::\+Binary\+Space\+Tree@{mlpack\+::tree\+::\+Binary\+Space\+Tree}!Dataset@{Dataset}}
\index{Dataset@{Dataset}!mlpack\+::tree\+::\+Binary\+Space\+Tree@{mlpack\+::tree\+::\+Binary\+Space\+Tree}}
\subsubsection[{Dataset()}]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename Metric\+Type , typename Statistic\+Type  = Empty\+Statistic, typename Mat\+Type  = arma\+::mat, template$<$ typename Bound\+Metric\+Type, typename... $>$ class Bound\+Type = bound\+::\+H\+Rect\+Bound, template$<$ typename Split\+Bound\+Type, typename Split\+Mat\+Type $>$ class Split\+Type = Midpoint\+Split$>$ Mat\+Type\& {\bf mlpack\+::tree\+::\+Binary\+Space\+Tree}$<$ Metric\+Type, Statistic\+Type, Mat\+Type, Bound\+Type, Split\+Type $>$\+::Dataset (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}}\label{classmlpack_1_1tree_1_1BinarySpaceTree_add85b6bb420a7a52cf6726d7ac333f4c}


Modify the dataset which the tree is built on. Be careful! 



Definition at line 334 of file binary\+\_\+space\+\_\+tree.\+hpp.



References mlpack\+::tree\+::\+Binary\+Space\+Tree$<$ Metric\+Type, Statistic\+Type, Mat\+Type, Bound\+Type, Split\+Type $>$\+::dataset.

\index{mlpack\+::tree\+::\+Binary\+Space\+Tree@{mlpack\+::tree\+::\+Binary\+Space\+Tree}!Descendant@{Descendant}}
\index{Descendant@{Descendant}!mlpack\+::tree\+::\+Binary\+Space\+Tree@{mlpack\+::tree\+::\+Binary\+Space\+Tree}}
\subsubsection[{Descendant(const size\+\_\+t index) const }]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename Metric\+Type , typename Statistic\+Type  = Empty\+Statistic, typename Mat\+Type  = arma\+::mat, template$<$ typename Bound\+Metric\+Type, typename... $>$ class Bound\+Type = bound\+::\+H\+Rect\+Bound, template$<$ typename Split\+Bound\+Type, typename Split\+Mat\+Type $>$ class Split\+Type = Midpoint\+Split$>$ size\+\_\+t {\bf mlpack\+::tree\+::\+Binary\+Space\+Tree}$<$ Metric\+Type, Statistic\+Type, Mat\+Type, Bound\+Type, Split\+Type $>$\+::Descendant (
\begin{DoxyParamCaption}
\item[{const size\+\_\+t}]{index}
\end{DoxyParamCaption}
) const}\label{classmlpack_1_1tree_1_1BinarySpaceTree_a26519b1b418c451c6ce9c0a73e1ed9a4}


Return the index (with reference to the dataset) of a particular descendant of this node. 

The index should be greater than zero but less than the number of descendants.


\begin{DoxyParams}{Parameters}
{\em index} & Index of the descendant. \\
\hline
\end{DoxyParams}


Referenced by mlpack\+::tree\+::\+Binary\+Space\+Tree$<$ Metric\+Type, Statistic\+Type, Mat\+Type, Bound\+Type, Split\+Type $>$\+::\+Child\+Ptr().

\index{mlpack\+::tree\+::\+Binary\+Space\+Tree@{mlpack\+::tree\+::\+Binary\+Space\+Tree}!Furthest\+Descendant\+Distance@{Furthest\+Descendant\+Distance}}
\index{Furthest\+Descendant\+Distance@{Furthest\+Descendant\+Distance}!mlpack\+::tree\+::\+Binary\+Space\+Tree@{mlpack\+::tree\+::\+Binary\+Space\+Tree}}
\subsubsection[{Furthest\+Descendant\+Distance() const }]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename Metric\+Type , typename Statistic\+Type  = Empty\+Statistic, typename Mat\+Type  = arma\+::mat, template$<$ typename Bound\+Metric\+Type, typename... $>$ class Bound\+Type = bound\+::\+H\+Rect\+Bound, template$<$ typename Split\+Bound\+Type, typename Split\+Mat\+Type $>$ class Split\+Type = Midpoint\+Split$>$ {\bf Elem\+Type} {\bf mlpack\+::tree\+::\+Binary\+Space\+Tree}$<$ Metric\+Type, Statistic\+Type, Mat\+Type, Bound\+Type, Split\+Type $>$\+::Furthest\+Descendant\+Distance (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
) const}\label{classmlpack_1_1tree_1_1BinarySpaceTree_a610bf44c4a589238ccb3157076f01403}


Return the furthest possible descendant distance. 

This returns the maximum distance from the centroid to the edge of the bound and not the empirical quantity which is the actual furthest descendant distance. So the actual furthest descendant distance may be less than what this method returns (but it will never be greater than this). 

Referenced by mlpack\+::tree\+::\+Binary\+Space\+Tree$<$ Metric\+Type, Statistic\+Type, Mat\+Type, Bound\+Type, Split\+Type $>$\+::\+Metric().

\index{mlpack\+::tree\+::\+Binary\+Space\+Tree@{mlpack\+::tree\+::\+Binary\+Space\+Tree}!Furthest\+Point\+Distance@{Furthest\+Point\+Distance}}
\index{Furthest\+Point\+Distance@{Furthest\+Point\+Distance}!mlpack\+::tree\+::\+Binary\+Space\+Tree@{mlpack\+::tree\+::\+Binary\+Space\+Tree}}
\subsubsection[{Furthest\+Point\+Distance() const }]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename Metric\+Type , typename Statistic\+Type  = Empty\+Statistic, typename Mat\+Type  = arma\+::mat, template$<$ typename Bound\+Metric\+Type, typename... $>$ class Bound\+Type = bound\+::\+H\+Rect\+Bound, template$<$ typename Split\+Bound\+Type, typename Split\+Mat\+Type $>$ class Split\+Type = Midpoint\+Split$>$ {\bf Elem\+Type} {\bf mlpack\+::tree\+::\+Binary\+Space\+Tree}$<$ Metric\+Type, Statistic\+Type, Mat\+Type, Bound\+Type, Split\+Type $>$\+::Furthest\+Point\+Distance (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
) const}\label{classmlpack_1_1tree_1_1BinarySpaceTree_aa42c0fa0301656c00edec02e1c5a30fb}


Return the furthest distance to a point held in this node. 

If this is not a leaf node, then the distance is 0 because the node holds no points. 

Referenced by mlpack\+::tree\+::\+Binary\+Space\+Tree$<$ Metric\+Type, Statistic\+Type, Mat\+Type, Bound\+Type, Split\+Type $>$\+::\+Metric().

\index{mlpack\+::tree\+::\+Binary\+Space\+Tree@{mlpack\+::tree\+::\+Binary\+Space\+Tree}!Get\+Furthest\+Child@{Get\+Furthest\+Child}}
\index{Get\+Furthest\+Child@{Get\+Furthest\+Child}!mlpack\+::tree\+::\+Binary\+Space\+Tree@{mlpack\+::tree\+::\+Binary\+Space\+Tree}}
\subsubsection[{Get\+Furthest\+Child(const Vec\+Type \&point, typename std\+::enable\+\_\+if\+\_\+t$<$ Is\+Vector$<$ Vec\+Type $>$\+::value $>$ $\ast$=0)}]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename Metric\+Type , typename Statistic\+Type  = Empty\+Statistic, typename Mat\+Type  = arma\+::mat, template$<$ typename Bound\+Metric\+Type, typename... $>$ class Bound\+Type = bound\+::\+H\+Rect\+Bound, template$<$ typename Split\+Bound\+Type, typename Split\+Mat\+Type $>$ class Split\+Type = Midpoint\+Split$>$ template$<$typename Vec\+Type $>$ size\+\_\+t {\bf mlpack\+::tree\+::\+Binary\+Space\+Tree}$<$ Metric\+Type, Statistic\+Type, Mat\+Type, Bound\+Type, Split\+Type $>$\+::Get\+Furthest\+Child (
\begin{DoxyParamCaption}
\item[{const Vec\+Type \&}]{point, }
\item[{typename {\bf std\+::enable\+\_\+if\+\_\+t}$<$ {\bf Is\+Vector}$<$ Vec\+Type $>$\+::value $>$ $\ast$}]{ = {\ttfamily 0}}
\end{DoxyParamCaption}
)}\label{classmlpack_1_1tree_1_1BinarySpaceTree_a5d19406a1d846dbb17b602e4bc484c18}


Return the index of the furthest child node to the given query point. 

If this is a leaf node, it will return \doxyref{Num\+Children()}{p.}{classmlpack_1_1tree_1_1BinarySpaceTree_a5adbf8b4fe5a91ccd17a641d378d7ea6} (invalid index). 

Referenced by mlpack\+::tree\+::\+Binary\+Space\+Tree$<$ Metric\+Type, Statistic\+Type, Mat\+Type, Bound\+Type, Split\+Type $>$\+::\+Metric().

\index{mlpack\+::tree\+::\+Binary\+Space\+Tree@{mlpack\+::tree\+::\+Binary\+Space\+Tree}!Get\+Furthest\+Child@{Get\+Furthest\+Child}}
\index{Get\+Furthest\+Child@{Get\+Furthest\+Child}!mlpack\+::tree\+::\+Binary\+Space\+Tree@{mlpack\+::tree\+::\+Binary\+Space\+Tree}}
\subsubsection[{Get\+Furthest\+Child(const Binary\+Space\+Tree \&query\+Node)}]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename Metric\+Type , typename Statistic\+Type  = Empty\+Statistic, typename Mat\+Type  = arma\+::mat, template$<$ typename Bound\+Metric\+Type, typename... $>$ class Bound\+Type = bound\+::\+H\+Rect\+Bound, template$<$ typename Split\+Bound\+Type, typename Split\+Mat\+Type $>$ class Split\+Type = Midpoint\+Split$>$ size\+\_\+t {\bf mlpack\+::tree\+::\+Binary\+Space\+Tree}$<$ Metric\+Type, Statistic\+Type, Mat\+Type, Bound\+Type, Split\+Type $>$\+::Get\+Furthest\+Child (
\begin{DoxyParamCaption}
\item[{const {\bf Binary\+Space\+Tree}$<$ Metric\+Type, Statistic\+Type, Mat\+Type, Bound\+Type, Split\+Type $>$ \&}]{query\+Node}
\end{DoxyParamCaption}
)}\label{classmlpack_1_1tree_1_1BinarySpaceTree_a34e6a4b1e0437a3cc98e7160051c4f2b}


Return the index of the furthest child node to the given query node. 

If it can\textquotesingle{}t decide, it will return \doxyref{Num\+Children()}{p.}{classmlpack_1_1tree_1_1BinarySpaceTree_a5adbf8b4fe5a91ccd17a641d378d7ea6} (invalid index). \index{mlpack\+::tree\+::\+Binary\+Space\+Tree@{mlpack\+::tree\+::\+Binary\+Space\+Tree}!Get\+Nearest\+Child@{Get\+Nearest\+Child}}
\index{Get\+Nearest\+Child@{Get\+Nearest\+Child}!mlpack\+::tree\+::\+Binary\+Space\+Tree@{mlpack\+::tree\+::\+Binary\+Space\+Tree}}
\subsubsection[{Get\+Nearest\+Child(const Vec\+Type \&point, typename std\+::enable\+\_\+if\+\_\+t$<$ Is\+Vector$<$ Vec\+Type $>$\+::value $>$ $\ast$=0)}]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename Metric\+Type , typename Statistic\+Type  = Empty\+Statistic, typename Mat\+Type  = arma\+::mat, template$<$ typename Bound\+Metric\+Type, typename... $>$ class Bound\+Type = bound\+::\+H\+Rect\+Bound, template$<$ typename Split\+Bound\+Type, typename Split\+Mat\+Type $>$ class Split\+Type = Midpoint\+Split$>$ template$<$typename Vec\+Type $>$ size\+\_\+t {\bf mlpack\+::tree\+::\+Binary\+Space\+Tree}$<$ Metric\+Type, Statistic\+Type, Mat\+Type, Bound\+Type, Split\+Type $>$\+::Get\+Nearest\+Child (
\begin{DoxyParamCaption}
\item[{const Vec\+Type \&}]{point, }
\item[{typename {\bf std\+::enable\+\_\+if\+\_\+t}$<$ {\bf Is\+Vector}$<$ Vec\+Type $>$\+::value $>$ $\ast$}]{ = {\ttfamily 0}}
\end{DoxyParamCaption}
)}\label{classmlpack_1_1tree_1_1BinarySpaceTree_a86588b2410e73642bec20531d73a1e04}


Return the index of the nearest child node to the given query point. 

If this is a leaf node, it will return \doxyref{Num\+Children()}{p.}{classmlpack_1_1tree_1_1BinarySpaceTree_a5adbf8b4fe5a91ccd17a641d378d7ea6} (invalid index). 

Referenced by mlpack\+::tree\+::\+Binary\+Space\+Tree$<$ Metric\+Type, Statistic\+Type, Mat\+Type, Bound\+Type, Split\+Type $>$\+::\+Metric().

\index{mlpack\+::tree\+::\+Binary\+Space\+Tree@{mlpack\+::tree\+::\+Binary\+Space\+Tree}!Get\+Nearest\+Child@{Get\+Nearest\+Child}}
\index{Get\+Nearest\+Child@{Get\+Nearest\+Child}!mlpack\+::tree\+::\+Binary\+Space\+Tree@{mlpack\+::tree\+::\+Binary\+Space\+Tree}}
\subsubsection[{Get\+Nearest\+Child(const Binary\+Space\+Tree \&query\+Node)}]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename Metric\+Type , typename Statistic\+Type  = Empty\+Statistic, typename Mat\+Type  = arma\+::mat, template$<$ typename Bound\+Metric\+Type, typename... $>$ class Bound\+Type = bound\+::\+H\+Rect\+Bound, template$<$ typename Split\+Bound\+Type, typename Split\+Mat\+Type $>$ class Split\+Type = Midpoint\+Split$>$ size\+\_\+t {\bf mlpack\+::tree\+::\+Binary\+Space\+Tree}$<$ Metric\+Type, Statistic\+Type, Mat\+Type, Bound\+Type, Split\+Type $>$\+::Get\+Nearest\+Child (
\begin{DoxyParamCaption}
\item[{const {\bf Binary\+Space\+Tree}$<$ Metric\+Type, Statistic\+Type, Mat\+Type, Bound\+Type, Split\+Type $>$ \&}]{query\+Node}
\end{DoxyParamCaption}
)}\label{classmlpack_1_1tree_1_1BinarySpaceTree_a01bdad53130270216d4a4a1e29d325a2}


Return the index of the nearest child node to the given query node. 

If it can\textquotesingle{}t decide, it will return \doxyref{Num\+Children()}{p.}{classmlpack_1_1tree_1_1BinarySpaceTree_a5adbf8b4fe5a91ccd17a641d378d7ea6} (invalid index). \index{mlpack\+::tree\+::\+Binary\+Space\+Tree@{mlpack\+::tree\+::\+Binary\+Space\+Tree}!Is\+Leaf@{Is\+Leaf}}
\index{Is\+Leaf@{Is\+Leaf}!mlpack\+::tree\+::\+Binary\+Space\+Tree@{mlpack\+::tree\+::\+Binary\+Space\+Tree}}
\subsubsection[{Is\+Leaf() const }]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename Metric\+Type , typename Statistic\+Type  = Empty\+Statistic, typename Mat\+Type  = arma\+::mat, template$<$ typename Bound\+Metric\+Type, typename... $>$ class Bound\+Type = bound\+::\+H\+Rect\+Bound, template$<$ typename Split\+Bound\+Type, typename Split\+Mat\+Type $>$ class Split\+Type = Midpoint\+Split$>$ bool {\bf mlpack\+::tree\+::\+Binary\+Space\+Tree}$<$ Metric\+Type, Statistic\+Type, Mat\+Type, Bound\+Type, Split\+Type $>$\+::Is\+Leaf (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
) const}\label{classmlpack_1_1tree_1_1BinarySpaceTree_ad5cda936d6f2cc112d357fcd2acaa785}


Return whether or not this node is a leaf (true if it has no children). 



Referenced by mlpack\+::tree\+::\+Binary\+Space\+Tree$<$ Metric\+Type, Statistic\+Type, Mat\+Type, Bound\+Type, Split\+Type $>$\+::\+Stat().

\index{mlpack\+::tree\+::\+Binary\+Space\+Tree@{mlpack\+::tree\+::\+Binary\+Space\+Tree}!Left@{Left}}
\index{Left@{Left}!mlpack\+::tree\+::\+Binary\+Space\+Tree@{mlpack\+::tree\+::\+Binary\+Space\+Tree}}
\subsubsection[{Left() const }]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename Metric\+Type , typename Statistic\+Type  = Empty\+Statistic, typename Mat\+Type  = arma\+::mat, template$<$ typename Bound\+Metric\+Type, typename... $>$ class Bound\+Type = bound\+::\+H\+Rect\+Bound, template$<$ typename Split\+Bound\+Type, typename Split\+Mat\+Type $>$ class Split\+Type = Midpoint\+Split$>$ {\bf Binary\+Space\+Tree}$\ast$ {\bf mlpack\+::tree\+::\+Binary\+Space\+Tree}$<$ Metric\+Type, Statistic\+Type, Mat\+Type, Bound\+Type, Split\+Type $>$\+::Left (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
) const\hspace{0.3cm}{\ttfamily [inline]}}\label{classmlpack_1_1tree_1_1BinarySpaceTree_ab5e8942881d61e589ac3cba84ff79ee5}


Gets the left child of this node. 



Definition at line 317 of file binary\+\_\+space\+\_\+tree.\+hpp.



References mlpack\+::tree\+::\+Binary\+Space\+Tree$<$ Metric\+Type, Statistic\+Type, Mat\+Type, Bound\+Type, Split\+Type $>$\+::left.

\index{mlpack\+::tree\+::\+Binary\+Space\+Tree@{mlpack\+::tree\+::\+Binary\+Space\+Tree}!Left@{Left}}
\index{Left@{Left}!mlpack\+::tree\+::\+Binary\+Space\+Tree@{mlpack\+::tree\+::\+Binary\+Space\+Tree}}
\subsubsection[{Left()}]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename Metric\+Type , typename Statistic\+Type  = Empty\+Statistic, typename Mat\+Type  = arma\+::mat, template$<$ typename Bound\+Metric\+Type, typename... $>$ class Bound\+Type = bound\+::\+H\+Rect\+Bound, template$<$ typename Split\+Bound\+Type, typename Split\+Mat\+Type $>$ class Split\+Type = Midpoint\+Split$>$ {\bf Binary\+Space\+Tree}$\ast$\& {\bf mlpack\+::tree\+::\+Binary\+Space\+Tree}$<$ Metric\+Type, Statistic\+Type, Mat\+Type, Bound\+Type, Split\+Type $>$\+::Left (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}}\label{classmlpack_1_1tree_1_1BinarySpaceTree_a86146b31e86890a703097429805a08c1}


Modify the left child of this node. 



Definition at line 319 of file binary\+\_\+space\+\_\+tree.\+hpp.



References mlpack\+::tree\+::\+Binary\+Space\+Tree$<$ Metric\+Type, Statistic\+Type, Mat\+Type, Bound\+Type, Split\+Type $>$\+::left.

\index{mlpack\+::tree\+::\+Binary\+Space\+Tree@{mlpack\+::tree\+::\+Binary\+Space\+Tree}!Max\+Distance@{Max\+Distance}}
\index{Max\+Distance@{Max\+Distance}!mlpack\+::tree\+::\+Binary\+Space\+Tree@{mlpack\+::tree\+::\+Binary\+Space\+Tree}}
\subsubsection[{Max\+Distance(const Binary\+Space\+Tree \&other) const }]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename Metric\+Type , typename Statistic\+Type  = Empty\+Statistic, typename Mat\+Type  = arma\+::mat, template$<$ typename Bound\+Metric\+Type, typename... $>$ class Bound\+Type = bound\+::\+H\+Rect\+Bound, template$<$ typename Split\+Bound\+Type, typename Split\+Mat\+Type $>$ class Split\+Type = Midpoint\+Split$>$ {\bf Elem\+Type} {\bf mlpack\+::tree\+::\+Binary\+Space\+Tree}$<$ Metric\+Type, Statistic\+Type, Mat\+Type, Bound\+Type, Split\+Type $>$\+::Max\+Distance (
\begin{DoxyParamCaption}
\item[{const {\bf Binary\+Space\+Tree}$<$ Metric\+Type, Statistic\+Type, Mat\+Type, Bound\+Type, Split\+Type $>$ \&}]{other}
\end{DoxyParamCaption}
) const\hspace{0.3cm}{\ttfamily [inline]}}\label{classmlpack_1_1tree_1_1BinarySpaceTree_a0aecfce2b0eab57c4a30219dd8b5b718}


Return the maximum distance to another node. 



Definition at line 444 of file binary\+\_\+space\+\_\+tree.\+hpp.



References mlpack\+::tree\+::\+Binary\+Space\+Tree$<$ Metric\+Type, Statistic\+Type, Mat\+Type, Bound\+Type, Split\+Type $>$\+::\+Bound().

\index{mlpack\+::tree\+::\+Binary\+Space\+Tree@{mlpack\+::tree\+::\+Binary\+Space\+Tree}!Max\+Distance@{Max\+Distance}}
\index{Max\+Distance@{Max\+Distance}!mlpack\+::tree\+::\+Binary\+Space\+Tree@{mlpack\+::tree\+::\+Binary\+Space\+Tree}}
\subsubsection[{Max\+Distance(const Vec\+Type \&point, typename std\+::enable\+\_\+if\+\_\+t$<$ Is\+Vector$<$ Vec\+Type $>$\+::value $>$ $\ast$=0) const }]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename Metric\+Type , typename Statistic\+Type  = Empty\+Statistic, typename Mat\+Type  = arma\+::mat, template$<$ typename Bound\+Metric\+Type, typename... $>$ class Bound\+Type = bound\+::\+H\+Rect\+Bound, template$<$ typename Split\+Bound\+Type, typename Split\+Mat\+Type $>$ class Split\+Type = Midpoint\+Split$>$ template$<$typename Vec\+Type $>$ {\bf Elem\+Type} {\bf mlpack\+::tree\+::\+Binary\+Space\+Tree}$<$ Metric\+Type, Statistic\+Type, Mat\+Type, Bound\+Type, Split\+Type $>$\+::Max\+Distance (
\begin{DoxyParamCaption}
\item[{const Vec\+Type \&}]{point, }
\item[{typename {\bf std\+::enable\+\_\+if\+\_\+t}$<$ {\bf Is\+Vector}$<$ Vec\+Type $>$\+::value $>$ $\ast$}]{ = {\ttfamily 0}}
\end{DoxyParamCaption}
) const\hspace{0.3cm}{\ttfamily [inline]}}\label{classmlpack_1_1tree_1_1BinarySpaceTree_a0c2f0795c55f458880dbbdf018b2ae9b}


Return the maximum distance to another point. 



Definition at line 466 of file binary\+\_\+space\+\_\+tree.\+hpp.

\index{mlpack\+::tree\+::\+Binary\+Space\+Tree@{mlpack\+::tree\+::\+Binary\+Space\+Tree}!Metric@{Metric}}
\index{Metric@{Metric}!mlpack\+::tree\+::\+Binary\+Space\+Tree@{mlpack\+::tree\+::\+Binary\+Space\+Tree}}
\subsubsection[{Metric() const }]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename Metric\+Type , typename Statistic\+Type  = Empty\+Statistic, typename Mat\+Type  = arma\+::mat, template$<$ typename Bound\+Metric\+Type, typename... $>$ class Bound\+Type = bound\+::\+H\+Rect\+Bound, template$<$ typename Split\+Bound\+Type, typename Split\+Mat\+Type $>$ class Split\+Type = Midpoint\+Split$>$ Metric\+Type {\bf mlpack\+::tree\+::\+Binary\+Space\+Tree}$<$ Metric\+Type, Statistic\+Type, Mat\+Type, Bound\+Type, Split\+Type $>$\+::Metric (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
) const\hspace{0.3cm}{\ttfamily [inline]}}\label{classmlpack_1_1tree_1_1BinarySpaceTree_af97ffcf5536eff69c2df58dfc512382f}


Get the metric that the tree uses. 



Definition at line 337 of file binary\+\_\+space\+\_\+tree.\+hpp.



References mlpack\+::tree\+::\+Binary\+Space\+Tree$<$ Metric\+Type, Statistic\+Type, Mat\+Type, Bound\+Type, Split\+Type $>$\+::\+Furthest\+Descendant\+Distance(), mlpack\+::tree\+::\+Binary\+Space\+Tree$<$ Metric\+Type, Statistic\+Type, Mat\+Type, Bound\+Type, Split\+Type $>$\+::\+Furthest\+Point\+Distance(), mlpack\+::tree\+::\+Binary\+Space\+Tree$<$ Metric\+Type, Statistic\+Type, Mat\+Type, Bound\+Type, Split\+Type $>$\+::\+Get\+Furthest\+Child(), mlpack\+::tree\+::\+Binary\+Space\+Tree$<$ Metric\+Type, Statistic\+Type, Mat\+Type, Bound\+Type, Split\+Type $>$\+::\+Get\+Nearest\+Child(), mlpack\+::tree\+::\+Binary\+Space\+Tree$<$ Metric\+Type, Statistic\+Type, Mat\+Type, Bound\+Type, Split\+Type $>$\+::\+Minimum\+Bound\+Distance(), and mlpack\+::tree\+::\+Binary\+Space\+Tree$<$ Metric\+Type, Statistic\+Type, Mat\+Type, Bound\+Type, Split\+Type $>$\+::\+Num\+Children().

\index{mlpack\+::tree\+::\+Binary\+Space\+Tree@{mlpack\+::tree\+::\+Binary\+Space\+Tree}!Min\+Distance@{Min\+Distance}}
\index{Min\+Distance@{Min\+Distance}!mlpack\+::tree\+::\+Binary\+Space\+Tree@{mlpack\+::tree\+::\+Binary\+Space\+Tree}}
\subsubsection[{Min\+Distance(const Binary\+Space\+Tree \&other) const }]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename Metric\+Type , typename Statistic\+Type  = Empty\+Statistic, typename Mat\+Type  = arma\+::mat, template$<$ typename Bound\+Metric\+Type, typename... $>$ class Bound\+Type = bound\+::\+H\+Rect\+Bound, template$<$ typename Split\+Bound\+Type, typename Split\+Mat\+Type $>$ class Split\+Type = Midpoint\+Split$>$ {\bf Elem\+Type} {\bf mlpack\+::tree\+::\+Binary\+Space\+Tree}$<$ Metric\+Type, Statistic\+Type, Mat\+Type, Bound\+Type, Split\+Type $>$\+::Min\+Distance (
\begin{DoxyParamCaption}
\item[{const {\bf Binary\+Space\+Tree}$<$ Metric\+Type, Statistic\+Type, Mat\+Type, Bound\+Type, Split\+Type $>$ \&}]{other}
\end{DoxyParamCaption}
) const\hspace{0.3cm}{\ttfamily [inline]}}\label{classmlpack_1_1tree_1_1BinarySpaceTree_a841df3c5421c31182cfe2de2f97097b3}


Return the minimum distance to another node. 



Definition at line 438 of file binary\+\_\+space\+\_\+tree.\+hpp.



References mlpack\+::tree\+::\+Binary\+Space\+Tree$<$ Metric\+Type, Statistic\+Type, Mat\+Type, Bound\+Type, Split\+Type $>$\+::\+Bound().

\index{mlpack\+::tree\+::\+Binary\+Space\+Tree@{mlpack\+::tree\+::\+Binary\+Space\+Tree}!Min\+Distance@{Min\+Distance}}
\index{Min\+Distance@{Min\+Distance}!mlpack\+::tree\+::\+Binary\+Space\+Tree@{mlpack\+::tree\+::\+Binary\+Space\+Tree}}
\subsubsection[{Min\+Distance(const Vec\+Type \&point, typename std\+::enable\+\_\+if\+\_\+t$<$ Is\+Vector$<$ Vec\+Type $>$\+::value $>$ $\ast$=0) const }]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename Metric\+Type , typename Statistic\+Type  = Empty\+Statistic, typename Mat\+Type  = arma\+::mat, template$<$ typename Bound\+Metric\+Type, typename... $>$ class Bound\+Type = bound\+::\+H\+Rect\+Bound, template$<$ typename Split\+Bound\+Type, typename Split\+Mat\+Type $>$ class Split\+Type = Midpoint\+Split$>$ template$<$typename Vec\+Type $>$ {\bf Elem\+Type} {\bf mlpack\+::tree\+::\+Binary\+Space\+Tree}$<$ Metric\+Type, Statistic\+Type, Mat\+Type, Bound\+Type, Split\+Type $>$\+::Min\+Distance (
\begin{DoxyParamCaption}
\item[{const Vec\+Type \&}]{point, }
\item[{typename {\bf std\+::enable\+\_\+if\+\_\+t}$<$ {\bf Is\+Vector}$<$ Vec\+Type $>$\+::value $>$ $\ast$}]{ = {\ttfamily 0}}
\end{DoxyParamCaption}
) const\hspace{0.3cm}{\ttfamily [inline]}}\label{classmlpack_1_1tree_1_1BinarySpaceTree_a73d85567fefb22185d53286292530529}


Return the minimum distance to another point. 



Definition at line 457 of file binary\+\_\+space\+\_\+tree.\+hpp.

\index{mlpack\+::tree\+::\+Binary\+Space\+Tree@{mlpack\+::tree\+::\+Binary\+Space\+Tree}!Minimum\+Bound\+Distance@{Minimum\+Bound\+Distance}}
\index{Minimum\+Bound\+Distance@{Minimum\+Bound\+Distance}!mlpack\+::tree\+::\+Binary\+Space\+Tree@{mlpack\+::tree\+::\+Binary\+Space\+Tree}}
\subsubsection[{Minimum\+Bound\+Distance() const }]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename Metric\+Type , typename Statistic\+Type  = Empty\+Statistic, typename Mat\+Type  = arma\+::mat, template$<$ typename Bound\+Metric\+Type, typename... $>$ class Bound\+Type = bound\+::\+H\+Rect\+Bound, template$<$ typename Split\+Bound\+Type, typename Split\+Mat\+Type $>$ class Split\+Type = Midpoint\+Split$>$ {\bf Elem\+Type} {\bf mlpack\+::tree\+::\+Binary\+Space\+Tree}$<$ Metric\+Type, Statistic\+Type, Mat\+Type, Bound\+Type, Split\+Type $>$\+::Minimum\+Bound\+Distance (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
) const}\label{classmlpack_1_1tree_1_1BinarySpaceTree_aad1060c92be12f7fb4a72bea9ecc9cab}


Return the minimum distance from the center of the node to any bound edge. 



Referenced by mlpack\+::tree\+::\+Binary\+Space\+Tree$<$ Metric\+Type, Statistic\+Type, Mat\+Type, Bound\+Type, Split\+Type $>$\+::\+Metric().

\index{mlpack\+::tree\+::\+Binary\+Space\+Tree@{mlpack\+::tree\+::\+Binary\+Space\+Tree}!Num\+Children@{Num\+Children}}
\index{Num\+Children@{Num\+Children}!mlpack\+::tree\+::\+Binary\+Space\+Tree@{mlpack\+::tree\+::\+Binary\+Space\+Tree}}
\subsubsection[{Num\+Children() const }]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename Metric\+Type , typename Statistic\+Type  = Empty\+Statistic, typename Mat\+Type  = arma\+::mat, template$<$ typename Bound\+Metric\+Type, typename... $>$ class Bound\+Type = bound\+::\+H\+Rect\+Bound, template$<$ typename Split\+Bound\+Type, typename Split\+Mat\+Type $>$ class Split\+Type = Midpoint\+Split$>$ size\+\_\+t {\bf mlpack\+::tree\+::\+Binary\+Space\+Tree}$<$ Metric\+Type, Statistic\+Type, Mat\+Type, Bound\+Type, Split\+Type $>$\+::Num\+Children (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
) const}\label{classmlpack_1_1tree_1_1BinarySpaceTree_a5adbf8b4fe5a91ccd17a641d378d7ea6}


Return the number of children in this node. 



Referenced by mlpack\+::tree\+::\+Binary\+Space\+Tree$<$ Metric\+Type, Statistic\+Type, Mat\+Type, Bound\+Type, Split\+Type $>$\+::\+Metric().

\index{mlpack\+::tree\+::\+Binary\+Space\+Tree@{mlpack\+::tree\+::\+Binary\+Space\+Tree}!Num\+Descendants@{Num\+Descendants}}
\index{Num\+Descendants@{Num\+Descendants}!mlpack\+::tree\+::\+Binary\+Space\+Tree@{mlpack\+::tree\+::\+Binary\+Space\+Tree}}
\subsubsection[{Num\+Descendants() const }]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename Metric\+Type , typename Statistic\+Type  = Empty\+Statistic, typename Mat\+Type  = arma\+::mat, template$<$ typename Bound\+Metric\+Type, typename... $>$ class Bound\+Type = bound\+::\+H\+Rect\+Bound, template$<$ typename Split\+Bound\+Type, typename Split\+Mat\+Type $>$ class Split\+Type = Midpoint\+Split$>$ size\+\_\+t {\bf mlpack\+::tree\+::\+Binary\+Space\+Tree}$<$ Metric\+Type, Statistic\+Type, Mat\+Type, Bound\+Type, Split\+Type $>$\+::Num\+Descendants (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
) const}\label{classmlpack_1_1tree_1_1BinarySpaceTree_ad5761f88aa817bd59230a132032b2d1d}


Return the number of descendants of this node. 

For a non-\/leaf in a binary space tree, this is the number of points at the descendant leaves. For a leaf, this is the number of points in the leaf. 

Referenced by mlpack\+::tree\+::\+Binary\+Space\+Tree$<$ Metric\+Type, Statistic\+Type, Mat\+Type, Bound\+Type, Split\+Type $>$\+::\+Child\+Ptr().

\index{mlpack\+::tree\+::\+Binary\+Space\+Tree@{mlpack\+::tree\+::\+Binary\+Space\+Tree}!Num\+Points@{Num\+Points}}
\index{Num\+Points@{Num\+Points}!mlpack\+::tree\+::\+Binary\+Space\+Tree@{mlpack\+::tree\+::\+Binary\+Space\+Tree}}
\subsubsection[{Num\+Points() const }]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename Metric\+Type , typename Statistic\+Type  = Empty\+Statistic, typename Mat\+Type  = arma\+::mat, template$<$ typename Bound\+Metric\+Type, typename... $>$ class Bound\+Type = bound\+::\+H\+Rect\+Bound, template$<$ typename Split\+Bound\+Type, typename Split\+Mat\+Type $>$ class Split\+Type = Midpoint\+Split$>$ size\+\_\+t {\bf mlpack\+::tree\+::\+Binary\+Space\+Tree}$<$ Metric\+Type, Statistic\+Type, Mat\+Type, Bound\+Type, Split\+Type $>$\+::Num\+Points (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
) const}\label{classmlpack_1_1tree_1_1BinarySpaceTree_add40e242806e6107f22f236c413614ba}


Return the number of points in this node (0 if not a leaf). 



Referenced by mlpack\+::tree\+::\+Binary\+Space\+Tree$<$ Metric\+Type, Statistic\+Type, Mat\+Type, Bound\+Type, Split\+Type $>$\+::\+Child\+Ptr().

\index{mlpack\+::tree\+::\+Binary\+Space\+Tree@{mlpack\+::tree\+::\+Binary\+Space\+Tree}!Parent@{Parent}}
\index{Parent@{Parent}!mlpack\+::tree\+::\+Binary\+Space\+Tree@{mlpack\+::tree\+::\+Binary\+Space\+Tree}}
\subsubsection[{Parent() const }]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename Metric\+Type , typename Statistic\+Type  = Empty\+Statistic, typename Mat\+Type  = arma\+::mat, template$<$ typename Bound\+Metric\+Type, typename... $>$ class Bound\+Type = bound\+::\+H\+Rect\+Bound, template$<$ typename Split\+Bound\+Type, typename Split\+Mat\+Type $>$ class Split\+Type = Midpoint\+Split$>$ {\bf Binary\+Space\+Tree}$\ast$ {\bf mlpack\+::tree\+::\+Binary\+Space\+Tree}$<$ Metric\+Type, Statistic\+Type, Mat\+Type, Bound\+Type, Split\+Type $>$\+::Parent (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
) const\hspace{0.3cm}{\ttfamily [inline]}}\label{classmlpack_1_1tree_1_1BinarySpaceTree_a37a33c6faab909c699cbb60aada9521f}


Gets the parent of this node. 



Definition at line 327 of file binary\+\_\+space\+\_\+tree.\+hpp.



References mlpack\+::tree\+::\+Binary\+Space\+Tree$<$ Metric\+Type, Statistic\+Type, Mat\+Type, Bound\+Type, Split\+Type $>$\+::parent.

\index{mlpack\+::tree\+::\+Binary\+Space\+Tree@{mlpack\+::tree\+::\+Binary\+Space\+Tree}!Parent@{Parent}}
\index{Parent@{Parent}!mlpack\+::tree\+::\+Binary\+Space\+Tree@{mlpack\+::tree\+::\+Binary\+Space\+Tree}}
\subsubsection[{Parent()}]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename Metric\+Type , typename Statistic\+Type  = Empty\+Statistic, typename Mat\+Type  = arma\+::mat, template$<$ typename Bound\+Metric\+Type, typename... $>$ class Bound\+Type = bound\+::\+H\+Rect\+Bound, template$<$ typename Split\+Bound\+Type, typename Split\+Mat\+Type $>$ class Split\+Type = Midpoint\+Split$>$ {\bf Binary\+Space\+Tree}$\ast$\& {\bf mlpack\+::tree\+::\+Binary\+Space\+Tree}$<$ Metric\+Type, Statistic\+Type, Mat\+Type, Bound\+Type, Split\+Type $>$\+::Parent (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}}\label{classmlpack_1_1tree_1_1BinarySpaceTree_ae059911bf41c71290a07f6fd7920a823}


Modify the parent of this node. 



Definition at line 329 of file binary\+\_\+space\+\_\+tree.\+hpp.



References mlpack\+::tree\+::\+Binary\+Space\+Tree$<$ Metric\+Type, Statistic\+Type, Mat\+Type, Bound\+Type, Split\+Type $>$\+::parent.

\index{mlpack\+::tree\+::\+Binary\+Space\+Tree@{mlpack\+::tree\+::\+Binary\+Space\+Tree}!Parent\+Distance@{Parent\+Distance}}
\index{Parent\+Distance@{Parent\+Distance}!mlpack\+::tree\+::\+Binary\+Space\+Tree@{mlpack\+::tree\+::\+Binary\+Space\+Tree}}
\subsubsection[{Parent\+Distance() const }]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename Metric\+Type , typename Statistic\+Type  = Empty\+Statistic, typename Mat\+Type  = arma\+::mat, template$<$ typename Bound\+Metric\+Type, typename... $>$ class Bound\+Type = bound\+::\+H\+Rect\+Bound, template$<$ typename Split\+Bound\+Type, typename Split\+Mat\+Type $>$ class Split\+Type = Midpoint\+Split$>$ {\bf Elem\+Type} {\bf mlpack\+::tree\+::\+Binary\+Space\+Tree}$<$ Metric\+Type, Statistic\+Type, Mat\+Type, Bound\+Type, Split\+Type $>$\+::Parent\+Distance (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
) const\hspace{0.3cm}{\ttfamily [inline]}}\label{classmlpack_1_1tree_1_1BinarySpaceTree_a4492862c990821516dd5b655fc0e0e53}


Return the distance from the center of this node to the center of the parent node. 



Definition at line 392 of file binary\+\_\+space\+\_\+tree.\+hpp.



References mlpack\+::tree\+::\+Binary\+Space\+Tree$<$ Metric\+Type, Statistic\+Type, Mat\+Type, Bound\+Type, Split\+Type $>$\+::parent\+Distance.

\index{mlpack\+::tree\+::\+Binary\+Space\+Tree@{mlpack\+::tree\+::\+Binary\+Space\+Tree}!Parent\+Distance@{Parent\+Distance}}
\index{Parent\+Distance@{Parent\+Distance}!mlpack\+::tree\+::\+Binary\+Space\+Tree@{mlpack\+::tree\+::\+Binary\+Space\+Tree}}
\subsubsection[{Parent\+Distance()}]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename Metric\+Type , typename Statistic\+Type  = Empty\+Statistic, typename Mat\+Type  = arma\+::mat, template$<$ typename Bound\+Metric\+Type, typename... $>$ class Bound\+Type = bound\+::\+H\+Rect\+Bound, template$<$ typename Split\+Bound\+Type, typename Split\+Mat\+Type $>$ class Split\+Type = Midpoint\+Split$>$ {\bf Elem\+Type}\& {\bf mlpack\+::tree\+::\+Binary\+Space\+Tree}$<$ Metric\+Type, Statistic\+Type, Mat\+Type, Bound\+Type, Split\+Type $>$\+::Parent\+Distance (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}}\label{classmlpack_1_1tree_1_1BinarySpaceTree_a55425ebec0ef2c0ace9b2fe6006f42f6}


Modify the distance from the center of this node to the center of the parent node. 



Definition at line 395 of file binary\+\_\+space\+\_\+tree.\+hpp.



References mlpack\+::tree\+::\+Binary\+Space\+Tree$<$ Metric\+Type, Statistic\+Type, Mat\+Type, Bound\+Type, Split\+Type $>$\+::\+Child(), and mlpack\+::tree\+::\+Binary\+Space\+Tree$<$ Metric\+Type, Statistic\+Type, Mat\+Type, Bound\+Type, Split\+Type $>$\+::parent\+Distance.

\index{mlpack\+::tree\+::\+Binary\+Space\+Tree@{mlpack\+::tree\+::\+Binary\+Space\+Tree}!Point@{Point}}
\index{Point@{Point}!mlpack\+::tree\+::\+Binary\+Space\+Tree@{mlpack\+::tree\+::\+Binary\+Space\+Tree}}
\subsubsection[{Point(const size\+\_\+t index) const }]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename Metric\+Type , typename Statistic\+Type  = Empty\+Statistic, typename Mat\+Type  = arma\+::mat, template$<$ typename Bound\+Metric\+Type, typename... $>$ class Bound\+Type = bound\+::\+H\+Rect\+Bound, template$<$ typename Split\+Bound\+Type, typename Split\+Mat\+Type $>$ class Split\+Type = Midpoint\+Split$>$ size\+\_\+t {\bf mlpack\+::tree\+::\+Binary\+Space\+Tree}$<$ Metric\+Type, Statistic\+Type, Mat\+Type, Bound\+Type, Split\+Type $>$\+::Point (
\begin{DoxyParamCaption}
\item[{const size\+\_\+t}]{index}
\end{DoxyParamCaption}
) const}\label{classmlpack_1_1tree_1_1BinarySpaceTree_a6833a92874e6342fa3523fead08ec411}


Return the index (with reference to the dataset) of a particular point in this node. 

This will happily return invalid indices if the given index is greater than the number of points in this node (obtained with \doxyref{Num\+Points()}{p.}{classmlpack_1_1tree_1_1BinarySpaceTree_add40e242806e6107f22f236c413614ba}) -- be careful.


\begin{DoxyParams}{Parameters}
{\em index} & Index of point for which a dataset index is wanted. \\
\hline
\end{DoxyParams}


Referenced by mlpack\+::tree\+::\+Binary\+Space\+Tree$<$ Metric\+Type, Statistic\+Type, Mat\+Type, Bound\+Type, Split\+Type $>$\+::\+Child\+Ptr().

\index{mlpack\+::tree\+::\+Binary\+Space\+Tree@{mlpack\+::tree\+::\+Binary\+Space\+Tree}!Range\+Distance@{Range\+Distance}}
\index{Range\+Distance@{Range\+Distance}!mlpack\+::tree\+::\+Binary\+Space\+Tree@{mlpack\+::tree\+::\+Binary\+Space\+Tree}}
\subsubsection[{Range\+Distance(const Binary\+Space\+Tree \&other) const }]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename Metric\+Type , typename Statistic\+Type  = Empty\+Statistic, typename Mat\+Type  = arma\+::mat, template$<$ typename Bound\+Metric\+Type, typename... $>$ class Bound\+Type = bound\+::\+H\+Rect\+Bound, template$<$ typename Split\+Bound\+Type, typename Split\+Mat\+Type $>$ class Split\+Type = Midpoint\+Split$>$ {\bf math\+::\+Range\+Type}$<${\bf Elem\+Type}$>$ {\bf mlpack\+::tree\+::\+Binary\+Space\+Tree}$<$ Metric\+Type, Statistic\+Type, Mat\+Type, Bound\+Type, Split\+Type $>$\+::Range\+Distance (
\begin{DoxyParamCaption}
\item[{const {\bf Binary\+Space\+Tree}$<$ Metric\+Type, Statistic\+Type, Mat\+Type, Bound\+Type, Split\+Type $>$ \&}]{other}
\end{DoxyParamCaption}
) const\hspace{0.3cm}{\ttfamily [inline]}}\label{classmlpack_1_1tree_1_1BinarySpaceTree_a91052a8efe03a7da378cf0c646dd6f37}


Return the minimum and maximum distance to another node. 



Definition at line 450 of file binary\+\_\+space\+\_\+tree.\+hpp.



References mlpack\+::tree\+::\+Binary\+Space\+Tree$<$ Metric\+Type, Statistic\+Type, Mat\+Type, Bound\+Type, Split\+Type $>$\+::\+Bound().

\index{mlpack\+::tree\+::\+Binary\+Space\+Tree@{mlpack\+::tree\+::\+Binary\+Space\+Tree}!Range\+Distance@{Range\+Distance}}
\index{Range\+Distance@{Range\+Distance}!mlpack\+::tree\+::\+Binary\+Space\+Tree@{mlpack\+::tree\+::\+Binary\+Space\+Tree}}
\subsubsection[{Range\+Distance(const Vec\+Type \&point, typename std\+::enable\+\_\+if\+\_\+t$<$ Is\+Vector$<$ Vec\+Type $>$\+::value $>$ $\ast$=0) const }]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename Metric\+Type , typename Statistic\+Type  = Empty\+Statistic, typename Mat\+Type  = arma\+::mat, template$<$ typename Bound\+Metric\+Type, typename... $>$ class Bound\+Type = bound\+::\+H\+Rect\+Bound, template$<$ typename Split\+Bound\+Type, typename Split\+Mat\+Type $>$ class Split\+Type = Midpoint\+Split$>$ template$<$typename Vec\+Type $>$ {\bf math\+::\+Range\+Type}$<${\bf Elem\+Type}$>$ {\bf mlpack\+::tree\+::\+Binary\+Space\+Tree}$<$ Metric\+Type, Statistic\+Type, Mat\+Type, Bound\+Type, Split\+Type $>$\+::Range\+Distance (
\begin{DoxyParamCaption}
\item[{const Vec\+Type \&}]{point, }
\item[{typename {\bf std\+::enable\+\_\+if\+\_\+t}$<$ {\bf Is\+Vector}$<$ Vec\+Type $>$\+::value $>$ $\ast$}]{ = {\ttfamily 0}}
\end{DoxyParamCaption}
) const\hspace{0.3cm}{\ttfamily [inline]}}\label{classmlpack_1_1tree_1_1BinarySpaceTree_a95bee6fc9977cf83afc2cc5294619308}


Return the minimum and maximum distance to another point. 



Definition at line 476 of file binary\+\_\+space\+\_\+tree.\+hpp.

\index{mlpack\+::tree\+::\+Binary\+Space\+Tree@{mlpack\+::tree\+::\+Binary\+Space\+Tree}!Right@{Right}}
\index{Right@{Right}!mlpack\+::tree\+::\+Binary\+Space\+Tree@{mlpack\+::tree\+::\+Binary\+Space\+Tree}}
\subsubsection[{Right() const }]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename Metric\+Type , typename Statistic\+Type  = Empty\+Statistic, typename Mat\+Type  = arma\+::mat, template$<$ typename Bound\+Metric\+Type, typename... $>$ class Bound\+Type = bound\+::\+H\+Rect\+Bound, template$<$ typename Split\+Bound\+Type, typename Split\+Mat\+Type $>$ class Split\+Type = Midpoint\+Split$>$ {\bf Binary\+Space\+Tree}$\ast$ {\bf mlpack\+::tree\+::\+Binary\+Space\+Tree}$<$ Metric\+Type, Statistic\+Type, Mat\+Type, Bound\+Type, Split\+Type $>$\+::Right (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
) const\hspace{0.3cm}{\ttfamily [inline]}}\label{classmlpack_1_1tree_1_1BinarySpaceTree_abc46ccbcdd25d2907042c02aa969286e}


Gets the right child of this node. 



Definition at line 322 of file binary\+\_\+space\+\_\+tree.\+hpp.



References mlpack\+::tree\+::\+Binary\+Space\+Tree$<$ Metric\+Type, Statistic\+Type, Mat\+Type, Bound\+Type, Split\+Type $>$\+::right.

\index{mlpack\+::tree\+::\+Binary\+Space\+Tree@{mlpack\+::tree\+::\+Binary\+Space\+Tree}!Right@{Right}}
\index{Right@{Right}!mlpack\+::tree\+::\+Binary\+Space\+Tree@{mlpack\+::tree\+::\+Binary\+Space\+Tree}}
\subsubsection[{Right()}]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename Metric\+Type , typename Statistic\+Type  = Empty\+Statistic, typename Mat\+Type  = arma\+::mat, template$<$ typename Bound\+Metric\+Type, typename... $>$ class Bound\+Type = bound\+::\+H\+Rect\+Bound, template$<$ typename Split\+Bound\+Type, typename Split\+Mat\+Type $>$ class Split\+Type = Midpoint\+Split$>$ {\bf Binary\+Space\+Tree}$\ast$\& {\bf mlpack\+::tree\+::\+Binary\+Space\+Tree}$<$ Metric\+Type, Statistic\+Type, Mat\+Type, Bound\+Type, Split\+Type $>$\+::Right (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}}\label{classmlpack_1_1tree_1_1BinarySpaceTree_a348fb083c7711cce7cbb1a3df65d661a}


Modify the right child of this node. 



Definition at line 324 of file binary\+\_\+space\+\_\+tree.\+hpp.



References mlpack\+::tree\+::\+Binary\+Space\+Tree$<$ Metric\+Type, Statistic\+Type, Mat\+Type, Bound\+Type, Split\+Type $>$\+::right.

\index{mlpack\+::tree\+::\+Binary\+Space\+Tree@{mlpack\+::tree\+::\+Binary\+Space\+Tree}!Serialize@{Serialize}}
\index{Serialize@{Serialize}!mlpack\+::tree\+::\+Binary\+Space\+Tree@{mlpack\+::tree\+::\+Binary\+Space\+Tree}}
\subsubsection[{Serialize(\+Archive \&ar, const unsigned int version)}]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename Metric\+Type , typename Statistic\+Type  = Empty\+Statistic, typename Mat\+Type  = arma\+::mat, template$<$ typename Bound\+Metric\+Type, typename... $>$ class Bound\+Type = bound\+::\+H\+Rect\+Bound, template$<$ typename Split\+Bound\+Type, typename Split\+Mat\+Type $>$ class Split\+Type = Midpoint\+Split$>$ template$<$typename Archive $>$ void {\bf mlpack\+::tree\+::\+Binary\+Space\+Tree}$<$ Metric\+Type, Statistic\+Type, Mat\+Type, Bound\+Type, Split\+Type $>$\+::Serialize (
\begin{DoxyParamCaption}
\item[{Archive \&}]{ar, }
\item[{const unsigned int}]{version}
\end{DoxyParamCaption}
)}\label{classmlpack_1_1tree_1_1BinarySpaceTree_ab95f82ba85224db2c4c002320813aeee}


Serialize the tree. 

\index{mlpack\+::tree\+::\+Binary\+Space\+Tree@{mlpack\+::tree\+::\+Binary\+Space\+Tree}!Split\+Node@{Split\+Node}}
\index{Split\+Node@{Split\+Node}!mlpack\+::tree\+::\+Binary\+Space\+Tree@{mlpack\+::tree\+::\+Binary\+Space\+Tree}}
\subsubsection[{Split\+Node(const size\+\_\+t max\+Leaf\+Size, Split\+Type$<$ Bound\+Type$<$ Metric\+Type $>$, Mat\+Type $>$ \&splitter)}]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename Metric\+Type , typename Statistic\+Type  = Empty\+Statistic, typename Mat\+Type  = arma\+::mat, template$<$ typename Bound\+Metric\+Type, typename... $>$ class Bound\+Type = bound\+::\+H\+Rect\+Bound, template$<$ typename Split\+Bound\+Type, typename Split\+Mat\+Type $>$ class Split\+Type = Midpoint\+Split$>$ void {\bf mlpack\+::tree\+::\+Binary\+Space\+Tree}$<$ Metric\+Type, Statistic\+Type, Mat\+Type, Bound\+Type, Split\+Type $>$\+::Split\+Node (
\begin{DoxyParamCaption}
\item[{const size\+\_\+t}]{max\+Leaf\+Size, }
\item[{Split\+Type$<$ Bound\+Type$<$ Metric\+Type $>$, Mat\+Type $>$ \&}]{splitter}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [private]}}\label{classmlpack_1_1tree_1_1BinarySpaceTree_a359804f7939de9bda4d011e25609c3da}


Splits the current node, assigning its left and right children recursively. 


\begin{DoxyParams}{Parameters}
{\em max\+Leaf\+Size} & Maximum number of points held in a leaf. \\
\hline
{\em splitter} & Instantiated Split\+Type object. \\
\hline
\end{DoxyParams}


Referenced by mlpack\+::tree\+::\+Binary\+Space\+Tree$<$ Metric\+Type, Statistic\+Type, Mat\+Type, Bound\+Type, Split\+Type $>$\+::\+Center().

\index{mlpack\+::tree\+::\+Binary\+Space\+Tree@{mlpack\+::tree\+::\+Binary\+Space\+Tree}!Split\+Node@{Split\+Node}}
\index{Split\+Node@{Split\+Node}!mlpack\+::tree\+::\+Binary\+Space\+Tree@{mlpack\+::tree\+::\+Binary\+Space\+Tree}}
\subsubsection[{Split\+Node(std\+::vector$<$ size\+\_\+t $>$ \&old\+From\+New, const size\+\_\+t max\+Leaf\+Size, Split\+Type$<$ Bound\+Type$<$ Metric\+Type $>$, Mat\+Type $>$ \&splitter)}]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename Metric\+Type , typename Statistic\+Type  = Empty\+Statistic, typename Mat\+Type  = arma\+::mat, template$<$ typename Bound\+Metric\+Type, typename... $>$ class Bound\+Type = bound\+::\+H\+Rect\+Bound, template$<$ typename Split\+Bound\+Type, typename Split\+Mat\+Type $>$ class Split\+Type = Midpoint\+Split$>$ void {\bf mlpack\+::tree\+::\+Binary\+Space\+Tree}$<$ Metric\+Type, Statistic\+Type, Mat\+Type, Bound\+Type, Split\+Type $>$\+::Split\+Node (
\begin{DoxyParamCaption}
\item[{std\+::vector$<$ size\+\_\+t $>$ \&}]{old\+From\+New, }
\item[{const size\+\_\+t}]{max\+Leaf\+Size, }
\item[{Split\+Type$<$ Bound\+Type$<$ Metric\+Type $>$, Mat\+Type $>$ \&}]{splitter}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [private]}}\label{classmlpack_1_1tree_1_1BinarySpaceTree_ad458708a10ab1d557dd2de5feae8cc05}


Splits the current node, assigning its left and right children recursively. 

Also returns a list of the changed indices.


\begin{DoxyParams}{Parameters}
{\em old\+From\+New} & Vector holding permuted indices. \\
\hline
{\em max\+Leaf\+Size} & Maximum number of points held in a leaf. \\
\hline
{\em splitter} & Instantiated Split\+Type object. \\
\hline
\end{DoxyParams}
\index{mlpack\+::tree\+::\+Binary\+Space\+Tree@{mlpack\+::tree\+::\+Binary\+Space\+Tree}!Stat@{Stat}}
\index{Stat@{Stat}!mlpack\+::tree\+::\+Binary\+Space\+Tree@{mlpack\+::tree\+::\+Binary\+Space\+Tree}}
\subsubsection[{Stat() const }]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename Metric\+Type , typename Statistic\+Type  = Empty\+Statistic, typename Mat\+Type  = arma\+::mat, template$<$ typename Bound\+Metric\+Type, typename... $>$ class Bound\+Type = bound\+::\+H\+Rect\+Bound, template$<$ typename Split\+Bound\+Type, typename Split\+Mat\+Type $>$ class Split\+Type = Midpoint\+Split$>$ const Statistic\+Type\& {\bf mlpack\+::tree\+::\+Binary\+Space\+Tree}$<$ Metric\+Type, Statistic\+Type, Mat\+Type, Bound\+Type, Split\+Type $>$\+::Stat (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
) const\hspace{0.3cm}{\ttfamily [inline]}}\label{classmlpack_1_1tree_1_1BinarySpaceTree_a54d70c2f89b0578a80925f6fcea7dc6e}


Return the statistic object for this node. 



Definition at line 309 of file binary\+\_\+space\+\_\+tree.\+hpp.



References mlpack\+::tree\+::\+Binary\+Space\+Tree$<$ Metric\+Type, Statistic\+Type, Mat\+Type, Bound\+Type, Split\+Type $>$\+::stat.

\index{mlpack\+::tree\+::\+Binary\+Space\+Tree@{mlpack\+::tree\+::\+Binary\+Space\+Tree}!Stat@{Stat}}
\index{Stat@{Stat}!mlpack\+::tree\+::\+Binary\+Space\+Tree@{mlpack\+::tree\+::\+Binary\+Space\+Tree}}
\subsubsection[{Stat()}]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename Metric\+Type , typename Statistic\+Type  = Empty\+Statistic, typename Mat\+Type  = arma\+::mat, template$<$ typename Bound\+Metric\+Type, typename... $>$ class Bound\+Type = bound\+::\+H\+Rect\+Bound, template$<$ typename Split\+Bound\+Type, typename Split\+Mat\+Type $>$ class Split\+Type = Midpoint\+Split$>$ Statistic\+Type\& {\bf mlpack\+::tree\+::\+Binary\+Space\+Tree}$<$ Metric\+Type, Statistic\+Type, Mat\+Type, Bound\+Type, Split\+Type $>$\+::Stat (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}}\label{classmlpack_1_1tree_1_1BinarySpaceTree_a683b56dae5c4d17ea6de59ee64219b17}


Return the statistic object for this node. 



Definition at line 311 of file binary\+\_\+space\+\_\+tree.\+hpp.



References mlpack\+::tree\+::\+Binary\+Space\+Tree$<$ Metric\+Type, Statistic\+Type, Mat\+Type, Bound\+Type, Split\+Type $>$\+::\+Is\+Leaf(), and mlpack\+::tree\+::\+Binary\+Space\+Tree$<$ Metric\+Type, Statistic\+Type, Mat\+Type, Bound\+Type, Split\+Type $>$\+::stat.

\index{mlpack\+::tree\+::\+Binary\+Space\+Tree@{mlpack\+::tree\+::\+Binary\+Space\+Tree}!Update\+Bound@{Update\+Bound}}
\index{Update\+Bound@{Update\+Bound}!mlpack\+::tree\+::\+Binary\+Space\+Tree@{mlpack\+::tree\+::\+Binary\+Space\+Tree}}
\subsubsection[{Update\+Bound(\+Bound\+Type2 \&bound\+To\+Update)}]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename Metric\+Type , typename Statistic\+Type  = Empty\+Statistic, typename Mat\+Type  = arma\+::mat, template$<$ typename Bound\+Metric\+Type, typename... $>$ class Bound\+Type = bound\+::\+H\+Rect\+Bound, template$<$ typename Split\+Bound\+Type, typename Split\+Mat\+Type $>$ class Split\+Type = Midpoint\+Split$>$ template$<$typename Bound\+Type2 $>$ void {\bf mlpack\+::tree\+::\+Binary\+Space\+Tree}$<$ Metric\+Type, Statistic\+Type, Mat\+Type, Bound\+Type, Split\+Type $>$\+::Update\+Bound (
\begin{DoxyParamCaption}
\item[{Bound\+Type2 \&}]{bound\+To\+Update}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [private]}}\label{classmlpack_1_1tree_1_1BinarySpaceTree_a773ea7548ad7ddba6265e242bceb2221}


Update the bound of the current node. 

This method does not take into account bound-\/specific properties.


\begin{DoxyParams}{Parameters}
{\em bound\+To\+Update} & The bound to update. \\
\hline
\end{DoxyParams}


Referenced by mlpack\+::tree\+::\+Binary\+Space\+Tree$<$ Metric\+Type, Statistic\+Type, Mat\+Type, Bound\+Type, Split\+Type $>$\+::\+Center().

\index{mlpack\+::tree\+::\+Binary\+Space\+Tree@{mlpack\+::tree\+::\+Binary\+Space\+Tree}!Update\+Bound@{Update\+Bound}}
\index{Update\+Bound@{Update\+Bound}!mlpack\+::tree\+::\+Binary\+Space\+Tree@{mlpack\+::tree\+::\+Binary\+Space\+Tree}}
\subsubsection[{Update\+Bound(bound\+::\+Hollow\+Ball\+Bound$<$ Metric\+Type $>$ \&bound\+To\+Update)}]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename Metric\+Type , typename Statistic\+Type  = Empty\+Statistic, typename Mat\+Type  = arma\+::mat, template$<$ typename Bound\+Metric\+Type, typename... $>$ class Bound\+Type = bound\+::\+H\+Rect\+Bound, template$<$ typename Split\+Bound\+Type, typename Split\+Mat\+Type $>$ class Split\+Type = Midpoint\+Split$>$ void {\bf mlpack\+::tree\+::\+Binary\+Space\+Tree}$<$ Metric\+Type, Statistic\+Type, Mat\+Type, Bound\+Type, Split\+Type $>$\+::Update\+Bound (
\begin{DoxyParamCaption}
\item[{{\bf bound\+::\+Hollow\+Ball\+Bound}$<$ Metric\+Type $>$ \&}]{bound\+To\+Update}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [private]}}\label{classmlpack_1_1tree_1_1BinarySpaceTree_a2ef5d210b25f800a87112c2e1d565688}


Update the bound of the current node. 

This method is designed for Hollow\+Ball\+Bound only.


\begin{DoxyParams}{Parameters}
{\em bound\+To\+Update} & The bound to update. \\
\hline
\end{DoxyParams}


\subsection{Member Data Documentation}
\index{mlpack\+::tree\+::\+Binary\+Space\+Tree@{mlpack\+::tree\+::\+Binary\+Space\+Tree}!begin@{begin}}
\index{begin@{begin}!mlpack\+::tree\+::\+Binary\+Space\+Tree@{mlpack\+::tree\+::\+Binary\+Space\+Tree}}
\subsubsection[{begin}]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename Metric\+Type , typename Statistic\+Type  = Empty\+Statistic, typename Mat\+Type  = arma\+::mat, template$<$ typename Bound\+Metric\+Type, typename... $>$ class Bound\+Type = bound\+::\+H\+Rect\+Bound, template$<$ typename Split\+Bound\+Type, typename Split\+Mat\+Type $>$ class Split\+Type = Midpoint\+Split$>$ size\+\_\+t {\bf mlpack\+::tree\+::\+Binary\+Space\+Tree}$<$ Metric\+Type, Statistic\+Type, Mat\+Type, Bound\+Type, Split\+Type $>$\+::begin\hspace{0.3cm}{\ttfamily [private]}}\label{classmlpack_1_1tree_1_1BinarySpaceTree_af040cc83b8f5086e5dae3ad269435238}


The index of the first point in the dataset contained in this node (and its children). 



Definition at line 73 of file binary\+\_\+space\+\_\+tree.\+hpp.



Referenced by mlpack\+::tree\+::\+Binary\+Space\+Tree$<$ Metric\+Type, Statistic\+Type, Mat\+Type, Bound\+Type, Split\+Type $>$\+::\+Begin().

\index{mlpack\+::tree\+::\+Binary\+Space\+Tree@{mlpack\+::tree\+::\+Binary\+Space\+Tree}!bound@{bound}}
\index{bound@{bound}!mlpack\+::tree\+::\+Binary\+Space\+Tree@{mlpack\+::tree\+::\+Binary\+Space\+Tree}}
\subsubsection[{bound}]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename Metric\+Type , typename Statistic\+Type  = Empty\+Statistic, typename Mat\+Type  = arma\+::mat, template$<$ typename Bound\+Metric\+Type, typename... $>$ class Bound\+Type = bound\+::\+H\+Rect\+Bound, template$<$ typename Split\+Bound\+Type, typename Split\+Mat\+Type $>$ class Split\+Type = Midpoint\+Split$>$ Bound\+Type$<$Metric\+Type$>$ {\bf mlpack\+::tree\+::\+Binary\+Space\+Tree}$<$ Metric\+Type, Statistic\+Type, Mat\+Type, Bound\+Type, Split\+Type $>$\+::bound\hspace{0.3cm}{\ttfamily [private]}}\label{classmlpack_1_1tree_1_1BinarySpaceTree_a989e92e4ca3e6eb1943e394cd0cf6123}


The bound object for this node. 



Definition at line 78 of file binary\+\_\+space\+\_\+tree.\+hpp.



Referenced by mlpack\+::tree\+::\+Binary\+Space\+Tree$<$ Metric\+Type, Statistic\+Type, Mat\+Type, Bound\+Type, Split\+Type $>$\+::\+Bound().

\index{mlpack\+::tree\+::\+Binary\+Space\+Tree@{mlpack\+::tree\+::\+Binary\+Space\+Tree}!count@{count}}
\index{count@{count}!mlpack\+::tree\+::\+Binary\+Space\+Tree@{mlpack\+::tree\+::\+Binary\+Space\+Tree}}
\subsubsection[{count}]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename Metric\+Type , typename Statistic\+Type  = Empty\+Statistic, typename Mat\+Type  = arma\+::mat, template$<$ typename Bound\+Metric\+Type, typename... $>$ class Bound\+Type = bound\+::\+H\+Rect\+Bound, template$<$ typename Split\+Bound\+Type, typename Split\+Mat\+Type $>$ class Split\+Type = Midpoint\+Split$>$ size\+\_\+t {\bf mlpack\+::tree\+::\+Binary\+Space\+Tree}$<$ Metric\+Type, Statistic\+Type, Mat\+Type, Bound\+Type, Split\+Type $>$\+::count\hspace{0.3cm}{\ttfamily [private]}}\label{classmlpack_1_1tree_1_1BinarySpaceTree_a858649909a8a1dc833a60034e85f5a55}


The number of points of the dataset contained in this node (and its children). 



Definition at line 76 of file binary\+\_\+space\+\_\+tree.\+hpp.



Referenced by mlpack\+::tree\+::\+Binary\+Space\+Tree$<$ Metric\+Type, Statistic\+Type, Mat\+Type, Bound\+Type, Split\+Type $>$\+::\+Count().

\index{mlpack\+::tree\+::\+Binary\+Space\+Tree@{mlpack\+::tree\+::\+Binary\+Space\+Tree}!dataset@{dataset}}
\index{dataset@{dataset}!mlpack\+::tree\+::\+Binary\+Space\+Tree@{mlpack\+::tree\+::\+Binary\+Space\+Tree}}
\subsubsection[{dataset}]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename Metric\+Type , typename Statistic\+Type  = Empty\+Statistic, typename Mat\+Type  = arma\+::mat, template$<$ typename Bound\+Metric\+Type, typename... $>$ class Bound\+Type = bound\+::\+H\+Rect\+Bound, template$<$ typename Split\+Bound\+Type, typename Split\+Mat\+Type $>$ class Split\+Type = Midpoint\+Split$>$ Mat\+Type$\ast$ {\bf mlpack\+::tree\+::\+Binary\+Space\+Tree}$<$ Metric\+Type, Statistic\+Type, Mat\+Type, Bound\+Type, Split\+Type $>$\+::dataset\hspace{0.3cm}{\ttfamily [private]}}\label{classmlpack_1_1tree_1_1BinarySpaceTree_a2ae04b81295704fd05c0442308291f81}


The dataset. 

If we are the root of the tree, we own the dataset and must delete it. 

Definition at line 90 of file binary\+\_\+space\+\_\+tree.\+hpp.



Referenced by mlpack\+::tree\+::\+Binary\+Space\+Tree$<$ Metric\+Type, Statistic\+Type, Mat\+Type, Bound\+Type, Split\+Type $>$\+::\+Dataset().

\index{mlpack\+::tree\+::\+Binary\+Space\+Tree@{mlpack\+::tree\+::\+Binary\+Space\+Tree}!furthest\+Descendant\+Distance@{furthest\+Descendant\+Distance}}
\index{furthest\+Descendant\+Distance@{furthest\+Descendant\+Distance}!mlpack\+::tree\+::\+Binary\+Space\+Tree@{mlpack\+::tree\+::\+Binary\+Space\+Tree}}
\subsubsection[{furthest\+Descendant\+Distance}]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename Metric\+Type , typename Statistic\+Type  = Empty\+Statistic, typename Mat\+Type  = arma\+::mat, template$<$ typename Bound\+Metric\+Type, typename... $>$ class Bound\+Type = bound\+::\+H\+Rect\+Bound, template$<$ typename Split\+Bound\+Type, typename Split\+Mat\+Type $>$ class Split\+Type = Midpoint\+Split$>$ {\bf Elem\+Type} {\bf mlpack\+::tree\+::\+Binary\+Space\+Tree}$<$ Metric\+Type, Statistic\+Type, Mat\+Type, Bound\+Type, Split\+Type $>$\+::furthest\+Descendant\+Distance\hspace{0.3cm}{\ttfamily [private]}}\label{classmlpack_1_1tree_1_1BinarySpaceTree_a5ce6e105067f681d45ff65aaac388c90}


The worst possible distance to the furthest descendant, cached to speed things up. 



Definition at line 85 of file binary\+\_\+space\+\_\+tree.\+hpp.

\index{mlpack\+::tree\+::\+Binary\+Space\+Tree@{mlpack\+::tree\+::\+Binary\+Space\+Tree}!left@{left}}
\index{left@{left}!mlpack\+::tree\+::\+Binary\+Space\+Tree@{mlpack\+::tree\+::\+Binary\+Space\+Tree}}
\subsubsection[{left}]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename Metric\+Type , typename Statistic\+Type  = Empty\+Statistic, typename Mat\+Type  = arma\+::mat, template$<$ typename Bound\+Metric\+Type, typename... $>$ class Bound\+Type = bound\+::\+H\+Rect\+Bound, template$<$ typename Split\+Bound\+Type, typename Split\+Mat\+Type $>$ class Split\+Type = Midpoint\+Split$>$ {\bf Binary\+Space\+Tree}$\ast$ {\bf mlpack\+::tree\+::\+Binary\+Space\+Tree}$<$ Metric\+Type, Statistic\+Type, Mat\+Type, Bound\+Type, Split\+Type $>$\+::left\hspace{0.3cm}{\ttfamily [private]}}\label{classmlpack_1_1tree_1_1BinarySpaceTree_acab6f54be9e548cf8b381a76587e72c5}


The left child node. 



Definition at line 66 of file binary\+\_\+space\+\_\+tree.\+hpp.



Referenced by mlpack\+::tree\+::\+Binary\+Space\+Tree$<$ Metric\+Type, Statistic\+Type, Mat\+Type, Bound\+Type, Split\+Type $>$\+::\+Left().

\index{mlpack\+::tree\+::\+Binary\+Space\+Tree@{mlpack\+::tree\+::\+Binary\+Space\+Tree}!minimum\+Bound\+Distance@{minimum\+Bound\+Distance}}
\index{minimum\+Bound\+Distance@{minimum\+Bound\+Distance}!mlpack\+::tree\+::\+Binary\+Space\+Tree@{mlpack\+::tree\+::\+Binary\+Space\+Tree}}
\subsubsection[{minimum\+Bound\+Distance}]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename Metric\+Type , typename Statistic\+Type  = Empty\+Statistic, typename Mat\+Type  = arma\+::mat, template$<$ typename Bound\+Metric\+Type, typename... $>$ class Bound\+Type = bound\+::\+H\+Rect\+Bound, template$<$ typename Split\+Bound\+Type, typename Split\+Mat\+Type $>$ class Split\+Type = Midpoint\+Split$>$ {\bf Elem\+Type} {\bf mlpack\+::tree\+::\+Binary\+Space\+Tree}$<$ Metric\+Type, Statistic\+Type, Mat\+Type, Bound\+Type, Split\+Type $>$\+::minimum\+Bound\+Distance\hspace{0.3cm}{\ttfamily [private]}}\label{classmlpack_1_1tree_1_1BinarySpaceTree_af1c6cf1c39d8f5fef58ad2b882f15b36}


The minimum distance from the center to any edge of the bound. 



Definition at line 87 of file binary\+\_\+space\+\_\+tree.\+hpp.

\index{mlpack\+::tree\+::\+Binary\+Space\+Tree@{mlpack\+::tree\+::\+Binary\+Space\+Tree}!parent@{parent}}
\index{parent@{parent}!mlpack\+::tree\+::\+Binary\+Space\+Tree@{mlpack\+::tree\+::\+Binary\+Space\+Tree}}
\subsubsection[{parent}]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename Metric\+Type , typename Statistic\+Type  = Empty\+Statistic, typename Mat\+Type  = arma\+::mat, template$<$ typename Bound\+Metric\+Type, typename... $>$ class Bound\+Type = bound\+::\+H\+Rect\+Bound, template$<$ typename Split\+Bound\+Type, typename Split\+Mat\+Type $>$ class Split\+Type = Midpoint\+Split$>$ {\bf Binary\+Space\+Tree}$\ast$ {\bf mlpack\+::tree\+::\+Binary\+Space\+Tree}$<$ Metric\+Type, Statistic\+Type, Mat\+Type, Bound\+Type, Split\+Type $>$\+::parent\hspace{0.3cm}{\ttfamily [private]}}\label{classmlpack_1_1tree_1_1BinarySpaceTree_a5d32df7d289d19f3ac067490633e3073}


The parent node (N\+U\+LL if this is the root of the tree). 



Definition at line 70 of file binary\+\_\+space\+\_\+tree.\+hpp.



Referenced by mlpack\+::tree\+::\+Binary\+Space\+Tree$<$ Metric\+Type, Statistic\+Type, Mat\+Type, Bound\+Type, Split\+Type $>$\+::\+Parent().

\index{mlpack\+::tree\+::\+Binary\+Space\+Tree@{mlpack\+::tree\+::\+Binary\+Space\+Tree}!parent\+Distance@{parent\+Distance}}
\index{parent\+Distance@{parent\+Distance}!mlpack\+::tree\+::\+Binary\+Space\+Tree@{mlpack\+::tree\+::\+Binary\+Space\+Tree}}
\subsubsection[{parent\+Distance}]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename Metric\+Type , typename Statistic\+Type  = Empty\+Statistic, typename Mat\+Type  = arma\+::mat, template$<$ typename Bound\+Metric\+Type, typename... $>$ class Bound\+Type = bound\+::\+H\+Rect\+Bound, template$<$ typename Split\+Bound\+Type, typename Split\+Mat\+Type $>$ class Split\+Type = Midpoint\+Split$>$ {\bf Elem\+Type} {\bf mlpack\+::tree\+::\+Binary\+Space\+Tree}$<$ Metric\+Type, Statistic\+Type, Mat\+Type, Bound\+Type, Split\+Type $>$\+::parent\+Distance\hspace{0.3cm}{\ttfamily [private]}}\label{classmlpack_1_1tree_1_1BinarySpaceTree_a5b75bc715e51a56b80b82303819035a1}


The distance from the centroid of this node to the centroid of the parent. 



Definition at line 82 of file binary\+\_\+space\+\_\+tree.\+hpp.



Referenced by mlpack\+::tree\+::\+Binary\+Space\+Tree$<$ Metric\+Type, Statistic\+Type, Mat\+Type, Bound\+Type, Split\+Type $>$\+::\+Parent\+Distance().

\index{mlpack\+::tree\+::\+Binary\+Space\+Tree@{mlpack\+::tree\+::\+Binary\+Space\+Tree}!right@{right}}
\index{right@{right}!mlpack\+::tree\+::\+Binary\+Space\+Tree@{mlpack\+::tree\+::\+Binary\+Space\+Tree}}
\subsubsection[{right}]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename Metric\+Type , typename Statistic\+Type  = Empty\+Statistic, typename Mat\+Type  = arma\+::mat, template$<$ typename Bound\+Metric\+Type, typename... $>$ class Bound\+Type = bound\+::\+H\+Rect\+Bound, template$<$ typename Split\+Bound\+Type, typename Split\+Mat\+Type $>$ class Split\+Type = Midpoint\+Split$>$ {\bf Binary\+Space\+Tree}$\ast$ {\bf mlpack\+::tree\+::\+Binary\+Space\+Tree}$<$ Metric\+Type, Statistic\+Type, Mat\+Type, Bound\+Type, Split\+Type $>$\+::right\hspace{0.3cm}{\ttfamily [private]}}\label{classmlpack_1_1tree_1_1BinarySpaceTree_a8fe71cdc33cdbe0f740d533d4058fb2e}


The right child node. 



Definition at line 68 of file binary\+\_\+space\+\_\+tree.\+hpp.



Referenced by mlpack\+::tree\+::\+Binary\+Space\+Tree$<$ Metric\+Type, Statistic\+Type, Mat\+Type, Bound\+Type, Split\+Type $>$\+::\+Child\+Ptr(), and mlpack\+::tree\+::\+Binary\+Space\+Tree$<$ Metric\+Type, Statistic\+Type, Mat\+Type, Bound\+Type, Split\+Type $>$\+::\+Right().

\index{mlpack\+::tree\+::\+Binary\+Space\+Tree@{mlpack\+::tree\+::\+Binary\+Space\+Tree}!stat@{stat}}
\index{stat@{stat}!mlpack\+::tree\+::\+Binary\+Space\+Tree@{mlpack\+::tree\+::\+Binary\+Space\+Tree}}
\subsubsection[{stat}]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename Metric\+Type , typename Statistic\+Type  = Empty\+Statistic, typename Mat\+Type  = arma\+::mat, template$<$ typename Bound\+Metric\+Type, typename... $>$ class Bound\+Type = bound\+::\+H\+Rect\+Bound, template$<$ typename Split\+Bound\+Type, typename Split\+Mat\+Type $>$ class Split\+Type = Midpoint\+Split$>$ Statistic\+Type {\bf mlpack\+::tree\+::\+Binary\+Space\+Tree}$<$ Metric\+Type, Statistic\+Type, Mat\+Type, Bound\+Type, Split\+Type $>$\+::stat\hspace{0.3cm}{\ttfamily [private]}}\label{classmlpack_1_1tree_1_1BinarySpaceTree_a5ec54f09a2a94c8735a5b5a8fb19a447}


Any extra data contained in the node. 



Definition at line 80 of file binary\+\_\+space\+\_\+tree.\+hpp.



Referenced by mlpack\+::tree\+::\+Binary\+Space\+Tree$<$ Metric\+Type, Statistic\+Type, Mat\+Type, Bound\+Type, Split\+Type $>$\+::\+Stat().



The documentation for this class was generated from the following file\+:\begin{DoxyCompactItemize}
\item 
src/mlpack/core/tree/binary\+\_\+space\+\_\+tree/{\bf binary\+\_\+space\+\_\+tree.\+hpp}\end{DoxyCompactItemize}
