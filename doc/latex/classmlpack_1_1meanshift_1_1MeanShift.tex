\section{mlpack\+:\+:meanshift\+:\+:Mean\+Shift$<$ Use\+Kernel, Kernel\+Type, Mat\+Type $>$ Class Template Reference}
\label{classmlpack_1_1meanshift_1_1MeanShift}\index{mlpack\+::meanshift\+::\+Mean\+Shift$<$ Use\+Kernel, Kernel\+Type, Mat\+Type $>$@{mlpack\+::meanshift\+::\+Mean\+Shift$<$ Use\+Kernel, Kernel\+Type, Mat\+Type $>$}}


This class implements mean shift clustering.  


\subsection*{Public Member Functions}
\begin{DoxyCompactItemize}
\item 
{\bf Mean\+Shift} (const double {\bf radius}=0, const size\+\_\+t {\bf max\+Iterations}=1000, const Kernel\+Type {\bf kernel}=Kernel\+Type())
\begin{DoxyCompactList}\small\item\em Create a mean shift object and set the parameters which mean shift will be run with. \end{DoxyCompactList}\item 
void {\bf Cluster} (const Mat\+Type \&data, arma\+::\+Col$<$ size\+\_\+t $>$ \&assignments, arma\+::mat \&centroids, bool use\+Seeds=true)
\begin{DoxyCompactList}\small\item\em Perform mean shift clustering on the data, returning a list of cluster assignments and centroids. \end{DoxyCompactList}\item 
double {\bf Estimate\+Radius} (const Mat\+Type \&data, const double ratio=0.\+2)
\begin{DoxyCompactList}\small\item\em Give an estimation of radius based on given dataset. \end{DoxyCompactList}\item 
const Kernel\+Type \& {\bf Kernel} () const 
\begin{DoxyCompactList}\small\item\em Get the kernel. \end{DoxyCompactList}\item 
Kernel\+Type \& {\bf Kernel} ()
\begin{DoxyCompactList}\small\item\em Modify the kernel. \end{DoxyCompactList}\item 
size\+\_\+t {\bf Max\+Iterations} () const 
\begin{DoxyCompactList}\small\item\em Get the maximum number of iterations. \end{DoxyCompactList}\item 
size\+\_\+t \& {\bf Max\+Iterations} ()
\begin{DoxyCompactList}\small\item\em Set the maximum number of iterations. \end{DoxyCompactList}\item 
double {\bf Radius} () const 
\begin{DoxyCompactList}\small\item\em Get the radius. \end{DoxyCompactList}\item 
void {\bf Radius} (double {\bf radius})
\begin{DoxyCompactList}\small\item\em Set the radius. \end{DoxyCompactList}\end{DoxyCompactItemize}
\subsection*{Private Member Functions}
\begin{DoxyCompactItemize}
\item 
{\footnotesize template$<$bool Apply\+Kernel = Use\+Kernel$>$ }\\std\+::enable\+\_\+if$<$ Apply\+Kernel, bool $>$\+::type {\bf Calculate\+Centroid} (const Mat\+Type \&data, const std\+::vector$<$ size\+\_\+t $>$ \&neighbors, const std\+::vector$<$ double $>$ \&distances, arma\+::colvec \&centroid)
\begin{DoxyCompactList}\small\item\em Use kernel to calculate new centroid given dataset and valid neighbors. \end{DoxyCompactList}\item 
{\footnotesize template$<$bool Apply\+Kernel = Use\+Kernel$>$ }\\std\+::enable\+\_\+if$<$!Apply\+Kernel, bool $>$\+::type {\bf Calculate\+Centroid} (const Mat\+Type \&data, const std\+::vector$<$ size\+\_\+t $>$ \&neighbors, const std\+::vector$<$ double $>$ \&, arma\+::colvec \&centroid)
\begin{DoxyCompactList}\small\item\em Use mean to calculate new centroid given dataset and valid neighbors. \end{DoxyCompactList}\item 
void {\bf Gen\+Seeds} (const Mat\+Type \&data, const double bin\+Size, const int min\+Freq, Mat\+Type \&seeds)
\begin{DoxyCompactList}\small\item\em To speed up, we can generate some seeds from data set and use them as initial centroids rather than all the points in the data set. \end{DoxyCompactList}\end{DoxyCompactItemize}
\subsection*{Private Attributes}
\begin{DoxyCompactItemize}
\item 
Kernel\+Type {\bf kernel}
\begin{DoxyCompactList}\small\item\em Instantiated kernel. \end{DoxyCompactList}\item 
size\+\_\+t {\bf max\+Iterations}
\begin{DoxyCompactList}\small\item\em Maximum number of iterations before giving up. \end{DoxyCompactList}\item 
double {\bf radius}
\begin{DoxyCompactList}\small\item\em If distance of two centroids is less than radius, one will be removed. \end{DoxyCompactList}\end{DoxyCompactItemize}


\subsection{Detailed Description}
\subsubsection*{template$<$bool Use\+Kernel = false, typename Kernel\+Type = kernel\+::\+Gaussian\+Kernel, typename Mat\+Type = arma\+::mat$>$\\*
class mlpack\+::meanshift\+::\+Mean\+Shift$<$ Use\+Kernel, Kernel\+Type, Mat\+Type $>$}

This class implements mean shift clustering. 

For each point in dataset, apply mean shift algorithm until maximum iterations or convergence. Then remove duplicate centroids.

A simple example of how to run mean shift clustering is shown below.


\begin{DoxyCode}
\textcolor{keyword}{extern} arma::mat data; \textcolor{comment}{// Dataset we want to run mean shift on.}
arma::Col<size\_t> assignments; \textcolor{comment}{// Cluster assignments.}
arma::mat centroids; \textcolor{comment}{// Cluster centroids.}

MeanShift<> meanShift();
meanShift.Cluster(dataset, assignments, centroids);
\end{DoxyCode}



\begin{DoxyTemplParams}{Template Parameters}
{\em Use\+Kernel} & Use kernel or mean to calculate new centroid. If false, Kernel\+Type will be ignored. \\
\hline
{\em Kernel\+Type} & The kernel to use. \\
\hline
{\em Mat\+Type} & The type of matrix the data is stored in. \\
\hline
\end{DoxyTemplParams}


Definition at line 49 of file mean\+\_\+shift.\+hpp.



\subsection{Constructor \& Destructor Documentation}
\index{mlpack\+::meanshift\+::\+Mean\+Shift@{mlpack\+::meanshift\+::\+Mean\+Shift}!Mean\+Shift@{Mean\+Shift}}
\index{Mean\+Shift@{Mean\+Shift}!mlpack\+::meanshift\+::\+Mean\+Shift@{mlpack\+::meanshift\+::\+Mean\+Shift}}
\subsubsection[{Mean\+Shift(const double radius=0, const size\+\_\+t max\+Iterations=1000, const Kernel\+Type kernel=\+Kernel\+Type())}]{\setlength{\rightskip}{0pt plus 5cm}template$<$bool Use\+Kernel = false, typename Kernel\+Type  = kernel\+::\+Gaussian\+Kernel, typename Mat\+Type  = arma\+::mat$>$ {\bf mlpack\+::meanshift\+::\+Mean\+Shift}$<$ Use\+Kernel, Kernel\+Type, Mat\+Type $>$\+::{\bf Mean\+Shift} (
\begin{DoxyParamCaption}
\item[{const double}]{radius = {\ttfamily 0}, }
\item[{const size\+\_\+t}]{max\+Iterations = {\ttfamily 1000}, }
\item[{const Kernel\+Type}]{kernel = {\ttfamily KernelType()}}
\end{DoxyParamCaption}
)}\label{classmlpack_1_1meanshift_1_1MeanShift_a7096a27c13dcae8541e3c34794af9b8c}


Create a mean shift object and set the parameters which mean shift will be run with. 


\begin{DoxyParams}{Parameters}
{\em radius} & If distance of two centroids is less than it, one will be removed. If this value isn\textquotesingle{}t positive, an estimation will be given when clustering. \\
\hline
{\em max\+Iterations} & Maximum number of iterations allowed before giving up iterations will terminate. \\
\hline
{\em kernel} & Optional Kernel\+Type object. \\
\hline
\end{DoxyParams}


\subsection{Member Function Documentation}
\index{mlpack\+::meanshift\+::\+Mean\+Shift@{mlpack\+::meanshift\+::\+Mean\+Shift}!Calculate\+Centroid@{Calculate\+Centroid}}
\index{Calculate\+Centroid@{Calculate\+Centroid}!mlpack\+::meanshift\+::\+Mean\+Shift@{mlpack\+::meanshift\+::\+Mean\+Shift}}
\subsubsection[{Calculate\+Centroid(const Mat\+Type \&data, const std\+::vector$<$ size\+\_\+t $>$ \&neighbors, const std\+::vector$<$ double $>$ \&distances, arma\+::colvec \&centroid)}]{\setlength{\rightskip}{0pt plus 5cm}template$<$bool Use\+Kernel = false, typename Kernel\+Type  = kernel\+::\+Gaussian\+Kernel, typename Mat\+Type  = arma\+::mat$>$ template$<$bool Apply\+Kernel = Use\+Kernel$>$ std\+::enable\+\_\+if$<$Apply\+Kernel, bool$>$\+::type {\bf mlpack\+::meanshift\+::\+Mean\+Shift}$<$ Use\+Kernel, Kernel\+Type, Mat\+Type $>$\+::Calculate\+Centroid (
\begin{DoxyParamCaption}
\item[{const Mat\+Type \&}]{data, }
\item[{const std\+::vector$<$ size\+\_\+t $>$ \&}]{neighbors, }
\item[{const std\+::vector$<$ double $>$ \&}]{distances, }
\item[{arma\+::colvec \&}]{centroid}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [private]}}\label{classmlpack_1_1meanshift_1_1MeanShift_aaeed62034a5df967dcae5e2a8e57f0f4}


Use kernel to calculate new centroid given dataset and valid neighbors. 


\begin{DoxyParams}{Parameters}
{\em data} & The whole dataset \\
\hline
{\em neighbors} & Valid neighbors \\
\hline
{\em distances} & Distances to neighbors \subsection*{centroid Store calculated centroid}\\
\hline
\end{DoxyParams}


Referenced by mlpack\+::meanshift\+::\+Mean\+Shift$<$ Use\+Kernel, Kernel\+Type, Mat\+Type $>$\+::\+Kernel().

\index{mlpack\+::meanshift\+::\+Mean\+Shift@{mlpack\+::meanshift\+::\+Mean\+Shift}!Calculate\+Centroid@{Calculate\+Centroid}}
\index{Calculate\+Centroid@{Calculate\+Centroid}!mlpack\+::meanshift\+::\+Mean\+Shift@{mlpack\+::meanshift\+::\+Mean\+Shift}}
\subsubsection[{Calculate\+Centroid(const Mat\+Type \&data, const std\+::vector$<$ size\+\_\+t $>$ \&neighbors, const std\+::vector$<$ double $>$ \&, arma\+::colvec \&centroid)}]{\setlength{\rightskip}{0pt plus 5cm}template$<$bool Use\+Kernel = false, typename Kernel\+Type  = kernel\+::\+Gaussian\+Kernel, typename Mat\+Type  = arma\+::mat$>$ template$<$bool Apply\+Kernel = Use\+Kernel$>$ std\+::enable\+\_\+if$<$!Apply\+Kernel, bool$>$\+::type {\bf mlpack\+::meanshift\+::\+Mean\+Shift}$<$ Use\+Kernel, Kernel\+Type, Mat\+Type $>$\+::Calculate\+Centroid (
\begin{DoxyParamCaption}
\item[{const Mat\+Type \&}]{data, }
\item[{const std\+::vector$<$ size\+\_\+t $>$ \&}]{neighbors, }
\item[{const std\+::vector$<$ double $>$ \&}]{, }
\item[{arma\+::colvec \&}]{centroid}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [private]}}\label{classmlpack_1_1meanshift_1_1MeanShift_aa518abec0854f7f4ac9244ff5d3d4910}


Use mean to calculate new centroid given dataset and valid neighbors. 


\begin{DoxyParams}{Parameters}
{\em data} & The whole dataset \\
\hline
{\em neighbors} & Valid neighbors \\
\hline
{\em distances} & Distances to neighbors \subsection*{centroid Store calculated centroid}\\
\hline
\end{DoxyParams}
\index{mlpack\+::meanshift\+::\+Mean\+Shift@{mlpack\+::meanshift\+::\+Mean\+Shift}!Cluster@{Cluster}}
\index{Cluster@{Cluster}!mlpack\+::meanshift\+::\+Mean\+Shift@{mlpack\+::meanshift\+::\+Mean\+Shift}}
\subsubsection[{Cluster(const Mat\+Type \&data, arma\+::\+Col$<$ size\+\_\+t $>$ \&assignments, arma\+::mat \&centroids, bool use\+Seeds=true)}]{\setlength{\rightskip}{0pt plus 5cm}template$<$bool Use\+Kernel = false, typename Kernel\+Type  = kernel\+::\+Gaussian\+Kernel, typename Mat\+Type  = arma\+::mat$>$ void {\bf mlpack\+::meanshift\+::\+Mean\+Shift}$<$ Use\+Kernel, Kernel\+Type, Mat\+Type $>$\+::Cluster (
\begin{DoxyParamCaption}
\item[{const Mat\+Type \&}]{data, }
\item[{arma\+::\+Col$<$ size\+\_\+t $>$ \&}]{assignments, }
\item[{arma\+::mat \&}]{centroids, }
\item[{bool}]{use\+Seeds = {\ttfamily true}}
\end{DoxyParamCaption}
)}\label{classmlpack_1_1meanshift_1_1MeanShift_a634cc8cb47c41dba7c53cb568a954806}


Perform mean shift clustering on the data, returning a list of cluster assignments and centroids. 


\begin{DoxyTemplParams}{Template Parameters}
{\em Mat\+Type} & Type of matrix. \\
\hline
\end{DoxyTemplParams}

\begin{DoxyParams}{Parameters}
{\em data} & Dataset to cluster. \\
\hline
{\em assignments} & Vector to store cluster assignments in. \\
\hline
{\em centroids} & Matrix in which centroids are stored. \\
\hline
\end{DoxyParams}
\index{mlpack\+::meanshift\+::\+Mean\+Shift@{mlpack\+::meanshift\+::\+Mean\+Shift}!Estimate\+Radius@{Estimate\+Radius}}
\index{Estimate\+Radius@{Estimate\+Radius}!mlpack\+::meanshift\+::\+Mean\+Shift@{mlpack\+::meanshift\+::\+Mean\+Shift}}
\subsubsection[{Estimate\+Radius(const Mat\+Type \&data, const double ratio=0.\+2)}]{\setlength{\rightskip}{0pt plus 5cm}template$<$bool Use\+Kernel = false, typename Kernel\+Type  = kernel\+::\+Gaussian\+Kernel, typename Mat\+Type  = arma\+::mat$>$ double {\bf mlpack\+::meanshift\+::\+Mean\+Shift}$<$ Use\+Kernel, Kernel\+Type, Mat\+Type $>$\+::Estimate\+Radius (
\begin{DoxyParamCaption}
\item[{const Mat\+Type \&}]{data, }
\item[{const double}]{ratio = {\ttfamily 0.2}}
\end{DoxyParamCaption}
)}\label{classmlpack_1_1meanshift_1_1MeanShift_af0bf781763e805cdc361e38fc536b0db}


Give an estimation of radius based on given dataset. 


\begin{DoxyParams}{Parameters}
{\em data} & Dataset for estimation. \\
\hline
{\em ratio} & Percentage of dataset to use for nearest neighbor search. \\
\hline
\end{DoxyParams}
\index{mlpack\+::meanshift\+::\+Mean\+Shift@{mlpack\+::meanshift\+::\+Mean\+Shift}!Gen\+Seeds@{Gen\+Seeds}}
\index{Gen\+Seeds@{Gen\+Seeds}!mlpack\+::meanshift\+::\+Mean\+Shift@{mlpack\+::meanshift\+::\+Mean\+Shift}}
\subsubsection[{Gen\+Seeds(const Mat\+Type \&data, const double bin\+Size, const int min\+Freq, Mat\+Type \&seeds)}]{\setlength{\rightskip}{0pt plus 5cm}template$<$bool Use\+Kernel = false, typename Kernel\+Type  = kernel\+::\+Gaussian\+Kernel, typename Mat\+Type  = arma\+::mat$>$ void {\bf mlpack\+::meanshift\+::\+Mean\+Shift}$<$ Use\+Kernel, Kernel\+Type, Mat\+Type $>$\+::Gen\+Seeds (
\begin{DoxyParamCaption}
\item[{const Mat\+Type \&}]{data, }
\item[{const double}]{bin\+Size, }
\item[{const int}]{min\+Freq, }
\item[{Mat\+Type \&}]{seeds}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [private]}}\label{classmlpack_1_1meanshift_1_1MeanShift_a49525d3a9a710c8e0329ba7f77d19d64}


To speed up, we can generate some seeds from data set and use them as initial centroids rather than all the points in the data set. 

The basic idea here is that we will place our points into hypercube bins of side length bin\+Size, and any bins that contain fewer than min\+Freq points will be removed as possible seeds. Usually, 1 is a sufficient parameter for min\+Freq, and the bin size can be set equal to the estimated radius.


\begin{DoxyParams}{Parameters}
{\em data} & The reference data set. \\
\hline
{\em bin\+Size} & Width of hypercube bins. \\
\hline
{\em min\+Freq} & Minimum number of points in bin. \\
\hline
{\em seed} & Matrix to store generated seeds in. \\
\hline
\end{DoxyParams}


Referenced by mlpack\+::meanshift\+::\+Mean\+Shift$<$ Use\+Kernel, Kernel\+Type, Mat\+Type $>$\+::\+Kernel().

\index{mlpack\+::meanshift\+::\+Mean\+Shift@{mlpack\+::meanshift\+::\+Mean\+Shift}!Kernel@{Kernel}}
\index{Kernel@{Kernel}!mlpack\+::meanshift\+::\+Mean\+Shift@{mlpack\+::meanshift\+::\+Mean\+Shift}}
\subsubsection[{Kernel() const }]{\setlength{\rightskip}{0pt plus 5cm}template$<$bool Use\+Kernel = false, typename Kernel\+Type  = kernel\+::\+Gaussian\+Kernel, typename Mat\+Type  = arma\+::mat$>$ const Kernel\+Type\& {\bf mlpack\+::meanshift\+::\+Mean\+Shift}$<$ Use\+Kernel, Kernel\+Type, Mat\+Type $>$\+::Kernel (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
) const\hspace{0.3cm}{\ttfamily [inline]}}\label{classmlpack_1_1meanshift_1_1MeanShift_a83f62187a300936a8901be14aceff2a9}


Get the kernel. 



Definition at line 100 of file mean\+\_\+shift.\+hpp.



References mlpack\+::meanshift\+::\+Mean\+Shift$<$ Use\+Kernel, Kernel\+Type, Mat\+Type $>$\+::kernel.

\index{mlpack\+::meanshift\+::\+Mean\+Shift@{mlpack\+::meanshift\+::\+Mean\+Shift}!Kernel@{Kernel}}
\index{Kernel@{Kernel}!mlpack\+::meanshift\+::\+Mean\+Shift@{mlpack\+::meanshift\+::\+Mean\+Shift}}
\subsubsection[{Kernel()}]{\setlength{\rightskip}{0pt plus 5cm}template$<$bool Use\+Kernel = false, typename Kernel\+Type  = kernel\+::\+Gaussian\+Kernel, typename Mat\+Type  = arma\+::mat$>$ Kernel\+Type\& {\bf mlpack\+::meanshift\+::\+Mean\+Shift}$<$ Use\+Kernel, Kernel\+Type, Mat\+Type $>$\+::Kernel (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}}\label{classmlpack_1_1meanshift_1_1MeanShift_ac29accd0bc21add072fad9b4e6a3893e}


Modify the kernel. 



Definition at line 102 of file mean\+\_\+shift.\+hpp.



References mlpack\+::meanshift\+::\+Mean\+Shift$<$ Use\+Kernel, Kernel\+Type, Mat\+Type $>$\+::\+Calculate\+Centroid(), mlpack\+::meanshift\+::\+Mean\+Shift$<$ Use\+Kernel, Kernel\+Type, Mat\+Type $>$\+::\+Gen\+Seeds(), and mlpack\+::meanshift\+::\+Mean\+Shift$<$ Use\+Kernel, Kernel\+Type, Mat\+Type $>$\+::kernel.

\index{mlpack\+::meanshift\+::\+Mean\+Shift@{mlpack\+::meanshift\+::\+Mean\+Shift}!Max\+Iterations@{Max\+Iterations}}
\index{Max\+Iterations@{Max\+Iterations}!mlpack\+::meanshift\+::\+Mean\+Shift@{mlpack\+::meanshift\+::\+Mean\+Shift}}
\subsubsection[{Max\+Iterations() const }]{\setlength{\rightskip}{0pt plus 5cm}template$<$bool Use\+Kernel = false, typename Kernel\+Type  = kernel\+::\+Gaussian\+Kernel, typename Mat\+Type  = arma\+::mat$>$ size\+\_\+t {\bf mlpack\+::meanshift\+::\+Mean\+Shift}$<$ Use\+Kernel, Kernel\+Type, Mat\+Type $>$\+::Max\+Iterations (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
) const\hspace{0.3cm}{\ttfamily [inline]}}\label{classmlpack_1_1meanshift_1_1MeanShift_a639165a033c556224b044704bcf5f812}


Get the maximum number of iterations. 



Definition at line 90 of file mean\+\_\+shift.\+hpp.



References mlpack\+::meanshift\+::\+Mean\+Shift$<$ Use\+Kernel, Kernel\+Type, Mat\+Type $>$\+::max\+Iterations.

\index{mlpack\+::meanshift\+::\+Mean\+Shift@{mlpack\+::meanshift\+::\+Mean\+Shift}!Max\+Iterations@{Max\+Iterations}}
\index{Max\+Iterations@{Max\+Iterations}!mlpack\+::meanshift\+::\+Mean\+Shift@{mlpack\+::meanshift\+::\+Mean\+Shift}}
\subsubsection[{Max\+Iterations()}]{\setlength{\rightskip}{0pt plus 5cm}template$<$bool Use\+Kernel = false, typename Kernel\+Type  = kernel\+::\+Gaussian\+Kernel, typename Mat\+Type  = arma\+::mat$>$ size\+\_\+t\& {\bf mlpack\+::meanshift\+::\+Mean\+Shift}$<$ Use\+Kernel, Kernel\+Type, Mat\+Type $>$\+::Max\+Iterations (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}}\label{classmlpack_1_1meanshift_1_1MeanShift_a542a7b9f360106cea4b7c549d3dcb3c6}


Set the maximum number of iterations. 



Definition at line 92 of file mean\+\_\+shift.\+hpp.



References mlpack\+::meanshift\+::\+Mean\+Shift$<$ Use\+Kernel, Kernel\+Type, Mat\+Type $>$\+::max\+Iterations.

\index{mlpack\+::meanshift\+::\+Mean\+Shift@{mlpack\+::meanshift\+::\+Mean\+Shift}!Radius@{Radius}}
\index{Radius@{Radius}!mlpack\+::meanshift\+::\+Mean\+Shift@{mlpack\+::meanshift\+::\+Mean\+Shift}}
\subsubsection[{Radius() const }]{\setlength{\rightskip}{0pt plus 5cm}template$<$bool Use\+Kernel = false, typename Kernel\+Type  = kernel\+::\+Gaussian\+Kernel, typename Mat\+Type  = arma\+::mat$>$ double {\bf mlpack\+::meanshift\+::\+Mean\+Shift}$<$ Use\+Kernel, Kernel\+Type, Mat\+Type $>$\+::Radius (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
) const\hspace{0.3cm}{\ttfamily [inline]}}\label{classmlpack_1_1meanshift_1_1MeanShift_aac1698b2653c2c00494ecfc6775e6652}


Get the radius. 



Definition at line 95 of file mean\+\_\+shift.\+hpp.



References mlpack\+::meanshift\+::\+Mean\+Shift$<$ Use\+Kernel, Kernel\+Type, Mat\+Type $>$\+::radius.

\index{mlpack\+::meanshift\+::\+Mean\+Shift@{mlpack\+::meanshift\+::\+Mean\+Shift}!Radius@{Radius}}
\index{Radius@{Radius}!mlpack\+::meanshift\+::\+Mean\+Shift@{mlpack\+::meanshift\+::\+Mean\+Shift}}
\subsubsection[{Radius(double radius)}]{\setlength{\rightskip}{0pt plus 5cm}template$<$bool Use\+Kernel = false, typename Kernel\+Type  = kernel\+::\+Gaussian\+Kernel, typename Mat\+Type  = arma\+::mat$>$ void {\bf mlpack\+::meanshift\+::\+Mean\+Shift}$<$ Use\+Kernel, Kernel\+Type, Mat\+Type $>$\+::Radius (
\begin{DoxyParamCaption}
\item[{double}]{radius}
\end{DoxyParamCaption}
)}\label{classmlpack_1_1meanshift_1_1MeanShift_a1625924f23373fa556be03e0f73c8138}


Set the radius. 



\subsection{Member Data Documentation}
\index{mlpack\+::meanshift\+::\+Mean\+Shift@{mlpack\+::meanshift\+::\+Mean\+Shift}!kernel@{kernel}}
\index{kernel@{kernel}!mlpack\+::meanshift\+::\+Mean\+Shift@{mlpack\+::meanshift\+::\+Mean\+Shift}}
\subsubsection[{kernel}]{\setlength{\rightskip}{0pt plus 5cm}template$<$bool Use\+Kernel = false, typename Kernel\+Type  = kernel\+::\+Gaussian\+Kernel, typename Mat\+Type  = arma\+::mat$>$ Kernel\+Type {\bf mlpack\+::meanshift\+::\+Mean\+Shift}$<$ Use\+Kernel, Kernel\+Type, Mat\+Type $>$\+::kernel\hspace{0.3cm}{\ttfamily [private]}}\label{classmlpack_1_1meanshift_1_1MeanShift_a1afba2513233536f47117a7b86e8384b}


Instantiated kernel. 



Definition at line 164 of file mean\+\_\+shift.\+hpp.



Referenced by mlpack\+::meanshift\+::\+Mean\+Shift$<$ Use\+Kernel, Kernel\+Type, Mat\+Type $>$\+::\+Kernel().

\index{mlpack\+::meanshift\+::\+Mean\+Shift@{mlpack\+::meanshift\+::\+Mean\+Shift}!max\+Iterations@{max\+Iterations}}
\index{max\+Iterations@{max\+Iterations}!mlpack\+::meanshift\+::\+Mean\+Shift@{mlpack\+::meanshift\+::\+Mean\+Shift}}
\subsubsection[{max\+Iterations}]{\setlength{\rightskip}{0pt plus 5cm}template$<$bool Use\+Kernel = false, typename Kernel\+Type  = kernel\+::\+Gaussian\+Kernel, typename Mat\+Type  = arma\+::mat$>$ size\+\_\+t {\bf mlpack\+::meanshift\+::\+Mean\+Shift}$<$ Use\+Kernel, Kernel\+Type, Mat\+Type $>$\+::max\+Iterations\hspace{0.3cm}{\ttfamily [private]}}\label{classmlpack_1_1meanshift_1_1MeanShift_ad84529171961bfad9b63e9c0bf76384f}


Maximum number of iterations before giving up. 



Definition at line 161 of file mean\+\_\+shift.\+hpp.



Referenced by mlpack\+::meanshift\+::\+Mean\+Shift$<$ Use\+Kernel, Kernel\+Type, Mat\+Type $>$\+::\+Max\+Iterations().

\index{mlpack\+::meanshift\+::\+Mean\+Shift@{mlpack\+::meanshift\+::\+Mean\+Shift}!radius@{radius}}
\index{radius@{radius}!mlpack\+::meanshift\+::\+Mean\+Shift@{mlpack\+::meanshift\+::\+Mean\+Shift}}
\subsubsection[{radius}]{\setlength{\rightskip}{0pt plus 5cm}template$<$bool Use\+Kernel = false, typename Kernel\+Type  = kernel\+::\+Gaussian\+Kernel, typename Mat\+Type  = arma\+::mat$>$ double {\bf mlpack\+::meanshift\+::\+Mean\+Shift}$<$ Use\+Kernel, Kernel\+Type, Mat\+Type $>$\+::radius\hspace{0.3cm}{\ttfamily [private]}}\label{classmlpack_1_1meanshift_1_1MeanShift_ac58cdbc587030f79cb05658d0221a88a}


If distance of two centroids is less than radius, one will be removed. 

Points with distance to current centroid less than radius will be used to calculate new centroid. 

Definition at line 158 of file mean\+\_\+shift.\+hpp.



Referenced by mlpack\+::meanshift\+::\+Mean\+Shift$<$ Use\+Kernel, Kernel\+Type, Mat\+Type $>$\+::\+Radius().



The documentation for this class was generated from the following file\+:\begin{DoxyCompactItemize}
\item 
src/mlpack/methods/mean\+\_\+shift/{\bf mean\+\_\+shift.\+hpp}\end{DoxyCompactItemize}
