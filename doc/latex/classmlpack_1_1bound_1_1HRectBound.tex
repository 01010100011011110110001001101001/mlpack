\section{mlpack\+:\+:bound\+:\+:H\+Rect\+Bound$<$ Metric\+Type, Elem\+Type $>$ Class Template Reference}
\label{classmlpack_1_1bound_1_1HRectBound}\index{mlpack\+::bound\+::\+H\+Rect\+Bound$<$ Metric\+Type, Elem\+Type $>$@{mlpack\+::bound\+::\+H\+Rect\+Bound$<$ Metric\+Type, Elem\+Type $>$}}


Hyper-\/rectangle bound for an L-\/metric.  




Inheritance diagram for mlpack\+:\+:bound\+:\+:H\+Rect\+Bound$<$ Metric\+Type, Elem\+Type $>$\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{classmlpack_1_1bound_1_1HRectBound__inherit__graph}
\end{center}
\end{figure}
\subsection*{Public Member Functions}
\begin{DoxyCompactItemize}
\item 
{\bf H\+Rect\+Bound} ()
\begin{DoxyCompactList}\small\item\em Empty constructor; creates a bound of dimensionality 0. \end{DoxyCompactList}\item 
{\bf H\+Rect\+Bound} (const size\+\_\+t dimension)
\begin{DoxyCompactList}\small\item\em Initializes to specified dimensionality with each dimension the empty set. \end{DoxyCompactList}\item 
{\bf H\+Rect\+Bound} (const {\bf H\+Rect\+Bound} \&other)
\begin{DoxyCompactList}\small\item\em Copy constructor; necessary to prevent memory leaks. \end{DoxyCompactList}\item 
{\bf H\+Rect\+Bound} ({\bf H\+Rect\+Bound} \&\&other)
\begin{DoxyCompactList}\small\item\em Move constructor\+: take possession of another bound\textquotesingle{}s information. \end{DoxyCompactList}\item 
{\bf $\sim$\+H\+Rect\+Bound} ()
\begin{DoxyCompactList}\small\item\em Destructor\+: clean up memory. \end{DoxyCompactList}\item 
void {\bf Center} (arma\+::\+Col$<$ Elem\+Type $>$ \&center) const 
\begin{DoxyCompactList}\small\item\em Calculates the center of the range, placing it into the given vector. \end{DoxyCompactList}\item 
void {\bf Clear} ()
\begin{DoxyCompactList}\small\item\em Resets all dimensions to the empty set (so that this bound contains nothing). \end{DoxyCompactList}\item 
{\footnotesize template$<$typename Vec\+Type $>$ }\\bool {\bf Contains} (const Vec\+Type \&point) const 
\begin{DoxyCompactList}\small\item\em Determines if a point is within this bound. \end{DoxyCompactList}\item 
bool {\bf Contains} (const {\bf H\+Rect\+Bound} \&bound) const 
\begin{DoxyCompactList}\small\item\em Determines if this bound partially contains a bound. \end{DoxyCompactList}\item 
Elem\+Type {\bf Diameter} () const 
\begin{DoxyCompactList}\small\item\em Returns the diameter of the hyperrectangle (that is, the longest diagonal). \end{DoxyCompactList}\item 
size\+\_\+t {\bf Dim} () const 
\begin{DoxyCompactList}\small\item\em Gets the dimensionality. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename Vec\+Type $>$ }\\Elem\+Type {\bf Max\+Distance} (const Vec\+Type \&point, typename {\bf std\+::enable\+\_\+if\+\_\+t}$<$ {\bf Is\+Vector}$<$ Vec\+Type $>$\+::value $>$ $\ast$=0) const 
\begin{DoxyCompactList}\small\item\em Calculates maximum bound-\/to-\/point squared distance. \end{DoxyCompactList}\item 
Elem\+Type {\bf Max\+Distance} (const {\bf H\+Rect\+Bound} \&other) const 
\begin{DoxyCompactList}\small\item\em Computes maximum distance. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename Vec\+Type $>$ }\\Elem\+Type {\bf Min\+Distance} (const Vec\+Type \&point, typename {\bf std\+::enable\+\_\+if\+\_\+t}$<$ {\bf Is\+Vector}$<$ Vec\+Type $>$\+::value $>$ $\ast$=0) const 
\begin{DoxyCompactList}\small\item\em Calculates minimum bound-\/to-\/point distance. \end{DoxyCompactList}\item 
Elem\+Type {\bf Min\+Distance} (const {\bf H\+Rect\+Bound} \&other) const 
\begin{DoxyCompactList}\small\item\em Calculates minimum bound-\/to-\/bound distance. \end{DoxyCompactList}\item 
Elem\+Type {\bf Min\+Width} () const 
\begin{DoxyCompactList}\small\item\em Get the minimum width of the bound. \end{DoxyCompactList}\item 
Elem\+Type \& {\bf Min\+Width} ()
\begin{DoxyCompactList}\small\item\em Modify the minimum width of the bound. \end{DoxyCompactList}\item 
{\bf H\+Rect\+Bound} {\bf operator\&} (const {\bf H\+Rect\+Bound} \&bound) const 
\begin{DoxyCompactList}\small\item\em Returns the intersection of this bound and another. \end{DoxyCompactList}\item 
{\bf H\+Rect\+Bound} \& {\bf operator\&=} (const {\bf H\+Rect\+Bound} \&bound)
\begin{DoxyCompactList}\small\item\em Intersects this bound with another. \end{DoxyCompactList}\item 
{\bf H\+Rect\+Bound} \& {\bf operator=} (const {\bf H\+Rect\+Bound} \&other)
\begin{DoxyCompactList}\small\item\em Same as copy constructor; necessary to prevent memory leaks. \end{DoxyCompactList}\item 
{\bf math\+::\+Range\+Type}$<$ Elem\+Type $>$ \& {\bf operator[$\,$]} (const size\+\_\+t i)
\begin{DoxyCompactList}\small\item\em Get the range for a particular dimension. \end{DoxyCompactList}\item 
const {\bf math\+::\+Range\+Type}$<$ Elem\+Type $>$ \& {\bf operator[$\,$]} (const size\+\_\+t i) const 
\begin{DoxyCompactList}\small\item\em Modify the range for a particular dimension. No bounds checking. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename Mat\+Type $>$ }\\{\bf H\+Rect\+Bound} \& {\bf operator$\vert$=} (const Mat\+Type \&data)
\begin{DoxyCompactList}\small\item\em Expands this region to include new points. \end{DoxyCompactList}\item 
{\bf H\+Rect\+Bound} \& {\bf operator$\vert$=} (const {\bf H\+Rect\+Bound} \&other)
\begin{DoxyCompactList}\small\item\em Expands this region to encompass another bound. \end{DoxyCompactList}\item 
Elem\+Type {\bf Overlap} (const {\bf H\+Rect\+Bound} \&bound) const 
\begin{DoxyCompactList}\small\item\em Returns the volume of overlap of this bound and another. \end{DoxyCompactList}\item 
{\bf math\+::\+Range\+Type}$<$ Elem\+Type $>$ {\bf Range\+Distance} (const {\bf H\+Rect\+Bound} \&other) const 
\begin{DoxyCompactList}\small\item\em Calculates minimum and maximum bound-\/to-\/bound distance. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename Vec\+Type $>$ }\\{\bf math\+::\+Range\+Type}$<$ Elem\+Type $>$ {\bf Range\+Distance} (const Vec\+Type \&point, typename {\bf std\+::enable\+\_\+if\+\_\+t}$<$ {\bf Is\+Vector}$<$ Vec\+Type $>$\+::value $>$ $\ast$=0) const 
\begin{DoxyCompactList}\small\item\em Calculates minimum and maximum bound-\/to-\/point distance. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename Archive $>$ }\\void {\bf Serialize} (Archive \&ar, const unsigned int version)
\begin{DoxyCompactList}\small\item\em Serialize the bound object. \end{DoxyCompactList}\item 
Elem\+Type {\bf Volume} () const 
\begin{DoxyCompactList}\small\item\em Calculate the volume of the hyperrectangle. \end{DoxyCompactList}\end{DoxyCompactItemize}
\subsection*{Private Attributes}
\begin{DoxyCompactItemize}
\item 
{\bf math\+::\+Range\+Type}$<$ Elem\+Type $>$ $\ast$ {\bf bounds}
\begin{DoxyCompactList}\small\item\em The bounds for each dimension. \end{DoxyCompactList}\item 
size\+\_\+t {\bf dim}
\begin{DoxyCompactList}\small\item\em The dimensionality of the bound. \end{DoxyCompactList}\item 
Elem\+Type {\bf min\+Width}
\begin{DoxyCompactList}\small\item\em Cached minimum width of bound. \end{DoxyCompactList}\end{DoxyCompactItemize}


\subsection{Detailed Description}
\subsubsection*{template$<$typename Metric\+Type = metric\+::\+L\+Metric$<$2, true$>$, typename Elem\+Type = double$>$\\*
class mlpack\+::bound\+::\+H\+Rect\+Bound$<$ Metric\+Type, Elem\+Type $>$}

Hyper-\/rectangle bound for an L-\/metric. 

This should be used in conjunction with the L\+Metric class. Be sure to use the same template parameters for L\+Metric as you do for \doxyref{H\+Rect\+Bound}{p.}{classmlpack_1_1bound_1_1HRectBound} -- otherwise odd results may occur.


\begin{DoxyTemplParams}{Template Parameters}
{\em Metric\+Type} & Type of metric to use; must be of type L\+Metric. \\
\hline
{\em Elem\+Type} & Element type (double/float/int/etc.). \\
\hline
\end{DoxyTemplParams}


Definition at line 54 of file hrectbound.\+hpp.



\subsection{Constructor \& Destructor Documentation}
\index{mlpack\+::bound\+::\+H\+Rect\+Bound@{mlpack\+::bound\+::\+H\+Rect\+Bound}!H\+Rect\+Bound@{H\+Rect\+Bound}}
\index{H\+Rect\+Bound@{H\+Rect\+Bound}!mlpack\+::bound\+::\+H\+Rect\+Bound@{mlpack\+::bound\+::\+H\+Rect\+Bound}}
\subsubsection[{H\+Rect\+Bound()}]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename Metric\+Type = metric\+::\+L\+Metric$<$2, true$>$, typename Elem\+Type = double$>$ {\bf mlpack\+::bound\+::\+H\+Rect\+Bound}$<$ Metric\+Type, Elem\+Type $>$\+::{\bf H\+Rect\+Bound} (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)}\label{classmlpack_1_1bound_1_1HRectBound_a7849495ec67b4173c77ed1561bbf0139}


Empty constructor; creates a bound of dimensionality 0. 

\index{mlpack\+::bound\+::\+H\+Rect\+Bound@{mlpack\+::bound\+::\+H\+Rect\+Bound}!H\+Rect\+Bound@{H\+Rect\+Bound}}
\index{H\+Rect\+Bound@{H\+Rect\+Bound}!mlpack\+::bound\+::\+H\+Rect\+Bound@{mlpack\+::bound\+::\+H\+Rect\+Bound}}
\subsubsection[{H\+Rect\+Bound(const size\+\_\+t dimension)}]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename Metric\+Type = metric\+::\+L\+Metric$<$2, true$>$, typename Elem\+Type = double$>$ {\bf mlpack\+::bound\+::\+H\+Rect\+Bound}$<$ Metric\+Type, Elem\+Type $>$\+::{\bf H\+Rect\+Bound} (
\begin{DoxyParamCaption}
\item[{const size\+\_\+t}]{dimension}
\end{DoxyParamCaption}
)}\label{classmlpack_1_1bound_1_1HRectBound_ae97a6b35d5dd299742b190288b91bb04}


Initializes to specified dimensionality with each dimension the empty set. 

\index{mlpack\+::bound\+::\+H\+Rect\+Bound@{mlpack\+::bound\+::\+H\+Rect\+Bound}!H\+Rect\+Bound@{H\+Rect\+Bound}}
\index{H\+Rect\+Bound@{H\+Rect\+Bound}!mlpack\+::bound\+::\+H\+Rect\+Bound@{mlpack\+::bound\+::\+H\+Rect\+Bound}}
\subsubsection[{H\+Rect\+Bound(const H\+Rect\+Bound \&other)}]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename Metric\+Type = metric\+::\+L\+Metric$<$2, true$>$, typename Elem\+Type = double$>$ {\bf mlpack\+::bound\+::\+H\+Rect\+Bound}$<$ Metric\+Type, Elem\+Type $>$\+::{\bf H\+Rect\+Bound} (
\begin{DoxyParamCaption}
\item[{const {\bf H\+Rect\+Bound}$<$ Metric\+Type, Elem\+Type $>$ \&}]{other}
\end{DoxyParamCaption}
)}\label{classmlpack_1_1bound_1_1HRectBound_a59989c5667ad4c47d26f8076ed782691}


Copy constructor; necessary to prevent memory leaks. 

\index{mlpack\+::bound\+::\+H\+Rect\+Bound@{mlpack\+::bound\+::\+H\+Rect\+Bound}!H\+Rect\+Bound@{H\+Rect\+Bound}}
\index{H\+Rect\+Bound@{H\+Rect\+Bound}!mlpack\+::bound\+::\+H\+Rect\+Bound@{mlpack\+::bound\+::\+H\+Rect\+Bound}}
\subsubsection[{H\+Rect\+Bound(\+H\+Rect\+Bound \&\&other)}]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename Metric\+Type = metric\+::\+L\+Metric$<$2, true$>$, typename Elem\+Type = double$>$ {\bf mlpack\+::bound\+::\+H\+Rect\+Bound}$<$ Metric\+Type, Elem\+Type $>$\+::{\bf H\+Rect\+Bound} (
\begin{DoxyParamCaption}
\item[{{\bf H\+Rect\+Bound}$<$ Metric\+Type, Elem\+Type $>$ \&\&}]{other}
\end{DoxyParamCaption}
)}\label{classmlpack_1_1bound_1_1HRectBound_a11c7ffc300b01cffc275f3fd27d65d7b}


Move constructor\+: take possession of another bound\textquotesingle{}s information. 

\index{mlpack\+::bound\+::\+H\+Rect\+Bound@{mlpack\+::bound\+::\+H\+Rect\+Bound}!````~H\+Rect\+Bound@{$\sim$\+H\+Rect\+Bound}}
\index{````~H\+Rect\+Bound@{$\sim$\+H\+Rect\+Bound}!mlpack\+::bound\+::\+H\+Rect\+Bound@{mlpack\+::bound\+::\+H\+Rect\+Bound}}
\subsubsection[{$\sim$\+H\+Rect\+Bound()}]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename Metric\+Type = metric\+::\+L\+Metric$<$2, true$>$, typename Elem\+Type = double$>$ {\bf mlpack\+::bound\+::\+H\+Rect\+Bound}$<$ Metric\+Type, Elem\+Type $>$\+::$\sim${\bf H\+Rect\+Bound} (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)}\label{classmlpack_1_1bound_1_1HRectBound_abea4f8eee5140670331b4d0d3afa7d2c}


Destructor\+: clean up memory. 



\subsection{Member Function Documentation}
\index{mlpack\+::bound\+::\+H\+Rect\+Bound@{mlpack\+::bound\+::\+H\+Rect\+Bound}!Center@{Center}}
\index{Center@{Center}!mlpack\+::bound\+::\+H\+Rect\+Bound@{mlpack\+::bound\+::\+H\+Rect\+Bound}}
\subsubsection[{Center(arma\+::\+Col$<$ Elem\+Type $>$ \&center) const }]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename Metric\+Type = metric\+::\+L\+Metric$<$2, true$>$, typename Elem\+Type = double$>$ void {\bf mlpack\+::bound\+::\+H\+Rect\+Bound}$<$ Metric\+Type, Elem\+Type $>$\+::Center (
\begin{DoxyParamCaption}
\item[{arma\+::\+Col$<$ Elem\+Type $>$ \&}]{center}
\end{DoxyParamCaption}
) const}\label{classmlpack_1_1bound_1_1HRectBound_ab1b554dff9988b1cb42ddf56ac0b50c4}


Calculates the center of the range, placing it into the given vector. 


\begin{DoxyParams}{Parameters}
{\em center} & Vector which the center will be written to. \\
\hline
\end{DoxyParams}


Referenced by mlpack\+::tree\+::\+Rectangle\+Tree$<$ Metric\+Type, Statistic\+Type, Mat\+Type, Split\+Type, Descent\+Type, Auxiliary\+Information\+Type $>$\+::\+Center(), and mlpack\+::tree\+::\+Octree$<$ Metric\+Type, Statistic\+Type, Mat\+Type $>$\+::\+Center().

\index{mlpack\+::bound\+::\+H\+Rect\+Bound@{mlpack\+::bound\+::\+H\+Rect\+Bound}!Clear@{Clear}}
\index{Clear@{Clear}!mlpack\+::bound\+::\+H\+Rect\+Bound@{mlpack\+::bound\+::\+H\+Rect\+Bound}}
\subsubsection[{Clear()}]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename Metric\+Type = metric\+::\+L\+Metric$<$2, true$>$, typename Elem\+Type = double$>$ void {\bf mlpack\+::bound\+::\+H\+Rect\+Bound}$<$ Metric\+Type, Elem\+Type $>$\+::Clear (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)}\label{classmlpack_1_1bound_1_1HRectBound_a7225cb0def075ca37b6c42a57a3f93ca}


Resets all dimensions to the empty set (so that this bound contains nothing). 

\index{mlpack\+::bound\+::\+H\+Rect\+Bound@{mlpack\+::bound\+::\+H\+Rect\+Bound}!Contains@{Contains}}
\index{Contains@{Contains}!mlpack\+::bound\+::\+H\+Rect\+Bound@{mlpack\+::bound\+::\+H\+Rect\+Bound}}
\subsubsection[{Contains(const Vec\+Type \&point) const }]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename Metric\+Type = metric\+::\+L\+Metric$<$2, true$>$, typename Elem\+Type = double$>$ template$<$typename Vec\+Type $>$ bool {\bf mlpack\+::bound\+::\+H\+Rect\+Bound}$<$ Metric\+Type, Elem\+Type $>$\+::Contains (
\begin{DoxyParamCaption}
\item[{const Vec\+Type \&}]{point}
\end{DoxyParamCaption}
) const}\label{classmlpack_1_1bound_1_1HRectBound_aae1da0abdbb86b27908d8bddf43c1855}


Determines if a point is within this bound. 

\index{mlpack\+::bound\+::\+H\+Rect\+Bound@{mlpack\+::bound\+::\+H\+Rect\+Bound}!Contains@{Contains}}
\index{Contains@{Contains}!mlpack\+::bound\+::\+H\+Rect\+Bound@{mlpack\+::bound\+::\+H\+Rect\+Bound}}
\subsubsection[{Contains(const H\+Rect\+Bound \&bound) const }]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename Metric\+Type = metric\+::\+L\+Metric$<$2, true$>$, typename Elem\+Type = double$>$ bool {\bf mlpack\+::bound\+::\+H\+Rect\+Bound}$<$ Metric\+Type, Elem\+Type $>$\+::Contains (
\begin{DoxyParamCaption}
\item[{const {\bf H\+Rect\+Bound}$<$ Metric\+Type, Elem\+Type $>$ \&}]{bound}
\end{DoxyParamCaption}
) const}\label{classmlpack_1_1bound_1_1HRectBound_a5a8c9ac48126696093c9f5ec7f3db0f8}


Determines if this bound partially contains a bound. 

\index{mlpack\+::bound\+::\+H\+Rect\+Bound@{mlpack\+::bound\+::\+H\+Rect\+Bound}!Diameter@{Diameter}}
\index{Diameter@{Diameter}!mlpack\+::bound\+::\+H\+Rect\+Bound@{mlpack\+::bound\+::\+H\+Rect\+Bound}}
\subsubsection[{Diameter() const }]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename Metric\+Type = metric\+::\+L\+Metric$<$2, true$>$, typename Elem\+Type = double$>$ Elem\+Type {\bf mlpack\+::bound\+::\+H\+Rect\+Bound}$<$ Metric\+Type, Elem\+Type $>$\+::Diameter (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
) const}\label{classmlpack_1_1bound_1_1HRectBound_a9f5a5acc60b647953068fc924a7b3de8}


Returns the diameter of the hyperrectangle (that is, the longest diagonal). 

\index{mlpack\+::bound\+::\+H\+Rect\+Bound@{mlpack\+::bound\+::\+H\+Rect\+Bound}!Dim@{Dim}}
\index{Dim@{Dim}!mlpack\+::bound\+::\+H\+Rect\+Bound@{mlpack\+::bound\+::\+H\+Rect\+Bound}}
\subsubsection[{Dim() const }]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename Metric\+Type = metric\+::\+L\+Metric$<$2, true$>$, typename Elem\+Type = double$>$ size\+\_\+t {\bf mlpack\+::bound\+::\+H\+Rect\+Bound}$<$ Metric\+Type, Elem\+Type $>$\+::Dim (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
) const\hspace{0.3cm}{\ttfamily [inline]}}\label{classmlpack_1_1bound_1_1HRectBound_a8c7b2e30979dbd7b483721ffd8407e8c}


Gets the dimensionality. 



Definition at line 90 of file hrectbound.\+hpp.

\index{mlpack\+::bound\+::\+H\+Rect\+Bound@{mlpack\+::bound\+::\+H\+Rect\+Bound}!Max\+Distance@{Max\+Distance}}
\index{Max\+Distance@{Max\+Distance}!mlpack\+::bound\+::\+H\+Rect\+Bound@{mlpack\+::bound\+::\+H\+Rect\+Bound}}
\subsubsection[{Max\+Distance(const Vec\+Type \&point, typename std\+::enable\+\_\+if\+\_\+t$<$ Is\+Vector$<$ Vec\+Type $>$\+::value $>$ $\ast$=0) const }]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename Metric\+Type = metric\+::\+L\+Metric$<$2, true$>$, typename Elem\+Type = double$>$ template$<$typename Vec\+Type $>$ Elem\+Type {\bf mlpack\+::bound\+::\+H\+Rect\+Bound}$<$ Metric\+Type, Elem\+Type $>$\+::Max\+Distance (
\begin{DoxyParamCaption}
\item[{const Vec\+Type \&}]{point, }
\item[{typename {\bf std\+::enable\+\_\+if\+\_\+t}$<$ {\bf Is\+Vector}$<$ Vec\+Type $>$\+::value $>$ $\ast$}]{ = {\ttfamily 0}}
\end{DoxyParamCaption}
) const}\label{classmlpack_1_1bound_1_1HRectBound_ae68fbe401588fc248371dc76517c7b5c}


Calculates maximum bound-\/to-\/point squared distance. 


\begin{DoxyParams}{Parameters}
{\em point} & Point to which the maximum distance is requested. \\
\hline
\end{DoxyParams}


Referenced by mlpack\+::tree\+::\+Rectangle\+Tree$<$ Metric\+Type, Statistic\+Type, Mat\+Type, Split\+Type, Descent\+Type, Auxiliary\+Information\+Type $>$\+::\+Max\+Distance().

\index{mlpack\+::bound\+::\+H\+Rect\+Bound@{mlpack\+::bound\+::\+H\+Rect\+Bound}!Max\+Distance@{Max\+Distance}}
\index{Max\+Distance@{Max\+Distance}!mlpack\+::bound\+::\+H\+Rect\+Bound@{mlpack\+::bound\+::\+H\+Rect\+Bound}}
\subsubsection[{Max\+Distance(const H\+Rect\+Bound \&other) const }]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename Metric\+Type = metric\+::\+L\+Metric$<$2, true$>$, typename Elem\+Type = double$>$ Elem\+Type {\bf mlpack\+::bound\+::\+H\+Rect\+Bound}$<$ Metric\+Type, Elem\+Type $>$\+::Max\+Distance (
\begin{DoxyParamCaption}
\item[{const {\bf H\+Rect\+Bound}$<$ Metric\+Type, Elem\+Type $>$ \&}]{other}
\end{DoxyParamCaption}
) const}\label{classmlpack_1_1bound_1_1HRectBound_adb66fb1753871f4a03c50cf4fb709e8c}


Computes maximum distance. 


\begin{DoxyParams}{Parameters}
{\em other} & Bound to which the maximum distance is requested. \\
\hline
\end{DoxyParams}
\index{mlpack\+::bound\+::\+H\+Rect\+Bound@{mlpack\+::bound\+::\+H\+Rect\+Bound}!Min\+Distance@{Min\+Distance}}
\index{Min\+Distance@{Min\+Distance}!mlpack\+::bound\+::\+H\+Rect\+Bound@{mlpack\+::bound\+::\+H\+Rect\+Bound}}
\subsubsection[{Min\+Distance(const Vec\+Type \&point, typename std\+::enable\+\_\+if\+\_\+t$<$ Is\+Vector$<$ Vec\+Type $>$\+::value $>$ $\ast$=0) const }]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename Metric\+Type = metric\+::\+L\+Metric$<$2, true$>$, typename Elem\+Type = double$>$ template$<$typename Vec\+Type $>$ Elem\+Type {\bf mlpack\+::bound\+::\+H\+Rect\+Bound}$<$ Metric\+Type, Elem\+Type $>$\+::Min\+Distance (
\begin{DoxyParamCaption}
\item[{const Vec\+Type \&}]{point, }
\item[{typename {\bf std\+::enable\+\_\+if\+\_\+t}$<$ {\bf Is\+Vector}$<$ Vec\+Type $>$\+::value $>$ $\ast$}]{ = {\ttfamily 0}}
\end{DoxyParamCaption}
) const}\label{classmlpack_1_1bound_1_1HRectBound_aaea70c9638f5123e3d83c1322fbdd721}


Calculates minimum bound-\/to-\/point distance. 


\begin{DoxyParams}{Parameters}
{\em point} & Point to which the minimum distance is requested. \\
\hline
\end{DoxyParams}


Referenced by mlpack\+::tree\+::\+Rectangle\+Tree$<$ Metric\+Type, Statistic\+Type, Mat\+Type, Split\+Type, Descent\+Type, Auxiliary\+Information\+Type $>$\+::\+Min\+Distance().

\index{mlpack\+::bound\+::\+H\+Rect\+Bound@{mlpack\+::bound\+::\+H\+Rect\+Bound}!Min\+Distance@{Min\+Distance}}
\index{Min\+Distance@{Min\+Distance}!mlpack\+::bound\+::\+H\+Rect\+Bound@{mlpack\+::bound\+::\+H\+Rect\+Bound}}
\subsubsection[{Min\+Distance(const H\+Rect\+Bound \&other) const }]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename Metric\+Type = metric\+::\+L\+Metric$<$2, true$>$, typename Elem\+Type = double$>$ Elem\+Type {\bf mlpack\+::bound\+::\+H\+Rect\+Bound}$<$ Metric\+Type, Elem\+Type $>$\+::Min\+Distance (
\begin{DoxyParamCaption}
\item[{const {\bf H\+Rect\+Bound}$<$ Metric\+Type, Elem\+Type $>$ \&}]{other}
\end{DoxyParamCaption}
) const}\label{classmlpack_1_1bound_1_1HRectBound_ac3f469c5b97a1900d9d235f53db17e10}


Calculates minimum bound-\/to-\/bound distance. 


\begin{DoxyParams}{Parameters}
{\em other} & Bound to which the minimum distance is requested. \\
\hline
\end{DoxyParams}
\index{mlpack\+::bound\+::\+H\+Rect\+Bound@{mlpack\+::bound\+::\+H\+Rect\+Bound}!Min\+Width@{Min\+Width}}
\index{Min\+Width@{Min\+Width}!mlpack\+::bound\+::\+H\+Rect\+Bound@{mlpack\+::bound\+::\+H\+Rect\+Bound}}
\subsubsection[{Min\+Width() const }]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename Metric\+Type = metric\+::\+L\+Metric$<$2, true$>$, typename Elem\+Type = double$>$ Elem\+Type {\bf mlpack\+::bound\+::\+H\+Rect\+Bound}$<$ Metric\+Type, Elem\+Type $>$\+::Min\+Width (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
) const\hspace{0.3cm}{\ttfamily [inline]}}\label{classmlpack_1_1bound_1_1HRectBound_a00ac407e260373af5490aa57f879a892}


Get the minimum width of the bound. 



Definition at line 100 of file hrectbound.\+hpp.



Referenced by mlpack\+::tree\+::\+Rectangle\+Tree$<$ Metric\+Type, Statistic\+Type, Mat\+Type, Split\+Type, Descent\+Type, Auxiliary\+Information\+Type $>$\+::\+Minimum\+Bound\+Distance().

\index{mlpack\+::bound\+::\+H\+Rect\+Bound@{mlpack\+::bound\+::\+H\+Rect\+Bound}!Min\+Width@{Min\+Width}}
\index{Min\+Width@{Min\+Width}!mlpack\+::bound\+::\+H\+Rect\+Bound@{mlpack\+::bound\+::\+H\+Rect\+Bound}}
\subsubsection[{Min\+Width()}]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename Metric\+Type = metric\+::\+L\+Metric$<$2, true$>$, typename Elem\+Type = double$>$ Elem\+Type\& {\bf mlpack\+::bound\+::\+H\+Rect\+Bound}$<$ Metric\+Type, Elem\+Type $>$\+::Min\+Width (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}}\label{classmlpack_1_1bound_1_1HRectBound_a1f96e4e87ad18cea349cb2b4e4d43d06}


Modify the minimum width of the bound. 



Definition at line 102 of file hrectbound.\+hpp.

\index{mlpack\+::bound\+::\+H\+Rect\+Bound@{mlpack\+::bound\+::\+H\+Rect\+Bound}!operator\&@{operator\&}}
\index{operator\&@{operator\&}!mlpack\+::bound\+::\+H\+Rect\+Bound@{mlpack\+::bound\+::\+H\+Rect\+Bound}}
\subsubsection[{operator\&(const H\+Rect\+Bound \&bound) const }]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename Metric\+Type = metric\+::\+L\+Metric$<$2, true$>$, typename Elem\+Type = double$>$ {\bf H\+Rect\+Bound} {\bf mlpack\+::bound\+::\+H\+Rect\+Bound}$<$ Metric\+Type, Elem\+Type $>$\+::operator\& (
\begin{DoxyParamCaption}
\item[{const {\bf H\+Rect\+Bound}$<$ Metric\+Type, Elem\+Type $>$ \&}]{bound}
\end{DoxyParamCaption}
) const}\label{classmlpack_1_1bound_1_1HRectBound_a69925c7af964171f2a2f3e55cd46e06e}


Returns the intersection of this bound and another. 

\index{mlpack\+::bound\+::\+H\+Rect\+Bound@{mlpack\+::bound\+::\+H\+Rect\+Bound}!operator\&=@{operator\&=}}
\index{operator\&=@{operator\&=}!mlpack\+::bound\+::\+H\+Rect\+Bound@{mlpack\+::bound\+::\+H\+Rect\+Bound}}
\subsubsection[{operator\&=(const H\+Rect\+Bound \&bound)}]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename Metric\+Type = metric\+::\+L\+Metric$<$2, true$>$, typename Elem\+Type = double$>$ {\bf H\+Rect\+Bound}\& {\bf mlpack\+::bound\+::\+H\+Rect\+Bound}$<$ Metric\+Type, Elem\+Type $>$\+::operator\&= (
\begin{DoxyParamCaption}
\item[{const {\bf H\+Rect\+Bound}$<$ Metric\+Type, Elem\+Type $>$ \&}]{bound}
\end{DoxyParamCaption}
)}\label{classmlpack_1_1bound_1_1HRectBound_a39c9285e39a56a9b633494e3d05bcafe}


Intersects this bound with another. 

\index{mlpack\+::bound\+::\+H\+Rect\+Bound@{mlpack\+::bound\+::\+H\+Rect\+Bound}!operator=@{operator=}}
\index{operator=@{operator=}!mlpack\+::bound\+::\+H\+Rect\+Bound@{mlpack\+::bound\+::\+H\+Rect\+Bound}}
\subsubsection[{operator=(const H\+Rect\+Bound \&other)}]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename Metric\+Type = metric\+::\+L\+Metric$<$2, true$>$, typename Elem\+Type = double$>$ {\bf H\+Rect\+Bound}\& {\bf mlpack\+::bound\+::\+H\+Rect\+Bound}$<$ Metric\+Type, Elem\+Type $>$\+::operator= (
\begin{DoxyParamCaption}
\item[{const {\bf H\+Rect\+Bound}$<$ Metric\+Type, Elem\+Type $>$ \&}]{other}
\end{DoxyParamCaption}
)}\label{classmlpack_1_1bound_1_1HRectBound_a78d1fde04fc5d71d5d303ec2d0592b93}


Same as copy constructor; necessary to prevent memory leaks. 

\index{mlpack\+::bound\+::\+H\+Rect\+Bound@{mlpack\+::bound\+::\+H\+Rect\+Bound}!operator[$\,$]@{operator[]}}
\index{operator[$\,$]@{operator[]}!mlpack\+::bound\+::\+H\+Rect\+Bound@{mlpack\+::bound\+::\+H\+Rect\+Bound}}
\subsubsection[{operator[](const size\+\_\+t i)}]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename Metric\+Type = metric\+::\+L\+Metric$<$2, true$>$, typename Elem\+Type = double$>$ {\bf math\+::\+Range\+Type}$<$Elem\+Type$>$\& {\bf mlpack\+::bound\+::\+H\+Rect\+Bound}$<$ Metric\+Type, Elem\+Type $>$\+::operator[$\,$] (
\begin{DoxyParamCaption}
\item[{const size\+\_\+t}]{i}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}}\label{classmlpack_1_1bound_1_1HRectBound_ab8fec960cc08494d0d77cb08d1eae736}


Get the range for a particular dimension. 

No bounds checking. Be careful\+: this may make \doxyref{Min\+Width()}{p.}{classmlpack_1_1bound_1_1HRectBound_a1f96e4e87ad18cea349cb2b4e4d43d06} invalid. 

Definition at line 94 of file hrectbound.\+hpp.

\index{mlpack\+::bound\+::\+H\+Rect\+Bound@{mlpack\+::bound\+::\+H\+Rect\+Bound}!operator[$\,$]@{operator[]}}
\index{operator[$\,$]@{operator[]}!mlpack\+::bound\+::\+H\+Rect\+Bound@{mlpack\+::bound\+::\+H\+Rect\+Bound}}
\subsubsection[{operator[](const size\+\_\+t i) const }]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename Metric\+Type = metric\+::\+L\+Metric$<$2, true$>$, typename Elem\+Type = double$>$ const {\bf math\+::\+Range\+Type}$<$Elem\+Type$>$\& {\bf mlpack\+::bound\+::\+H\+Rect\+Bound}$<$ Metric\+Type, Elem\+Type $>$\+::operator[$\,$] (
\begin{DoxyParamCaption}
\item[{const size\+\_\+t}]{i}
\end{DoxyParamCaption}
) const\hspace{0.3cm}{\ttfamily [inline]}}\label{classmlpack_1_1bound_1_1HRectBound_a43cee085e1a73b10fa83daf390b0e86d}


Modify the range for a particular dimension. No bounds checking. 



Definition at line 96 of file hrectbound.\+hpp.

\index{mlpack\+::bound\+::\+H\+Rect\+Bound@{mlpack\+::bound\+::\+H\+Rect\+Bound}!operator\texttt{"|}=@{operator\texttt{"|}=}}
\index{operator\texttt{"|}=@{operator\texttt{"|}=}!mlpack\+::bound\+::\+H\+Rect\+Bound@{mlpack\+::bound\+::\+H\+Rect\+Bound}}
\subsubsection[{operator\texttt{"|}=(const Mat\+Type \&data)}]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename Metric\+Type = metric\+::\+L\+Metric$<$2, true$>$, typename Elem\+Type = double$>$ template$<$typename Mat\+Type $>$ {\bf H\+Rect\+Bound}\& {\bf mlpack\+::bound\+::\+H\+Rect\+Bound}$<$ Metric\+Type, Elem\+Type $>$\+::operator$\vert$= (
\begin{DoxyParamCaption}
\item[{const Mat\+Type \&}]{data}
\end{DoxyParamCaption}
)}\label{classmlpack_1_1bound_1_1HRectBound_af7c4cc88ead1ab897c6069da5da5babb}


Expands this region to include new points. 


\begin{DoxyTemplParams}{Template Parameters}
{\em Mat\+Type} & Type of matrix; could be Mat, Sp\+Mat, a subview, or just a vector. \\
\hline
\end{DoxyTemplParams}

\begin{DoxyParams}{Parameters}
{\em data} & Data points to expand this region to include. \\
\hline
\end{DoxyParams}
\index{mlpack\+::bound\+::\+H\+Rect\+Bound@{mlpack\+::bound\+::\+H\+Rect\+Bound}!operator\texttt{"|}=@{operator\texttt{"|}=}}
\index{operator\texttt{"|}=@{operator\texttt{"|}=}!mlpack\+::bound\+::\+H\+Rect\+Bound@{mlpack\+::bound\+::\+H\+Rect\+Bound}}
\subsubsection[{operator\texttt{"|}=(const H\+Rect\+Bound \&other)}]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename Metric\+Type = metric\+::\+L\+Metric$<$2, true$>$, typename Elem\+Type = double$>$ {\bf H\+Rect\+Bound}\& {\bf mlpack\+::bound\+::\+H\+Rect\+Bound}$<$ Metric\+Type, Elem\+Type $>$\+::operator$\vert$= (
\begin{DoxyParamCaption}
\item[{const {\bf H\+Rect\+Bound}$<$ Metric\+Type, Elem\+Type $>$ \&}]{other}
\end{DoxyParamCaption}
)}\label{classmlpack_1_1bound_1_1HRectBound_a17237d2c86a069c58ab8efef25f215a5}


Expands this region to encompass another bound. 

\index{mlpack\+::bound\+::\+H\+Rect\+Bound@{mlpack\+::bound\+::\+H\+Rect\+Bound}!Overlap@{Overlap}}
\index{Overlap@{Overlap}!mlpack\+::bound\+::\+H\+Rect\+Bound@{mlpack\+::bound\+::\+H\+Rect\+Bound}}
\subsubsection[{Overlap(const H\+Rect\+Bound \&bound) const }]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename Metric\+Type = metric\+::\+L\+Metric$<$2, true$>$, typename Elem\+Type = double$>$ Elem\+Type {\bf mlpack\+::bound\+::\+H\+Rect\+Bound}$<$ Metric\+Type, Elem\+Type $>$\+::Overlap (
\begin{DoxyParamCaption}
\item[{const {\bf H\+Rect\+Bound}$<$ Metric\+Type, Elem\+Type $>$ \&}]{bound}
\end{DoxyParamCaption}
) const}\label{classmlpack_1_1bound_1_1HRectBound_a5579214d3bd322e01e6824077fce376a}


Returns the volume of overlap of this bound and another. 

\index{mlpack\+::bound\+::\+H\+Rect\+Bound@{mlpack\+::bound\+::\+H\+Rect\+Bound}!Range\+Distance@{Range\+Distance}}
\index{Range\+Distance@{Range\+Distance}!mlpack\+::bound\+::\+H\+Rect\+Bound@{mlpack\+::bound\+::\+H\+Rect\+Bound}}
\subsubsection[{Range\+Distance(const H\+Rect\+Bound \&other) const }]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename Metric\+Type = metric\+::\+L\+Metric$<$2, true$>$, typename Elem\+Type = double$>$ {\bf math\+::\+Range\+Type}$<$Elem\+Type$>$ {\bf mlpack\+::bound\+::\+H\+Rect\+Bound}$<$ Metric\+Type, Elem\+Type $>$\+::Range\+Distance (
\begin{DoxyParamCaption}
\item[{const {\bf H\+Rect\+Bound}$<$ Metric\+Type, Elem\+Type $>$ \&}]{other}
\end{DoxyParamCaption}
) const}\label{classmlpack_1_1bound_1_1HRectBound_a924c37907ab98cf2ac658abd983bc576}


Calculates minimum and maximum bound-\/to-\/bound distance. 


\begin{DoxyParams}{Parameters}
{\em other} & Bound to which the minimum and maximum distances are requested. \\
\hline
\end{DoxyParams}


Referenced by mlpack\+::tree\+::\+Rectangle\+Tree$<$ Metric\+Type, Statistic\+Type, Mat\+Type, Split\+Type, Descent\+Type, Auxiliary\+Information\+Type $>$\+::\+Range\+Distance().

\index{mlpack\+::bound\+::\+H\+Rect\+Bound@{mlpack\+::bound\+::\+H\+Rect\+Bound}!Range\+Distance@{Range\+Distance}}
\index{Range\+Distance@{Range\+Distance}!mlpack\+::bound\+::\+H\+Rect\+Bound@{mlpack\+::bound\+::\+H\+Rect\+Bound}}
\subsubsection[{Range\+Distance(const Vec\+Type \&point, typename std\+::enable\+\_\+if\+\_\+t$<$ Is\+Vector$<$ Vec\+Type $>$\+::value $>$ $\ast$=0) const }]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename Metric\+Type = metric\+::\+L\+Metric$<$2, true$>$, typename Elem\+Type = double$>$ template$<$typename Vec\+Type $>$ {\bf math\+::\+Range\+Type}$<$Elem\+Type$>$ {\bf mlpack\+::bound\+::\+H\+Rect\+Bound}$<$ Metric\+Type, Elem\+Type $>$\+::Range\+Distance (
\begin{DoxyParamCaption}
\item[{const Vec\+Type \&}]{point, }
\item[{typename {\bf std\+::enable\+\_\+if\+\_\+t}$<$ {\bf Is\+Vector}$<$ Vec\+Type $>$\+::value $>$ $\ast$}]{ = {\ttfamily 0}}
\end{DoxyParamCaption}
) const}\label{classmlpack_1_1bound_1_1HRectBound_ab0922db32cb17f3d50b999855e1ae548}


Calculates minimum and maximum bound-\/to-\/point distance. 


\begin{DoxyParams}{Parameters}
{\em point} & Point to which the minimum and maximum distances are requested. \\
\hline
\end{DoxyParams}
\index{mlpack\+::bound\+::\+H\+Rect\+Bound@{mlpack\+::bound\+::\+H\+Rect\+Bound}!Serialize@{Serialize}}
\index{Serialize@{Serialize}!mlpack\+::bound\+::\+H\+Rect\+Bound@{mlpack\+::bound\+::\+H\+Rect\+Bound}}
\subsubsection[{Serialize(\+Archive \&ar, const unsigned int version)}]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename Metric\+Type = metric\+::\+L\+Metric$<$2, true$>$, typename Elem\+Type = double$>$ template$<$typename Archive $>$ void {\bf mlpack\+::bound\+::\+H\+Rect\+Bound}$<$ Metric\+Type, Elem\+Type $>$\+::Serialize (
\begin{DoxyParamCaption}
\item[{Archive \&}]{ar, }
\item[{const unsigned int}]{version}
\end{DoxyParamCaption}
)}\label{classmlpack_1_1bound_1_1HRectBound_a22b55e4bc300c5dfdf43265630ed9fe8}


Serialize the bound object. 

\index{mlpack\+::bound\+::\+H\+Rect\+Bound@{mlpack\+::bound\+::\+H\+Rect\+Bound}!Volume@{Volume}}
\index{Volume@{Volume}!mlpack\+::bound\+::\+H\+Rect\+Bound@{mlpack\+::bound\+::\+H\+Rect\+Bound}}
\subsubsection[{Volume() const }]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename Metric\+Type = metric\+::\+L\+Metric$<$2, true$>$, typename Elem\+Type = double$>$ Elem\+Type {\bf mlpack\+::bound\+::\+H\+Rect\+Bound}$<$ Metric\+Type, Elem\+Type $>$\+::Volume (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
) const}\label{classmlpack_1_1bound_1_1HRectBound_a329adc60ec2ad2b31a538e06aae2afdb}


Calculate the volume of the hyperrectangle. 

\begin{DoxyReturn}{Returns}
Volume of the hyperrectangle. 
\end{DoxyReturn}


\subsection{Member Data Documentation}
\index{mlpack\+::bound\+::\+H\+Rect\+Bound@{mlpack\+::bound\+::\+H\+Rect\+Bound}!bounds@{bounds}}
\index{bounds@{bounds}!mlpack\+::bound\+::\+H\+Rect\+Bound@{mlpack\+::bound\+::\+H\+Rect\+Bound}}
\subsubsection[{bounds}]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename Metric\+Type = metric\+::\+L\+Metric$<$2, true$>$, typename Elem\+Type = double$>$ {\bf math\+::\+Range\+Type}$<$Elem\+Type$>$$\ast$ {\bf mlpack\+::bound\+::\+H\+Rect\+Bound}$<$ Metric\+Type, Elem\+Type $>$\+::bounds\hspace{0.3cm}{\ttfamily [private]}}\label{classmlpack_1_1bound_1_1HRectBound_a96b248175ef3a7febeb727b6b215c128}


The bounds for each dimension. 



Definition at line 227 of file hrectbound.\+hpp.

\index{mlpack\+::bound\+::\+H\+Rect\+Bound@{mlpack\+::bound\+::\+H\+Rect\+Bound}!dim@{dim}}
\index{dim@{dim}!mlpack\+::bound\+::\+H\+Rect\+Bound@{mlpack\+::bound\+::\+H\+Rect\+Bound}}
\subsubsection[{dim}]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename Metric\+Type = metric\+::\+L\+Metric$<$2, true$>$, typename Elem\+Type = double$>$ size\+\_\+t {\bf mlpack\+::bound\+::\+H\+Rect\+Bound}$<$ Metric\+Type, Elem\+Type $>$\+::dim\hspace{0.3cm}{\ttfamily [private]}}\label{classmlpack_1_1bound_1_1HRectBound_a251168b43839929f825ad7ffde339614}


The dimensionality of the bound. 



Definition at line 225 of file hrectbound.\+hpp.

\index{mlpack\+::bound\+::\+H\+Rect\+Bound@{mlpack\+::bound\+::\+H\+Rect\+Bound}!min\+Width@{min\+Width}}
\index{min\+Width@{min\+Width}!mlpack\+::bound\+::\+H\+Rect\+Bound@{mlpack\+::bound\+::\+H\+Rect\+Bound}}
\subsubsection[{min\+Width}]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename Metric\+Type = metric\+::\+L\+Metric$<$2, true$>$, typename Elem\+Type = double$>$ Elem\+Type {\bf mlpack\+::bound\+::\+H\+Rect\+Bound}$<$ Metric\+Type, Elem\+Type $>$\+::min\+Width\hspace{0.3cm}{\ttfamily [private]}}\label{classmlpack_1_1bound_1_1HRectBound_a5057297738a7dff66d599b1275977112}


Cached minimum width of bound. 



Definition at line 229 of file hrectbound.\+hpp.



The documentation for this class was generated from the following file\+:\begin{DoxyCompactItemize}
\item 
src/mlpack/core/tree/{\bf hrectbound.\+hpp}\end{DoxyCompactItemize}
