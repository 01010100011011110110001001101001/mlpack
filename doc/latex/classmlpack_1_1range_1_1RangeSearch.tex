\section{mlpack\+:\+:range\+:\+:Range\+Search$<$ Metric\+Type, Mat\+Type, Tree\+Type $>$ Class Template Reference}
\label{classmlpack_1_1range_1_1RangeSearch}\index{mlpack\+::range\+::\+Range\+Search$<$ Metric\+Type, Mat\+Type, Tree\+Type $>$@{mlpack\+::range\+::\+Range\+Search$<$ Metric\+Type, Mat\+Type, Tree\+Type $>$}}


The \doxyref{Range\+Search}{p.}{classmlpack_1_1range_1_1RangeSearch} class is a template class for performing range searches.  


\subsection*{Public Types}
\begin{DoxyCompactItemize}
\item 
typedef Tree\+Type$<$ Metric\+Type, {\bf Range\+Search\+Stat}, Mat\+Type $>$ {\bf Tree}
\begin{DoxyCompactList}\small\item\em Convenience typedef. \end{DoxyCompactList}\end{DoxyCompactItemize}
\subsection*{Public Member Functions}
\begin{DoxyCompactItemize}
\item 
{\bf Range\+Search} (const Mat\+Type \&{\bf reference\+Set}, const bool {\bf naive}=false, const bool {\bf single\+Mode}=false, const Metric\+Type {\bf metric}=Metric\+Type())
\begin{DoxyCompactList}\small\item\em Initialize the \doxyref{Range\+Search}{p.}{classmlpack_1_1range_1_1RangeSearch} object with a given reference dataset (this is the dataset which is searched). \end{DoxyCompactList}\item 
{\bf Range\+Search} (Mat\+Type \&\&{\bf reference\+Set}, const bool {\bf naive}=false, const bool {\bf single\+Mode}=false, const Metric\+Type {\bf metric}=Metric\+Type())
\begin{DoxyCompactList}\small\item\em Initialize the \doxyref{Range\+Search}{p.}{classmlpack_1_1range_1_1RangeSearch} object with the given reference dataset (this is the dataset which is searched), taking ownership of the matrix. \end{DoxyCompactList}\item 
{\bf Range\+Search} ({\bf Tree} $\ast${\bf reference\+Tree}, const bool {\bf single\+Mode}=false, const Metric\+Type {\bf metric}=Metric\+Type())
\begin{DoxyCompactList}\small\item\em Initialize the \doxyref{Range\+Search}{p.}{classmlpack_1_1range_1_1RangeSearch} object with the given pre-\/constructed reference tree (this is the tree built on the reference set, which is the set that is searched). \end{DoxyCompactList}\item 
{\bf Range\+Search} (const bool {\bf naive}=false, const bool {\bf single\+Mode}=false, const Metric\+Type {\bf metric}=Metric\+Type())
\begin{DoxyCompactList}\small\item\em Initialize the \doxyref{Range\+Search}{p.}{classmlpack_1_1range_1_1RangeSearch} object without any reference data. \end{DoxyCompactList}\item 
{\bf Range\+Search} (const {\bf Range\+Search} \&other)
\begin{DoxyCompactList}\small\item\em Construct the \doxyref{Range\+Search}{p.}{classmlpack_1_1range_1_1RangeSearch} model as a copy of the given model. \end{DoxyCompactList}\item 
{\bf Range\+Search} ({\bf Range\+Search} \&\&other)
\begin{DoxyCompactList}\small\item\em Construct the \doxyref{Range\+Search}{p.}{classmlpack_1_1range_1_1RangeSearch} model by taking ownership of the given model. \end{DoxyCompactList}\item 
{\bf $\sim$\+Range\+Search} ()
\begin{DoxyCompactList}\small\item\em Destroy the \doxyref{Range\+Search}{p.}{classmlpack_1_1range_1_1RangeSearch} object. \end{DoxyCompactList}\item 
size\+\_\+t {\bf Base\+Cases} () const 
\begin{DoxyCompactList}\small\item\em Get the number of base cases during the last search. \end{DoxyCompactList}\item 
bool {\bf Naive} () const 
\begin{DoxyCompactList}\small\item\em Get whether naive search is being used. \end{DoxyCompactList}\item 
bool \& {\bf Naive} ()
\begin{DoxyCompactList}\small\item\em Modify whether naive search is being used. \end{DoxyCompactList}\item 
{\bf Range\+Search} \& {\bf operator=} (const {\bf Range\+Search} \&other)
\begin{DoxyCompactList}\small\item\em Copy the given \doxyref{Range\+Search}{p.}{classmlpack_1_1range_1_1RangeSearch} model. \end{DoxyCompactList}\item 
{\bf Range\+Search} \& {\bf operator=} ({\bf Range\+Search} \&\&other)
\begin{DoxyCompactList}\small\item\em Take ownership of the given \doxyref{Range\+Search}{p.}{classmlpack_1_1range_1_1RangeSearch} model. \end{DoxyCompactList}\item 
const Mat\+Type \& {\bf Reference\+Set} () const 
\begin{DoxyCompactList}\small\item\em Return the reference set. \end{DoxyCompactList}\item 
{\bf Tree} $\ast$ {\bf Reference\+Tree} ()
\begin{DoxyCompactList}\small\item\em Return the reference tree (or N\+U\+LL if in naive mode). \end{DoxyCompactList}\item 
size\+\_\+t {\bf Scores} () const 
\begin{DoxyCompactList}\small\item\em Get the number of scores during the last search. \end{DoxyCompactList}\item 
void {\bf Search} (const Mat\+Type \&query\+Set, const {\bf math\+::\+Range} \&range, std\+::vector$<$ std\+::vector$<$ size\+\_\+t $>$$>$ \&neighbors, std\+::vector$<$ std\+::vector$<$ double $>$$>$ \&distances)
\begin{DoxyCompactList}\small\item\em Search for all reference points in the given range for each point in the query set, returning the results in the neighbors and distances objects. \end{DoxyCompactList}\item 
void {\bf Search} ({\bf Tree} $\ast$query\+Tree, const {\bf math\+::\+Range} \&range, std\+::vector$<$ std\+::vector$<$ size\+\_\+t $>$$>$ \&neighbors, std\+::vector$<$ std\+::vector$<$ double $>$$>$ \&distances)
\begin{DoxyCompactList}\small\item\em Given a pre-\/built query tree, search for all reference points in the given range for each point in the query set, returning the results in the neighbors and distances objects. \end{DoxyCompactList}\item 
void {\bf Search} (const {\bf math\+::\+Range} \&range, std\+::vector$<$ std\+::vector$<$ size\+\_\+t $>$$>$ \&neighbors, std\+::vector$<$ std\+::vector$<$ double $>$$>$ \&distances)
\begin{DoxyCompactList}\small\item\em Search for all points in the given range for each point in the reference set (which was passed to the constructor), returning the results in the neighbors and distances objects. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename Archive $>$ }\\void {\bf Serialize} (Archive \&ar, const unsigned int version)
\begin{DoxyCompactList}\small\item\em Serialize the model. \end{DoxyCompactList}\item 
bool {\bf Single\+Mode} () const 
\begin{DoxyCompactList}\small\item\em Get whether single-\/tree search is being used. \end{DoxyCompactList}\item 
bool \& {\bf Single\+Mode} ()
\begin{DoxyCompactList}\small\item\em Modify whether single-\/tree search is being used. \end{DoxyCompactList}\item 
void {\bf Train} (const Mat\+Type \&{\bf reference\+Set})
\begin{DoxyCompactList}\small\item\em Set the reference set to a new reference set, and build a tree if necessary. \end{DoxyCompactList}\item 
void {\bf Train} (Mat\+Type \&\&{\bf reference\+Set})
\begin{DoxyCompactList}\small\item\em Set the reference set to a new reference set, taking ownership of the set. \end{DoxyCompactList}\item 
void {\bf Train} ({\bf Tree} $\ast${\bf reference\+Tree})
\begin{DoxyCompactList}\small\item\em Set the reference tree to a new reference tree. \end{DoxyCompactList}\end{DoxyCompactItemize}
\subsection*{Private Attributes}
\begin{DoxyCompactItemize}
\item 
size\+\_\+t {\bf base\+Cases}
\begin{DoxyCompactList}\small\item\em The total number of base cases during the last search. \end{DoxyCompactList}\item 
Metric\+Type {\bf metric}
\begin{DoxyCompactList}\small\item\em Instantiated distance metric. \end{DoxyCompactList}\item 
bool {\bf naive}
\begin{DoxyCompactList}\small\item\em If true, O(n$^\wedge$2) naive computation is used. \end{DoxyCompactList}\item 
std\+::vector$<$ size\+\_\+t $>$ {\bf old\+From\+New\+References}
\begin{DoxyCompactList}\small\item\em Mappings to old reference indices (used when this object builds trees). \end{DoxyCompactList}\item 
const Mat\+Type $\ast$ {\bf reference\+Set}
\begin{DoxyCompactList}\small\item\em Reference set (data should be accessed using this). \end{DoxyCompactList}\item 
{\bf Tree} $\ast$ {\bf reference\+Tree}
\begin{DoxyCompactList}\small\item\em Reference tree. \end{DoxyCompactList}\item 
size\+\_\+t {\bf scores}
\begin{DoxyCompactList}\small\item\em The total number of scores during the last search. \end{DoxyCompactList}\item 
bool {\bf set\+Owner}
\begin{DoxyCompactList}\small\item\em If true, we own the reference set. \end{DoxyCompactList}\item 
bool {\bf single\+Mode}
\begin{DoxyCompactList}\small\item\em If true, single-\/tree computation is used. \end{DoxyCompactList}\item 
bool {\bf tree\+Owner}
\begin{DoxyCompactList}\small\item\em If true, this object is responsible for deleting the trees. \end{DoxyCompactList}\end{DoxyCompactItemize}


\subsection{Detailed Description}
\subsubsection*{template$<$typename Metric\+Type = metric\+::\+Euclidean\+Distance, typename Mat\+Type = arma\+::mat, template$<$ typename Tree\+Metric\+Type, typename Tree\+Stat\+Type, typename Tree\+Mat\+Type $>$ class Tree\+Type = tree\+::\+K\+D\+Tree$>$\\*
class mlpack\+::range\+::\+Range\+Search$<$ Metric\+Type, Mat\+Type, Tree\+Type $>$}

The \doxyref{Range\+Search}{p.}{classmlpack_1_1range_1_1RangeSearch} class is a template class for performing range searches. 

It is implemented in the style of a generalized tree-\/independent dual-\/tree algorithm; for more details on the actual algorithm, see the \doxyref{Range\+Search\+Rules}{p.}{classmlpack_1_1range_1_1RangeSearchRules} class.


\begin{DoxyTemplParams}{Template Parameters}
{\em Metric\+Type} & Metric to use for range search calculations. \\
\hline
{\em Mat\+Type} & Type of data to use. \\
\hline
{\em Tree\+Type} & Type of tree to use; must satisfy the Tree\+Type policy A\+PI. \\
\hline
\end{DoxyTemplParams}


Definition at line 42 of file range\+\_\+search.\+hpp.



\subsection{Member Typedef Documentation}
\index{mlpack\+::range\+::\+Range\+Search@{mlpack\+::range\+::\+Range\+Search}!Tree@{Tree}}
\index{Tree@{Tree}!mlpack\+::range\+::\+Range\+Search@{mlpack\+::range\+::\+Range\+Search}}
\subsubsection[{Tree}]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename Metric\+Type = metric\+::\+Euclidean\+Distance, typename Mat\+Type = arma\+::mat, template$<$ typename Tree\+Metric\+Type, typename Tree\+Stat\+Type, typename Tree\+Mat\+Type $>$ class Tree\+Type = tree\+::\+K\+D\+Tree$>$ typedef Tree\+Type$<$Metric\+Type, {\bf Range\+Search\+Stat}, Mat\+Type$>$ {\bf mlpack\+::range\+::\+Range\+Search}$<$ Metric\+Type, Mat\+Type, Tree\+Type $>$\+::{\bf Tree}}\label{classmlpack_1_1range_1_1RangeSearch_a56d716801a4d3390ba218a5de5d0ac63}


Convenience typedef. 



Definition at line 46 of file range\+\_\+search.\+hpp.



\subsection{Constructor \& Destructor Documentation}
\index{mlpack\+::range\+::\+Range\+Search@{mlpack\+::range\+::\+Range\+Search}!Range\+Search@{Range\+Search}}
\index{Range\+Search@{Range\+Search}!mlpack\+::range\+::\+Range\+Search@{mlpack\+::range\+::\+Range\+Search}}
\subsubsection[{Range\+Search(const Mat\+Type \&reference\+Set, const bool naive=false, const bool single\+Mode=false, const Metric\+Type metric=\+Metric\+Type())}]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename Metric\+Type = metric\+::\+Euclidean\+Distance, typename Mat\+Type = arma\+::mat, template$<$ typename Tree\+Metric\+Type, typename Tree\+Stat\+Type, typename Tree\+Mat\+Type $>$ class Tree\+Type = tree\+::\+K\+D\+Tree$>$ {\bf mlpack\+::range\+::\+Range\+Search}$<$ Metric\+Type, Mat\+Type, Tree\+Type $>$\+::{\bf Range\+Search} (
\begin{DoxyParamCaption}
\item[{const Mat\+Type \&}]{reference\+Set, }
\item[{const bool}]{naive = {\ttfamily false}, }
\item[{const bool}]{single\+Mode = {\ttfamily false}, }
\item[{const Metric\+Type}]{metric = {\ttfamily MetricType()}}
\end{DoxyParamCaption}
)}\label{classmlpack_1_1range_1_1RangeSearch_adc0bf4d8af5a5a3fdfe65802c1a849b4}


Initialize the \doxyref{Range\+Search}{p.}{classmlpack_1_1range_1_1RangeSearch} object with a given reference dataset (this is the dataset which is searched). 

Optionally, perform the computation in naive mode or single-\/tree mode. Additionally, an instantiated metric can be given, for cases where the distance metric holds data.

This method will copy the matrices to internal copies, which are rearranged during tree-\/building. You can avoid this extra copy by pre-\/constructing the trees and passing them using a different constructor.


\begin{DoxyParams}{Parameters}
{\em reference\+Set} & Reference dataset. \\
\hline
{\em naive} & Whether the computation should be done in O(n$^\wedge$2) naive mode. \\
\hline
{\em single\+Mode} & Whether single-\/tree computation should be used (as opposed to dual-\/tree computation). \\
\hline
{\em metric} & Instantiated distance metric. \\
\hline
\end{DoxyParams}
\index{mlpack\+::range\+::\+Range\+Search@{mlpack\+::range\+::\+Range\+Search}!Range\+Search@{Range\+Search}}
\index{Range\+Search@{Range\+Search}!mlpack\+::range\+::\+Range\+Search@{mlpack\+::range\+::\+Range\+Search}}
\subsubsection[{Range\+Search(\+Mat\+Type \&\&reference\+Set, const bool naive=false, const bool single\+Mode=false, const Metric\+Type metric=\+Metric\+Type())}]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename Metric\+Type = metric\+::\+Euclidean\+Distance, typename Mat\+Type = arma\+::mat, template$<$ typename Tree\+Metric\+Type, typename Tree\+Stat\+Type, typename Tree\+Mat\+Type $>$ class Tree\+Type = tree\+::\+K\+D\+Tree$>$ {\bf mlpack\+::range\+::\+Range\+Search}$<$ Metric\+Type, Mat\+Type, Tree\+Type $>$\+::{\bf Range\+Search} (
\begin{DoxyParamCaption}
\item[{Mat\+Type \&\&}]{reference\+Set, }
\item[{const bool}]{naive = {\ttfamily false}, }
\item[{const bool}]{single\+Mode = {\ttfamily false}, }
\item[{const Metric\+Type}]{metric = {\ttfamily MetricType()}}
\end{DoxyParamCaption}
)}\label{classmlpack_1_1range_1_1RangeSearch_a3fd1f0bdad229e5ae6e7f175a0f1db98}


Initialize the \doxyref{Range\+Search}{p.}{classmlpack_1_1range_1_1RangeSearch} object with the given reference dataset (this is the dataset which is searched), taking ownership of the matrix. 

Optionally, perform the computation in naive mode or single-\/tree mode. Additionally, an instantiated metric can be given, for cases where the distance metric holds data.

This method will not copy the data matrix, but will take ownership of it, and depending on the type of tree used, may rearrange the points. If you would rather a copy be made, consider using the constructor that takes a const reference to the data instead.


\begin{DoxyParams}{Parameters}
{\em reference\+Set} & Set of reference points. \\
\hline
{\em naive} & If true, brute force naive search will be used (as opposed to dual-\/tree search). This overrides single\+Mode (if it is set to true). \\
\hline
{\em single\+Mode} & If true, single-\/tree search will be used (as opposed to dual-\/tree search). \\
\hline
{\em metric} & An optional instance of the Metric\+Type class. \\
\hline
\end{DoxyParams}
\index{mlpack\+::range\+::\+Range\+Search@{mlpack\+::range\+::\+Range\+Search}!Range\+Search@{Range\+Search}}
\index{Range\+Search@{Range\+Search}!mlpack\+::range\+::\+Range\+Search@{mlpack\+::range\+::\+Range\+Search}}
\subsubsection[{Range\+Search(\+Tree $\ast$reference\+Tree, const bool single\+Mode=false, const Metric\+Type metric=\+Metric\+Type())}]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename Metric\+Type = metric\+::\+Euclidean\+Distance, typename Mat\+Type = arma\+::mat, template$<$ typename Tree\+Metric\+Type, typename Tree\+Stat\+Type, typename Tree\+Mat\+Type $>$ class Tree\+Type = tree\+::\+K\+D\+Tree$>$ {\bf mlpack\+::range\+::\+Range\+Search}$<$ Metric\+Type, Mat\+Type, Tree\+Type $>$\+::{\bf Range\+Search} (
\begin{DoxyParamCaption}
\item[{{\bf Tree} $\ast$}]{reference\+Tree, }
\item[{const bool}]{single\+Mode = {\ttfamily false}, }
\item[{const Metric\+Type}]{metric = {\ttfamily MetricType()}}
\end{DoxyParamCaption}
)}\label{classmlpack_1_1range_1_1RangeSearch_ae94872994a73b26b49b8c1952556f4ad}


Initialize the \doxyref{Range\+Search}{p.}{classmlpack_1_1range_1_1RangeSearch} object with the given pre-\/constructed reference tree (this is the tree built on the reference set, which is the set that is searched). 

Optionally, choose to use single-\/tree mode, which will not build a tree on query points. Naive mode is not available as an option for this constructor. Additionally, an instantiated distance metric can be given, for cases where the distance metric holds data.

There is no copying of the data matrices in this constructor (because tree-\/building is not necessary), so this is the constructor to use when copies absolutely must be avoided.

\begin{DoxyNote}{Note}
Because tree-\/building (at least with Binary\+Space\+Tree) modifies the ordering of a matrix, be aware that mapping of the points back to their original indices is not done when this constructor is used. 
\end{DoxyNote}

\begin{DoxyParams}{Parameters}
{\em reference\+Tree} & Pre-\/built tree for reference points. \\
\hline
{\em reference\+Set} & Set of reference points corresponding to reference\+Tree. \\
\hline
{\em single\+Mode} & Whether single-\/tree computation should be used (as opposed to dual-\/tree computation). \\
\hline
{\em metric} & Instantiated distance metric. \\
\hline
\end{DoxyParams}
\index{mlpack\+::range\+::\+Range\+Search@{mlpack\+::range\+::\+Range\+Search}!Range\+Search@{Range\+Search}}
\index{Range\+Search@{Range\+Search}!mlpack\+::range\+::\+Range\+Search@{mlpack\+::range\+::\+Range\+Search}}
\subsubsection[{Range\+Search(const bool naive=false, const bool single\+Mode=false, const Metric\+Type metric=\+Metric\+Type())}]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename Metric\+Type = metric\+::\+Euclidean\+Distance, typename Mat\+Type = arma\+::mat, template$<$ typename Tree\+Metric\+Type, typename Tree\+Stat\+Type, typename Tree\+Mat\+Type $>$ class Tree\+Type = tree\+::\+K\+D\+Tree$>$ {\bf mlpack\+::range\+::\+Range\+Search}$<$ Metric\+Type, Mat\+Type, Tree\+Type $>$\+::{\bf Range\+Search} (
\begin{DoxyParamCaption}
\item[{const bool}]{naive = {\ttfamily false}, }
\item[{const bool}]{single\+Mode = {\ttfamily false}, }
\item[{const Metric\+Type}]{metric = {\ttfamily MetricType()}}
\end{DoxyParamCaption}
)}\label{classmlpack_1_1range_1_1RangeSearch_a0d75340fc85bd5daa8a7dab95dffd259}


Initialize the \doxyref{Range\+Search}{p.}{classmlpack_1_1range_1_1RangeSearch} object without any reference data. 

If the monochromatic \doxyref{Search()}{p.}{classmlpack_1_1range_1_1RangeSearch_a7760049877247f43e0e75c09fc723ee3} is called before a reference set is set with \doxyref{Train()}{p.}{classmlpack_1_1range_1_1RangeSearch_a003da7634609d1798c5dc7debd923088}, no results will be returned (since the reference set is empty).


\begin{DoxyParams}{Parameters}
{\em naive} & Whether to use naive search. \\
\hline
{\em single\+Mode} & Whether single-\/tree computation should be used (as opposed to dual-\/tree computation). \\
\hline
{\em metric} & Instantiated metric. \\
\hline
\end{DoxyParams}
\index{mlpack\+::range\+::\+Range\+Search@{mlpack\+::range\+::\+Range\+Search}!Range\+Search@{Range\+Search}}
\index{Range\+Search@{Range\+Search}!mlpack\+::range\+::\+Range\+Search@{mlpack\+::range\+::\+Range\+Search}}
\subsubsection[{Range\+Search(const Range\+Search \&other)}]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename Metric\+Type = metric\+::\+Euclidean\+Distance, typename Mat\+Type = arma\+::mat, template$<$ typename Tree\+Metric\+Type, typename Tree\+Stat\+Type, typename Tree\+Mat\+Type $>$ class Tree\+Type = tree\+::\+K\+D\+Tree$>$ {\bf mlpack\+::range\+::\+Range\+Search}$<$ Metric\+Type, Mat\+Type, Tree\+Type $>$\+::{\bf Range\+Search} (
\begin{DoxyParamCaption}
\item[{const {\bf Range\+Search}$<$ Metric\+Type, Mat\+Type, Tree\+Type $>$ \&}]{other}
\end{DoxyParamCaption}
)}\label{classmlpack_1_1range_1_1RangeSearch_ae2cb1b2767d362bdd550acb83bdc2feb}


Construct the \doxyref{Range\+Search}{p.}{classmlpack_1_1range_1_1RangeSearch} model as a copy of the given model. 

Note that this may be computationally intensive!


\begin{DoxyParams}{Parameters}
{\em other} & \doxyref{Range\+Search}{p.}{classmlpack_1_1range_1_1RangeSearch} model to copy. \\
\hline
\end{DoxyParams}
\index{mlpack\+::range\+::\+Range\+Search@{mlpack\+::range\+::\+Range\+Search}!Range\+Search@{Range\+Search}}
\index{Range\+Search@{Range\+Search}!mlpack\+::range\+::\+Range\+Search@{mlpack\+::range\+::\+Range\+Search}}
\subsubsection[{Range\+Search(\+Range\+Search \&\&other)}]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename Metric\+Type = metric\+::\+Euclidean\+Distance, typename Mat\+Type = arma\+::mat, template$<$ typename Tree\+Metric\+Type, typename Tree\+Stat\+Type, typename Tree\+Mat\+Type $>$ class Tree\+Type = tree\+::\+K\+D\+Tree$>$ {\bf mlpack\+::range\+::\+Range\+Search}$<$ Metric\+Type, Mat\+Type, Tree\+Type $>$\+::{\bf Range\+Search} (
\begin{DoxyParamCaption}
\item[{{\bf Range\+Search}$<$ Metric\+Type, Mat\+Type, Tree\+Type $>$ \&\&}]{other}
\end{DoxyParamCaption}
)}\label{classmlpack_1_1range_1_1RangeSearch_ab1d4651ea430824ec02acc7ba1810c91}


Construct the \doxyref{Range\+Search}{p.}{classmlpack_1_1range_1_1RangeSearch} model by taking ownership of the given model. 


\begin{DoxyParams}{Parameters}
{\em other} & \doxyref{Range\+Search}{p.}{classmlpack_1_1range_1_1RangeSearch} model to take ownership of. \\
\hline
\end{DoxyParams}
\index{mlpack\+::range\+::\+Range\+Search@{mlpack\+::range\+::\+Range\+Search}!````~Range\+Search@{$\sim$\+Range\+Search}}
\index{````~Range\+Search@{$\sim$\+Range\+Search}!mlpack\+::range\+::\+Range\+Search@{mlpack\+::range\+::\+Range\+Search}}
\subsubsection[{$\sim$\+Range\+Search()}]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename Metric\+Type = metric\+::\+Euclidean\+Distance, typename Mat\+Type = arma\+::mat, template$<$ typename Tree\+Metric\+Type, typename Tree\+Stat\+Type, typename Tree\+Mat\+Type $>$ class Tree\+Type = tree\+::\+K\+D\+Tree$>$ {\bf mlpack\+::range\+::\+Range\+Search}$<$ Metric\+Type, Mat\+Type, Tree\+Type $>$\+::$\sim${\bf Range\+Search} (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)}\label{classmlpack_1_1range_1_1RangeSearch_a3812a7d101ec8f651983e1cacb013881}


Destroy the \doxyref{Range\+Search}{p.}{classmlpack_1_1range_1_1RangeSearch} object. 

If trees were created, they will be deleted. 

\subsection{Member Function Documentation}
\index{mlpack\+::range\+::\+Range\+Search@{mlpack\+::range\+::\+Range\+Search}!Base\+Cases@{Base\+Cases}}
\index{Base\+Cases@{Base\+Cases}!mlpack\+::range\+::\+Range\+Search@{mlpack\+::range\+::\+Range\+Search}}
\subsubsection[{Base\+Cases() const }]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename Metric\+Type = metric\+::\+Euclidean\+Distance, typename Mat\+Type = arma\+::mat, template$<$ typename Tree\+Metric\+Type, typename Tree\+Stat\+Type, typename Tree\+Mat\+Type $>$ class Tree\+Type = tree\+::\+K\+D\+Tree$>$ size\+\_\+t {\bf mlpack\+::range\+::\+Range\+Search}$<$ Metric\+Type, Mat\+Type, Tree\+Type $>$\+::Base\+Cases (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
) const\hspace{0.3cm}{\ttfamily [inline]}}\label{classmlpack_1_1range_1_1RangeSearch_aef3656047218f17eb201150fae88ee7f}


Get the number of base cases during the last search. 



Definition at line 313 of file range\+\_\+search.\+hpp.



References mlpack\+::range\+::\+Range\+Search$<$ Metric\+Type, Mat\+Type, Tree\+Type $>$\+::base\+Cases.

\index{mlpack\+::range\+::\+Range\+Search@{mlpack\+::range\+::\+Range\+Search}!Naive@{Naive}}
\index{Naive@{Naive}!mlpack\+::range\+::\+Range\+Search@{mlpack\+::range\+::\+Range\+Search}}
\subsubsection[{Naive() const }]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename Metric\+Type = metric\+::\+Euclidean\+Distance, typename Mat\+Type = arma\+::mat, template$<$ typename Tree\+Metric\+Type, typename Tree\+Stat\+Type, typename Tree\+Mat\+Type $>$ class Tree\+Type = tree\+::\+K\+D\+Tree$>$ bool {\bf mlpack\+::range\+::\+Range\+Search}$<$ Metric\+Type, Mat\+Type, Tree\+Type $>$\+::Naive (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
) const\hspace{0.3cm}{\ttfamily [inline]}}\label{classmlpack_1_1range_1_1RangeSearch_a74a147d17543d8f26fddd47344caa875}


Get whether naive search is being used. 



Definition at line 308 of file range\+\_\+search.\+hpp.



References mlpack\+::range\+::\+Range\+Search$<$ Metric\+Type, Mat\+Type, Tree\+Type $>$\+::naive.

\index{mlpack\+::range\+::\+Range\+Search@{mlpack\+::range\+::\+Range\+Search}!Naive@{Naive}}
\index{Naive@{Naive}!mlpack\+::range\+::\+Range\+Search@{mlpack\+::range\+::\+Range\+Search}}
\subsubsection[{Naive()}]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename Metric\+Type = metric\+::\+Euclidean\+Distance, typename Mat\+Type = arma\+::mat, template$<$ typename Tree\+Metric\+Type, typename Tree\+Stat\+Type, typename Tree\+Mat\+Type $>$ class Tree\+Type = tree\+::\+K\+D\+Tree$>$ bool\& {\bf mlpack\+::range\+::\+Range\+Search}$<$ Metric\+Type, Mat\+Type, Tree\+Type $>$\+::Naive (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}}\label{classmlpack_1_1range_1_1RangeSearch_accd75a74bee18c2d5332d19913791722}


Modify whether naive search is being used. 



Definition at line 310 of file range\+\_\+search.\+hpp.



References mlpack\+::range\+::\+Range\+Search$<$ Metric\+Type, Mat\+Type, Tree\+Type $>$\+::naive.

\index{mlpack\+::range\+::\+Range\+Search@{mlpack\+::range\+::\+Range\+Search}!operator=@{operator=}}
\index{operator=@{operator=}!mlpack\+::range\+::\+Range\+Search@{mlpack\+::range\+::\+Range\+Search}}
\subsubsection[{operator=(const Range\+Search \&other)}]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename Metric\+Type = metric\+::\+Euclidean\+Distance, typename Mat\+Type = arma\+::mat, template$<$ typename Tree\+Metric\+Type, typename Tree\+Stat\+Type, typename Tree\+Mat\+Type $>$ class Tree\+Type = tree\+::\+K\+D\+Tree$>$ {\bf Range\+Search}\& {\bf mlpack\+::range\+::\+Range\+Search}$<$ Metric\+Type, Mat\+Type, Tree\+Type $>$\+::operator= (
\begin{DoxyParamCaption}
\item[{const {\bf Range\+Search}$<$ Metric\+Type, Mat\+Type, Tree\+Type $>$ \&}]{other}
\end{DoxyParamCaption}
)}\label{classmlpack_1_1range_1_1RangeSearch_ab4e7d8cd71ff677fff203da04efdbea6}


Copy the given \doxyref{Range\+Search}{p.}{classmlpack_1_1range_1_1RangeSearch} model. 


\begin{DoxyParams}{Parameters}
{\em other} & \doxyref{Range\+Search}{p.}{classmlpack_1_1range_1_1RangeSearch} model to copy. \\
\hline
\end{DoxyParams}
\index{mlpack\+::range\+::\+Range\+Search@{mlpack\+::range\+::\+Range\+Search}!operator=@{operator=}}
\index{operator=@{operator=}!mlpack\+::range\+::\+Range\+Search@{mlpack\+::range\+::\+Range\+Search}}
\subsubsection[{operator=(\+Range\+Search \&\&other)}]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename Metric\+Type = metric\+::\+Euclidean\+Distance, typename Mat\+Type = arma\+::mat, template$<$ typename Tree\+Metric\+Type, typename Tree\+Stat\+Type, typename Tree\+Mat\+Type $>$ class Tree\+Type = tree\+::\+K\+D\+Tree$>$ {\bf Range\+Search}\& {\bf mlpack\+::range\+::\+Range\+Search}$<$ Metric\+Type, Mat\+Type, Tree\+Type $>$\+::operator= (
\begin{DoxyParamCaption}
\item[{{\bf Range\+Search}$<$ Metric\+Type, Mat\+Type, Tree\+Type $>$ \&\&}]{other}
\end{DoxyParamCaption}
)}\label{classmlpack_1_1range_1_1RangeSearch_a48a6fafd7944f1992ba74d6028ffe06c}


Take ownership of the given \doxyref{Range\+Search}{p.}{classmlpack_1_1range_1_1RangeSearch} model. 


\begin{DoxyParams}{Parameters}
{\em other} & \doxyref{Range\+Search}{p.}{classmlpack_1_1range_1_1RangeSearch} model to take ownership of. \\
\hline
\end{DoxyParams}
\index{mlpack\+::range\+::\+Range\+Search@{mlpack\+::range\+::\+Range\+Search}!Reference\+Set@{Reference\+Set}}
\index{Reference\+Set@{Reference\+Set}!mlpack\+::range\+::\+Range\+Search@{mlpack\+::range\+::\+Range\+Search}}
\subsubsection[{Reference\+Set() const }]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename Metric\+Type = metric\+::\+Euclidean\+Distance, typename Mat\+Type = arma\+::mat, template$<$ typename Tree\+Metric\+Type, typename Tree\+Stat\+Type, typename Tree\+Mat\+Type $>$ class Tree\+Type = tree\+::\+K\+D\+Tree$>$ const Mat\+Type\& {\bf mlpack\+::range\+::\+Range\+Search}$<$ Metric\+Type, Mat\+Type, Tree\+Type $>$\+::Reference\+Set (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
) const\hspace{0.3cm}{\ttfamily [inline]}}\label{classmlpack_1_1range_1_1RangeSearch_a671ec5dda79c51dd85e939a6ac51c1de}


Return the reference set. 



Definition at line 322 of file range\+\_\+search.\+hpp.



References mlpack\+::range\+::\+Range\+Search$<$ Metric\+Type, Mat\+Type, Tree\+Type $>$\+::reference\+Set.

\index{mlpack\+::range\+::\+Range\+Search@{mlpack\+::range\+::\+Range\+Search}!Reference\+Tree@{Reference\+Tree}}
\index{Reference\+Tree@{Reference\+Tree}!mlpack\+::range\+::\+Range\+Search@{mlpack\+::range\+::\+Range\+Search}}
\subsubsection[{Reference\+Tree()}]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename Metric\+Type = metric\+::\+Euclidean\+Distance, typename Mat\+Type = arma\+::mat, template$<$ typename Tree\+Metric\+Type, typename Tree\+Stat\+Type, typename Tree\+Mat\+Type $>$ class Tree\+Type = tree\+::\+K\+D\+Tree$>$ {\bf Tree}$\ast$ {\bf mlpack\+::range\+::\+Range\+Search}$<$ Metric\+Type, Mat\+Type, Tree\+Type $>$\+::Reference\+Tree (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}}\label{classmlpack_1_1range_1_1RangeSearch_a706464bac7cb1159558b67bfdfd9a43f}


Return the reference tree (or N\+U\+LL if in naive mode). 



Definition at line 325 of file range\+\_\+search.\+hpp.



References mlpack\+::range\+::\+Range\+Search$<$ Metric\+Type, Mat\+Type, Tree\+Type $>$\+::reference\+Tree.

\index{mlpack\+::range\+::\+Range\+Search@{mlpack\+::range\+::\+Range\+Search}!Scores@{Scores}}
\index{Scores@{Scores}!mlpack\+::range\+::\+Range\+Search@{mlpack\+::range\+::\+Range\+Search}}
\subsubsection[{Scores() const }]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename Metric\+Type = metric\+::\+Euclidean\+Distance, typename Mat\+Type = arma\+::mat, template$<$ typename Tree\+Metric\+Type, typename Tree\+Stat\+Type, typename Tree\+Mat\+Type $>$ class Tree\+Type = tree\+::\+K\+D\+Tree$>$ size\+\_\+t {\bf mlpack\+::range\+::\+Range\+Search}$<$ Metric\+Type, Mat\+Type, Tree\+Type $>$\+::Scores (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
) const\hspace{0.3cm}{\ttfamily [inline]}}\label{classmlpack_1_1range_1_1RangeSearch_acdac815b1c7a77544900d9c6d3eca494}


Get the number of scores during the last search. 



Definition at line 315 of file range\+\_\+search.\+hpp.



References mlpack\+::range\+::\+Range\+Search$<$ Metric\+Type, Mat\+Type, Tree\+Type $>$\+::scores, and mlpack\+::range\+::\+Range\+Search$<$ Metric\+Type, Mat\+Type, Tree\+Type $>$\+::\+Serialize().

\index{mlpack\+::range\+::\+Range\+Search@{mlpack\+::range\+::\+Range\+Search}!Search@{Search}}
\index{Search@{Search}!mlpack\+::range\+::\+Range\+Search@{mlpack\+::range\+::\+Range\+Search}}
\subsubsection[{Search(const Mat\+Type \&query\+Set, const math\+::\+Range \&range, std\+::vector$<$ std\+::vector$<$ size\+\_\+t $>$$>$ \&neighbors, std\+::vector$<$ std\+::vector$<$ double $>$$>$ \&distances)}]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename Metric\+Type = metric\+::\+Euclidean\+Distance, typename Mat\+Type = arma\+::mat, template$<$ typename Tree\+Metric\+Type, typename Tree\+Stat\+Type, typename Tree\+Mat\+Type $>$ class Tree\+Type = tree\+::\+K\+D\+Tree$>$ void {\bf mlpack\+::range\+::\+Range\+Search}$<$ Metric\+Type, Mat\+Type, Tree\+Type $>$\+::Search (
\begin{DoxyParamCaption}
\item[{const Mat\+Type \&}]{query\+Set, }
\item[{const {\bf math\+::\+Range} \&}]{range, }
\item[{std\+::vector$<$ std\+::vector$<$ size\+\_\+t $>$$>$ \&}]{neighbors, }
\item[{std\+::vector$<$ std\+::vector$<$ double $>$$>$ \&}]{distances}
\end{DoxyParamCaption}
)}\label{classmlpack_1_1range_1_1RangeSearch_a7760049877247f43e0e75c09fc723ee3}


Search for all reference points in the given range for each point in the query set, returning the results in the neighbors and distances objects. 

Each entry in the external vector corresponds to a query point. Each of these entries holds a vector which contains the indices and distances of the reference points falling into the given range.

That is\+:


\begin{DoxyItemize}
\item neighbors.\+size() and distances.\+size() both equal the number of query points.
\item neighbors[i] contains the indices of all the points in the reference set which have distances inside the given range to query point i.
\item distances[i] contains all of the distances corresponding to the indices contained in neighbors[i].
\item neighbors[i] and distances[i] are not sorted in any particular order.
\end{DoxyItemize}


\begin{DoxyParams}{Parameters}
{\em query\+Set} & Set of query points to search with. \\
\hline
{\em range} & Range of distances in which to search. \\
\hline
{\em neighbors} & Object which will hold the list of neighbors for each point which fell into the given range, for each query point. \\
\hline
{\em distances} & Object which will hold the list of distances for each point which fell into the given range, for each query point. \\
\hline
\end{DoxyParams}
\index{mlpack\+::range\+::\+Range\+Search@{mlpack\+::range\+::\+Range\+Search}!Search@{Search}}
\index{Search@{Search}!mlpack\+::range\+::\+Range\+Search@{mlpack\+::range\+::\+Range\+Search}}
\subsubsection[{Search(\+Tree $\ast$query\+Tree, const math\+::\+Range \&range, std\+::vector$<$ std\+::vector$<$ size\+\_\+t $>$$>$ \&neighbors, std\+::vector$<$ std\+::vector$<$ double $>$$>$ \&distances)}]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename Metric\+Type = metric\+::\+Euclidean\+Distance, typename Mat\+Type = arma\+::mat, template$<$ typename Tree\+Metric\+Type, typename Tree\+Stat\+Type, typename Tree\+Mat\+Type $>$ class Tree\+Type = tree\+::\+K\+D\+Tree$>$ void {\bf mlpack\+::range\+::\+Range\+Search}$<$ Metric\+Type, Mat\+Type, Tree\+Type $>$\+::Search (
\begin{DoxyParamCaption}
\item[{{\bf Tree} $\ast$}]{query\+Tree, }
\item[{const {\bf math\+::\+Range} \&}]{range, }
\item[{std\+::vector$<$ std\+::vector$<$ size\+\_\+t $>$$>$ \&}]{neighbors, }
\item[{std\+::vector$<$ std\+::vector$<$ double $>$$>$ \&}]{distances}
\end{DoxyParamCaption}
)}\label{classmlpack_1_1range_1_1RangeSearch_ad4764c10aaea589cdd9c8e21d0de1ce8}


Given a pre-\/built query tree, search for all reference points in the given range for each point in the query set, returning the results in the neighbors and distances objects. 

Each entry in the external vector corresponds to a query point. Each of these entries holds a vector which contains the indices and distances of the reference points falling into the given range.

That is\+:


\begin{DoxyItemize}
\item neighbors.\+size() and distances.\+size() both equal the number of query points.
\item neighbors[i] contains the indices of all the points in the reference set which have distances inside the given range to query point i.
\item distances[i] contains all of the distances corresponding to the indices contained in neighbors[i].
\item neighbors[i] and distances[i] are not sorted in any particular order.
\end{DoxyItemize}

If either naive or single\+Mode are set to true, this will throw an invalid\+\_\+argument exception; passing in a query tree implies dual-\/tree search.

If you want to use the reference tree as the query tree, instead call the overload of \doxyref{Search()}{p.}{classmlpack_1_1range_1_1RangeSearch_a7760049877247f43e0e75c09fc723ee3} that does not take a query set.


\begin{DoxyParams}{Parameters}
{\em query\+Tree} & Tree built on query points. \\
\hline
{\em range} & Range of distances in which to search. \\
\hline
{\em neighbors} & Object which will hold the list of neighbors for each point which fell into the given range, for each query point. \\
\hline
{\em distances} & Object which will hold the list of distances for each point which fell into the given range, for each query point. \\
\hline
\end{DoxyParams}
\index{mlpack\+::range\+::\+Range\+Search@{mlpack\+::range\+::\+Range\+Search}!Search@{Search}}
\index{Search@{Search}!mlpack\+::range\+::\+Range\+Search@{mlpack\+::range\+::\+Range\+Search}}
\subsubsection[{Search(const math\+::\+Range \&range, std\+::vector$<$ std\+::vector$<$ size\+\_\+t $>$$>$ \&neighbors, std\+::vector$<$ std\+::vector$<$ double $>$$>$ \&distances)}]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename Metric\+Type = metric\+::\+Euclidean\+Distance, typename Mat\+Type = arma\+::mat, template$<$ typename Tree\+Metric\+Type, typename Tree\+Stat\+Type, typename Tree\+Mat\+Type $>$ class Tree\+Type = tree\+::\+K\+D\+Tree$>$ void {\bf mlpack\+::range\+::\+Range\+Search}$<$ Metric\+Type, Mat\+Type, Tree\+Type $>$\+::Search (
\begin{DoxyParamCaption}
\item[{const {\bf math\+::\+Range} \&}]{range, }
\item[{std\+::vector$<$ std\+::vector$<$ size\+\_\+t $>$$>$ \&}]{neighbors, }
\item[{std\+::vector$<$ std\+::vector$<$ double $>$$>$ \&}]{distances}
\end{DoxyParamCaption}
)}\label{classmlpack_1_1range_1_1RangeSearch_a93fd96f099fb75f20301ea96571b3352}


Search for all points in the given range for each point in the reference set (which was passed to the constructor), returning the results in the neighbors and distances objects. 

This means that the query set and the reference set are the same.

Each entry in the external vector corresponds to a query point. Each of these entries holds a vector which contains the indices and distances of the reference points falling into the given range.

That is\+:


\begin{DoxyItemize}
\item neighbors.\+size() and distances.\+size() both equal the number of query points.
\item neighbors[i] contains the indices of all the points in the reference set which have distances inside the given range to query point i.
\item distances[i] contains all of the distances corresponding to the indices contained in neighbors[i].
\item neighbors[i] and distances[i] are not sorted in any particular order.
\end{DoxyItemize}


\begin{DoxyParams}{Parameters}
{\em query\+Tree} & Tree built on query points. \\
\hline
{\em range} & Range of distances in which to search. \\
\hline
{\em neighbors} & Object which will hold the list of neighbors for each point which fell into the given range, for each query point. \\
\hline
{\em distances} & Object which will hold the list of distances for each point which fell into the given range, for each query point. \\
\hline
\end{DoxyParams}
\index{mlpack\+::range\+::\+Range\+Search@{mlpack\+::range\+::\+Range\+Search}!Serialize@{Serialize}}
\index{Serialize@{Serialize}!mlpack\+::range\+::\+Range\+Search@{mlpack\+::range\+::\+Range\+Search}}
\subsubsection[{Serialize(\+Archive \&ar, const unsigned int version)}]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename Metric\+Type = metric\+::\+Euclidean\+Distance, typename Mat\+Type = arma\+::mat, template$<$ typename Tree\+Metric\+Type, typename Tree\+Stat\+Type, typename Tree\+Mat\+Type $>$ class Tree\+Type = tree\+::\+K\+D\+Tree$>$ template$<$typename Archive $>$ void {\bf mlpack\+::range\+::\+Range\+Search}$<$ Metric\+Type, Mat\+Type, Tree\+Type $>$\+::Serialize (
\begin{DoxyParamCaption}
\item[{Archive \&}]{ar, }
\item[{const unsigned int}]{version}
\end{DoxyParamCaption}
)}\label{classmlpack_1_1range_1_1RangeSearch_a6ef21346f949577dc5af79e26485e309}


Serialize the model. 



Referenced by mlpack\+::range\+::\+Range\+Search$<$ Metric\+Type, Mat\+Type, Tree\+Type $>$\+::\+Scores().

\index{mlpack\+::range\+::\+Range\+Search@{mlpack\+::range\+::\+Range\+Search}!Single\+Mode@{Single\+Mode}}
\index{Single\+Mode@{Single\+Mode}!mlpack\+::range\+::\+Range\+Search@{mlpack\+::range\+::\+Range\+Search}}
\subsubsection[{Single\+Mode() const }]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename Metric\+Type = metric\+::\+Euclidean\+Distance, typename Mat\+Type = arma\+::mat, template$<$ typename Tree\+Metric\+Type, typename Tree\+Stat\+Type, typename Tree\+Mat\+Type $>$ class Tree\+Type = tree\+::\+K\+D\+Tree$>$ bool {\bf mlpack\+::range\+::\+Range\+Search}$<$ Metric\+Type, Mat\+Type, Tree\+Type $>$\+::Single\+Mode (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
) const\hspace{0.3cm}{\ttfamily [inline]}}\label{classmlpack_1_1range_1_1RangeSearch_a5c12e63ad76cb13c2df11b8d3c697a82}


Get whether single-\/tree search is being used. 



Definition at line 303 of file range\+\_\+search.\+hpp.



References mlpack\+::range\+::\+Range\+Search$<$ Metric\+Type, Mat\+Type, Tree\+Type $>$\+::single\+Mode.

\index{mlpack\+::range\+::\+Range\+Search@{mlpack\+::range\+::\+Range\+Search}!Single\+Mode@{Single\+Mode}}
\index{Single\+Mode@{Single\+Mode}!mlpack\+::range\+::\+Range\+Search@{mlpack\+::range\+::\+Range\+Search}}
\subsubsection[{Single\+Mode()}]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename Metric\+Type = metric\+::\+Euclidean\+Distance, typename Mat\+Type = arma\+::mat, template$<$ typename Tree\+Metric\+Type, typename Tree\+Stat\+Type, typename Tree\+Mat\+Type $>$ class Tree\+Type = tree\+::\+K\+D\+Tree$>$ bool\& {\bf mlpack\+::range\+::\+Range\+Search}$<$ Metric\+Type, Mat\+Type, Tree\+Type $>$\+::Single\+Mode (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}}\label{classmlpack_1_1range_1_1RangeSearch_ae38f824cd17757de6297a7bcb70969c1}


Modify whether single-\/tree search is being used. 



Definition at line 305 of file range\+\_\+search.\+hpp.



References mlpack\+::range\+::\+Range\+Search$<$ Metric\+Type, Mat\+Type, Tree\+Type $>$\+::single\+Mode.

\index{mlpack\+::range\+::\+Range\+Search@{mlpack\+::range\+::\+Range\+Search}!Train@{Train}}
\index{Train@{Train}!mlpack\+::range\+::\+Range\+Search@{mlpack\+::range\+::\+Range\+Search}}
\subsubsection[{Train(const Mat\+Type \&reference\+Set)}]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename Metric\+Type = metric\+::\+Euclidean\+Distance, typename Mat\+Type = arma\+::mat, template$<$ typename Tree\+Metric\+Type, typename Tree\+Stat\+Type, typename Tree\+Mat\+Type $>$ class Tree\+Type = tree\+::\+K\+D\+Tree$>$ void {\bf mlpack\+::range\+::\+Range\+Search}$<$ Metric\+Type, Mat\+Type, Tree\+Type $>$\+::Train (
\begin{DoxyParamCaption}
\item[{const Mat\+Type \&}]{reference\+Set}
\end{DoxyParamCaption}
)}\label{classmlpack_1_1range_1_1RangeSearch_a003da7634609d1798c5dc7debd923088}


Set the reference set to a new reference set, and build a tree if necessary. 

This method is called \textquotesingle{}\doxyref{Train()}{p.}{classmlpack_1_1range_1_1RangeSearch_a003da7634609d1798c5dc7debd923088}\textquotesingle{} in order to match the rest of the mlpack abstractions, even though calling this \char`\"{}training\char`\"{} is maybe a bit of a stretch.


\begin{DoxyParams}{Parameters}
{\em reference\+Set} & New set of reference data. \\
\hline
\end{DoxyParams}
\index{mlpack\+::range\+::\+Range\+Search@{mlpack\+::range\+::\+Range\+Search}!Train@{Train}}
\index{Train@{Train}!mlpack\+::range\+::\+Range\+Search@{mlpack\+::range\+::\+Range\+Search}}
\subsubsection[{Train(\+Mat\+Type \&\&reference\+Set)}]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename Metric\+Type = metric\+::\+Euclidean\+Distance, typename Mat\+Type = arma\+::mat, template$<$ typename Tree\+Metric\+Type, typename Tree\+Stat\+Type, typename Tree\+Mat\+Type $>$ class Tree\+Type = tree\+::\+K\+D\+Tree$>$ void {\bf mlpack\+::range\+::\+Range\+Search}$<$ Metric\+Type, Mat\+Type, Tree\+Type $>$\+::Train (
\begin{DoxyParamCaption}
\item[{Mat\+Type \&\&}]{reference\+Set}
\end{DoxyParamCaption}
)}\label{classmlpack_1_1range_1_1RangeSearch_a5e23439bf899737980455689f22c081c}


Set the reference set to a new reference set, taking ownership of the set. 

A tree is built if necessary. This method is called \textquotesingle{}\doxyref{Train()}{p.}{classmlpack_1_1range_1_1RangeSearch_a003da7634609d1798c5dc7debd923088}\textquotesingle{} in order to match the rest of the mlpack abstractions, even though calling this \char`\"{}training\char`\"{} is maybe a bit of a stretch.


\begin{DoxyParams}{Parameters}
{\em reference\+Set} & New set of reference data. \\
\hline
\end{DoxyParams}
\index{mlpack\+::range\+::\+Range\+Search@{mlpack\+::range\+::\+Range\+Search}!Train@{Train}}
\index{Train@{Train}!mlpack\+::range\+::\+Range\+Search@{mlpack\+::range\+::\+Range\+Search}}
\subsubsection[{Train(\+Tree $\ast$reference\+Tree)}]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename Metric\+Type = metric\+::\+Euclidean\+Distance, typename Mat\+Type = arma\+::mat, template$<$ typename Tree\+Metric\+Type, typename Tree\+Stat\+Type, typename Tree\+Mat\+Type $>$ class Tree\+Type = tree\+::\+K\+D\+Tree$>$ void {\bf mlpack\+::range\+::\+Range\+Search}$<$ Metric\+Type, Mat\+Type, Tree\+Type $>$\+::Train (
\begin{DoxyParamCaption}
\item[{{\bf Tree} $\ast$}]{reference\+Tree}
\end{DoxyParamCaption}
)}\label{classmlpack_1_1range_1_1RangeSearch_aa88789e2b6107b4f37cd726017630e0c}


Set the reference tree to a new reference tree. 



\subsection{Member Data Documentation}
\index{mlpack\+::range\+::\+Range\+Search@{mlpack\+::range\+::\+Range\+Search}!base\+Cases@{base\+Cases}}
\index{base\+Cases@{base\+Cases}!mlpack\+::range\+::\+Range\+Search@{mlpack\+::range\+::\+Range\+Search}}
\subsubsection[{base\+Cases}]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename Metric\+Type = metric\+::\+Euclidean\+Distance, typename Mat\+Type = arma\+::mat, template$<$ typename Tree\+Metric\+Type, typename Tree\+Stat\+Type, typename Tree\+Mat\+Type $>$ class Tree\+Type = tree\+::\+K\+D\+Tree$>$ size\+\_\+t {\bf mlpack\+::range\+::\+Range\+Search}$<$ Metric\+Type, Mat\+Type, Tree\+Type $>$\+::base\+Cases\hspace{0.3cm}{\ttfamily [private]}}\label{classmlpack_1_1range_1_1RangeSearch_ab50e960886d53242ac37aeacbc05d766}


The total number of base cases during the last search. 



Definition at line 350 of file range\+\_\+search.\+hpp.



Referenced by mlpack\+::range\+::\+Range\+Search$<$ Metric\+Type, Mat\+Type, Tree\+Type $>$\+::\+Base\+Cases().

\index{mlpack\+::range\+::\+Range\+Search@{mlpack\+::range\+::\+Range\+Search}!metric@{metric}}
\index{metric@{metric}!mlpack\+::range\+::\+Range\+Search@{mlpack\+::range\+::\+Range\+Search}}
\subsubsection[{metric}]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename Metric\+Type = metric\+::\+Euclidean\+Distance, typename Mat\+Type = arma\+::mat, template$<$ typename Tree\+Metric\+Type, typename Tree\+Stat\+Type, typename Tree\+Mat\+Type $>$ class Tree\+Type = tree\+::\+K\+D\+Tree$>$ Metric\+Type {\bf mlpack\+::range\+::\+Range\+Search}$<$ Metric\+Type, Mat\+Type, Tree\+Type $>$\+::metric\hspace{0.3cm}{\ttfamily [private]}}\label{classmlpack_1_1range_1_1RangeSearch_a959ee6af1678c911f32b13471df05f85}


Instantiated distance metric. 



Definition at line 347 of file range\+\_\+search.\+hpp.

\index{mlpack\+::range\+::\+Range\+Search@{mlpack\+::range\+::\+Range\+Search}!naive@{naive}}
\index{naive@{naive}!mlpack\+::range\+::\+Range\+Search@{mlpack\+::range\+::\+Range\+Search}}
\subsubsection[{naive}]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename Metric\+Type = metric\+::\+Euclidean\+Distance, typename Mat\+Type = arma\+::mat, template$<$ typename Tree\+Metric\+Type, typename Tree\+Stat\+Type, typename Tree\+Mat\+Type $>$ class Tree\+Type = tree\+::\+K\+D\+Tree$>$ bool {\bf mlpack\+::range\+::\+Range\+Search}$<$ Metric\+Type, Mat\+Type, Tree\+Type $>$\+::naive\hspace{0.3cm}{\ttfamily [private]}}\label{classmlpack_1_1range_1_1RangeSearch_adfde3efd24902d19cbd49a6897dac353}


If true, O(n$^\wedge$2) naive computation is used. 



Definition at line 342 of file range\+\_\+search.\+hpp.



Referenced by mlpack\+::range\+::\+Range\+Search$<$ Metric\+Type, Mat\+Type, Tree\+Type $>$\+::\+Naive().

\index{mlpack\+::range\+::\+Range\+Search@{mlpack\+::range\+::\+Range\+Search}!old\+From\+New\+References@{old\+From\+New\+References}}
\index{old\+From\+New\+References@{old\+From\+New\+References}!mlpack\+::range\+::\+Range\+Search@{mlpack\+::range\+::\+Range\+Search}}
\subsubsection[{old\+From\+New\+References}]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename Metric\+Type = metric\+::\+Euclidean\+Distance, typename Mat\+Type = arma\+::mat, template$<$ typename Tree\+Metric\+Type, typename Tree\+Stat\+Type, typename Tree\+Mat\+Type $>$ class Tree\+Type = tree\+::\+K\+D\+Tree$>$ std\+::vector$<$size\+\_\+t$>$ {\bf mlpack\+::range\+::\+Range\+Search}$<$ Metric\+Type, Mat\+Type, Tree\+Type $>$\+::old\+From\+New\+References\hspace{0.3cm}{\ttfamily [private]}}\label{classmlpack_1_1range_1_1RangeSearch_a0975bc6fc9cf8f3b7c38d5e66989f119}


Mappings to old reference indices (used when this object builds trees). 



Definition at line 329 of file range\+\_\+search.\+hpp.

\index{mlpack\+::range\+::\+Range\+Search@{mlpack\+::range\+::\+Range\+Search}!reference\+Set@{reference\+Set}}
\index{reference\+Set@{reference\+Set}!mlpack\+::range\+::\+Range\+Search@{mlpack\+::range\+::\+Range\+Search}}
\subsubsection[{reference\+Set}]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename Metric\+Type = metric\+::\+Euclidean\+Distance, typename Mat\+Type = arma\+::mat, template$<$ typename Tree\+Metric\+Type, typename Tree\+Stat\+Type, typename Tree\+Mat\+Type $>$ class Tree\+Type = tree\+::\+K\+D\+Tree$>$ const Mat\+Type$\ast$ {\bf mlpack\+::range\+::\+Range\+Search}$<$ Metric\+Type, Mat\+Type, Tree\+Type $>$\+::reference\+Set\hspace{0.3cm}{\ttfamily [private]}}\label{classmlpack_1_1range_1_1RangeSearch_a11b020a4f8da4e67e9d7df9559253174}


Reference set (data should be accessed using this). 

In some situations we may be the owner of this. 

Definition at line 334 of file range\+\_\+search.\+hpp.



Referenced by mlpack\+::range\+::\+Range\+Search$<$ Metric\+Type, Mat\+Type, Tree\+Type $>$\+::\+Reference\+Set().

\index{mlpack\+::range\+::\+Range\+Search@{mlpack\+::range\+::\+Range\+Search}!reference\+Tree@{reference\+Tree}}
\index{reference\+Tree@{reference\+Tree}!mlpack\+::range\+::\+Range\+Search@{mlpack\+::range\+::\+Range\+Search}}
\subsubsection[{reference\+Tree}]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename Metric\+Type = metric\+::\+Euclidean\+Distance, typename Mat\+Type = arma\+::mat, template$<$ typename Tree\+Metric\+Type, typename Tree\+Stat\+Type, typename Tree\+Mat\+Type $>$ class Tree\+Type = tree\+::\+K\+D\+Tree$>$ {\bf Tree}$\ast$ {\bf mlpack\+::range\+::\+Range\+Search}$<$ Metric\+Type, Mat\+Type, Tree\+Type $>$\+::reference\+Tree\hspace{0.3cm}{\ttfamily [private]}}\label{classmlpack_1_1range_1_1RangeSearch_af4dd319afec22cdc66434513bcd6c48e}


Reference tree. 



Definition at line 331 of file range\+\_\+search.\+hpp.



Referenced by mlpack\+::range\+::\+Range\+Search$<$ Metric\+Type, Mat\+Type, Tree\+Type $>$\+::\+Reference\+Tree().

\index{mlpack\+::range\+::\+Range\+Search@{mlpack\+::range\+::\+Range\+Search}!scores@{scores}}
\index{scores@{scores}!mlpack\+::range\+::\+Range\+Search@{mlpack\+::range\+::\+Range\+Search}}
\subsubsection[{scores}]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename Metric\+Type = metric\+::\+Euclidean\+Distance, typename Mat\+Type = arma\+::mat, template$<$ typename Tree\+Metric\+Type, typename Tree\+Stat\+Type, typename Tree\+Mat\+Type $>$ class Tree\+Type = tree\+::\+K\+D\+Tree$>$ size\+\_\+t {\bf mlpack\+::range\+::\+Range\+Search}$<$ Metric\+Type, Mat\+Type, Tree\+Type $>$\+::scores\hspace{0.3cm}{\ttfamily [private]}}\label{classmlpack_1_1range_1_1RangeSearch_af9742c82dba7d424f495e88b0b5dff16}


The total number of scores during the last search. 



Definition at line 352 of file range\+\_\+search.\+hpp.



Referenced by mlpack\+::range\+::\+Range\+Search$<$ Metric\+Type, Mat\+Type, Tree\+Type $>$\+::\+Scores().

\index{mlpack\+::range\+::\+Range\+Search@{mlpack\+::range\+::\+Range\+Search}!set\+Owner@{set\+Owner}}
\index{set\+Owner@{set\+Owner}!mlpack\+::range\+::\+Range\+Search@{mlpack\+::range\+::\+Range\+Search}}
\subsubsection[{set\+Owner}]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename Metric\+Type = metric\+::\+Euclidean\+Distance, typename Mat\+Type = arma\+::mat, template$<$ typename Tree\+Metric\+Type, typename Tree\+Stat\+Type, typename Tree\+Mat\+Type $>$ class Tree\+Type = tree\+::\+K\+D\+Tree$>$ bool {\bf mlpack\+::range\+::\+Range\+Search}$<$ Metric\+Type, Mat\+Type, Tree\+Type $>$\+::set\+Owner\hspace{0.3cm}{\ttfamily [private]}}\label{classmlpack_1_1range_1_1RangeSearch_aee1da342a95d7065ecebbd3a499ec453}


If true, we own the reference set. 



Definition at line 339 of file range\+\_\+search.\+hpp.

\index{mlpack\+::range\+::\+Range\+Search@{mlpack\+::range\+::\+Range\+Search}!single\+Mode@{single\+Mode}}
\index{single\+Mode@{single\+Mode}!mlpack\+::range\+::\+Range\+Search@{mlpack\+::range\+::\+Range\+Search}}
\subsubsection[{single\+Mode}]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename Metric\+Type = metric\+::\+Euclidean\+Distance, typename Mat\+Type = arma\+::mat, template$<$ typename Tree\+Metric\+Type, typename Tree\+Stat\+Type, typename Tree\+Mat\+Type $>$ class Tree\+Type = tree\+::\+K\+D\+Tree$>$ bool {\bf mlpack\+::range\+::\+Range\+Search}$<$ Metric\+Type, Mat\+Type, Tree\+Type $>$\+::single\+Mode\hspace{0.3cm}{\ttfamily [private]}}\label{classmlpack_1_1range_1_1RangeSearch_ac656f90d07f39fc821d5f04aa1e10720}


If true, single-\/tree computation is used. 



Definition at line 344 of file range\+\_\+search.\+hpp.



Referenced by mlpack\+::range\+::\+Range\+Search$<$ Metric\+Type, Mat\+Type, Tree\+Type $>$\+::\+Single\+Mode().

\index{mlpack\+::range\+::\+Range\+Search@{mlpack\+::range\+::\+Range\+Search}!tree\+Owner@{tree\+Owner}}
\index{tree\+Owner@{tree\+Owner}!mlpack\+::range\+::\+Range\+Search@{mlpack\+::range\+::\+Range\+Search}}
\subsubsection[{tree\+Owner}]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename Metric\+Type = metric\+::\+Euclidean\+Distance, typename Mat\+Type = arma\+::mat, template$<$ typename Tree\+Metric\+Type, typename Tree\+Stat\+Type, typename Tree\+Mat\+Type $>$ class Tree\+Type = tree\+::\+K\+D\+Tree$>$ bool {\bf mlpack\+::range\+::\+Range\+Search}$<$ Metric\+Type, Mat\+Type, Tree\+Type $>$\+::tree\+Owner\hspace{0.3cm}{\ttfamily [private]}}\label{classmlpack_1_1range_1_1RangeSearch_ab8fe43c24f611f06aab98e6bb683da61}


If true, this object is responsible for deleting the trees. 



Definition at line 337 of file range\+\_\+search.\+hpp.



The documentation for this class was generated from the following file\+:\begin{DoxyCompactItemize}
\item 
src/mlpack/methods/range\+\_\+search/{\bf range\+\_\+search.\+hpp}\end{DoxyCompactItemize}
