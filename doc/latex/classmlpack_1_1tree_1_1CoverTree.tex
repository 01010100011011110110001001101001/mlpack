\section{mlpack\+:\+:tree\+:\+:Cover\+Tree$<$ Metric\+Type, Statistic\+Type, Mat\+Type, Root\+Point\+Policy $>$ Class Template Reference}
\label{classmlpack_1_1tree_1_1CoverTree}\index{mlpack\+::tree\+::\+Cover\+Tree$<$ Metric\+Type, Statistic\+Type, Mat\+Type, Root\+Point\+Policy $>$@{mlpack\+::tree\+::\+Cover\+Tree$<$ Metric\+Type, Statistic\+Type, Mat\+Type, Root\+Point\+Policy $>$}}


A cover tree is a tree specifically designed to speed up nearest-\/neighbor computation in high-\/dimensional spaces.  


\subsection*{Classes}
\begin{DoxyCompactItemize}
\item 
class {\bf Dual\+Tree\+Traverser}
\begin{DoxyCompactList}\small\item\em A dual-\/tree cover tree traverser; see dual\+\_\+tree\+\_\+traverser.\+hpp. \end{DoxyCompactList}\item 
class {\bf Single\+Tree\+Traverser}
\begin{DoxyCompactList}\small\item\em A single-\/tree cover tree traverser; see single\+\_\+tree\+\_\+traverser.\+hpp for implementation. \end{DoxyCompactList}\end{DoxyCompactItemize}
\subsection*{Public Types}
\begin{DoxyCompactItemize}
\item 
{\footnotesize template$<$typename Rule\+Type $>$ }\\using {\bf Breadth\+First\+Dual\+Tree\+Traverser} = {\bf Dual\+Tree\+Traverser}$<$ Rule\+Type $>$
\item 
typedef Mat\+Type\+::elem\+\_\+type {\bf Elem\+Type}
\begin{DoxyCompactList}\small\item\em The type held by the matrix type. \end{DoxyCompactList}\item 
typedef Mat\+Type {\bf Mat}
\begin{DoxyCompactList}\small\item\em So that other classes can access the matrix type. \end{DoxyCompactList}\end{DoxyCompactItemize}
\subsection*{Public Member Functions}
\begin{DoxyCompactItemize}
\item 
{\bf Cover\+Tree} (const Mat\+Type \&{\bf dataset}, const {\bf Elem\+Type} {\bf base}=2.\+0, Metric\+Type $\ast${\bf metric}=N\+U\+LL)
\begin{DoxyCompactList}\small\item\em Create the cover tree with the given dataset and given base. \end{DoxyCompactList}\item 
{\bf Cover\+Tree} (const Mat\+Type \&{\bf dataset}, Metric\+Type \&{\bf metric}, const {\bf Elem\+Type} {\bf base}=2.\+0)
\begin{DoxyCompactList}\small\item\em Create the cover tree with the given dataset and the given instantiated metric. \end{DoxyCompactList}\item 
{\bf Cover\+Tree} (Mat\+Type \&\&{\bf dataset}, const {\bf Elem\+Type} {\bf base}=2.\+0)
\begin{DoxyCompactList}\small\item\em Create the cover tree with the given dataset, taking ownership of the dataset. \end{DoxyCompactList}\item 
{\bf Cover\+Tree} (Mat\+Type \&\&{\bf dataset}, Metric\+Type \&{\bf metric}, const {\bf Elem\+Type} {\bf base}=2.\+0)
\begin{DoxyCompactList}\small\item\em Create the cover tree with the given dataset and the given instantiated metric, taking ownership of the dataset. \end{DoxyCompactList}\item 
{\bf Cover\+Tree} (const Mat\+Type \&{\bf dataset}, const {\bf Elem\+Type} {\bf base}, const size\+\_\+t point\+Index, const int {\bf scale}, {\bf Cover\+Tree} $\ast${\bf parent}, const {\bf Elem\+Type} {\bf parent\+Distance}, arma\+::\+Col$<$ size\+\_\+t $>$ \&indices, arma\+::vec \&distances, size\+\_\+t near\+Set\+Size, size\+\_\+t \&far\+Set\+Size, size\+\_\+t \&used\+Set\+Size, Metric\+Type \&{\bf metric}=N\+U\+LL)
\begin{DoxyCompactList}\small\item\em Construct a child cover tree node. \end{DoxyCompactList}\item 
{\bf Cover\+Tree} (const Mat\+Type \&{\bf dataset}, const {\bf Elem\+Type} {\bf base}, const size\+\_\+t point\+Index, const int {\bf scale}, {\bf Cover\+Tree} $\ast${\bf parent}, const {\bf Elem\+Type} {\bf parent\+Distance}, const {\bf Elem\+Type} {\bf furthest\+Descendant\+Distance}, Metric\+Type $\ast${\bf metric}=N\+U\+LL)
\begin{DoxyCompactList}\small\item\em Manually construct a cover tree node; no tree assembly is done in this constructor, and children must be added manually (use \doxyref{Children()}{p.}{classmlpack_1_1tree_1_1CoverTree_a0027dac9b598ae3c4541b2db36a8b111}). \end{DoxyCompactList}\item 
{\bf Cover\+Tree} (const {\bf Cover\+Tree} \&other)
\begin{DoxyCompactList}\small\item\em Create a cover tree from another tree. \end{DoxyCompactList}\item 
{\bf Cover\+Tree} ({\bf Cover\+Tree} \&\&other)
\begin{DoxyCompactList}\small\item\em Move constructor for a Cover Tree, possess all the members of the given tree. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename Archive $>$ }\\{\bf Cover\+Tree} (Archive \&ar, const typename {\bf std\+::enable\+\_\+if\+\_\+t}$<$ Archive\+::is\+\_\+loading\+::value $>$ $\ast$=0)
\begin{DoxyCompactList}\small\item\em Create a cover tree from a \doxyref{boost\+::serialization}{p.}{namespaceboost_1_1serialization} archive. \end{DoxyCompactList}\item 
{\bf $\sim$\+Cover\+Tree} ()
\begin{DoxyCompactList}\small\item\em Delete this cover tree node and its children. \end{DoxyCompactList}\item 
{\bf Elem\+Type} {\bf Base} () const 
\begin{DoxyCompactList}\small\item\em Get the base. \end{DoxyCompactList}\item 
{\bf Elem\+Type} \& {\bf Base} ()
\begin{DoxyCompactList}\small\item\em Modify the base; don\textquotesingle{}t do this, you\textquotesingle{}ll break everything. \end{DoxyCompactList}\item 
void {\bf Center} (arma\+::vec \&center) const 
\begin{DoxyCompactList}\small\item\em Get the center of the node and store it in the given vector. \end{DoxyCompactList}\item 
const {\bf Cover\+Tree} \& {\bf Child} (const size\+\_\+t index) const 
\begin{DoxyCompactList}\small\item\em Get a particular child node. \end{DoxyCompactList}\item 
{\bf Cover\+Tree} \& {\bf Child} (const size\+\_\+t index)
\begin{DoxyCompactList}\small\item\em Modify a particular child node. \end{DoxyCompactList}\item 
{\bf Cover\+Tree} $\ast$\& {\bf Child\+Ptr} (const size\+\_\+t index)
\item 
const std\+::vector$<$ {\bf Cover\+Tree} $\ast$ $>$ \& {\bf Children} () const 
\begin{DoxyCompactList}\small\item\em Get the children. \end{DoxyCompactList}\item 
std\+::vector$<$ {\bf Cover\+Tree} $\ast$ $>$ \& {\bf Children} ()
\begin{DoxyCompactList}\small\item\em Modify the children manually (maybe not a great idea). \end{DoxyCompactList}\item 
const Mat\+Type \& {\bf Dataset} () const 
\begin{DoxyCompactList}\small\item\em Get a reference to the dataset. \end{DoxyCompactList}\item 
size\+\_\+t {\bf Descendant} (const size\+\_\+t index) const 
\begin{DoxyCompactList}\small\item\em Get the index of a particular descendant point. \end{DoxyCompactList}\item 
size\+\_\+t {\bf Distance\+Comps} () const 
\item 
size\+\_\+t \& {\bf Distance\+Comps} ()
\item 
{\bf Elem\+Type} {\bf Furthest\+Descendant\+Distance} () const 
\begin{DoxyCompactList}\small\item\em Get the distance from the center of the node to the furthest descendant. \end{DoxyCompactList}\item 
{\bf Elem\+Type} \& {\bf Furthest\+Descendant\+Distance} ()
\begin{DoxyCompactList}\small\item\em Modify the distance from the center of the node to the furthest descendant. \end{DoxyCompactList}\item 
{\bf Elem\+Type} {\bf Furthest\+Point\+Distance} () const 
\begin{DoxyCompactList}\small\item\em Get the distance to the furthest point. This is always 0 for cover trees. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename Vec\+Type $>$ }\\size\+\_\+t {\bf Get\+Furthest\+Child} (const Vec\+Type \&{\bf point}, typename {\bf std\+::enable\+\_\+if\+\_\+t}$<$ {\bf Is\+Vector}$<$ Vec\+Type $>$\+::value $>$ $\ast$=0)
\begin{DoxyCompactList}\small\item\em Return the index of the furthest child node to the given query point. \end{DoxyCompactList}\item 
size\+\_\+t {\bf Get\+Furthest\+Child} (const {\bf Cover\+Tree} \&query\+Node)
\begin{DoxyCompactList}\small\item\em Return the index of the furthest child node to the given query node. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename Vec\+Type $>$ }\\size\+\_\+t {\bf Get\+Nearest\+Child} (const Vec\+Type \&{\bf point}, typename {\bf std\+::enable\+\_\+if\+\_\+t}$<$ {\bf Is\+Vector}$<$ Vec\+Type $>$\+::value $>$ $\ast$=0)
\begin{DoxyCompactList}\small\item\em Return the index of the nearest child node to the given query point. \end{DoxyCompactList}\item 
size\+\_\+t {\bf Get\+Nearest\+Child} (const {\bf Cover\+Tree} \&query\+Node)
\begin{DoxyCompactList}\small\item\em Return the index of the nearest child node to the given query node. \end{DoxyCompactList}\item 
bool {\bf Is\+Leaf} () const 
\item 
{\bf Elem\+Type} {\bf Max\+Distance} (const {\bf Cover\+Tree} \&other) const 
\begin{DoxyCompactList}\small\item\em Return the maximum distance to another node. \end{DoxyCompactList}\item 
{\bf Elem\+Type} {\bf Max\+Distance} (const {\bf Cover\+Tree} \&other, const {\bf Elem\+Type} distance) const 
\begin{DoxyCompactList}\small\item\em Return the maximum distance to another node given that the point-\/to-\/point distance has already been calculated. \end{DoxyCompactList}\item 
{\bf Elem\+Type} {\bf Max\+Distance} (const arma\+::vec \&other) const 
\begin{DoxyCompactList}\small\item\em Return the maximum distance to another point. \end{DoxyCompactList}\item 
{\bf Elem\+Type} {\bf Max\+Distance} (const arma\+::vec \&other, const {\bf Elem\+Type} distance) const 
\begin{DoxyCompactList}\small\item\em Return the maximum distance to another point given that the distance from the center to the point has already been calculated. \end{DoxyCompactList}\item 
Metric\+Type \& {\bf Metric} () const 
\begin{DoxyCompactList}\small\item\em Get the instantiated metric. \end{DoxyCompactList}\item 
{\bf Elem\+Type} {\bf Min\+Distance} (const {\bf Cover\+Tree} \&other) const 
\begin{DoxyCompactList}\small\item\em Return the minimum distance to another node. \end{DoxyCompactList}\item 
{\bf Elem\+Type} {\bf Min\+Distance} (const {\bf Cover\+Tree} \&other, const {\bf Elem\+Type} distance) const 
\begin{DoxyCompactList}\small\item\em Return the minimum distance to another node given that the point-\/to-\/point distance has already been calculated. \end{DoxyCompactList}\item 
{\bf Elem\+Type} {\bf Min\+Distance} (const arma\+::vec \&other) const 
\begin{DoxyCompactList}\small\item\em Return the minimum distance to another point. \end{DoxyCompactList}\item 
{\bf Elem\+Type} {\bf Min\+Distance} (const arma\+::vec \&other, const {\bf Elem\+Type} distance) const 
\begin{DoxyCompactList}\small\item\em Return the minimum distance to another point given that the distance from the center to the point has already been calculated. \end{DoxyCompactList}\item 
{\bf Elem\+Type} {\bf Minimum\+Bound\+Distance} () const 
\begin{DoxyCompactList}\small\item\em Get the minimum distance from the center to any bound edge (this is the same as furthest\+Descendant\+Distance). \end{DoxyCompactList}\item 
size\+\_\+t {\bf Num\+Children} () const 
\begin{DoxyCompactList}\small\item\em Get the number of children. \end{DoxyCompactList}\item 
size\+\_\+t {\bf Num\+Descendants} () const 
\begin{DoxyCompactList}\small\item\em Get the number of descendant points. \end{DoxyCompactList}\item 
size\+\_\+t {\bf Num\+Points} () const 
\item 
{\bf Cover\+Tree} $\ast$ {\bf Parent} () const 
\begin{DoxyCompactList}\small\item\em Get the parent node. \end{DoxyCompactList}\item 
{\bf Cover\+Tree} $\ast$\& {\bf Parent} ()
\begin{DoxyCompactList}\small\item\em Modify the parent node. \end{DoxyCompactList}\item 
{\bf Elem\+Type} {\bf Parent\+Distance} () const 
\begin{DoxyCompactList}\small\item\em Get the distance to the parent. \end{DoxyCompactList}\item 
{\bf Elem\+Type} \& {\bf Parent\+Distance} ()
\begin{DoxyCompactList}\small\item\em Modify the distance to the parent. \end{DoxyCompactList}\item 
size\+\_\+t {\bf Point} () const 
\begin{DoxyCompactList}\small\item\em Get the index of the point which this node represents. \end{DoxyCompactList}\item 
size\+\_\+t {\bf Point} (const size\+\_\+t) const 
\begin{DoxyCompactList}\small\item\em For compatibility with other trees; the argument is ignored. \end{DoxyCompactList}\item 
{\bf math\+::\+Range\+Type}$<$ {\bf Elem\+Type} $>$ {\bf Range\+Distance} (const {\bf Cover\+Tree} \&other) const 
\begin{DoxyCompactList}\small\item\em Return the minimum and maximum distance to another node. \end{DoxyCompactList}\item 
{\bf math\+::\+Range\+Type}$<$ {\bf Elem\+Type} $>$ {\bf Range\+Distance} (const {\bf Cover\+Tree} \&other, const {\bf Elem\+Type} distance) const 
\begin{DoxyCompactList}\small\item\em Return the minimum and maximum distance to another node given that the point-\/to-\/point distance has already been calculated. \end{DoxyCompactList}\item 
{\bf math\+::\+Range\+Type}$<$ {\bf Elem\+Type} $>$ {\bf Range\+Distance} (const arma\+::vec \&other) const 
\begin{DoxyCompactList}\small\item\em Return the minimum and maximum distance to another point. \end{DoxyCompactList}\item 
{\bf math\+::\+Range\+Type}$<$ {\bf Elem\+Type} $>$ {\bf Range\+Distance} (const arma\+::vec \&other, const {\bf Elem\+Type} distance) const 
\begin{DoxyCompactList}\small\item\em Return the minimum and maximum distance to another point given that the point-\/to-\/point distance has already been calculated. \end{DoxyCompactList}\item 
int {\bf Scale} () const 
\begin{DoxyCompactList}\small\item\em Get the scale of this node. \end{DoxyCompactList}\item 
int \& {\bf Scale} ()
\begin{DoxyCompactList}\small\item\em Modify the scale of this node. Be careful... \end{DoxyCompactList}\item 
{\footnotesize template$<$typename Archive $>$ }\\void {\bf Serialize} (Archive \&ar, const unsigned int)
\begin{DoxyCompactList}\small\item\em Serialize the tree. \end{DoxyCompactList}\item 
const Statistic\+Type \& {\bf Stat} () const 
\begin{DoxyCompactList}\small\item\em Get the statistic for this node. \end{DoxyCompactList}\item 
Statistic\+Type \& {\bf Stat} ()
\begin{DoxyCompactList}\small\item\em Modify the statistic for this node. \end{DoxyCompactList}\end{DoxyCompactItemize}
\subsection*{Protected Member Functions}
\begin{DoxyCompactItemize}
\item 
{\bf Cover\+Tree} ()
\begin{DoxyCompactList}\small\item\em A default constructor. \end{DoxyCompactList}\end{DoxyCompactItemize}
\subsection*{Private Member Functions}
\begin{DoxyCompactItemize}
\item 
void {\bf Compute\+Distances} (const size\+\_\+t point\+Index, const arma\+::\+Col$<$ size\+\_\+t $>$ \&indices, arma\+::vec \&distances, const size\+\_\+t point\+Set\+Size)
\begin{DoxyCompactList}\small\item\em Fill the vector of distances with the distances between the point specified by point\+Index and each point in the indices array. \end{DoxyCompactList}\item 
void {\bf Create\+Children} (arma\+::\+Col$<$ size\+\_\+t $>$ \&indices, arma\+::vec \&distances, size\+\_\+t near\+Set\+Size, size\+\_\+t \&far\+Set\+Size, size\+\_\+t \&used\+Set\+Size)
\begin{DoxyCompactList}\small\item\em Create the children for this node. \end{DoxyCompactList}\item 
void {\bf Move\+To\+Used\+Set} (arma\+::\+Col$<$ size\+\_\+t $>$ \&indices, arma\+::vec \&distances, size\+\_\+t \&near\+Set\+Size, size\+\_\+t \&far\+Set\+Size, size\+\_\+t \&used\+Set\+Size, arma\+::\+Col$<$ size\+\_\+t $>$ \&child\+Indices, const size\+\_\+t child\+Far\+Set\+Size, const size\+\_\+t child\+Used\+Set\+Size)
\item 
size\+\_\+t {\bf Prune\+Far\+Set} (arma\+::\+Col$<$ size\+\_\+t $>$ \&indices, arma\+::vec \&distances, const {\bf Elem\+Type} bound, const size\+\_\+t near\+Set\+Size, const size\+\_\+t point\+Set\+Size)
\item 
void {\bf Remove\+New\+Implicit\+Nodes} ()
\begin{DoxyCompactList}\small\item\em Take a look at the last child (the most recently created one) and remove any implicit nodes that have been created. \end{DoxyCompactList}\item 
size\+\_\+t {\bf Sort\+Point\+Set} (arma\+::\+Col$<$ size\+\_\+t $>$ \&indices, arma\+::vec \&distances, const size\+\_\+t child\+Far\+Set\+Size, const size\+\_\+t child\+Used\+Set\+Size, const size\+\_\+t far\+Set\+Size)
\begin{DoxyCompactList}\small\item\em Assuming that the list of indices and distances is sorted as [ child\+Far\+Set $\vert$ child\+Used\+Set $\vert$ far\+Set $\vert$ used\+Set ], resort the sets so the organization is [ child\+Far\+Set $\vert$ far\+Set $\vert$ child\+Used\+Set $\vert$ used\+Set ]. \end{DoxyCompactList}\item 
size\+\_\+t {\bf Split\+Near\+Far} (arma\+::\+Col$<$ size\+\_\+t $>$ \&indices, arma\+::vec \&distances, const {\bf Elem\+Type} bound, const size\+\_\+t point\+Set\+Size)
\begin{DoxyCompactList}\small\item\em Split the given indices and distances into a near and a far set, returning the number of points in the near set. \end{DoxyCompactList}\end{DoxyCompactItemize}
\subsection*{Private Attributes}
\begin{DoxyCompactItemize}
\item 
{\bf Elem\+Type} {\bf base}
\begin{DoxyCompactList}\small\item\em The base used to construct the tree. \end{DoxyCompactList}\item 
std\+::vector$<$ {\bf Cover\+Tree} $\ast$ $>$ {\bf children}
\begin{DoxyCompactList}\small\item\em The list of children; the first is the self-\/child. \end{DoxyCompactList}\item 
const Mat\+Type $\ast$ {\bf dataset}
\begin{DoxyCompactList}\small\item\em Reference to the matrix which this tree is built on. \end{DoxyCompactList}\item 
size\+\_\+t {\bf distance\+Comps}
\item 
{\bf Elem\+Type} {\bf furthest\+Descendant\+Distance}
\begin{DoxyCompactList}\small\item\em Distance to the furthest descendant. \end{DoxyCompactList}\item 
bool {\bf local\+Dataset}
\begin{DoxyCompactList}\small\item\em If true, we own the dataset and need to destroy it in the destructor. \end{DoxyCompactList}\item 
bool {\bf local\+Metric}
\begin{DoxyCompactList}\small\item\em Whether or not we need to destroy the metric in the destructor. \end{DoxyCompactList}\item 
Metric\+Type $\ast$ {\bf metric}
\begin{DoxyCompactList}\small\item\em The metric used for this tree. \end{DoxyCompactList}\item 
size\+\_\+t {\bf num\+Descendants}
\begin{DoxyCompactList}\small\item\em The number of descendant points. \end{DoxyCompactList}\item 
{\bf Cover\+Tree} $\ast$ {\bf parent}
\begin{DoxyCompactList}\small\item\em The parent node (N\+U\+LL if this is the root of the tree). \end{DoxyCompactList}\item 
{\bf Elem\+Type} {\bf parent\+Distance}
\begin{DoxyCompactList}\small\item\em Distance to the parent. \end{DoxyCompactList}\item 
size\+\_\+t {\bf point}
\begin{DoxyCompactList}\small\item\em Index of the point in the matrix which this node represents. \end{DoxyCompactList}\item 
int {\bf scale}
\begin{DoxyCompactList}\small\item\em Scale level of the node. \end{DoxyCompactList}\item 
Statistic\+Type {\bf stat}
\begin{DoxyCompactList}\small\item\em The instantiated statistic. \end{DoxyCompactList}\end{DoxyCompactItemize}


\subsection{Detailed Description}
\subsubsection*{template$<$typename Metric\+Type = metric\+::\+L\+Metric$<$2, true$>$, typename Statistic\+Type = Empty\+Statistic, typename Mat\+Type = arma\+::mat, typename Root\+Point\+Policy = First\+Point\+Is\+Root$>$\\*
class mlpack\+::tree\+::\+Cover\+Tree$<$ Metric\+Type, Statistic\+Type, Mat\+Type, Root\+Point\+Policy $>$}

A cover tree is a tree specifically designed to speed up nearest-\/neighbor computation in high-\/dimensional spaces. 

Each non-\/leaf node references a point and has a nonzero number of children, including a \char`\"{}self-\/child\char`\"{} which references the same point. A leaf node represents only one point.

The tree can be thought of as a hierarchy with the root node at the top level and the leaf nodes at the bottom level. Each level in the tree has an assigned \textquotesingle{}scale\textquotesingle{} i. The tree follows these two invariants\+:


\begin{DoxyItemize}
\item nesting\+: the level C\+\_\+i is a subset of the level C\+\_\+\{i -\/ 1\}.
\item covering\+: all node in level C\+\_\+\{i -\/ 1\} have at least one node in the level C\+\_\+i with distance less than or equal to b$^\wedge$i (exactly one of these is a parent of the point in level C\+\_\+\{i -\/ 1\}.
\end{DoxyItemize}

Note that in the cover tree paper, there is a third invariant (the \textquotesingle{}separation invariant\textquotesingle{}), but that does not apply to our implementation, because we have relaxed the invariant.

The value \textquotesingle{}b\textquotesingle{} refers to the base, which is a parameter of the tree. These three properties make the cover tree very good for fast, high-\/dimensional nearest-\/neighbor search.

The theoretical structure of the tree contains many \textquotesingle{}implicit\textquotesingle{} nodes which only have a \char`\"{}self-\/child\char`\"{} (a child referencing the same point, but at a lower scale level). This practical implementation only constructs explicit nodes -- non-\/leaf nodes with more than one child. A leaf node has no children, and its scale level is I\+N\+T\+\_\+\+M\+IN.

For more information on cover trees, see


\begin{DoxyCode}
@inproceedings\{
  author = \{Beygelzimer, Alina and Kakade, Sham and Langford, John\},
  title = \{Cover trees \textcolor{keywordflow}{for} nearest neighbor\},
  booktitle = \{Proceedings of the 23rd International Conference on Machine
    Learning\},
  series = \{ICML \textcolor{stringliteral}{'06\},}
\textcolor{stringliteral}{  year = \{2006\},}
\textcolor{stringliteral}{  pages = \{97--104]}
\textcolor{stringliteral}{\}}
\end{DoxyCode}


For information on runtime bounds of the nearest-\/neighbor computation using cover trees, see the following paper, presented at N\+I\+PS 2009\+:


\begin{DoxyCode}
@inproceedings\{
  author = \{Ram, P., and Lee, D., and March, W.B., and Gray, A.G.\},
  title = \{Linear-time Algorithms \textcolor{keywordflow}{for} Pairwise Statistical Problems\},
  booktitle = \{Advances in Neural Information Processing Systems 22\},
  editor = \{Y. Bengio and D. Schuurmans and J. Lafferty and C.K.I. Williams
    and A. Culotta\},
  pages = \{1527--1535\},
  year = \{2009\}
\}
\end{DoxyCode}


The \doxyref{Cover\+Tree}{p.}{classmlpack_1_1tree_1_1CoverTree} class offers three template parameters; a custom metric type can be used with Metric\+Type (this class defaults to the L2-\/squared metric). The root node\textquotesingle{}s point can be chosen with the Root\+Point\+Policy; by default, the \doxyref{First\+Point\+Is\+Root}{p.}{classmlpack_1_1tree_1_1FirstPointIsRoot} policy is used, meaning the first point in the dataset is used. The Statistic\+Type policy allows you to define statistics which can be gathered during the creation of the tree.


\begin{DoxyTemplParams}{Template Parameters}
{\em Metric\+Type} & Metric type to use during tree construction. \\
\hline
{\em Root\+Point\+Policy} & Determines which point to use as the root node. \\
\hline
{\em Statistic\+Type} & Statistic to be used during tree creation. \\
\hline
{\em Mat\+Type} & Type of matrix to build the tree on (generally mat or sp\+\_\+mat). \\
\hline
\end{DoxyTemplParams}


Definition at line 99 of file cover\+\_\+tree.\+hpp.



\subsection{Member Typedef Documentation}
\index{mlpack\+::tree\+::\+Cover\+Tree@{mlpack\+::tree\+::\+Cover\+Tree}!Breadth\+First\+Dual\+Tree\+Traverser@{Breadth\+First\+Dual\+Tree\+Traverser}}
\index{Breadth\+First\+Dual\+Tree\+Traverser@{Breadth\+First\+Dual\+Tree\+Traverser}!mlpack\+::tree\+::\+Cover\+Tree@{mlpack\+::tree\+::\+Cover\+Tree}}
\subsubsection[{Breadth\+First\+Dual\+Tree\+Traverser}]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename Metric\+Type  = metric\+::\+L\+Metric$<$2, true$>$, typename Statistic\+Type  = Empty\+Statistic, typename Mat\+Type  = arma\+::mat, typename Root\+Point\+Policy  = First\+Point\+Is\+Root$>$ template$<$typename Rule\+Type $>$ using {\bf mlpack\+::tree\+::\+Cover\+Tree}$<$ Metric\+Type, Statistic\+Type, Mat\+Type, Root\+Point\+Policy $>$\+::{\bf Breadth\+First\+Dual\+Tree\+Traverser} =  {\bf Dual\+Tree\+Traverser}$<$Rule\+Type$>$}\label{classmlpack_1_1tree_1_1CoverTree_a6ad87f457dcb3c5fda1a02ca2c630847}


Definition at line 264 of file cover\+\_\+tree.\+hpp.

\index{mlpack\+::tree\+::\+Cover\+Tree@{mlpack\+::tree\+::\+Cover\+Tree}!Elem\+Type@{Elem\+Type}}
\index{Elem\+Type@{Elem\+Type}!mlpack\+::tree\+::\+Cover\+Tree@{mlpack\+::tree\+::\+Cover\+Tree}}
\subsubsection[{Elem\+Type}]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename Metric\+Type  = metric\+::\+L\+Metric$<$2, true$>$, typename Statistic\+Type  = Empty\+Statistic, typename Mat\+Type  = arma\+::mat, typename Root\+Point\+Policy  = First\+Point\+Is\+Root$>$ typedef Mat\+Type\+::elem\+\_\+type {\bf mlpack\+::tree\+::\+Cover\+Tree}$<$ Metric\+Type, Statistic\+Type, Mat\+Type, Root\+Point\+Policy $>$\+::{\bf Elem\+Type}}\label{classmlpack_1_1tree_1_1CoverTree_a642f3b132a13c354b6216392a349e10f}


The type held by the matrix type. 



Definition at line 105 of file cover\+\_\+tree.\+hpp.

\index{mlpack\+::tree\+::\+Cover\+Tree@{mlpack\+::tree\+::\+Cover\+Tree}!Mat@{Mat}}
\index{Mat@{Mat}!mlpack\+::tree\+::\+Cover\+Tree@{mlpack\+::tree\+::\+Cover\+Tree}}
\subsubsection[{Mat}]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename Metric\+Type  = metric\+::\+L\+Metric$<$2, true$>$, typename Statistic\+Type  = Empty\+Statistic, typename Mat\+Type  = arma\+::mat, typename Root\+Point\+Policy  = First\+Point\+Is\+Root$>$ typedef Mat\+Type {\bf mlpack\+::tree\+::\+Cover\+Tree}$<$ Metric\+Type, Statistic\+Type, Mat\+Type, Root\+Point\+Policy $>$\+::{\bf Mat}}\label{classmlpack_1_1tree_1_1CoverTree_a75114973b7b4ec9b6459a2a2ffb8eddc}


So that other classes can access the matrix type. 



Definition at line 103 of file cover\+\_\+tree.\+hpp.



\subsection{Constructor \& Destructor Documentation}
\index{mlpack\+::tree\+::\+Cover\+Tree@{mlpack\+::tree\+::\+Cover\+Tree}!Cover\+Tree@{Cover\+Tree}}
\index{Cover\+Tree@{Cover\+Tree}!mlpack\+::tree\+::\+Cover\+Tree@{mlpack\+::tree\+::\+Cover\+Tree}}
\subsubsection[{Cover\+Tree(const Mat\+Type \&dataset, const Elem\+Type base=2.\+0, Metric\+Type $\ast$metric=\+N\+U\+L\+L)}]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename Metric\+Type  = metric\+::\+L\+Metric$<$2, true$>$, typename Statistic\+Type  = Empty\+Statistic, typename Mat\+Type  = arma\+::mat, typename Root\+Point\+Policy  = First\+Point\+Is\+Root$>$ {\bf mlpack\+::tree\+::\+Cover\+Tree}$<$ Metric\+Type, Statistic\+Type, Mat\+Type, Root\+Point\+Policy $>$\+::{\bf Cover\+Tree} (
\begin{DoxyParamCaption}
\item[{const Mat\+Type \&}]{dataset, }
\item[{const {\bf Elem\+Type}}]{base = {\ttfamily 2.0}, }
\item[{Metric\+Type $\ast$}]{metric = {\ttfamily NULL}}
\end{DoxyParamCaption}
)}\label{classmlpack_1_1tree_1_1CoverTree_a3df0aa1fec8459e5e55bceee89545a6e}


Create the cover tree with the given dataset and given base. 

The dataset will not be modified during the building procedure (unlike \doxyref{Binary\+Space\+Tree}{p.}{classmlpack_1_1tree_1_1BinarySpaceTree}).

The last argument will be removed in mlpack 1.\+1.\+0 (see \#274 and \#273).


\begin{DoxyParams}{Parameters}
{\em dataset} & Reference to the dataset to build a tree on. \\
\hline
{\em base} & Base to use during tree building (default 2.\+0). \\
\hline
\end{DoxyParams}
\index{mlpack\+::tree\+::\+Cover\+Tree@{mlpack\+::tree\+::\+Cover\+Tree}!Cover\+Tree@{Cover\+Tree}}
\index{Cover\+Tree@{Cover\+Tree}!mlpack\+::tree\+::\+Cover\+Tree@{mlpack\+::tree\+::\+Cover\+Tree}}
\subsubsection[{Cover\+Tree(const Mat\+Type \&dataset, Metric\+Type \&metric, const Elem\+Type base=2.\+0)}]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename Metric\+Type  = metric\+::\+L\+Metric$<$2, true$>$, typename Statistic\+Type  = Empty\+Statistic, typename Mat\+Type  = arma\+::mat, typename Root\+Point\+Policy  = First\+Point\+Is\+Root$>$ {\bf mlpack\+::tree\+::\+Cover\+Tree}$<$ Metric\+Type, Statistic\+Type, Mat\+Type, Root\+Point\+Policy $>$\+::{\bf Cover\+Tree} (
\begin{DoxyParamCaption}
\item[{const Mat\+Type \&}]{dataset, }
\item[{Metric\+Type \&}]{metric, }
\item[{const {\bf Elem\+Type}}]{base = {\ttfamily 2.0}}
\end{DoxyParamCaption}
)}\label{classmlpack_1_1tree_1_1CoverTree_a826e5c232306bf6368a8ad9ad4e464d9}


Create the cover tree with the given dataset and the given instantiated metric. 

Optionally, set the base. The dataset will not be modified during the building procedure (unlike \doxyref{Binary\+Space\+Tree}{p.}{classmlpack_1_1tree_1_1BinarySpaceTree}).


\begin{DoxyParams}{Parameters}
{\em dataset} & Reference to the dataset to build a tree on. \\
\hline
{\em metric} & Instantiated metric to use during tree building. \\
\hline
{\em base} & Base to use during tree building (default 2.\+0). \\
\hline
\end{DoxyParams}
\index{mlpack\+::tree\+::\+Cover\+Tree@{mlpack\+::tree\+::\+Cover\+Tree}!Cover\+Tree@{Cover\+Tree}}
\index{Cover\+Tree@{Cover\+Tree}!mlpack\+::tree\+::\+Cover\+Tree@{mlpack\+::tree\+::\+Cover\+Tree}}
\subsubsection[{Cover\+Tree(\+Mat\+Type \&\&dataset, const Elem\+Type base=2.\+0)}]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename Metric\+Type  = metric\+::\+L\+Metric$<$2, true$>$, typename Statistic\+Type  = Empty\+Statistic, typename Mat\+Type  = arma\+::mat, typename Root\+Point\+Policy  = First\+Point\+Is\+Root$>$ {\bf mlpack\+::tree\+::\+Cover\+Tree}$<$ Metric\+Type, Statistic\+Type, Mat\+Type, Root\+Point\+Policy $>$\+::{\bf Cover\+Tree} (
\begin{DoxyParamCaption}
\item[{Mat\+Type \&\&}]{dataset, }
\item[{const {\bf Elem\+Type}}]{base = {\ttfamily 2.0}}
\end{DoxyParamCaption}
)}\label{classmlpack_1_1tree_1_1CoverTree_ae70dc14e53d01ffd7f540dc3b33ab9a4}


Create the cover tree with the given dataset, taking ownership of the dataset. 

Optionally, set the base.


\begin{DoxyParams}{Parameters}
{\em dataset} & Reference to the dataset to build a tree on. \\
\hline
{\em base} & Base to use during tree building (default 2.\+0). \\
\hline
\end{DoxyParams}
\index{mlpack\+::tree\+::\+Cover\+Tree@{mlpack\+::tree\+::\+Cover\+Tree}!Cover\+Tree@{Cover\+Tree}}
\index{Cover\+Tree@{Cover\+Tree}!mlpack\+::tree\+::\+Cover\+Tree@{mlpack\+::tree\+::\+Cover\+Tree}}
\subsubsection[{Cover\+Tree(\+Mat\+Type \&\&dataset, Metric\+Type \&metric, const Elem\+Type base=2.\+0)}]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename Metric\+Type  = metric\+::\+L\+Metric$<$2, true$>$, typename Statistic\+Type  = Empty\+Statistic, typename Mat\+Type  = arma\+::mat, typename Root\+Point\+Policy  = First\+Point\+Is\+Root$>$ {\bf mlpack\+::tree\+::\+Cover\+Tree}$<$ Metric\+Type, Statistic\+Type, Mat\+Type, Root\+Point\+Policy $>$\+::{\bf Cover\+Tree} (
\begin{DoxyParamCaption}
\item[{Mat\+Type \&\&}]{dataset, }
\item[{Metric\+Type \&}]{metric, }
\item[{const {\bf Elem\+Type}}]{base = {\ttfamily 2.0}}
\end{DoxyParamCaption}
)}\label{classmlpack_1_1tree_1_1CoverTree_ae2eeb3c58aae3eeb4fa1720ee6da6148}


Create the cover tree with the given dataset and the given instantiated metric, taking ownership of the dataset. 

Optionally, set the base.


\begin{DoxyParams}{Parameters}
{\em dataset} & Reference to the dataset to build a tree on. \\
\hline
{\em metric} & Instantiated metric to use during tree building. \\
\hline
{\em base} & Base to use during tree building (default 2.\+0). \\
\hline
\end{DoxyParams}
\index{mlpack\+::tree\+::\+Cover\+Tree@{mlpack\+::tree\+::\+Cover\+Tree}!Cover\+Tree@{Cover\+Tree}}
\index{Cover\+Tree@{Cover\+Tree}!mlpack\+::tree\+::\+Cover\+Tree@{mlpack\+::tree\+::\+Cover\+Tree}}
\subsubsection[{Cover\+Tree(const Mat\+Type \&dataset, const Elem\+Type base, const size\+\_\+t point\+Index, const int scale, Cover\+Tree $\ast$parent, const Elem\+Type parent\+Distance, arma\+::\+Col$<$ size\+\_\+t $>$ \&indices, arma\+::vec \&distances, size\+\_\+t near\+Set\+Size, size\+\_\+t \&far\+Set\+Size, size\+\_\+t \&used\+Set\+Size, Metric\+Type \&metric=\+N\+U\+L\+L)}]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename Metric\+Type  = metric\+::\+L\+Metric$<$2, true$>$, typename Statistic\+Type  = Empty\+Statistic, typename Mat\+Type  = arma\+::mat, typename Root\+Point\+Policy  = First\+Point\+Is\+Root$>$ {\bf mlpack\+::tree\+::\+Cover\+Tree}$<$ Metric\+Type, Statistic\+Type, Mat\+Type, Root\+Point\+Policy $>$\+::{\bf Cover\+Tree} (
\begin{DoxyParamCaption}
\item[{const Mat\+Type \&}]{dataset, }
\item[{const {\bf Elem\+Type}}]{base, }
\item[{const size\+\_\+t}]{point\+Index, }
\item[{const int}]{scale, }
\item[{{\bf Cover\+Tree}$<$ Metric\+Type, Statistic\+Type, Mat\+Type, Root\+Point\+Policy $>$ $\ast$}]{parent, }
\item[{const {\bf Elem\+Type}}]{parent\+Distance, }
\item[{arma\+::\+Col$<$ size\+\_\+t $>$ \&}]{indices, }
\item[{arma\+::vec \&}]{distances, }
\item[{size\+\_\+t}]{near\+Set\+Size, }
\item[{size\+\_\+t \&}]{far\+Set\+Size, }
\item[{size\+\_\+t \&}]{used\+Set\+Size, }
\item[{Metric\+Type \&}]{metric = {\ttfamily NULL}}
\end{DoxyParamCaption}
)}\label{classmlpack_1_1tree_1_1CoverTree_ad74b0613756174481ade5c1d70b54b98}


Construct a child cover tree node. 

This constructor is not meant to be used externally, but it could be used to insert another node into a tree. This procedure uses only one vector for the near set, the far set, and the used set (this is to prevent unnecessary memory allocation in recursive calls to this constructor). Therefore, the size of the near set, far set, and used set must be passed in. The near set will be entirely used up, and some of the far set may be used. The value of used\+Set\+Size will be set to the number of points used in the construction of this node, and the value of far\+Set\+Size will be modified to reflect the number of points in the far set {\itshape after} the construction of this node.

If you are calling this manually, be careful that the given scale is as small as possible, or you may be creating an implicit node in your tree.


\begin{DoxyParams}{Parameters}
{\em dataset} & Reference to the dataset to build a tree on. \\
\hline
{\em base} & Base to use during tree building. \\
\hline
{\em point\+Index} & Index of the point this node references. \\
\hline
{\em scale} & Scale of this level in the tree. \\
\hline
{\em parent} & Parent of this node (N\+U\+LL indicates no parent). \\
\hline
{\em parent\+Distance} & Distance to the parent node. \\
\hline
{\em indices} & Array of indices, ordered [ near\+Set $\vert$ far\+Set $\vert$ used\+Set ]; will be modified to [ far\+Set $\vert$ used\+Set ]. \\
\hline
{\em distances} & Array of distances, ordered the same way as the indices. These represent the distances between the point specified by point\+Index and each point in the indices array. \\
\hline
{\em near\+Set\+Size} & Size of the near set; if 0, this will be a leaf. \\
\hline
{\em far\+Set\+Size} & Size of the far set; may be modified (if this node uses any points in the far set). \\
\hline
{\em used\+Set\+Size} & The number of points used will be added to this number. \\
\hline
\end{DoxyParams}
\index{mlpack\+::tree\+::\+Cover\+Tree@{mlpack\+::tree\+::\+Cover\+Tree}!Cover\+Tree@{Cover\+Tree}}
\index{Cover\+Tree@{Cover\+Tree}!mlpack\+::tree\+::\+Cover\+Tree@{mlpack\+::tree\+::\+Cover\+Tree}}
\subsubsection[{Cover\+Tree(const Mat\+Type \&dataset, const Elem\+Type base, const size\+\_\+t point\+Index, const int scale, Cover\+Tree $\ast$parent, const Elem\+Type parent\+Distance, const Elem\+Type furthest\+Descendant\+Distance, Metric\+Type $\ast$metric=\+N\+U\+L\+L)}]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename Metric\+Type  = metric\+::\+L\+Metric$<$2, true$>$, typename Statistic\+Type  = Empty\+Statistic, typename Mat\+Type  = arma\+::mat, typename Root\+Point\+Policy  = First\+Point\+Is\+Root$>$ {\bf mlpack\+::tree\+::\+Cover\+Tree}$<$ Metric\+Type, Statistic\+Type, Mat\+Type, Root\+Point\+Policy $>$\+::{\bf Cover\+Tree} (
\begin{DoxyParamCaption}
\item[{const Mat\+Type \&}]{dataset, }
\item[{const {\bf Elem\+Type}}]{base, }
\item[{const size\+\_\+t}]{point\+Index, }
\item[{const int}]{scale, }
\item[{{\bf Cover\+Tree}$<$ Metric\+Type, Statistic\+Type, Mat\+Type, Root\+Point\+Policy $>$ $\ast$}]{parent, }
\item[{const {\bf Elem\+Type}}]{parent\+Distance, }
\item[{const {\bf Elem\+Type}}]{furthest\+Descendant\+Distance, }
\item[{Metric\+Type $\ast$}]{metric = {\ttfamily NULL}}
\end{DoxyParamCaption}
)}\label{classmlpack_1_1tree_1_1CoverTree_a82c67e0d4407065cc105b189acadbe02}


Manually construct a cover tree node; no tree assembly is done in this constructor, and children must be added manually (use \doxyref{Children()}{p.}{classmlpack_1_1tree_1_1CoverTree_a0027dac9b598ae3c4541b2db36a8b111}). 

This constructor is useful when the tree is being \char`\"{}imported\char`\"{} into the \doxyref{Cover\+Tree}{p.}{classmlpack_1_1tree_1_1CoverTree} class after being created in some other manner.


\begin{DoxyParams}{Parameters}
{\em dataset} & Reference to the dataset this node is a part of. \\
\hline
{\em base} & Base that was used for tree building. \\
\hline
{\em point\+Index} & Index of the point in the dataset which this node refers to. \\
\hline
{\em scale} & Scale of this node\textquotesingle{}s level in the tree. \\
\hline
{\em parent} & Parent node (N\+U\+LL indicates no parent). \\
\hline
{\em parent\+Distance} & Distance to parent node point. \\
\hline
{\em furthest\+Descendant\+Distance} & Distance to furthest descendant point. \\
\hline
{\em metric} & Instantiated metric (optional). \\
\hline
\end{DoxyParams}
\index{mlpack\+::tree\+::\+Cover\+Tree@{mlpack\+::tree\+::\+Cover\+Tree}!Cover\+Tree@{Cover\+Tree}}
\index{Cover\+Tree@{Cover\+Tree}!mlpack\+::tree\+::\+Cover\+Tree@{mlpack\+::tree\+::\+Cover\+Tree}}
\subsubsection[{Cover\+Tree(const Cover\+Tree \&other)}]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename Metric\+Type  = metric\+::\+L\+Metric$<$2, true$>$, typename Statistic\+Type  = Empty\+Statistic, typename Mat\+Type  = arma\+::mat, typename Root\+Point\+Policy  = First\+Point\+Is\+Root$>$ {\bf mlpack\+::tree\+::\+Cover\+Tree}$<$ Metric\+Type, Statistic\+Type, Mat\+Type, Root\+Point\+Policy $>$\+::{\bf Cover\+Tree} (
\begin{DoxyParamCaption}
\item[{const {\bf Cover\+Tree}$<$ Metric\+Type, Statistic\+Type, Mat\+Type, Root\+Point\+Policy $>$ \&}]{other}
\end{DoxyParamCaption}
)}\label{classmlpack_1_1tree_1_1CoverTree_a537db7b52e2c3426604ad6f34710dd33}


Create a cover tree from another tree. 

Be careful! This may use a lot of memory and take a lot of time. This will also make a copy of the dataset.


\begin{DoxyParams}{Parameters}
{\em other} & Cover tree to copy from. \\
\hline
\end{DoxyParams}
\index{mlpack\+::tree\+::\+Cover\+Tree@{mlpack\+::tree\+::\+Cover\+Tree}!Cover\+Tree@{Cover\+Tree}}
\index{Cover\+Tree@{Cover\+Tree}!mlpack\+::tree\+::\+Cover\+Tree@{mlpack\+::tree\+::\+Cover\+Tree}}
\subsubsection[{Cover\+Tree(\+Cover\+Tree \&\&other)}]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename Metric\+Type  = metric\+::\+L\+Metric$<$2, true$>$, typename Statistic\+Type  = Empty\+Statistic, typename Mat\+Type  = arma\+::mat, typename Root\+Point\+Policy  = First\+Point\+Is\+Root$>$ {\bf mlpack\+::tree\+::\+Cover\+Tree}$<$ Metric\+Type, Statistic\+Type, Mat\+Type, Root\+Point\+Policy $>$\+::{\bf Cover\+Tree} (
\begin{DoxyParamCaption}
\item[{{\bf Cover\+Tree}$<$ Metric\+Type, Statistic\+Type, Mat\+Type, Root\+Point\+Policy $>$ \&\&}]{other}
\end{DoxyParamCaption}
)}\label{classmlpack_1_1tree_1_1CoverTree_a8720353fb2e6f7b46c79424302cf071c}


Move constructor for a Cover Tree, possess all the members of the given tree. 


\begin{DoxyParams}{Parameters}
{\em other} & Cover Tree to move. \\
\hline
\end{DoxyParams}
\index{mlpack\+::tree\+::\+Cover\+Tree@{mlpack\+::tree\+::\+Cover\+Tree}!Cover\+Tree@{Cover\+Tree}}
\index{Cover\+Tree@{Cover\+Tree}!mlpack\+::tree\+::\+Cover\+Tree@{mlpack\+::tree\+::\+Cover\+Tree}}
\subsubsection[{Cover\+Tree(\+Archive \&ar, const typename std\+::enable\+\_\+if\+\_\+t$<$ Archive\+::is\+\_\+loading\+::value $>$ $\ast$=0)}]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename Metric\+Type  = metric\+::\+L\+Metric$<$2, true$>$, typename Statistic\+Type  = Empty\+Statistic, typename Mat\+Type  = arma\+::mat, typename Root\+Point\+Policy  = First\+Point\+Is\+Root$>$ template$<$typename Archive $>$ {\bf mlpack\+::tree\+::\+Cover\+Tree}$<$ Metric\+Type, Statistic\+Type, Mat\+Type, Root\+Point\+Policy $>$\+::{\bf Cover\+Tree} (
\begin{DoxyParamCaption}
\item[{Archive \&}]{ar, }
\item[{const typename {\bf std\+::enable\+\_\+if\+\_\+t}$<$ Archive\+::is\+\_\+loading\+::value $>$ $\ast$}]{ = {\ttfamily 0}}
\end{DoxyParamCaption}
)}\label{classmlpack_1_1tree_1_1CoverTree_aa57ca8739c13b7bf3437e94eacc40b9d}


Create a cover tree from a \doxyref{boost\+::serialization}{p.}{namespaceboost_1_1serialization} archive. 

\index{mlpack\+::tree\+::\+Cover\+Tree@{mlpack\+::tree\+::\+Cover\+Tree}!````~Cover\+Tree@{$\sim$\+Cover\+Tree}}
\index{````~Cover\+Tree@{$\sim$\+Cover\+Tree}!mlpack\+::tree\+::\+Cover\+Tree@{mlpack\+::tree\+::\+Cover\+Tree}}
\subsubsection[{$\sim$\+Cover\+Tree()}]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename Metric\+Type  = metric\+::\+L\+Metric$<$2, true$>$, typename Statistic\+Type  = Empty\+Statistic, typename Mat\+Type  = arma\+::mat, typename Root\+Point\+Policy  = First\+Point\+Is\+Root$>$ {\bf mlpack\+::tree\+::\+Cover\+Tree}$<$ Metric\+Type, Statistic\+Type, Mat\+Type, Root\+Point\+Policy $>$\+::$\sim${\bf Cover\+Tree} (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)}\label{classmlpack_1_1tree_1_1CoverTree_a33cc8ae8c40dc16c733ebf1cd1711bd9}


Delete this cover tree node and its children. 

\index{mlpack\+::tree\+::\+Cover\+Tree@{mlpack\+::tree\+::\+Cover\+Tree}!Cover\+Tree@{Cover\+Tree}}
\index{Cover\+Tree@{Cover\+Tree}!mlpack\+::tree\+::\+Cover\+Tree@{mlpack\+::tree\+::\+Cover\+Tree}}
\subsubsection[{Cover\+Tree()}]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename Metric\+Type  = metric\+::\+L\+Metric$<$2, true$>$, typename Statistic\+Type  = Empty\+Statistic, typename Mat\+Type  = arma\+::mat, typename Root\+Point\+Policy  = First\+Point\+Is\+Root$>$ {\bf mlpack\+::tree\+::\+Cover\+Tree}$<$ Metric\+Type, Statistic\+Type, Mat\+Type, Root\+Point\+Policy $>$\+::{\bf Cover\+Tree} (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [protected]}}\label{classmlpack_1_1tree_1_1CoverTree_a3e8ba98ec80f4ed426dc50b5a5aa2da6}


A default constructor. 

This is meant to only be used with \doxyref{boost\+::serialization}{p.}{namespaceboost_1_1serialization}, which is allowed with the friend declaration below. This does not return a valid tree! This method must be protected, so that the serialization shim can work with the default constructor. 

\subsection{Member Function Documentation}
\index{mlpack\+::tree\+::\+Cover\+Tree@{mlpack\+::tree\+::\+Cover\+Tree}!Base@{Base}}
\index{Base@{Base}!mlpack\+::tree\+::\+Cover\+Tree@{mlpack\+::tree\+::\+Cover\+Tree}}
\subsubsection[{Base() const }]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename Metric\+Type  = metric\+::\+L\+Metric$<$2, true$>$, typename Statistic\+Type  = Empty\+Statistic, typename Mat\+Type  = arma\+::mat, typename Root\+Point\+Policy  = First\+Point\+Is\+Root$>$ {\bf Elem\+Type} {\bf mlpack\+::tree\+::\+Cover\+Tree}$<$ Metric\+Type, Statistic\+Type, Mat\+Type, Root\+Point\+Policy $>$\+::Base (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
) const\hspace{0.3cm}{\ttfamily [inline]}}\label{classmlpack_1_1tree_1_1CoverTree_a427fdef7116fa186fcbd97c7badba608}


Get the base. 



Definition at line 304 of file cover\+\_\+tree.\+hpp.



References mlpack\+::tree\+::\+Cover\+Tree$<$ Metric\+Type, Statistic\+Type, Mat\+Type, Root\+Point\+Policy $>$\+::base.

\index{mlpack\+::tree\+::\+Cover\+Tree@{mlpack\+::tree\+::\+Cover\+Tree}!Base@{Base}}
\index{Base@{Base}!mlpack\+::tree\+::\+Cover\+Tree@{mlpack\+::tree\+::\+Cover\+Tree}}
\subsubsection[{Base()}]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename Metric\+Type  = metric\+::\+L\+Metric$<$2, true$>$, typename Statistic\+Type  = Empty\+Statistic, typename Mat\+Type  = arma\+::mat, typename Root\+Point\+Policy  = First\+Point\+Is\+Root$>$ {\bf Elem\+Type}\& {\bf mlpack\+::tree\+::\+Cover\+Tree}$<$ Metric\+Type, Statistic\+Type, Mat\+Type, Root\+Point\+Policy $>$\+::Base (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}}\label{classmlpack_1_1tree_1_1CoverTree_a1674fe051bbe42ffae646d100b2eb4a7}


Modify the base; don\textquotesingle{}t do this, you\textquotesingle{}ll break everything. 



Definition at line 306 of file cover\+\_\+tree.\+hpp.



References mlpack\+::tree\+::\+Cover\+Tree$<$ Metric\+Type, Statistic\+Type, Mat\+Type, Root\+Point\+Policy $>$\+::base.

\index{mlpack\+::tree\+::\+Cover\+Tree@{mlpack\+::tree\+::\+Cover\+Tree}!Center@{Center}}
\index{Center@{Center}!mlpack\+::tree\+::\+Cover\+Tree@{mlpack\+::tree\+::\+Cover\+Tree}}
\subsubsection[{Center(arma\+::vec \&center) const }]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename Metric\+Type  = metric\+::\+L\+Metric$<$2, true$>$, typename Statistic\+Type  = Empty\+Statistic, typename Mat\+Type  = arma\+::mat, typename Root\+Point\+Policy  = First\+Point\+Is\+Root$>$ void {\bf mlpack\+::tree\+::\+Cover\+Tree}$<$ Metric\+Type, Statistic\+Type, Mat\+Type, Root\+Point\+Policy $>$\+::Center (
\begin{DoxyParamCaption}
\item[{arma\+::vec \&}]{center}
\end{DoxyParamCaption}
) const\hspace{0.3cm}{\ttfamily [inline]}}\label{classmlpack_1_1tree_1_1CoverTree_a98990555dafef479f4cc1afa125daebb}


Get the center of the node and store it in the given vector. 



Definition at line 412 of file cover\+\_\+tree.\+hpp.



References mlpack\+::tree\+::\+Cover\+Tree$<$ Metric\+Type, Statistic\+Type, Mat\+Type, Root\+Point\+Policy $>$\+::dataset.

\index{mlpack\+::tree\+::\+Cover\+Tree@{mlpack\+::tree\+::\+Cover\+Tree}!Child@{Child}}
\index{Child@{Child}!mlpack\+::tree\+::\+Cover\+Tree@{mlpack\+::tree\+::\+Cover\+Tree}}
\subsubsection[{Child(const size\+\_\+t index) const }]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename Metric\+Type  = metric\+::\+L\+Metric$<$2, true$>$, typename Statistic\+Type  = Empty\+Statistic, typename Mat\+Type  = arma\+::mat, typename Root\+Point\+Policy  = First\+Point\+Is\+Root$>$ const {\bf Cover\+Tree}\& {\bf mlpack\+::tree\+::\+Cover\+Tree}$<$ Metric\+Type, Statistic\+Type, Mat\+Type, Root\+Point\+Policy $>$\+::Child (
\begin{DoxyParamCaption}
\item[{const size\+\_\+t}]{index}
\end{DoxyParamCaption}
) const\hspace{0.3cm}{\ttfamily [inline]}}\label{classmlpack_1_1tree_1_1CoverTree_a0737407fbd8c454844933c83d574cfa7}


Get a particular child node. 



Definition at line 278 of file cover\+\_\+tree.\+hpp.



References mlpack\+::tree\+::\+Cover\+Tree$<$ Metric\+Type, Statistic\+Type, Mat\+Type, Root\+Point\+Policy $>$\+::children.

\index{mlpack\+::tree\+::\+Cover\+Tree@{mlpack\+::tree\+::\+Cover\+Tree}!Child@{Child}}
\index{Child@{Child}!mlpack\+::tree\+::\+Cover\+Tree@{mlpack\+::tree\+::\+Cover\+Tree}}
\subsubsection[{Child(const size\+\_\+t index)}]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename Metric\+Type  = metric\+::\+L\+Metric$<$2, true$>$, typename Statistic\+Type  = Empty\+Statistic, typename Mat\+Type  = arma\+::mat, typename Root\+Point\+Policy  = First\+Point\+Is\+Root$>$ {\bf Cover\+Tree}\& {\bf mlpack\+::tree\+::\+Cover\+Tree}$<$ Metric\+Type, Statistic\+Type, Mat\+Type, Root\+Point\+Policy $>$\+::Child (
\begin{DoxyParamCaption}
\item[{const size\+\_\+t}]{index}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}}\label{classmlpack_1_1tree_1_1CoverTree_a2cfa2e7d58176a85d2a52dfa7f569290}


Modify a particular child node. 



Definition at line 280 of file cover\+\_\+tree.\+hpp.



References mlpack\+::tree\+::\+Cover\+Tree$<$ Metric\+Type, Statistic\+Type, Mat\+Type, Root\+Point\+Policy $>$\+::children.

\index{mlpack\+::tree\+::\+Cover\+Tree@{mlpack\+::tree\+::\+Cover\+Tree}!Child\+Ptr@{Child\+Ptr}}
\index{Child\+Ptr@{Child\+Ptr}!mlpack\+::tree\+::\+Cover\+Tree@{mlpack\+::tree\+::\+Cover\+Tree}}
\subsubsection[{Child\+Ptr(const size\+\_\+t index)}]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename Metric\+Type  = metric\+::\+L\+Metric$<$2, true$>$, typename Statistic\+Type  = Empty\+Statistic, typename Mat\+Type  = arma\+::mat, typename Root\+Point\+Policy  = First\+Point\+Is\+Root$>$ {\bf Cover\+Tree}$\ast$\& {\bf mlpack\+::tree\+::\+Cover\+Tree}$<$ Metric\+Type, Statistic\+Type, Mat\+Type, Root\+Point\+Policy $>$\+::Child\+Ptr (
\begin{DoxyParamCaption}
\item[{const size\+\_\+t}]{index}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}}\label{classmlpack_1_1tree_1_1CoverTree_a6a9281286d39fc8fff2e1e65a1cbfc07}


Definition at line 282 of file cover\+\_\+tree.\+hpp.



References mlpack\+::tree\+::\+Cover\+Tree$<$ Metric\+Type, Statistic\+Type, Mat\+Type, Root\+Point\+Policy $>$\+::children.

\index{mlpack\+::tree\+::\+Cover\+Tree@{mlpack\+::tree\+::\+Cover\+Tree}!Children@{Children}}
\index{Children@{Children}!mlpack\+::tree\+::\+Cover\+Tree@{mlpack\+::tree\+::\+Cover\+Tree}}
\subsubsection[{Children() const }]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename Metric\+Type  = metric\+::\+L\+Metric$<$2, true$>$, typename Statistic\+Type  = Empty\+Statistic, typename Mat\+Type  = arma\+::mat, typename Root\+Point\+Policy  = First\+Point\+Is\+Root$>$ const std\+::vector$<${\bf Cover\+Tree}$\ast$$>$\& {\bf mlpack\+::tree\+::\+Cover\+Tree}$<$ Metric\+Type, Statistic\+Type, Mat\+Type, Root\+Point\+Policy $>$\+::Children (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
) const\hspace{0.3cm}{\ttfamily [inline]}}\label{classmlpack_1_1tree_1_1CoverTree_a757545c9dda7e527efb618c09d468b87}


Get the children. 



Definition at line 288 of file cover\+\_\+tree.\+hpp.



References mlpack\+::tree\+::\+Cover\+Tree$<$ Metric\+Type, Statistic\+Type, Mat\+Type, Root\+Point\+Policy $>$\+::children.

\index{mlpack\+::tree\+::\+Cover\+Tree@{mlpack\+::tree\+::\+Cover\+Tree}!Children@{Children}}
\index{Children@{Children}!mlpack\+::tree\+::\+Cover\+Tree@{mlpack\+::tree\+::\+Cover\+Tree}}
\subsubsection[{Children()}]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename Metric\+Type  = metric\+::\+L\+Metric$<$2, true$>$, typename Statistic\+Type  = Empty\+Statistic, typename Mat\+Type  = arma\+::mat, typename Root\+Point\+Policy  = First\+Point\+Is\+Root$>$ std\+::vector$<${\bf Cover\+Tree}$\ast$$>$\& {\bf mlpack\+::tree\+::\+Cover\+Tree}$<$ Metric\+Type, Statistic\+Type, Mat\+Type, Root\+Point\+Policy $>$\+::Children (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}}\label{classmlpack_1_1tree_1_1CoverTree_a0027dac9b598ae3c4541b2db36a8b111}


Modify the children manually (maybe not a great idea). 



Definition at line 290 of file cover\+\_\+tree.\+hpp.



References mlpack\+::tree\+::\+Cover\+Tree$<$ Metric\+Type, Statistic\+Type, Mat\+Type, Root\+Point\+Policy $>$\+::children, mlpack\+::tree\+::\+Cover\+Tree$<$ Metric\+Type, Statistic\+Type, Mat\+Type, Root\+Point\+Policy $>$\+::\+Descendant(), and mlpack\+::tree\+::\+Cover\+Tree$<$ Metric\+Type, Statistic\+Type, Mat\+Type, Root\+Point\+Policy $>$\+::\+Num\+Descendants().

\index{mlpack\+::tree\+::\+Cover\+Tree@{mlpack\+::tree\+::\+Cover\+Tree}!Compute\+Distances@{Compute\+Distances}}
\index{Compute\+Distances@{Compute\+Distances}!mlpack\+::tree\+::\+Cover\+Tree@{mlpack\+::tree\+::\+Cover\+Tree}}
\subsubsection[{Compute\+Distances(const size\+\_\+t point\+Index, const arma\+::\+Col$<$ size\+\_\+t $>$ \&indices, arma\+::vec \&distances, const size\+\_\+t point\+Set\+Size)}]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename Metric\+Type  = metric\+::\+L\+Metric$<$2, true$>$, typename Statistic\+Type  = Empty\+Statistic, typename Mat\+Type  = arma\+::mat, typename Root\+Point\+Policy  = First\+Point\+Is\+Root$>$ void {\bf mlpack\+::tree\+::\+Cover\+Tree}$<$ Metric\+Type, Statistic\+Type, Mat\+Type, Root\+Point\+Policy $>$\+::Compute\+Distances (
\begin{DoxyParamCaption}
\item[{const size\+\_\+t}]{point\+Index, }
\item[{const arma\+::\+Col$<$ size\+\_\+t $>$ \&}]{indices, }
\item[{arma\+::vec \&}]{distances, }
\item[{const size\+\_\+t}]{point\+Set\+Size}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [private]}}\label{classmlpack_1_1tree_1_1CoverTree_a0e85c192e7960a904122c987ff83871b}


Fill the vector of distances with the distances between the point specified by point\+Index and each point in the indices array. 

The distances of the first point\+Set\+Size points in indices are calculated (so, this does not necessarily need to use all of the points in the arrays).


\begin{DoxyParams}{Parameters}
{\em point\+Index} & Point to build the distances for. \\
\hline
{\em indices} & List of indices to compute distances for. \\
\hline
{\em distances} & Vector to store calculated distances in. \\
\hline
{\em point\+Set\+Size} & Number of points in arrays to calculate distances for. \\
\hline
\end{DoxyParams}
\index{mlpack\+::tree\+::\+Cover\+Tree@{mlpack\+::tree\+::\+Cover\+Tree}!Create\+Children@{Create\+Children}}
\index{Create\+Children@{Create\+Children}!mlpack\+::tree\+::\+Cover\+Tree@{mlpack\+::tree\+::\+Cover\+Tree}}
\subsubsection[{Create\+Children(arma\+::\+Col$<$ size\+\_\+t $>$ \&indices, arma\+::vec \&distances, size\+\_\+t near\+Set\+Size, size\+\_\+t \&far\+Set\+Size, size\+\_\+t \&used\+Set\+Size)}]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename Metric\+Type  = metric\+::\+L\+Metric$<$2, true$>$, typename Statistic\+Type  = Empty\+Statistic, typename Mat\+Type  = arma\+::mat, typename Root\+Point\+Policy  = First\+Point\+Is\+Root$>$ void {\bf mlpack\+::tree\+::\+Cover\+Tree}$<$ Metric\+Type, Statistic\+Type, Mat\+Type, Root\+Point\+Policy $>$\+::Create\+Children (
\begin{DoxyParamCaption}
\item[{arma\+::\+Col$<$ size\+\_\+t $>$ \&}]{indices, }
\item[{arma\+::vec \&}]{distances, }
\item[{size\+\_\+t}]{near\+Set\+Size, }
\item[{size\+\_\+t \&}]{far\+Set\+Size, }
\item[{size\+\_\+t \&}]{used\+Set\+Size}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [private]}}\label{classmlpack_1_1tree_1_1CoverTree_a511dff4cf835339aa9aaafcdc425e902}


Create the children for this node. 

\index{mlpack\+::tree\+::\+Cover\+Tree@{mlpack\+::tree\+::\+Cover\+Tree}!Dataset@{Dataset}}
\index{Dataset@{Dataset}!mlpack\+::tree\+::\+Cover\+Tree@{mlpack\+::tree\+::\+Cover\+Tree}}
\subsubsection[{Dataset() const }]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename Metric\+Type  = metric\+::\+L\+Metric$<$2, true$>$, typename Statistic\+Type  = Empty\+Statistic, typename Mat\+Type  = arma\+::mat, typename Root\+Point\+Policy  = First\+Point\+Is\+Root$>$ const Mat\+Type\& {\bf mlpack\+::tree\+::\+Cover\+Tree}$<$ Metric\+Type, Statistic\+Type, Mat\+Type, Root\+Point\+Policy $>$\+::Dataset (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
) const\hspace{0.3cm}{\ttfamily [inline]}}\label{classmlpack_1_1tree_1_1CoverTree_ae60926ac52a340ab6460f0b3166c4560}


Get a reference to the dataset. 



Definition at line 267 of file cover\+\_\+tree.\+hpp.



References mlpack\+::tree\+::\+Cover\+Tree$<$ Metric\+Type, Statistic\+Type, Mat\+Type, Root\+Point\+Policy $>$\+::dataset.

\index{mlpack\+::tree\+::\+Cover\+Tree@{mlpack\+::tree\+::\+Cover\+Tree}!Descendant@{Descendant}}
\index{Descendant@{Descendant}!mlpack\+::tree\+::\+Cover\+Tree@{mlpack\+::tree\+::\+Cover\+Tree}}
\subsubsection[{Descendant(const size\+\_\+t index) const }]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename Metric\+Type  = metric\+::\+L\+Metric$<$2, true$>$, typename Statistic\+Type  = Empty\+Statistic, typename Mat\+Type  = arma\+::mat, typename Root\+Point\+Policy  = First\+Point\+Is\+Root$>$ size\+\_\+t {\bf mlpack\+::tree\+::\+Cover\+Tree}$<$ Metric\+Type, Statistic\+Type, Mat\+Type, Root\+Point\+Policy $>$\+::Descendant (
\begin{DoxyParamCaption}
\item[{const size\+\_\+t}]{index}
\end{DoxyParamCaption}
) const}\label{classmlpack_1_1tree_1_1CoverTree_afacf661b4d068be353359093c36e297e}


Get the index of a particular descendant point. 



Referenced by mlpack\+::tree\+::\+Cover\+Tree$<$ Metric\+Type, Statistic\+Type, Mat\+Type, Root\+Point\+Policy $>$\+::\+Children().

\index{mlpack\+::tree\+::\+Cover\+Tree@{mlpack\+::tree\+::\+Cover\+Tree}!Distance\+Comps@{Distance\+Comps}}
\index{Distance\+Comps@{Distance\+Comps}!mlpack\+::tree\+::\+Cover\+Tree@{mlpack\+::tree\+::\+Cover\+Tree}}
\subsubsection[{Distance\+Comps() const }]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename Metric\+Type  = metric\+::\+L\+Metric$<$2, true$>$, typename Statistic\+Type  = Empty\+Statistic, typename Mat\+Type  = arma\+::mat, typename Root\+Point\+Policy  = First\+Point\+Is\+Root$>$ size\+\_\+t {\bf mlpack\+::tree\+::\+Cover\+Tree}$<$ Metric\+Type, Statistic\+Type, Mat\+Type, Root\+Point\+Policy $>$\+::Distance\+Comps (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
) const\hspace{0.3cm}{\ttfamily [inline]}}\label{classmlpack_1_1tree_1_1CoverTree_a3e9bc47574fc407b975c01f5f0b447c9}


Definition at line 555 of file cover\+\_\+tree.\+hpp.



References mlpack\+::tree\+::\+Cover\+Tree$<$ Metric\+Type, Statistic\+Type, Mat\+Type, Root\+Point\+Policy $>$\+::distance\+Comps.

\index{mlpack\+::tree\+::\+Cover\+Tree@{mlpack\+::tree\+::\+Cover\+Tree}!Distance\+Comps@{Distance\+Comps}}
\index{Distance\+Comps@{Distance\+Comps}!mlpack\+::tree\+::\+Cover\+Tree@{mlpack\+::tree\+::\+Cover\+Tree}}
\subsubsection[{Distance\+Comps()}]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename Metric\+Type  = metric\+::\+L\+Metric$<$2, true$>$, typename Statistic\+Type  = Empty\+Statistic, typename Mat\+Type  = arma\+::mat, typename Root\+Point\+Policy  = First\+Point\+Is\+Root$>$ size\+\_\+t\& {\bf mlpack\+::tree\+::\+Cover\+Tree}$<$ Metric\+Type, Statistic\+Type, Mat\+Type, Root\+Point\+Policy $>$\+::Distance\+Comps (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}}\label{classmlpack_1_1tree_1_1CoverTree_a511284621893472e2b577b2c67f0c3c9}


Definition at line 556 of file cover\+\_\+tree.\+hpp.



References mlpack\+::tree\+::\+Cover\+Tree$<$ Metric\+Type, Statistic\+Type, Mat\+Type, Root\+Point\+Policy $>$\+::distance\+Comps.

\index{mlpack\+::tree\+::\+Cover\+Tree@{mlpack\+::tree\+::\+Cover\+Tree}!Furthest\+Descendant\+Distance@{Furthest\+Descendant\+Distance}}
\index{Furthest\+Descendant\+Distance@{Furthest\+Descendant\+Distance}!mlpack\+::tree\+::\+Cover\+Tree@{mlpack\+::tree\+::\+Cover\+Tree}}
\subsubsection[{Furthest\+Descendant\+Distance() const }]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename Metric\+Type  = metric\+::\+L\+Metric$<$2, true$>$, typename Statistic\+Type  = Empty\+Statistic, typename Mat\+Type  = arma\+::mat, typename Root\+Point\+Policy  = First\+Point\+Is\+Root$>$ {\bf Elem\+Type} {\bf mlpack\+::tree\+::\+Cover\+Tree}$<$ Metric\+Type, Statistic\+Type, Mat\+Type, Root\+Point\+Policy $>$\+::Furthest\+Descendant\+Distance (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
) const\hspace{0.3cm}{\ttfamily [inline]}}\label{classmlpack_1_1tree_1_1CoverTree_a9d080b25267d41c1f9b30da0b477184a}


Get the distance from the center of the node to the furthest descendant. 



Definition at line 401 of file cover\+\_\+tree.\+hpp.



References mlpack\+::tree\+::\+Cover\+Tree$<$ Metric\+Type, Statistic\+Type, Mat\+Type, Root\+Point\+Policy $>$\+::furthest\+Descendant\+Distance.

\index{mlpack\+::tree\+::\+Cover\+Tree@{mlpack\+::tree\+::\+Cover\+Tree}!Furthest\+Descendant\+Distance@{Furthest\+Descendant\+Distance}}
\index{Furthest\+Descendant\+Distance@{Furthest\+Descendant\+Distance}!mlpack\+::tree\+::\+Cover\+Tree@{mlpack\+::tree\+::\+Cover\+Tree}}
\subsubsection[{Furthest\+Descendant\+Distance()}]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename Metric\+Type  = metric\+::\+L\+Metric$<$2, true$>$, typename Statistic\+Type  = Empty\+Statistic, typename Mat\+Type  = arma\+::mat, typename Root\+Point\+Policy  = First\+Point\+Is\+Root$>$ {\bf Elem\+Type}\& {\bf mlpack\+::tree\+::\+Cover\+Tree}$<$ Metric\+Type, Statistic\+Type, Mat\+Type, Root\+Point\+Policy $>$\+::Furthest\+Descendant\+Distance (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}}\label{classmlpack_1_1tree_1_1CoverTree_a2eafe6d384d67aad28d23b7aee4ba313}


Modify the distance from the center of the node to the furthest descendant. 



Definition at line 405 of file cover\+\_\+tree.\+hpp.



References mlpack\+::tree\+::\+Cover\+Tree$<$ Metric\+Type, Statistic\+Type, Mat\+Type, Root\+Point\+Policy $>$\+::furthest\+Descendant\+Distance.

\index{mlpack\+::tree\+::\+Cover\+Tree@{mlpack\+::tree\+::\+Cover\+Tree}!Furthest\+Point\+Distance@{Furthest\+Point\+Distance}}
\index{Furthest\+Point\+Distance@{Furthest\+Point\+Distance}!mlpack\+::tree\+::\+Cover\+Tree@{mlpack\+::tree\+::\+Cover\+Tree}}
\subsubsection[{Furthest\+Point\+Distance() const }]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename Metric\+Type  = metric\+::\+L\+Metric$<$2, true$>$, typename Statistic\+Type  = Empty\+Statistic, typename Mat\+Type  = arma\+::mat, typename Root\+Point\+Policy  = First\+Point\+Is\+Root$>$ {\bf Elem\+Type} {\bf mlpack\+::tree\+::\+Cover\+Tree}$<$ Metric\+Type, Statistic\+Type, Mat\+Type, Root\+Point\+Policy $>$\+::Furthest\+Point\+Distance (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
) const\hspace{0.3cm}{\ttfamily [inline]}}\label{classmlpack_1_1tree_1_1CoverTree_ab198744571bcb2258d2c30bd32be0f60}


Get the distance to the furthest point. This is always 0 for cover trees. 



Definition at line 398 of file cover\+\_\+tree.\+hpp.

\index{mlpack\+::tree\+::\+Cover\+Tree@{mlpack\+::tree\+::\+Cover\+Tree}!Get\+Furthest\+Child@{Get\+Furthest\+Child}}
\index{Get\+Furthest\+Child@{Get\+Furthest\+Child}!mlpack\+::tree\+::\+Cover\+Tree@{mlpack\+::tree\+::\+Cover\+Tree}}
\subsubsection[{Get\+Furthest\+Child(const Vec\+Type \&point, typename std\+::enable\+\_\+if\+\_\+t$<$ Is\+Vector$<$ Vec\+Type $>$\+::value $>$ $\ast$=0)}]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename Metric\+Type  = metric\+::\+L\+Metric$<$2, true$>$, typename Statistic\+Type  = Empty\+Statistic, typename Mat\+Type  = arma\+::mat, typename Root\+Point\+Policy  = First\+Point\+Is\+Root$>$ template$<$typename Vec\+Type $>$ size\+\_\+t {\bf mlpack\+::tree\+::\+Cover\+Tree}$<$ Metric\+Type, Statistic\+Type, Mat\+Type, Root\+Point\+Policy $>$\+::Get\+Furthest\+Child (
\begin{DoxyParamCaption}
\item[{const Vec\+Type \&}]{point, }
\item[{typename {\bf std\+::enable\+\_\+if\+\_\+t}$<$ {\bf Is\+Vector}$<$ Vec\+Type $>$\+::value $>$ $\ast$}]{ = {\ttfamily 0}}
\end{DoxyParamCaption}
)}\label{classmlpack_1_1tree_1_1CoverTree_a3d8a884391b492c4f774d81c0ee665ba}


Return the index of the furthest child node to the given query point. 

If this is a leaf node, it will return \doxyref{Num\+Children()}{p.}{classmlpack_1_1tree_1_1CoverTree_a3b8f146e0dd0e1b93fc1323337b03015} (invalid index). 

Referenced by mlpack\+::tree\+::\+Cover\+Tree$<$ Metric\+Type, Statistic\+Type, Mat\+Type, Root\+Point\+Policy $>$\+::\+Stat().

\index{mlpack\+::tree\+::\+Cover\+Tree@{mlpack\+::tree\+::\+Cover\+Tree}!Get\+Furthest\+Child@{Get\+Furthest\+Child}}
\index{Get\+Furthest\+Child@{Get\+Furthest\+Child}!mlpack\+::tree\+::\+Cover\+Tree@{mlpack\+::tree\+::\+Cover\+Tree}}
\subsubsection[{Get\+Furthest\+Child(const Cover\+Tree \&query\+Node)}]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename Metric\+Type  = metric\+::\+L\+Metric$<$2, true$>$, typename Statistic\+Type  = Empty\+Statistic, typename Mat\+Type  = arma\+::mat, typename Root\+Point\+Policy  = First\+Point\+Is\+Root$>$ size\+\_\+t {\bf mlpack\+::tree\+::\+Cover\+Tree}$<$ Metric\+Type, Statistic\+Type, Mat\+Type, Root\+Point\+Policy $>$\+::Get\+Furthest\+Child (
\begin{DoxyParamCaption}
\item[{const {\bf Cover\+Tree}$<$ Metric\+Type, Statistic\+Type, Mat\+Type, Root\+Point\+Policy $>$ \&}]{query\+Node}
\end{DoxyParamCaption}
)}\label{classmlpack_1_1tree_1_1CoverTree_a93c73fba945a33911d95b6014497a511}


Return the index of the furthest child node to the given query node. 

If it can\textquotesingle{}t decide, it will return \doxyref{Num\+Children()}{p.}{classmlpack_1_1tree_1_1CoverTree_a3b8f146e0dd0e1b93fc1323337b03015} (invalid index). \index{mlpack\+::tree\+::\+Cover\+Tree@{mlpack\+::tree\+::\+Cover\+Tree}!Get\+Nearest\+Child@{Get\+Nearest\+Child}}
\index{Get\+Nearest\+Child@{Get\+Nearest\+Child}!mlpack\+::tree\+::\+Cover\+Tree@{mlpack\+::tree\+::\+Cover\+Tree}}
\subsubsection[{Get\+Nearest\+Child(const Vec\+Type \&point, typename std\+::enable\+\_\+if\+\_\+t$<$ Is\+Vector$<$ Vec\+Type $>$\+::value $>$ $\ast$=0)}]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename Metric\+Type  = metric\+::\+L\+Metric$<$2, true$>$, typename Statistic\+Type  = Empty\+Statistic, typename Mat\+Type  = arma\+::mat, typename Root\+Point\+Policy  = First\+Point\+Is\+Root$>$ template$<$typename Vec\+Type $>$ size\+\_\+t {\bf mlpack\+::tree\+::\+Cover\+Tree}$<$ Metric\+Type, Statistic\+Type, Mat\+Type, Root\+Point\+Policy $>$\+::Get\+Nearest\+Child (
\begin{DoxyParamCaption}
\item[{const Vec\+Type \&}]{point, }
\item[{typename {\bf std\+::enable\+\_\+if\+\_\+t}$<$ {\bf Is\+Vector}$<$ Vec\+Type $>$\+::value $>$ $\ast$}]{ = {\ttfamily 0}}
\end{DoxyParamCaption}
)}\label{classmlpack_1_1tree_1_1CoverTree_abf42b5bd15362b7f18d3b61958851826}


Return the index of the nearest child node to the given query point. 

If this is a leaf node, it will return \doxyref{Num\+Children()}{p.}{classmlpack_1_1tree_1_1CoverTree_a3b8f146e0dd0e1b93fc1323337b03015} (invalid index). 

Referenced by mlpack\+::tree\+::\+Cover\+Tree$<$ Metric\+Type, Statistic\+Type, Mat\+Type, Root\+Point\+Policy $>$\+::\+Stat().

\index{mlpack\+::tree\+::\+Cover\+Tree@{mlpack\+::tree\+::\+Cover\+Tree}!Get\+Nearest\+Child@{Get\+Nearest\+Child}}
\index{Get\+Nearest\+Child@{Get\+Nearest\+Child}!mlpack\+::tree\+::\+Cover\+Tree@{mlpack\+::tree\+::\+Cover\+Tree}}
\subsubsection[{Get\+Nearest\+Child(const Cover\+Tree \&query\+Node)}]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename Metric\+Type  = metric\+::\+L\+Metric$<$2, true$>$, typename Statistic\+Type  = Empty\+Statistic, typename Mat\+Type  = arma\+::mat, typename Root\+Point\+Policy  = First\+Point\+Is\+Root$>$ size\+\_\+t {\bf mlpack\+::tree\+::\+Cover\+Tree}$<$ Metric\+Type, Statistic\+Type, Mat\+Type, Root\+Point\+Policy $>$\+::Get\+Nearest\+Child (
\begin{DoxyParamCaption}
\item[{const {\bf Cover\+Tree}$<$ Metric\+Type, Statistic\+Type, Mat\+Type, Root\+Point\+Policy $>$ \&}]{query\+Node}
\end{DoxyParamCaption}
)}\label{classmlpack_1_1tree_1_1CoverTree_a9ffe9b0276ff5e3a3a4ef24d60e2cf6b}


Return the index of the nearest child node to the given query node. 

If it can\textquotesingle{}t decide, it will return \doxyref{Num\+Children()}{p.}{classmlpack_1_1tree_1_1CoverTree_a3b8f146e0dd0e1b93fc1323337b03015} (invalid index). \index{mlpack\+::tree\+::\+Cover\+Tree@{mlpack\+::tree\+::\+Cover\+Tree}!Is\+Leaf@{Is\+Leaf}}
\index{Is\+Leaf@{Is\+Leaf}!mlpack\+::tree\+::\+Cover\+Tree@{mlpack\+::tree\+::\+Cover\+Tree}}
\subsubsection[{Is\+Leaf() const }]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename Metric\+Type  = metric\+::\+L\+Metric$<$2, true$>$, typename Statistic\+Type  = Empty\+Statistic, typename Mat\+Type  = arma\+::mat, typename Root\+Point\+Policy  = First\+Point\+Is\+Root$>$ bool {\bf mlpack\+::tree\+::\+Cover\+Tree}$<$ Metric\+Type, Statistic\+Type, Mat\+Type, Root\+Point\+Policy $>$\+::Is\+Leaf (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
) const\hspace{0.3cm}{\ttfamily [inline]}}\label{classmlpack_1_1tree_1_1CoverTree_a3bb1efed1a28a8fc7f5171cb2eba8505}


Definition at line 274 of file cover\+\_\+tree.\+hpp.



References mlpack\+::tree\+::\+Cover\+Tree$<$ Metric\+Type, Statistic\+Type, Mat\+Type, Root\+Point\+Policy $>$\+::children.

\index{mlpack\+::tree\+::\+Cover\+Tree@{mlpack\+::tree\+::\+Cover\+Tree}!Max\+Distance@{Max\+Distance}}
\index{Max\+Distance@{Max\+Distance}!mlpack\+::tree\+::\+Cover\+Tree@{mlpack\+::tree\+::\+Cover\+Tree}}
\subsubsection[{Max\+Distance(const Cover\+Tree \&other) const }]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename Metric\+Type  = metric\+::\+L\+Metric$<$2, true$>$, typename Statistic\+Type  = Empty\+Statistic, typename Mat\+Type  = arma\+::mat, typename Root\+Point\+Policy  = First\+Point\+Is\+Root$>$ {\bf Elem\+Type} {\bf mlpack\+::tree\+::\+Cover\+Tree}$<$ Metric\+Type, Statistic\+Type, Mat\+Type, Root\+Point\+Policy $>$\+::Max\+Distance (
\begin{DoxyParamCaption}
\item[{const {\bf Cover\+Tree}$<$ Metric\+Type, Statistic\+Type, Mat\+Type, Root\+Point\+Policy $>$ \&}]{other}
\end{DoxyParamCaption}
) const}\label{classmlpack_1_1tree_1_1CoverTree_ac34136681c6ed01506c860dd1e815825}


Return the maximum distance to another node. 



Referenced by mlpack\+::tree\+::\+Cover\+Tree$<$ Metric\+Type, Statistic\+Type, Mat\+Type, Root\+Point\+Policy $>$\+::\+Stat().

\index{mlpack\+::tree\+::\+Cover\+Tree@{mlpack\+::tree\+::\+Cover\+Tree}!Max\+Distance@{Max\+Distance}}
\index{Max\+Distance@{Max\+Distance}!mlpack\+::tree\+::\+Cover\+Tree@{mlpack\+::tree\+::\+Cover\+Tree}}
\subsubsection[{Max\+Distance(const Cover\+Tree \&other, const Elem\+Type distance) const }]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename Metric\+Type  = metric\+::\+L\+Metric$<$2, true$>$, typename Statistic\+Type  = Empty\+Statistic, typename Mat\+Type  = arma\+::mat, typename Root\+Point\+Policy  = First\+Point\+Is\+Root$>$ {\bf Elem\+Type} {\bf mlpack\+::tree\+::\+Cover\+Tree}$<$ Metric\+Type, Statistic\+Type, Mat\+Type, Root\+Point\+Policy $>$\+::Max\+Distance (
\begin{DoxyParamCaption}
\item[{const {\bf Cover\+Tree}$<$ Metric\+Type, Statistic\+Type, Mat\+Type, Root\+Point\+Policy $>$ \&}]{other, }
\item[{const {\bf Elem\+Type}}]{distance}
\end{DoxyParamCaption}
) const}\label{classmlpack_1_1tree_1_1CoverTree_aa92c3e282821170705c946d15421d778}


Return the maximum distance to another node given that the point-\/to-\/point distance has already been calculated. 

\index{mlpack\+::tree\+::\+Cover\+Tree@{mlpack\+::tree\+::\+Cover\+Tree}!Max\+Distance@{Max\+Distance}}
\index{Max\+Distance@{Max\+Distance}!mlpack\+::tree\+::\+Cover\+Tree@{mlpack\+::tree\+::\+Cover\+Tree}}
\subsubsection[{Max\+Distance(const arma\+::vec \&other) const }]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename Metric\+Type  = metric\+::\+L\+Metric$<$2, true$>$, typename Statistic\+Type  = Empty\+Statistic, typename Mat\+Type  = arma\+::mat, typename Root\+Point\+Policy  = First\+Point\+Is\+Root$>$ {\bf Elem\+Type} {\bf mlpack\+::tree\+::\+Cover\+Tree}$<$ Metric\+Type, Statistic\+Type, Mat\+Type, Root\+Point\+Policy $>$\+::Max\+Distance (
\begin{DoxyParamCaption}
\item[{const arma\+::vec \&}]{other}
\end{DoxyParamCaption}
) const}\label{classmlpack_1_1tree_1_1CoverTree_a91d061eee88cba38709cfbf6f458580f}


Return the maximum distance to another point. 

\index{mlpack\+::tree\+::\+Cover\+Tree@{mlpack\+::tree\+::\+Cover\+Tree}!Max\+Distance@{Max\+Distance}}
\index{Max\+Distance@{Max\+Distance}!mlpack\+::tree\+::\+Cover\+Tree@{mlpack\+::tree\+::\+Cover\+Tree}}
\subsubsection[{Max\+Distance(const arma\+::vec \&other, const Elem\+Type distance) const }]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename Metric\+Type  = metric\+::\+L\+Metric$<$2, true$>$, typename Statistic\+Type  = Empty\+Statistic, typename Mat\+Type  = arma\+::mat, typename Root\+Point\+Policy  = First\+Point\+Is\+Root$>$ {\bf Elem\+Type} {\bf mlpack\+::tree\+::\+Cover\+Tree}$<$ Metric\+Type, Statistic\+Type, Mat\+Type, Root\+Point\+Policy $>$\+::Max\+Distance (
\begin{DoxyParamCaption}
\item[{const arma\+::vec \&}]{other, }
\item[{const {\bf Elem\+Type}}]{distance}
\end{DoxyParamCaption}
) const}\label{classmlpack_1_1tree_1_1CoverTree_a11eaf5874bf8f5c996e83856c8cdeeb7}


Return the maximum distance to another point given that the distance from the center to the point has already been calculated. 

\index{mlpack\+::tree\+::\+Cover\+Tree@{mlpack\+::tree\+::\+Cover\+Tree}!Metric@{Metric}}
\index{Metric@{Metric}!mlpack\+::tree\+::\+Cover\+Tree@{mlpack\+::tree\+::\+Cover\+Tree}}
\subsubsection[{Metric() const }]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename Metric\+Type  = metric\+::\+L\+Metric$<$2, true$>$, typename Statistic\+Type  = Empty\+Statistic, typename Mat\+Type  = arma\+::mat, typename Root\+Point\+Policy  = First\+Point\+Is\+Root$>$ Metric\+Type\& {\bf mlpack\+::tree\+::\+Cover\+Tree}$<$ Metric\+Type, Statistic\+Type, Mat\+Type, Root\+Point\+Policy $>$\+::Metric (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
) const\hspace{0.3cm}{\ttfamily [inline]}}\label{classmlpack_1_1tree_1_1CoverTree_a6b207b875e2417607b0b6aec34f8906e}


Get the instantiated metric. 



Definition at line 418 of file cover\+\_\+tree.\+hpp.



References mlpack\+::tree\+::\+Cover\+Tree$<$ Metric\+Type, Statistic\+Type, Mat\+Type, Root\+Point\+Policy $>$\+::metric.

\index{mlpack\+::tree\+::\+Cover\+Tree@{mlpack\+::tree\+::\+Cover\+Tree}!Min\+Distance@{Min\+Distance}}
\index{Min\+Distance@{Min\+Distance}!mlpack\+::tree\+::\+Cover\+Tree@{mlpack\+::tree\+::\+Cover\+Tree}}
\subsubsection[{Min\+Distance(const Cover\+Tree \&other) const }]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename Metric\+Type  = metric\+::\+L\+Metric$<$2, true$>$, typename Statistic\+Type  = Empty\+Statistic, typename Mat\+Type  = arma\+::mat, typename Root\+Point\+Policy  = First\+Point\+Is\+Root$>$ {\bf Elem\+Type} {\bf mlpack\+::tree\+::\+Cover\+Tree}$<$ Metric\+Type, Statistic\+Type, Mat\+Type, Root\+Point\+Policy $>$\+::Min\+Distance (
\begin{DoxyParamCaption}
\item[{const {\bf Cover\+Tree}$<$ Metric\+Type, Statistic\+Type, Mat\+Type, Root\+Point\+Policy $>$ \&}]{other}
\end{DoxyParamCaption}
) const}\label{classmlpack_1_1tree_1_1CoverTree_a224890c6d0c8dd58bb7b9761990cac4e}


Return the minimum distance to another node. 



Referenced by mlpack\+::tree\+::\+Cover\+Tree$<$ Metric\+Type, Statistic\+Type, Mat\+Type, Root\+Point\+Policy $>$\+::\+Stat().

\index{mlpack\+::tree\+::\+Cover\+Tree@{mlpack\+::tree\+::\+Cover\+Tree}!Min\+Distance@{Min\+Distance}}
\index{Min\+Distance@{Min\+Distance}!mlpack\+::tree\+::\+Cover\+Tree@{mlpack\+::tree\+::\+Cover\+Tree}}
\subsubsection[{Min\+Distance(const Cover\+Tree \&other, const Elem\+Type distance) const }]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename Metric\+Type  = metric\+::\+L\+Metric$<$2, true$>$, typename Statistic\+Type  = Empty\+Statistic, typename Mat\+Type  = arma\+::mat, typename Root\+Point\+Policy  = First\+Point\+Is\+Root$>$ {\bf Elem\+Type} {\bf mlpack\+::tree\+::\+Cover\+Tree}$<$ Metric\+Type, Statistic\+Type, Mat\+Type, Root\+Point\+Policy $>$\+::Min\+Distance (
\begin{DoxyParamCaption}
\item[{const {\bf Cover\+Tree}$<$ Metric\+Type, Statistic\+Type, Mat\+Type, Root\+Point\+Policy $>$ \&}]{other, }
\item[{const {\bf Elem\+Type}}]{distance}
\end{DoxyParamCaption}
) const}\label{classmlpack_1_1tree_1_1CoverTree_ae9909712ecc46641ade692cba5fae929}


Return the minimum distance to another node given that the point-\/to-\/point distance has already been calculated. 

\index{mlpack\+::tree\+::\+Cover\+Tree@{mlpack\+::tree\+::\+Cover\+Tree}!Min\+Distance@{Min\+Distance}}
\index{Min\+Distance@{Min\+Distance}!mlpack\+::tree\+::\+Cover\+Tree@{mlpack\+::tree\+::\+Cover\+Tree}}
\subsubsection[{Min\+Distance(const arma\+::vec \&other) const }]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename Metric\+Type  = metric\+::\+L\+Metric$<$2, true$>$, typename Statistic\+Type  = Empty\+Statistic, typename Mat\+Type  = arma\+::mat, typename Root\+Point\+Policy  = First\+Point\+Is\+Root$>$ {\bf Elem\+Type} {\bf mlpack\+::tree\+::\+Cover\+Tree}$<$ Metric\+Type, Statistic\+Type, Mat\+Type, Root\+Point\+Policy $>$\+::Min\+Distance (
\begin{DoxyParamCaption}
\item[{const arma\+::vec \&}]{other}
\end{DoxyParamCaption}
) const}\label{classmlpack_1_1tree_1_1CoverTree_a6249d58ab805cdf8be3dc54b6468e1e5}


Return the minimum distance to another point. 

\index{mlpack\+::tree\+::\+Cover\+Tree@{mlpack\+::tree\+::\+Cover\+Tree}!Min\+Distance@{Min\+Distance}}
\index{Min\+Distance@{Min\+Distance}!mlpack\+::tree\+::\+Cover\+Tree@{mlpack\+::tree\+::\+Cover\+Tree}}
\subsubsection[{Min\+Distance(const arma\+::vec \&other, const Elem\+Type distance) const }]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename Metric\+Type  = metric\+::\+L\+Metric$<$2, true$>$, typename Statistic\+Type  = Empty\+Statistic, typename Mat\+Type  = arma\+::mat, typename Root\+Point\+Policy  = First\+Point\+Is\+Root$>$ {\bf Elem\+Type} {\bf mlpack\+::tree\+::\+Cover\+Tree}$<$ Metric\+Type, Statistic\+Type, Mat\+Type, Root\+Point\+Policy $>$\+::Min\+Distance (
\begin{DoxyParamCaption}
\item[{const arma\+::vec \&}]{other, }
\item[{const {\bf Elem\+Type}}]{distance}
\end{DoxyParamCaption}
) const}\label{classmlpack_1_1tree_1_1CoverTree_a4a90f936936e8e17bd35ab813b7cc75c}


Return the minimum distance to another point given that the distance from the center to the point has already been calculated. 

\index{mlpack\+::tree\+::\+Cover\+Tree@{mlpack\+::tree\+::\+Cover\+Tree}!Minimum\+Bound\+Distance@{Minimum\+Bound\+Distance}}
\index{Minimum\+Bound\+Distance@{Minimum\+Bound\+Distance}!mlpack\+::tree\+::\+Cover\+Tree@{mlpack\+::tree\+::\+Cover\+Tree}}
\subsubsection[{Minimum\+Bound\+Distance() const }]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename Metric\+Type  = metric\+::\+L\+Metric$<$2, true$>$, typename Statistic\+Type  = Empty\+Statistic, typename Mat\+Type  = arma\+::mat, typename Root\+Point\+Policy  = First\+Point\+Is\+Root$>$ {\bf Elem\+Type} {\bf mlpack\+::tree\+::\+Cover\+Tree}$<$ Metric\+Type, Statistic\+Type, Mat\+Type, Root\+Point\+Policy $>$\+::Minimum\+Bound\+Distance (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
) const\hspace{0.3cm}{\ttfamily [inline]}}\label{classmlpack_1_1tree_1_1CoverTree_a4f39bc6648e21a7aecaaf5ca71c69dfd}


Get the minimum distance from the center to any bound edge (this is the same as furthest\+Descendant\+Distance). 



Definition at line 409 of file cover\+\_\+tree.\+hpp.



References mlpack\+::tree\+::\+Cover\+Tree$<$ Metric\+Type, Statistic\+Type, Mat\+Type, Root\+Point\+Policy $>$\+::furthest\+Descendant\+Distance.

\index{mlpack\+::tree\+::\+Cover\+Tree@{mlpack\+::tree\+::\+Cover\+Tree}!Move\+To\+Used\+Set@{Move\+To\+Used\+Set}}
\index{Move\+To\+Used\+Set@{Move\+To\+Used\+Set}!mlpack\+::tree\+::\+Cover\+Tree@{mlpack\+::tree\+::\+Cover\+Tree}}
\subsubsection[{Move\+To\+Used\+Set(arma\+::\+Col$<$ size\+\_\+t $>$ \&indices, arma\+::vec \&distances, size\+\_\+t \&near\+Set\+Size, size\+\_\+t \&far\+Set\+Size, size\+\_\+t \&used\+Set\+Size, arma\+::\+Col$<$ size\+\_\+t $>$ \&child\+Indices, const size\+\_\+t child\+Far\+Set\+Size, const size\+\_\+t child\+Used\+Set\+Size)}]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename Metric\+Type  = metric\+::\+L\+Metric$<$2, true$>$, typename Statistic\+Type  = Empty\+Statistic, typename Mat\+Type  = arma\+::mat, typename Root\+Point\+Policy  = First\+Point\+Is\+Root$>$ void {\bf mlpack\+::tree\+::\+Cover\+Tree}$<$ Metric\+Type, Statistic\+Type, Mat\+Type, Root\+Point\+Policy $>$\+::Move\+To\+Used\+Set (
\begin{DoxyParamCaption}
\item[{arma\+::\+Col$<$ size\+\_\+t $>$ \&}]{indices, }
\item[{arma\+::vec \&}]{distances, }
\item[{size\+\_\+t \&}]{near\+Set\+Size, }
\item[{size\+\_\+t \&}]{far\+Set\+Size, }
\item[{size\+\_\+t \&}]{used\+Set\+Size, }
\item[{arma\+::\+Col$<$ size\+\_\+t $>$ \&}]{child\+Indices, }
\item[{const size\+\_\+t}]{child\+Far\+Set\+Size, }
\item[{const size\+\_\+t}]{child\+Used\+Set\+Size}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [private]}}\label{classmlpack_1_1tree_1_1CoverTree_aefd0b12f7369727b24ecbafc67344248}
\index{mlpack\+::tree\+::\+Cover\+Tree@{mlpack\+::tree\+::\+Cover\+Tree}!Num\+Children@{Num\+Children}}
\index{Num\+Children@{Num\+Children}!mlpack\+::tree\+::\+Cover\+Tree@{mlpack\+::tree\+::\+Cover\+Tree}}
\subsubsection[{Num\+Children() const }]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename Metric\+Type  = metric\+::\+L\+Metric$<$2, true$>$, typename Statistic\+Type  = Empty\+Statistic, typename Mat\+Type  = arma\+::mat, typename Root\+Point\+Policy  = First\+Point\+Is\+Root$>$ size\+\_\+t {\bf mlpack\+::tree\+::\+Cover\+Tree}$<$ Metric\+Type, Statistic\+Type, Mat\+Type, Root\+Point\+Policy $>$\+::Num\+Children (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
) const\hspace{0.3cm}{\ttfamily [inline]}}\label{classmlpack_1_1tree_1_1CoverTree_a3b8f146e0dd0e1b93fc1323337b03015}


Get the number of children. 



Definition at line 285 of file cover\+\_\+tree.\+hpp.



References mlpack\+::tree\+::\+Cover\+Tree$<$ Metric\+Type, Statistic\+Type, Mat\+Type, Root\+Point\+Policy $>$\+::children.

\index{mlpack\+::tree\+::\+Cover\+Tree@{mlpack\+::tree\+::\+Cover\+Tree}!Num\+Descendants@{Num\+Descendants}}
\index{Num\+Descendants@{Num\+Descendants}!mlpack\+::tree\+::\+Cover\+Tree@{mlpack\+::tree\+::\+Cover\+Tree}}
\subsubsection[{Num\+Descendants() const }]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename Metric\+Type  = metric\+::\+L\+Metric$<$2, true$>$, typename Statistic\+Type  = Empty\+Statistic, typename Mat\+Type  = arma\+::mat, typename Root\+Point\+Policy  = First\+Point\+Is\+Root$>$ size\+\_\+t {\bf mlpack\+::tree\+::\+Cover\+Tree}$<$ Metric\+Type, Statistic\+Type, Mat\+Type, Root\+Point\+Policy $>$\+::Num\+Descendants (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
) const}\label{classmlpack_1_1tree_1_1CoverTree_a636250f6263af229c53ba39ff8d90c58}


Get the number of descendant points. 



Referenced by mlpack\+::tree\+::\+Cover\+Tree$<$ Metric\+Type, Statistic\+Type, Mat\+Type, Root\+Point\+Policy $>$\+::\+Children().

\index{mlpack\+::tree\+::\+Cover\+Tree@{mlpack\+::tree\+::\+Cover\+Tree}!Num\+Points@{Num\+Points}}
\index{Num\+Points@{Num\+Points}!mlpack\+::tree\+::\+Cover\+Tree@{mlpack\+::tree\+::\+Cover\+Tree}}
\subsubsection[{Num\+Points() const }]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename Metric\+Type  = metric\+::\+L\+Metric$<$2, true$>$, typename Statistic\+Type  = Empty\+Statistic, typename Mat\+Type  = arma\+::mat, typename Root\+Point\+Policy  = First\+Point\+Is\+Root$>$ size\+\_\+t {\bf mlpack\+::tree\+::\+Cover\+Tree}$<$ Metric\+Type, Statistic\+Type, Mat\+Type, Root\+Point\+Policy $>$\+::Num\+Points (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
) const\hspace{0.3cm}{\ttfamily [inline]}}\label{classmlpack_1_1tree_1_1CoverTree_a960fe5e58b30eee324f09a274acefbbd}


Definition at line 275 of file cover\+\_\+tree.\+hpp.

\index{mlpack\+::tree\+::\+Cover\+Tree@{mlpack\+::tree\+::\+Cover\+Tree}!Parent@{Parent}}
\index{Parent@{Parent}!mlpack\+::tree\+::\+Cover\+Tree@{mlpack\+::tree\+::\+Cover\+Tree}}
\subsubsection[{Parent() const }]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename Metric\+Type  = metric\+::\+L\+Metric$<$2, true$>$, typename Statistic\+Type  = Empty\+Statistic, typename Mat\+Type  = arma\+::mat, typename Root\+Point\+Policy  = First\+Point\+Is\+Root$>$ {\bf Cover\+Tree}$\ast$ {\bf mlpack\+::tree\+::\+Cover\+Tree}$<$ Metric\+Type, Statistic\+Type, Mat\+Type, Root\+Point\+Policy $>$\+::Parent (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
) const\hspace{0.3cm}{\ttfamily [inline]}}\label{classmlpack_1_1tree_1_1CoverTree_ad6c8c4015ce8cca967cc8984be46ee17}


Get the parent node. 



Definition at line 388 of file cover\+\_\+tree.\+hpp.



References mlpack\+::tree\+::\+Cover\+Tree$<$ Metric\+Type, Statistic\+Type, Mat\+Type, Root\+Point\+Policy $>$\+::parent.

\index{mlpack\+::tree\+::\+Cover\+Tree@{mlpack\+::tree\+::\+Cover\+Tree}!Parent@{Parent}}
\index{Parent@{Parent}!mlpack\+::tree\+::\+Cover\+Tree@{mlpack\+::tree\+::\+Cover\+Tree}}
\subsubsection[{Parent()}]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename Metric\+Type  = metric\+::\+L\+Metric$<$2, true$>$, typename Statistic\+Type  = Empty\+Statistic, typename Mat\+Type  = arma\+::mat, typename Root\+Point\+Policy  = First\+Point\+Is\+Root$>$ {\bf Cover\+Tree}$\ast$\& {\bf mlpack\+::tree\+::\+Cover\+Tree}$<$ Metric\+Type, Statistic\+Type, Mat\+Type, Root\+Point\+Policy $>$\+::Parent (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}}\label{classmlpack_1_1tree_1_1CoverTree_aecaec628cffa169aee3ad423b2eda993}


Modify the parent node. 



Definition at line 390 of file cover\+\_\+tree.\+hpp.



References mlpack\+::tree\+::\+Cover\+Tree$<$ Metric\+Type, Statistic\+Type, Mat\+Type, Root\+Point\+Policy $>$\+::parent.

\index{mlpack\+::tree\+::\+Cover\+Tree@{mlpack\+::tree\+::\+Cover\+Tree}!Parent\+Distance@{Parent\+Distance}}
\index{Parent\+Distance@{Parent\+Distance}!mlpack\+::tree\+::\+Cover\+Tree@{mlpack\+::tree\+::\+Cover\+Tree}}
\subsubsection[{Parent\+Distance() const }]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename Metric\+Type  = metric\+::\+L\+Metric$<$2, true$>$, typename Statistic\+Type  = Empty\+Statistic, typename Mat\+Type  = arma\+::mat, typename Root\+Point\+Policy  = First\+Point\+Is\+Root$>$ {\bf Elem\+Type} {\bf mlpack\+::tree\+::\+Cover\+Tree}$<$ Metric\+Type, Statistic\+Type, Mat\+Type, Root\+Point\+Policy $>$\+::Parent\+Distance (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
) const\hspace{0.3cm}{\ttfamily [inline]}}\label{classmlpack_1_1tree_1_1CoverTree_a5e7ae2e58272d84c8f708940de346ae0}


Get the distance to the parent. 



Definition at line 393 of file cover\+\_\+tree.\+hpp.



References mlpack\+::tree\+::\+Cover\+Tree$<$ Metric\+Type, Statistic\+Type, Mat\+Type, Root\+Point\+Policy $>$\+::parent\+Distance.

\index{mlpack\+::tree\+::\+Cover\+Tree@{mlpack\+::tree\+::\+Cover\+Tree}!Parent\+Distance@{Parent\+Distance}}
\index{Parent\+Distance@{Parent\+Distance}!mlpack\+::tree\+::\+Cover\+Tree@{mlpack\+::tree\+::\+Cover\+Tree}}
\subsubsection[{Parent\+Distance()}]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename Metric\+Type  = metric\+::\+L\+Metric$<$2, true$>$, typename Statistic\+Type  = Empty\+Statistic, typename Mat\+Type  = arma\+::mat, typename Root\+Point\+Policy  = First\+Point\+Is\+Root$>$ {\bf Elem\+Type}\& {\bf mlpack\+::tree\+::\+Cover\+Tree}$<$ Metric\+Type, Statistic\+Type, Mat\+Type, Root\+Point\+Policy $>$\+::Parent\+Distance (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}}\label{classmlpack_1_1tree_1_1CoverTree_a3a07575869b17786688799abd21d0778}


Modify the distance to the parent. 



Definition at line 395 of file cover\+\_\+tree.\+hpp.



References mlpack\+::tree\+::\+Cover\+Tree$<$ Metric\+Type, Statistic\+Type, Mat\+Type, Root\+Point\+Policy $>$\+::parent\+Distance.

\index{mlpack\+::tree\+::\+Cover\+Tree@{mlpack\+::tree\+::\+Cover\+Tree}!Point@{Point}}
\index{Point@{Point}!mlpack\+::tree\+::\+Cover\+Tree@{mlpack\+::tree\+::\+Cover\+Tree}}
\subsubsection[{Point() const }]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename Metric\+Type  = metric\+::\+L\+Metric$<$2, true$>$, typename Statistic\+Type  = Empty\+Statistic, typename Mat\+Type  = arma\+::mat, typename Root\+Point\+Policy  = First\+Point\+Is\+Root$>$ size\+\_\+t {\bf mlpack\+::tree\+::\+Cover\+Tree}$<$ Metric\+Type, Statistic\+Type, Mat\+Type, Root\+Point\+Policy $>$\+::Point (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
) const\hspace{0.3cm}{\ttfamily [inline]}}\label{classmlpack_1_1tree_1_1CoverTree_aaf6a77d1e77e4e18f30d3a099e805e0f}


Get the index of the point which this node represents. 



Definition at line 270 of file cover\+\_\+tree.\+hpp.



References mlpack\+::tree\+::\+Cover\+Tree$<$ Metric\+Type, Statistic\+Type, Mat\+Type, Root\+Point\+Policy $>$\+::point.

\index{mlpack\+::tree\+::\+Cover\+Tree@{mlpack\+::tree\+::\+Cover\+Tree}!Point@{Point}}
\index{Point@{Point}!mlpack\+::tree\+::\+Cover\+Tree@{mlpack\+::tree\+::\+Cover\+Tree}}
\subsubsection[{Point(const size\+\_\+t) const }]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename Metric\+Type  = metric\+::\+L\+Metric$<$2, true$>$, typename Statistic\+Type  = Empty\+Statistic, typename Mat\+Type  = arma\+::mat, typename Root\+Point\+Policy  = First\+Point\+Is\+Root$>$ size\+\_\+t {\bf mlpack\+::tree\+::\+Cover\+Tree}$<$ Metric\+Type, Statistic\+Type, Mat\+Type, Root\+Point\+Policy $>$\+::Point (
\begin{DoxyParamCaption}
\item[{const size\+\_\+t}]{}
\end{DoxyParamCaption}
) const\hspace{0.3cm}{\ttfamily [inline]}}\label{classmlpack_1_1tree_1_1CoverTree_ab3f8e37fab1a6993896440002de36402}


For compatibility with other trees; the argument is ignored. 



Definition at line 272 of file cover\+\_\+tree.\+hpp.



References mlpack\+::tree\+::\+Cover\+Tree$<$ Metric\+Type, Statistic\+Type, Mat\+Type, Root\+Point\+Policy $>$\+::point.

\index{mlpack\+::tree\+::\+Cover\+Tree@{mlpack\+::tree\+::\+Cover\+Tree}!Prune\+Far\+Set@{Prune\+Far\+Set}}
\index{Prune\+Far\+Set@{Prune\+Far\+Set}!mlpack\+::tree\+::\+Cover\+Tree@{mlpack\+::tree\+::\+Cover\+Tree}}
\subsubsection[{Prune\+Far\+Set(arma\+::\+Col$<$ size\+\_\+t $>$ \&indices, arma\+::vec \&distances, const Elem\+Type bound, const size\+\_\+t near\+Set\+Size, const size\+\_\+t point\+Set\+Size)}]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename Metric\+Type  = metric\+::\+L\+Metric$<$2, true$>$, typename Statistic\+Type  = Empty\+Statistic, typename Mat\+Type  = arma\+::mat, typename Root\+Point\+Policy  = First\+Point\+Is\+Root$>$ size\+\_\+t {\bf mlpack\+::tree\+::\+Cover\+Tree}$<$ Metric\+Type, Statistic\+Type, Mat\+Type, Root\+Point\+Policy $>$\+::Prune\+Far\+Set (
\begin{DoxyParamCaption}
\item[{arma\+::\+Col$<$ size\+\_\+t $>$ \&}]{indices, }
\item[{arma\+::vec \&}]{distances, }
\item[{const {\bf Elem\+Type}}]{bound, }
\item[{const size\+\_\+t}]{near\+Set\+Size, }
\item[{const size\+\_\+t}]{point\+Set\+Size}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [private]}}\label{classmlpack_1_1tree_1_1CoverTree_a7b712e1c689cd76c80fad0f71efaad13}
\index{mlpack\+::tree\+::\+Cover\+Tree@{mlpack\+::tree\+::\+Cover\+Tree}!Range\+Distance@{Range\+Distance}}
\index{Range\+Distance@{Range\+Distance}!mlpack\+::tree\+::\+Cover\+Tree@{mlpack\+::tree\+::\+Cover\+Tree}}
\subsubsection[{Range\+Distance(const Cover\+Tree \&other) const }]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename Metric\+Type  = metric\+::\+L\+Metric$<$2, true$>$, typename Statistic\+Type  = Empty\+Statistic, typename Mat\+Type  = arma\+::mat, typename Root\+Point\+Policy  = First\+Point\+Is\+Root$>$ {\bf math\+::\+Range\+Type}$<${\bf Elem\+Type}$>$ {\bf mlpack\+::tree\+::\+Cover\+Tree}$<$ Metric\+Type, Statistic\+Type, Mat\+Type, Root\+Point\+Policy $>$\+::Range\+Distance (
\begin{DoxyParamCaption}
\item[{const {\bf Cover\+Tree}$<$ Metric\+Type, Statistic\+Type, Mat\+Type, Root\+Point\+Policy $>$ \&}]{other}
\end{DoxyParamCaption}
) const}\label{classmlpack_1_1tree_1_1CoverTree_ab9cb1ec67855df16783c9925c36f8370}


Return the minimum and maximum distance to another node. 



Referenced by mlpack\+::tree\+::\+Cover\+Tree$<$ Metric\+Type, Statistic\+Type, Mat\+Type, Root\+Point\+Policy $>$\+::\+Stat().

\index{mlpack\+::tree\+::\+Cover\+Tree@{mlpack\+::tree\+::\+Cover\+Tree}!Range\+Distance@{Range\+Distance}}
\index{Range\+Distance@{Range\+Distance}!mlpack\+::tree\+::\+Cover\+Tree@{mlpack\+::tree\+::\+Cover\+Tree}}
\subsubsection[{Range\+Distance(const Cover\+Tree \&other, const Elem\+Type distance) const }]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename Metric\+Type  = metric\+::\+L\+Metric$<$2, true$>$, typename Statistic\+Type  = Empty\+Statistic, typename Mat\+Type  = arma\+::mat, typename Root\+Point\+Policy  = First\+Point\+Is\+Root$>$ {\bf math\+::\+Range\+Type}$<${\bf Elem\+Type}$>$ {\bf mlpack\+::tree\+::\+Cover\+Tree}$<$ Metric\+Type, Statistic\+Type, Mat\+Type, Root\+Point\+Policy $>$\+::Range\+Distance (
\begin{DoxyParamCaption}
\item[{const {\bf Cover\+Tree}$<$ Metric\+Type, Statistic\+Type, Mat\+Type, Root\+Point\+Policy $>$ \&}]{other, }
\item[{const {\bf Elem\+Type}}]{distance}
\end{DoxyParamCaption}
) const}\label{classmlpack_1_1tree_1_1CoverTree_a2838478e41dc5f7c5737fb5723e26a4e}


Return the minimum and maximum distance to another node given that the point-\/to-\/point distance has already been calculated. 

\index{mlpack\+::tree\+::\+Cover\+Tree@{mlpack\+::tree\+::\+Cover\+Tree}!Range\+Distance@{Range\+Distance}}
\index{Range\+Distance@{Range\+Distance}!mlpack\+::tree\+::\+Cover\+Tree@{mlpack\+::tree\+::\+Cover\+Tree}}
\subsubsection[{Range\+Distance(const arma\+::vec \&other) const }]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename Metric\+Type  = metric\+::\+L\+Metric$<$2, true$>$, typename Statistic\+Type  = Empty\+Statistic, typename Mat\+Type  = arma\+::mat, typename Root\+Point\+Policy  = First\+Point\+Is\+Root$>$ {\bf math\+::\+Range\+Type}$<${\bf Elem\+Type}$>$ {\bf mlpack\+::tree\+::\+Cover\+Tree}$<$ Metric\+Type, Statistic\+Type, Mat\+Type, Root\+Point\+Policy $>$\+::Range\+Distance (
\begin{DoxyParamCaption}
\item[{const arma\+::vec \&}]{other}
\end{DoxyParamCaption}
) const}\label{classmlpack_1_1tree_1_1CoverTree_ab822714680aea9c61d508e98ec947097}


Return the minimum and maximum distance to another point. 

\index{mlpack\+::tree\+::\+Cover\+Tree@{mlpack\+::tree\+::\+Cover\+Tree}!Range\+Distance@{Range\+Distance}}
\index{Range\+Distance@{Range\+Distance}!mlpack\+::tree\+::\+Cover\+Tree@{mlpack\+::tree\+::\+Cover\+Tree}}
\subsubsection[{Range\+Distance(const arma\+::vec \&other, const Elem\+Type distance) const }]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename Metric\+Type  = metric\+::\+L\+Metric$<$2, true$>$, typename Statistic\+Type  = Empty\+Statistic, typename Mat\+Type  = arma\+::mat, typename Root\+Point\+Policy  = First\+Point\+Is\+Root$>$ {\bf math\+::\+Range\+Type}$<${\bf Elem\+Type}$>$ {\bf mlpack\+::tree\+::\+Cover\+Tree}$<$ Metric\+Type, Statistic\+Type, Mat\+Type, Root\+Point\+Policy $>$\+::Range\+Distance (
\begin{DoxyParamCaption}
\item[{const arma\+::vec \&}]{other, }
\item[{const {\bf Elem\+Type}}]{distance}
\end{DoxyParamCaption}
) const}\label{classmlpack_1_1tree_1_1CoverTree_a776d321e871a93c0eac6bfdeee974cf5}


Return the minimum and maximum distance to another point given that the point-\/to-\/point distance has already been calculated. 

\index{mlpack\+::tree\+::\+Cover\+Tree@{mlpack\+::tree\+::\+Cover\+Tree}!Remove\+New\+Implicit\+Nodes@{Remove\+New\+Implicit\+Nodes}}
\index{Remove\+New\+Implicit\+Nodes@{Remove\+New\+Implicit\+Nodes}!mlpack\+::tree\+::\+Cover\+Tree@{mlpack\+::tree\+::\+Cover\+Tree}}
\subsubsection[{Remove\+New\+Implicit\+Nodes()}]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename Metric\+Type  = metric\+::\+L\+Metric$<$2, true$>$, typename Statistic\+Type  = Empty\+Statistic, typename Mat\+Type  = arma\+::mat, typename Root\+Point\+Policy  = First\+Point\+Is\+Root$>$ void {\bf mlpack\+::tree\+::\+Cover\+Tree}$<$ Metric\+Type, Statistic\+Type, Mat\+Type, Root\+Point\+Policy $>$\+::Remove\+New\+Implicit\+Nodes (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [private]}}\label{classmlpack_1_1tree_1_1CoverTree_a9b2ebd124ecafec70d30f6d777ae8b86}


Take a look at the last child (the most recently created one) and remove any implicit nodes that have been created. 

\index{mlpack\+::tree\+::\+Cover\+Tree@{mlpack\+::tree\+::\+Cover\+Tree}!Scale@{Scale}}
\index{Scale@{Scale}!mlpack\+::tree\+::\+Cover\+Tree@{mlpack\+::tree\+::\+Cover\+Tree}}
\subsubsection[{Scale() const }]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename Metric\+Type  = metric\+::\+L\+Metric$<$2, true$>$, typename Statistic\+Type  = Empty\+Statistic, typename Mat\+Type  = arma\+::mat, typename Root\+Point\+Policy  = First\+Point\+Is\+Root$>$ int {\bf mlpack\+::tree\+::\+Cover\+Tree}$<$ Metric\+Type, Statistic\+Type, Mat\+Type, Root\+Point\+Policy $>$\+::Scale (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
) const\hspace{0.3cm}{\ttfamily [inline]}}\label{classmlpack_1_1tree_1_1CoverTree_ac6ed268c6f2fadd341f825f2d6a7c4be}


Get the scale of this node. 



Definition at line 299 of file cover\+\_\+tree.\+hpp.



References mlpack\+::tree\+::\+Cover\+Tree$<$ Metric\+Type, Statistic\+Type, Mat\+Type, Root\+Point\+Policy $>$\+::scale.

\index{mlpack\+::tree\+::\+Cover\+Tree@{mlpack\+::tree\+::\+Cover\+Tree}!Scale@{Scale}}
\index{Scale@{Scale}!mlpack\+::tree\+::\+Cover\+Tree@{mlpack\+::tree\+::\+Cover\+Tree}}
\subsubsection[{Scale()}]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename Metric\+Type  = metric\+::\+L\+Metric$<$2, true$>$, typename Statistic\+Type  = Empty\+Statistic, typename Mat\+Type  = arma\+::mat, typename Root\+Point\+Policy  = First\+Point\+Is\+Root$>$ int\& {\bf mlpack\+::tree\+::\+Cover\+Tree}$<$ Metric\+Type, Statistic\+Type, Mat\+Type, Root\+Point\+Policy $>$\+::Scale (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}}\label{classmlpack_1_1tree_1_1CoverTree_a1e0ba4c2ad71797c47a86368e6b64a4d}


Modify the scale of this node. Be careful... 



Definition at line 301 of file cover\+\_\+tree.\+hpp.



References mlpack\+::tree\+::\+Cover\+Tree$<$ Metric\+Type, Statistic\+Type, Mat\+Type, Root\+Point\+Policy $>$\+::scale.

\index{mlpack\+::tree\+::\+Cover\+Tree@{mlpack\+::tree\+::\+Cover\+Tree}!Serialize@{Serialize}}
\index{Serialize@{Serialize}!mlpack\+::tree\+::\+Cover\+Tree@{mlpack\+::tree\+::\+Cover\+Tree}}
\subsubsection[{Serialize(\+Archive \&ar, const unsigned int)}]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename Metric\+Type  = metric\+::\+L\+Metric$<$2, true$>$, typename Statistic\+Type  = Empty\+Statistic, typename Mat\+Type  = arma\+::mat, typename Root\+Point\+Policy  = First\+Point\+Is\+Root$>$ template$<$typename Archive $>$ void {\bf mlpack\+::tree\+::\+Cover\+Tree}$<$ Metric\+Type, Statistic\+Type, Mat\+Type, Root\+Point\+Policy $>$\+::Serialize (
\begin{DoxyParamCaption}
\item[{Archive \&}]{ar, }
\item[{const unsigned}]{int}
\end{DoxyParamCaption}
)}\label{classmlpack_1_1tree_1_1CoverTree_a749d57e31307ae682f68981c33895792}


Serialize the tree. 

\index{mlpack\+::tree\+::\+Cover\+Tree@{mlpack\+::tree\+::\+Cover\+Tree}!Sort\+Point\+Set@{Sort\+Point\+Set}}
\index{Sort\+Point\+Set@{Sort\+Point\+Set}!mlpack\+::tree\+::\+Cover\+Tree@{mlpack\+::tree\+::\+Cover\+Tree}}
\subsubsection[{Sort\+Point\+Set(arma\+::\+Col$<$ size\+\_\+t $>$ \&indices, arma\+::vec \&distances, const size\+\_\+t child\+Far\+Set\+Size, const size\+\_\+t child\+Used\+Set\+Size, const size\+\_\+t far\+Set\+Size)}]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename Metric\+Type  = metric\+::\+L\+Metric$<$2, true$>$, typename Statistic\+Type  = Empty\+Statistic, typename Mat\+Type  = arma\+::mat, typename Root\+Point\+Policy  = First\+Point\+Is\+Root$>$ size\+\_\+t {\bf mlpack\+::tree\+::\+Cover\+Tree}$<$ Metric\+Type, Statistic\+Type, Mat\+Type, Root\+Point\+Policy $>$\+::Sort\+Point\+Set (
\begin{DoxyParamCaption}
\item[{arma\+::\+Col$<$ size\+\_\+t $>$ \&}]{indices, }
\item[{arma\+::vec \&}]{distances, }
\item[{const size\+\_\+t}]{child\+Far\+Set\+Size, }
\item[{const size\+\_\+t}]{child\+Used\+Set\+Size, }
\item[{const size\+\_\+t}]{far\+Set\+Size}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [private]}}\label{classmlpack_1_1tree_1_1CoverTree_aecc2d731a64ea28547d0f357e5ad1942}


Assuming that the list of indices and distances is sorted as [ child\+Far\+Set $\vert$ child\+Used\+Set $\vert$ far\+Set $\vert$ used\+Set ], resort the sets so the organization is [ child\+Far\+Set $\vert$ far\+Set $\vert$ child\+Used\+Set $\vert$ used\+Set ]. 

The size\+\_\+t parameters specify the sizes of each set in the array. Only the ordering of the indices and distances arrays will be modified (not their actual contents).

The size of any of the four sets can be zero and this method will handle that case accordingly.


\begin{DoxyParams}{Parameters}
{\em indices} & List of indices to sort. \\
\hline
{\em distances} & List of distances to sort. \\
\hline
{\em child\+Far\+Set\+Size} & Number of points in child far set (child\+Far\+Set). \\
\hline
{\em child\+Used\+Set\+Size} & Number of points in child used set (child\+Used\+Set). \\
\hline
{\em far\+Set\+Size} & Number of points in far set (far\+Set). \\
\hline
\end{DoxyParams}
\index{mlpack\+::tree\+::\+Cover\+Tree@{mlpack\+::tree\+::\+Cover\+Tree}!Split\+Near\+Far@{Split\+Near\+Far}}
\index{Split\+Near\+Far@{Split\+Near\+Far}!mlpack\+::tree\+::\+Cover\+Tree@{mlpack\+::tree\+::\+Cover\+Tree}}
\subsubsection[{Split\+Near\+Far(arma\+::\+Col$<$ size\+\_\+t $>$ \&indices, arma\+::vec \&distances, const Elem\+Type bound, const size\+\_\+t point\+Set\+Size)}]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename Metric\+Type  = metric\+::\+L\+Metric$<$2, true$>$, typename Statistic\+Type  = Empty\+Statistic, typename Mat\+Type  = arma\+::mat, typename Root\+Point\+Policy  = First\+Point\+Is\+Root$>$ size\+\_\+t {\bf mlpack\+::tree\+::\+Cover\+Tree}$<$ Metric\+Type, Statistic\+Type, Mat\+Type, Root\+Point\+Policy $>$\+::Split\+Near\+Far (
\begin{DoxyParamCaption}
\item[{arma\+::\+Col$<$ size\+\_\+t $>$ \&}]{indices, }
\item[{arma\+::vec \&}]{distances, }
\item[{const {\bf Elem\+Type}}]{bound, }
\item[{const size\+\_\+t}]{point\+Set\+Size}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [private]}}\label{classmlpack_1_1tree_1_1CoverTree_aa7c2eba7e2c49bb19d6114281e411e45}


Split the given indices and distances into a near and a far set, returning the number of points in the near set. 

The distances must already be initialized. This will order the indices and distances such that the points in the near set make up the first part of the array and the far set makes up the rest\+: [ near\+Set $\vert$ far\+Set ].


\begin{DoxyParams}{Parameters}
{\em indices} & List of indices; will be reordered. \\
\hline
{\em distances} & List of distances; will be reordered. \\
\hline
{\em bound} & If the distance is less than or equal to this bound, the point is placed into the near set. \\
\hline
{\em point\+Set\+Size} & Size of point set (because we may be sorting a smaller list than the indices vector will hold). \\
\hline
\end{DoxyParams}
\index{mlpack\+::tree\+::\+Cover\+Tree@{mlpack\+::tree\+::\+Cover\+Tree}!Stat@{Stat}}
\index{Stat@{Stat}!mlpack\+::tree\+::\+Cover\+Tree@{mlpack\+::tree\+::\+Cover\+Tree}}
\subsubsection[{Stat() const }]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename Metric\+Type  = metric\+::\+L\+Metric$<$2, true$>$, typename Statistic\+Type  = Empty\+Statistic, typename Mat\+Type  = arma\+::mat, typename Root\+Point\+Policy  = First\+Point\+Is\+Root$>$ const Statistic\+Type\& {\bf mlpack\+::tree\+::\+Cover\+Tree}$<$ Metric\+Type, Statistic\+Type, Mat\+Type, Root\+Point\+Policy $>$\+::Stat (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
) const\hspace{0.3cm}{\ttfamily [inline]}}\label{classmlpack_1_1tree_1_1CoverTree_a805333d4c49319bc9a65392eff723c7e}


Get the statistic for this node. 



Definition at line 309 of file cover\+\_\+tree.\+hpp.



References mlpack\+::tree\+::\+Cover\+Tree$<$ Metric\+Type, Statistic\+Type, Mat\+Type, Root\+Point\+Policy $>$\+::stat.

\index{mlpack\+::tree\+::\+Cover\+Tree@{mlpack\+::tree\+::\+Cover\+Tree}!Stat@{Stat}}
\index{Stat@{Stat}!mlpack\+::tree\+::\+Cover\+Tree@{mlpack\+::tree\+::\+Cover\+Tree}}
\subsubsection[{Stat()}]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename Metric\+Type  = metric\+::\+L\+Metric$<$2, true$>$, typename Statistic\+Type  = Empty\+Statistic, typename Mat\+Type  = arma\+::mat, typename Root\+Point\+Policy  = First\+Point\+Is\+Root$>$ Statistic\+Type\& {\bf mlpack\+::tree\+::\+Cover\+Tree}$<$ Metric\+Type, Statistic\+Type, Mat\+Type, Root\+Point\+Policy $>$\+::Stat (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}}\label{classmlpack_1_1tree_1_1CoverTree_a05a9c01433f36a9f21f67abc13a1ef37}


Modify the statistic for this node. 



Definition at line 311 of file cover\+\_\+tree.\+hpp.



References mlpack\+::tree\+::\+Cover\+Tree$<$ Metric\+Type, Statistic\+Type, Mat\+Type, Root\+Point\+Policy $>$\+::\+Get\+Furthest\+Child(), mlpack\+::tree\+::\+Cover\+Tree$<$ Metric\+Type, Statistic\+Type, Mat\+Type, Root\+Point\+Policy $>$\+::\+Get\+Nearest\+Child(), mlpack\+::tree\+::\+Cover\+Tree$<$ Metric\+Type, Statistic\+Type, Mat\+Type, Root\+Point\+Policy $>$\+::\+Max\+Distance(), mlpack\+::tree\+::\+Cover\+Tree$<$ Metric\+Type, Statistic\+Type, Mat\+Type, Root\+Point\+Policy $>$\+::\+Min\+Distance(), mlpack\+::tree\+::\+Cover\+Tree$<$ Metric\+Type, Statistic\+Type, Mat\+Type, Root\+Point\+Policy $>$\+::point, mlpack\+::tree\+::\+Cover\+Tree$<$ Metric\+Type, Statistic\+Type, Mat\+Type, Root\+Point\+Policy $>$\+::\+Range\+Distance(), and mlpack\+::tree\+::\+Cover\+Tree$<$ Metric\+Type, Statistic\+Type, Mat\+Type, Root\+Point\+Policy $>$\+::stat.



\subsection{Member Data Documentation}
\index{mlpack\+::tree\+::\+Cover\+Tree@{mlpack\+::tree\+::\+Cover\+Tree}!base@{base}}
\index{base@{base}!mlpack\+::tree\+::\+Cover\+Tree@{mlpack\+::tree\+::\+Cover\+Tree}}
\subsubsection[{base}]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename Metric\+Type  = metric\+::\+L\+Metric$<$2, true$>$, typename Statistic\+Type  = Empty\+Statistic, typename Mat\+Type  = arma\+::mat, typename Root\+Point\+Policy  = First\+Point\+Is\+Root$>$ {\bf Elem\+Type} {\bf mlpack\+::tree\+::\+Cover\+Tree}$<$ Metric\+Type, Statistic\+Type, Mat\+Type, Root\+Point\+Policy $>$\+::base\hspace{0.3cm}{\ttfamily [private]}}\label{classmlpack_1_1tree_1_1CoverTree_a02f91a888a58e108a3862ac527548e6a}


The base used to construct the tree. 



Definition at line 430 of file cover\+\_\+tree.\+hpp.



Referenced by mlpack\+::tree\+::\+Cover\+Tree$<$ Metric\+Type, Statistic\+Type, Mat\+Type, Root\+Point\+Policy $>$\+::\+Base().

\index{mlpack\+::tree\+::\+Cover\+Tree@{mlpack\+::tree\+::\+Cover\+Tree}!children@{children}}
\index{children@{children}!mlpack\+::tree\+::\+Cover\+Tree@{mlpack\+::tree\+::\+Cover\+Tree}}
\subsubsection[{children}]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename Metric\+Type  = metric\+::\+L\+Metric$<$2, true$>$, typename Statistic\+Type  = Empty\+Statistic, typename Mat\+Type  = arma\+::mat, typename Root\+Point\+Policy  = First\+Point\+Is\+Root$>$ std\+::vector$<${\bf Cover\+Tree}$\ast$$>$ {\bf mlpack\+::tree\+::\+Cover\+Tree}$<$ Metric\+Type, Statistic\+Type, Mat\+Type, Root\+Point\+Policy $>$\+::children\hspace{0.3cm}{\ttfamily [private]}}\label{classmlpack_1_1tree_1_1CoverTree_a27d7bcd05c073f2305cac979e3a6146e}


The list of children; the first is the self-\/child. 



Definition at line 426 of file cover\+\_\+tree.\+hpp.



Referenced by mlpack\+::tree\+::\+Cover\+Tree$<$ Metric\+Type, Statistic\+Type, Mat\+Type, Root\+Point\+Policy $>$\+::\+Child(), mlpack\+::tree\+::\+Cover\+Tree$<$ Metric\+Type, Statistic\+Type, Mat\+Type, Root\+Point\+Policy $>$\+::\+Child\+Ptr(), mlpack\+::tree\+::\+Cover\+Tree$<$ Metric\+Type, Statistic\+Type, Mat\+Type, Root\+Point\+Policy $>$\+::\+Children(), mlpack\+::tree\+::\+Cover\+Tree$<$ Metric\+Type, Statistic\+Type, Mat\+Type, Root\+Point\+Policy $>$\+::\+Is\+Leaf(), and mlpack\+::tree\+::\+Cover\+Tree$<$ Metric\+Type, Statistic\+Type, Mat\+Type, Root\+Point\+Policy $>$\+::\+Num\+Children().

\index{mlpack\+::tree\+::\+Cover\+Tree@{mlpack\+::tree\+::\+Cover\+Tree}!dataset@{dataset}}
\index{dataset@{dataset}!mlpack\+::tree\+::\+Cover\+Tree@{mlpack\+::tree\+::\+Cover\+Tree}}
\subsubsection[{dataset}]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename Metric\+Type  = metric\+::\+L\+Metric$<$2, true$>$, typename Statistic\+Type  = Empty\+Statistic, typename Mat\+Type  = arma\+::mat, typename Root\+Point\+Policy  = First\+Point\+Is\+Root$>$ const Mat\+Type$\ast$ {\bf mlpack\+::tree\+::\+Cover\+Tree}$<$ Metric\+Type, Statistic\+Type, Mat\+Type, Root\+Point\+Policy $>$\+::dataset\hspace{0.3cm}{\ttfamily [private]}}\label{classmlpack_1_1tree_1_1CoverTree_adfd47c0f8ba7d5872aacc8ec076173e9}


Reference to the matrix which this tree is built on. 



Definition at line 422 of file cover\+\_\+tree.\+hpp.



Referenced by mlpack\+::tree\+::\+Cover\+Tree$<$ Metric\+Type, Statistic\+Type, Mat\+Type, Root\+Point\+Policy $>$\+::\+Center(), and mlpack\+::tree\+::\+Cover\+Tree$<$ Metric\+Type, Statistic\+Type, Mat\+Type, Root\+Point\+Policy $>$\+::\+Dataset().

\index{mlpack\+::tree\+::\+Cover\+Tree@{mlpack\+::tree\+::\+Cover\+Tree}!distance\+Comps@{distance\+Comps}}
\index{distance\+Comps@{distance\+Comps}!mlpack\+::tree\+::\+Cover\+Tree@{mlpack\+::tree\+::\+Cover\+Tree}}
\subsubsection[{distance\+Comps}]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename Metric\+Type  = metric\+::\+L\+Metric$<$2, true$>$, typename Statistic\+Type  = Empty\+Statistic, typename Mat\+Type  = arma\+::mat, typename Root\+Point\+Policy  = First\+Point\+Is\+Root$>$ size\+\_\+t {\bf mlpack\+::tree\+::\+Cover\+Tree}$<$ Metric\+Type, Statistic\+Type, Mat\+Type, Root\+Point\+Policy $>$\+::distance\+Comps\hspace{0.3cm}{\ttfamily [private]}}\label{classmlpack_1_1tree_1_1CoverTree_a46f9ef0dd77ea3e1c268690bb8929252}


Definition at line 559 of file cover\+\_\+tree.\+hpp.



Referenced by mlpack\+::tree\+::\+Cover\+Tree$<$ Metric\+Type, Statistic\+Type, Mat\+Type, Root\+Point\+Policy $>$\+::\+Distance\+Comps().

\index{mlpack\+::tree\+::\+Cover\+Tree@{mlpack\+::tree\+::\+Cover\+Tree}!furthest\+Descendant\+Distance@{furthest\+Descendant\+Distance}}
\index{furthest\+Descendant\+Distance@{furthest\+Descendant\+Distance}!mlpack\+::tree\+::\+Cover\+Tree@{mlpack\+::tree\+::\+Cover\+Tree}}
\subsubsection[{furthest\+Descendant\+Distance}]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename Metric\+Type  = metric\+::\+L\+Metric$<$2, true$>$, typename Statistic\+Type  = Empty\+Statistic, typename Mat\+Type  = arma\+::mat, typename Root\+Point\+Policy  = First\+Point\+Is\+Root$>$ {\bf Elem\+Type} {\bf mlpack\+::tree\+::\+Cover\+Tree}$<$ Metric\+Type, Statistic\+Type, Mat\+Type, Root\+Point\+Policy $>$\+::furthest\+Descendant\+Distance\hspace{0.3cm}{\ttfamily [private]}}\label{classmlpack_1_1tree_1_1CoverTree_a290c1faf9cc9ae2357bec59a2f1502dc}


Distance to the furthest descendant. 



Definition at line 440 of file cover\+\_\+tree.\+hpp.



Referenced by mlpack\+::tree\+::\+Cover\+Tree$<$ Metric\+Type, Statistic\+Type, Mat\+Type, Root\+Point\+Policy $>$\+::\+Furthest\+Descendant\+Distance(), and mlpack\+::tree\+::\+Cover\+Tree$<$ Metric\+Type, Statistic\+Type, Mat\+Type, Root\+Point\+Policy $>$\+::\+Minimum\+Bound\+Distance().

\index{mlpack\+::tree\+::\+Cover\+Tree@{mlpack\+::tree\+::\+Cover\+Tree}!local\+Dataset@{local\+Dataset}}
\index{local\+Dataset@{local\+Dataset}!mlpack\+::tree\+::\+Cover\+Tree@{mlpack\+::tree\+::\+Cover\+Tree}}
\subsubsection[{local\+Dataset}]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename Metric\+Type  = metric\+::\+L\+Metric$<$2, true$>$, typename Statistic\+Type  = Empty\+Statistic, typename Mat\+Type  = arma\+::mat, typename Root\+Point\+Policy  = First\+Point\+Is\+Root$>$ bool {\bf mlpack\+::tree\+::\+Cover\+Tree}$<$ Metric\+Type, Statistic\+Type, Mat\+Type, Root\+Point\+Policy $>$\+::local\+Dataset\hspace{0.3cm}{\ttfamily [private]}}\label{classmlpack_1_1tree_1_1CoverTree_ab0ac3c705092923de263dd0195b14f91}


If true, we own the dataset and need to destroy it in the destructor. 



Definition at line 444 of file cover\+\_\+tree.\+hpp.

\index{mlpack\+::tree\+::\+Cover\+Tree@{mlpack\+::tree\+::\+Cover\+Tree}!local\+Metric@{local\+Metric}}
\index{local\+Metric@{local\+Metric}!mlpack\+::tree\+::\+Cover\+Tree@{mlpack\+::tree\+::\+Cover\+Tree}}
\subsubsection[{local\+Metric}]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename Metric\+Type  = metric\+::\+L\+Metric$<$2, true$>$, typename Statistic\+Type  = Empty\+Statistic, typename Mat\+Type  = arma\+::mat, typename Root\+Point\+Policy  = First\+Point\+Is\+Root$>$ bool {\bf mlpack\+::tree\+::\+Cover\+Tree}$<$ Metric\+Type, Statistic\+Type, Mat\+Type, Root\+Point\+Policy $>$\+::local\+Metric\hspace{0.3cm}{\ttfamily [private]}}\label{classmlpack_1_1tree_1_1CoverTree_ad975620be4041087edeb9a00190d6db5}


Whether or not we need to destroy the metric in the destructor. 



Definition at line 442 of file cover\+\_\+tree.\+hpp.

\index{mlpack\+::tree\+::\+Cover\+Tree@{mlpack\+::tree\+::\+Cover\+Tree}!metric@{metric}}
\index{metric@{metric}!mlpack\+::tree\+::\+Cover\+Tree@{mlpack\+::tree\+::\+Cover\+Tree}}
\subsubsection[{metric}]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename Metric\+Type  = metric\+::\+L\+Metric$<$2, true$>$, typename Statistic\+Type  = Empty\+Statistic, typename Mat\+Type  = arma\+::mat, typename Root\+Point\+Policy  = First\+Point\+Is\+Root$>$ Metric\+Type$\ast$ {\bf mlpack\+::tree\+::\+Cover\+Tree}$<$ Metric\+Type, Statistic\+Type, Mat\+Type, Root\+Point\+Policy $>$\+::metric\hspace{0.3cm}{\ttfamily [private]}}\label{classmlpack_1_1tree_1_1CoverTree_ae06af16ea4c191e6bf6b83b98d68446e}


The metric used for this tree. 



Definition at line 446 of file cover\+\_\+tree.\+hpp.



Referenced by mlpack\+::tree\+::\+Cover\+Tree$<$ Metric\+Type, Statistic\+Type, Mat\+Type, Root\+Point\+Policy $>$\+::\+Metric().

\index{mlpack\+::tree\+::\+Cover\+Tree@{mlpack\+::tree\+::\+Cover\+Tree}!num\+Descendants@{num\+Descendants}}
\index{num\+Descendants@{num\+Descendants}!mlpack\+::tree\+::\+Cover\+Tree@{mlpack\+::tree\+::\+Cover\+Tree}}
\subsubsection[{num\+Descendants}]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename Metric\+Type  = metric\+::\+L\+Metric$<$2, true$>$, typename Statistic\+Type  = Empty\+Statistic, typename Mat\+Type  = arma\+::mat, typename Root\+Point\+Policy  = First\+Point\+Is\+Root$>$ size\+\_\+t {\bf mlpack\+::tree\+::\+Cover\+Tree}$<$ Metric\+Type, Statistic\+Type, Mat\+Type, Root\+Point\+Policy $>$\+::num\+Descendants\hspace{0.3cm}{\ttfamily [private]}}\label{classmlpack_1_1tree_1_1CoverTree_a504372096c8711d196d7096a1e742bef}


The number of descendant points. 



Definition at line 434 of file cover\+\_\+tree.\+hpp.

\index{mlpack\+::tree\+::\+Cover\+Tree@{mlpack\+::tree\+::\+Cover\+Tree}!parent@{parent}}
\index{parent@{parent}!mlpack\+::tree\+::\+Cover\+Tree@{mlpack\+::tree\+::\+Cover\+Tree}}
\subsubsection[{parent}]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename Metric\+Type  = metric\+::\+L\+Metric$<$2, true$>$, typename Statistic\+Type  = Empty\+Statistic, typename Mat\+Type  = arma\+::mat, typename Root\+Point\+Policy  = First\+Point\+Is\+Root$>$ {\bf Cover\+Tree}$\ast$ {\bf mlpack\+::tree\+::\+Cover\+Tree}$<$ Metric\+Type, Statistic\+Type, Mat\+Type, Root\+Point\+Policy $>$\+::parent\hspace{0.3cm}{\ttfamily [private]}}\label{classmlpack_1_1tree_1_1CoverTree_a47dad54f3d619550d5c9a4e077b3b32d}


The parent node (N\+U\+LL if this is the root of the tree). 



Definition at line 436 of file cover\+\_\+tree.\+hpp.



Referenced by mlpack\+::tree\+::\+Cover\+Tree$<$ Metric\+Type, Statistic\+Type, Mat\+Type, Root\+Point\+Policy $>$\+::\+Parent().

\index{mlpack\+::tree\+::\+Cover\+Tree@{mlpack\+::tree\+::\+Cover\+Tree}!parent\+Distance@{parent\+Distance}}
\index{parent\+Distance@{parent\+Distance}!mlpack\+::tree\+::\+Cover\+Tree@{mlpack\+::tree\+::\+Cover\+Tree}}
\subsubsection[{parent\+Distance}]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename Metric\+Type  = metric\+::\+L\+Metric$<$2, true$>$, typename Statistic\+Type  = Empty\+Statistic, typename Mat\+Type  = arma\+::mat, typename Root\+Point\+Policy  = First\+Point\+Is\+Root$>$ {\bf Elem\+Type} {\bf mlpack\+::tree\+::\+Cover\+Tree}$<$ Metric\+Type, Statistic\+Type, Mat\+Type, Root\+Point\+Policy $>$\+::parent\+Distance\hspace{0.3cm}{\ttfamily [private]}}\label{classmlpack_1_1tree_1_1CoverTree_a0601970c11e745c323269e9782dfbf0e}


Distance to the parent. 



Definition at line 438 of file cover\+\_\+tree.\+hpp.



Referenced by mlpack\+::tree\+::\+Cover\+Tree$<$ Metric\+Type, Statistic\+Type, Mat\+Type, Root\+Point\+Policy $>$\+::\+Parent\+Distance().

\index{mlpack\+::tree\+::\+Cover\+Tree@{mlpack\+::tree\+::\+Cover\+Tree}!point@{point}}
\index{point@{point}!mlpack\+::tree\+::\+Cover\+Tree@{mlpack\+::tree\+::\+Cover\+Tree}}
\subsubsection[{point}]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename Metric\+Type  = metric\+::\+L\+Metric$<$2, true$>$, typename Statistic\+Type  = Empty\+Statistic, typename Mat\+Type  = arma\+::mat, typename Root\+Point\+Policy  = First\+Point\+Is\+Root$>$ size\+\_\+t {\bf mlpack\+::tree\+::\+Cover\+Tree}$<$ Metric\+Type, Statistic\+Type, Mat\+Type, Root\+Point\+Policy $>$\+::point\hspace{0.3cm}{\ttfamily [private]}}\label{classmlpack_1_1tree_1_1CoverTree_abe65d8768e7599c6a5278cf35c78d97e}


Index of the point in the matrix which this node represents. 



Definition at line 424 of file cover\+\_\+tree.\+hpp.



Referenced by mlpack\+::tree\+::\+Cover\+Tree$<$ Metric\+Type, Statistic\+Type, Mat\+Type, Root\+Point\+Policy $>$\+::\+Point(), and mlpack\+::tree\+::\+Cover\+Tree$<$ Metric\+Type, Statistic\+Type, Mat\+Type, Root\+Point\+Policy $>$\+::\+Stat().

\index{mlpack\+::tree\+::\+Cover\+Tree@{mlpack\+::tree\+::\+Cover\+Tree}!scale@{scale}}
\index{scale@{scale}!mlpack\+::tree\+::\+Cover\+Tree@{mlpack\+::tree\+::\+Cover\+Tree}}
\subsubsection[{scale}]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename Metric\+Type  = metric\+::\+L\+Metric$<$2, true$>$, typename Statistic\+Type  = Empty\+Statistic, typename Mat\+Type  = arma\+::mat, typename Root\+Point\+Policy  = First\+Point\+Is\+Root$>$ int {\bf mlpack\+::tree\+::\+Cover\+Tree}$<$ Metric\+Type, Statistic\+Type, Mat\+Type, Root\+Point\+Policy $>$\+::scale\hspace{0.3cm}{\ttfamily [private]}}\label{classmlpack_1_1tree_1_1CoverTree_a268da22f80377d7ebb25b9d12b2128b4}


Scale level of the node. 



Definition at line 428 of file cover\+\_\+tree.\+hpp.



Referenced by mlpack\+::tree\+::\+Cover\+Tree$<$ Metric\+Type, Statistic\+Type, Mat\+Type, Root\+Point\+Policy $>$\+::\+Scale().

\index{mlpack\+::tree\+::\+Cover\+Tree@{mlpack\+::tree\+::\+Cover\+Tree}!stat@{stat}}
\index{stat@{stat}!mlpack\+::tree\+::\+Cover\+Tree@{mlpack\+::tree\+::\+Cover\+Tree}}
\subsubsection[{stat}]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename Metric\+Type  = metric\+::\+L\+Metric$<$2, true$>$, typename Statistic\+Type  = Empty\+Statistic, typename Mat\+Type  = arma\+::mat, typename Root\+Point\+Policy  = First\+Point\+Is\+Root$>$ Statistic\+Type {\bf mlpack\+::tree\+::\+Cover\+Tree}$<$ Metric\+Type, Statistic\+Type, Mat\+Type, Root\+Point\+Policy $>$\+::stat\hspace{0.3cm}{\ttfamily [private]}}\label{classmlpack_1_1tree_1_1CoverTree_af6e9e4c9ab4ee1801f69ac36d5253e48}


The instantiated statistic. 



Definition at line 432 of file cover\+\_\+tree.\+hpp.



Referenced by mlpack\+::tree\+::\+Cover\+Tree$<$ Metric\+Type, Statistic\+Type, Mat\+Type, Root\+Point\+Policy $>$\+::\+Stat().



The documentation for this class was generated from the following file\+:\begin{DoxyCompactItemize}
\item 
src/mlpack/core/tree/cover\+\_\+tree/{\bf cover\+\_\+tree.\+hpp}\end{DoxyCompactItemize}
