\section{mlpack\+:\+:neighbor Namespace Reference}
\label{namespacemlpack_1_1neighbor}\index{mlpack\+::neighbor@{mlpack\+::neighbor}}


Neighbor-\/search routines.  


\subsection*{Classes}
\begin{DoxyCompactItemize}
\item 
class {\bf Bi\+Search\+Visitor}
\begin{DoxyCompactList}\small\item\em \doxyref{Bi\+Search\+Visitor}{p.}{classmlpack_1_1neighbor_1_1BiSearchVisitor} executes a bichromatic neighbor search on the given N\+S\+Type. \end{DoxyCompactList}\item 
class {\bf Delete\+Visitor}
\begin{DoxyCompactList}\small\item\em \doxyref{Delete\+Visitor}{p.}{classmlpack_1_1neighbor_1_1DeleteVisitor} deletes the given N\+S\+Type instance. \end{DoxyCompactList}\item 
class {\bf Drusilla\+Select}
\item 
class {\bf Epsilon\+Visitor}
\begin{DoxyCompactList}\small\item\em \doxyref{Epsilon\+Visitor}{p.}{classmlpack_1_1neighbor_1_1EpsilonVisitor} exposes the Epsilon method of the given N\+S\+Type. \end{DoxyCompactList}\item 
class {\bf Furthest\+Neighbor\+Sort}
\begin{DoxyCompactList}\small\item\em This class implements the necessary methods for the Sort\+Policy template parameter of the \doxyref{Neighbor\+Search}{p.}{classmlpack_1_1neighbor_1_1NeighborSearch} class. \end{DoxyCompactList}\item 
class {\bf L\+S\+H\+Search}
\begin{DoxyCompactList}\small\item\em The \doxyref{L\+S\+H\+Search}{p.}{classmlpack_1_1neighbor_1_1LSHSearch} class; this class builds a hash on the reference set and uses this hash to compute the distance-\/approximate nearest-\/neighbors of the given queries. \end{DoxyCompactList}\item 
class {\bf Mono\+Search\+Visitor}
\begin{DoxyCompactList}\small\item\em \doxyref{Mono\+Search\+Visitor}{p.}{classmlpack_1_1neighbor_1_1MonoSearchVisitor} executes a monochromatic neighbor search on the given N\+S\+Type. \end{DoxyCompactList}\item 
class {\bf Nearest\+Neighbor\+Sort}
\begin{DoxyCompactList}\small\item\em This class implements the necessary methods for the Sort\+Policy template parameter of the \doxyref{Neighbor\+Search}{p.}{classmlpack_1_1neighbor_1_1NeighborSearch} class. \end{DoxyCompactList}\item 
class {\bf Neighbor\+Search}
\begin{DoxyCompactList}\small\item\em The \doxyref{Neighbor\+Search}{p.}{classmlpack_1_1neighbor_1_1NeighborSearch} class is a template class for performing distance-\/based neighbor searches. \end{DoxyCompactList}\item 
class {\bf Neighbor\+Search\+Rules}
\begin{DoxyCompactList}\small\item\em The \doxyref{Neighbor\+Search\+Rules}{p.}{classmlpack_1_1neighbor_1_1NeighborSearchRules} class is a template helper class used by \doxyref{Neighbor\+Search}{p.}{classmlpack_1_1neighbor_1_1NeighborSearch} class when performing distance-\/based neighbor searches. \end{DoxyCompactList}\item 
class {\bf Neighbor\+Search\+Stat}
\begin{DoxyCompactList}\small\item\em Extra data for each node in the tree. \end{DoxyCompactList}\item 
class {\bf N\+S\+Model}
\begin{DoxyCompactList}\small\item\em The \doxyref{N\+S\+Model}{p.}{classmlpack_1_1neighbor_1_1NSModel} class provides an easy way to serialize a model, abstracts away the different types of trees, and also reflects the \doxyref{Neighbor\+Search}{p.}{classmlpack_1_1neighbor_1_1NeighborSearch} A\+PI. \end{DoxyCompactList}\item 
struct {\bf N\+S\+Model\+Name}
\item 
struct {\bf N\+S\+Model\+Name$<$ Furthest\+Neighbor\+Sort $>$}
\item 
struct {\bf N\+S\+Model\+Name$<$ Nearest\+Neighbor\+Sort $>$}
\item 
class {\bf Q\+D\+A\+FN}
\item 
class {\bf R\+A\+Model}
\begin{DoxyCompactList}\small\item\em The \doxyref{R\+A\+Model}{p.}{classmlpack_1_1neighbor_1_1RAModel} class provides an abstraction for the \doxyref{R\+A\+Search}{p.}{classmlpack_1_1neighbor_1_1RASearch} class, abstracting away the Tree\+Type parameter and allowing it to be specified at runtime in this class. \end{DoxyCompactList}\item 
class {\bf R\+A\+Query\+Stat}
\begin{DoxyCompactList}\small\item\em Extra data for each node in the tree. \end{DoxyCompactList}\item 
class {\bf R\+A\+Search}
\begin{DoxyCompactList}\small\item\em The \doxyref{R\+A\+Search}{p.}{classmlpack_1_1neighbor_1_1RASearch} class\+: This class provides a generic manner to perform rank-\/approximate search via random-\/sampling. \end{DoxyCompactList}\item 
class {\bf R\+A\+Search\+Rules}
\begin{DoxyCompactList}\small\item\em The \doxyref{R\+A\+Search\+Rules}{p.}{classmlpack_1_1neighbor_1_1RASearchRules} class is a template helper class used by \doxyref{R\+A\+Search}{p.}{classmlpack_1_1neighbor_1_1RASearch} class when performing rank-\/approximate search via random-\/sampling. \end{DoxyCompactList}\item 
class {\bf R\+A\+Util}
\item 
class {\bf Reference\+Set\+Visitor}
\begin{DoxyCompactList}\small\item\em \doxyref{Reference\+Set\+Visitor}{p.}{classmlpack_1_1neighbor_1_1ReferenceSetVisitor} exposes the reference\+Set of the given N\+S\+Type. \end{DoxyCompactList}\item 
class {\bf Search\+Mode\+Visitor}
\begin{DoxyCompactList}\small\item\em \doxyref{Search\+Mode\+Visitor}{p.}{classmlpack_1_1neighbor_1_1SearchModeVisitor} exposes the Search\+Mode() method of the given N\+S\+Type. \end{DoxyCompactList}\item 
class {\bf Train\+Visitor}
\begin{DoxyCompactList}\small\item\em \doxyref{Train\+Visitor}{p.}{classmlpack_1_1neighbor_1_1TrainVisitor} sets the reference set to a new reference set on the given N\+S\+Type. \end{DoxyCompactList}\end{DoxyCompactItemize}
\subsection*{Typedefs}
\begin{DoxyCompactItemize}
\item 
typedef {\bf Neighbor\+Search}$<$ {\bf Furthest\+Neighbor\+Sort}, {\bf metric\+::\+Euclidean\+Distance} $>$ {\bf Allk\+FN}
\item 
typedef {\bf Neighbor\+Search}$<$ {\bf Nearest\+Neighbor\+Sort}, {\bf metric\+::\+Euclidean\+Distance} $>$ {\bf Allk\+NN}
\item 
typedef {\bf R\+A\+Search} {\bf Allk\+R\+A\+FN}
\item 
typedef {\bf R\+A\+Search} {\bf Allk\+R\+A\+NN}
\item 
{\footnotesize template$<$template$<$ typename Tree\+Metric\+Type, typename Tree\+Stat\+Type, typename Tree\+Mat\+Type $>$ class Tree\+Type = tree\+::\+S\+P\+Tree$>$ }\\using {\bf Defeatist\+K\+NN} = {\bf Neighbor\+Search}$<$ {\bf Nearest\+Neighbor\+Sort}, {\bf metric\+::\+Euclidean\+Distance}, arma\+::mat, Tree\+Type, Tree\+Type$<$ {\bf metric\+::\+Euclidean\+Distance}, {\bf Neighbor\+Search\+Stat}$<$ {\bf Nearest\+Neighbor\+Sort} $>$, arma\+::mat $>$\+::template Defeatist\+Dual\+Tree\+Traverser, Tree\+Type$<$ {\bf metric\+::\+Euclidean\+Distance}, {\bf Neighbor\+Search\+Stat}$<$ {\bf Nearest\+Neighbor\+Sort} $>$, arma\+::mat $>$\+::template Defeatist\+Single\+Tree\+Traverser $>$
\begin{DoxyCompactList}\small\item\em The Defeatist\+K\+NN class is the k-\/nearest-\/neighbors method considering defeatist search. \end{DoxyCompactList}\item 
typedef {\bf Neighbor\+Search}$<$ {\bf Furthest\+Neighbor\+Sort}, {\bf metric\+::\+Euclidean\+Distance} $>$ {\bf K\+FN}
\begin{DoxyCompactList}\small\item\em The K\+FN class is the k-\/furthest-\/neighbors method. \end{DoxyCompactList}\item 
typedef {\bf Neighbor\+Search}$<$ {\bf Nearest\+Neighbor\+Sort}, {\bf metric\+::\+Euclidean\+Distance} $>$ {\bf K\+NN}
\begin{DoxyCompactList}\small\item\em The K\+NN class is the k-\/nearest-\/neighbors method. \end{DoxyCompactList}\item 
typedef {\bf R\+A\+Search}$<$ {\bf Furthest\+Neighbor\+Sort} $>$ {\bf K\+R\+A\+FN}
\begin{DoxyCompactList}\small\item\em The K\+R\+A\+FN class is the k-\/rank-\/approximate-\/farthest-\/neighbors method. \end{DoxyCompactList}\item 
typedef {\bf R\+A\+Search} {\bf K\+R\+A\+NN}
\begin{DoxyCompactList}\small\item\em The K\+R\+A\+NN class is the k-\/rank-\/approximate-\/nearest-\/neighbors method. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename Sort\+Policy , template$<$ typename Tree\+Metric\+Type, typename Tree\+Stat\+Type, typename Tree\+Mat\+Type $>$ class Tree\+Type$>$ }\\using {\bf N\+S\+Type} = {\bf Neighbor\+Search}$<$ Sort\+Policy, {\bf metric\+::\+Euclidean\+Distance}, arma\+::mat, Tree\+Type, Tree\+Type$<$ {\bf metric\+::\+Euclidean\+Distance}, {\bf Neighbor\+Search\+Stat}$<$ Sort\+Policy $>$, arma\+::mat $>$\+::template Dual\+Tree\+Traverser $>$
\begin{DoxyCompactList}\small\item\em Alias template for euclidean neighbor search. \end{DoxyCompactList}\item 
typedef {\bf Defeatist\+K\+NN}$<$ {\bf tree\+::\+S\+P\+Tree} $>$ {\bf Spill\+K\+NN}
\begin{DoxyCompactList}\small\item\em The Spill\+K\+NN class is the k-\/nearest-\/neighbors method considering defeatist search on S\+P\+Tree. \end{DoxyCompactList}\end{DoxyCompactItemize}
\subsection*{Enumerations}
\begin{DoxyCompactItemize}
\item 
enum {\bf Neighbor\+Search\+Mode} \{ \\*
{\bf N\+A\+I\+V\+E\+\_\+\+M\+O\+DE}, 
\\*
{\bf S\+I\+N\+G\+L\+E\+\_\+\+T\+R\+E\+E\+\_\+\+M\+O\+DE}, 
\\*
{\bf D\+U\+A\+L\+\_\+\+T\+R\+E\+E\+\_\+\+M\+O\+DE}, 
\\*
{\bf G\+R\+E\+E\+D\+Y\+\_\+\+S\+I\+N\+G\+L\+E\+\_\+\+T\+R\+E\+E\+\_\+\+M\+O\+DE}
 \}\begin{DoxyCompactList}\small\item\em Neighbor\+Search\+Mode represents the different neighbor search modes available. \end{DoxyCompactList}
\end{DoxyCompactItemize}
\subsection*{Functions}
\begin{DoxyCompactItemize}
\item 
void {\bf Unmap} (const arma\+::\+Mat$<$ size\+\_\+t $>$ \&neighbors, const arma\+::mat \&distances, const std\+::vector$<$ size\+\_\+t $>$ \&reference\+Map, const std\+::vector$<$ size\+\_\+t $>$ \&query\+Map, arma\+::\+Mat$<$ size\+\_\+t $>$ \&neighbors\+Out, arma\+::mat \&distances\+Out, const bool square\+Root=false)
\begin{DoxyCompactList}\small\item\em Assuming that the datasets have been mapped using the reference\+Map and the query\+Map (such as during kd-\/tree construction), unmap the columns of the distances and neighbors matrices into neighbors\+Out and distances\+Out, and also unmap the entries in each row of neighbors. \end{DoxyCompactList}\item 
void {\bf Unmap} (const arma\+::\+Mat$<$ size\+\_\+t $>$ \&neighbors, const arma\+::mat \&distances, const std\+::vector$<$ size\+\_\+t $>$ \&reference\+Map, arma\+::\+Mat$<$ size\+\_\+t $>$ \&neighbors\+Out, arma\+::mat \&distances\+Out, const bool square\+Root=false)
\begin{DoxyCompactList}\small\item\em Assuming that the datasets have been mapped using reference\+Map (such as during kd-\/tree construction), unmap the columns of the distances and neighbors matrices into neighbors\+Out and distances\+Out, and also unmap the entries in each row of neighbors. \end{DoxyCompactList}\end{DoxyCompactItemize}


\subsection{Detailed Description}
Neighbor-\/search routines. 

These include all-\/nearest-\/neighbors and all-\/furthest-\/neighbors searches. 

\subsection{Typedef Documentation}
\index{mlpack\+::neighbor@{mlpack\+::neighbor}!Allk\+FN@{Allk\+FN}}
\index{Allk\+FN@{Allk\+FN}!mlpack\+::neighbor@{mlpack\+::neighbor}}
\subsubsection[{Allk\+FN}]{\setlength{\rightskip}{0pt plus 5cm}typedef {\bf Neighbor\+Search}$<${\bf Furthest\+Neighbor\+Sort}, {\bf metric\+::\+Euclidean\+Distance}$>$ {\bf mlpack\+::neighbor\+::\+Allk\+FN}}\label{namespacemlpack_1_1neighbor_a0934c373db9c668f7ab95b182181db22}
It returns L2 distances (Euclidean distances) for each of the k furthest neighbors. This typedef will be removed in mlpack 3.\+0.\+0; use the K\+FN typedef instead. 

Definition at line 83 of file typedef.\+hpp.

\index{mlpack\+::neighbor@{mlpack\+::neighbor}!Allk\+NN@{Allk\+NN}}
\index{Allk\+NN@{Allk\+NN}!mlpack\+::neighbor@{mlpack\+::neighbor}}
\subsubsection[{Allk\+NN}]{\setlength{\rightskip}{0pt plus 5cm}typedef {\bf Neighbor\+Search}$<${\bf Nearest\+Neighbor\+Sort}, {\bf metric\+::\+Euclidean\+Distance}$>$ {\bf mlpack\+::neighbor\+::\+Allk\+NN}}\label{namespacemlpack_1_1neighbor_af730c334b56efb655152c975a3e15ace}
It returns L2 distances (Euclidean distances) for each of the k nearest neighbors. This typedef will be removed in mlpack 3.\+0.\+0; use the K\+NN typedef instead. 

Definition at line 75 of file typedef.\+hpp.

\index{mlpack\+::neighbor@{mlpack\+::neighbor}!Allk\+R\+A\+FN@{Allk\+R\+A\+FN}}
\index{Allk\+R\+A\+FN@{Allk\+R\+A\+FN}!mlpack\+::neighbor@{mlpack\+::neighbor}}
\subsubsection[{Allk\+R\+A\+FN}]{\setlength{\rightskip}{0pt plus 5cm}typedef {\bf R\+A\+Search} {\bf mlpack\+::neighbor\+::\+Allk\+R\+A\+FN}}\label{namespacemlpack_1_1neighbor_a4c42857e9f11644bc3283a348c82763b}
It returns L2 distances for each of the k rank-\/approximate farthest-\/neighbors.

The approximation is controlled with two parameters (see allkrann\+\_\+main.\+cpp) which can be specified at search time. So the tree building is done only once while the search can be performed multiple times with different approximation levels.

This typedef will be removed in mlpack 3.\+0.\+0; use the K\+R\+A\+NN typedef instead. 

Definition at line 76 of file ra\+\_\+typedef.\+hpp.

\index{mlpack\+::neighbor@{mlpack\+::neighbor}!Allk\+R\+A\+NN@{Allk\+R\+A\+NN}}
\index{Allk\+R\+A\+NN@{Allk\+R\+A\+NN}!mlpack\+::neighbor@{mlpack\+::neighbor}}
\subsubsection[{Allk\+R\+A\+NN}]{\setlength{\rightskip}{0pt plus 5cm}typedef {\bf R\+A\+Search} {\bf mlpack\+::neighbor\+::\+Allk\+R\+A\+NN}}\label{namespacemlpack_1_1neighbor_a1d10ceee8731e0d5712ffbc7307f0d0d}
It returns L2 distances for each of the k rank-\/approximate nearest-\/neighbors.

The approximation is controlled with two parameters (see allkrann\+\_\+main.\+cpp) which can be specified at search time. So the tree building is done only once while the search can be performed multiple times with different approximation levels.

This typedef will be removed in mlpack 3.\+0.\+0; use the K\+R\+A\+NN typedef instead. 

Definition at line 61 of file ra\+\_\+typedef.\+hpp.

\index{mlpack\+::neighbor@{mlpack\+::neighbor}!Defeatist\+K\+NN@{Defeatist\+K\+NN}}
\index{Defeatist\+K\+NN@{Defeatist\+K\+NN}!mlpack\+::neighbor@{mlpack\+::neighbor}}
\subsubsection[{Defeatist\+K\+NN}]{\setlength{\rightskip}{0pt plus 5cm}template$<$template$<$ typename Tree\+Metric\+Type, typename Tree\+Stat\+Type, typename Tree\+Mat\+Type $>$ class Tree\+Type = tree\+::\+S\+P\+Tree$>$ using {\bf mlpack\+::neighbor\+::\+Defeatist\+K\+NN} = typedef {\bf Neighbor\+Search}$<$ {\bf Nearest\+Neighbor\+Sort}, {\bf metric\+::\+Euclidean\+Distance}, arma\+::mat, Tree\+Type, Tree\+Type$<${\bf metric\+::\+Euclidean\+Distance}, {\bf Neighbor\+Search\+Stat}$<${\bf Nearest\+Neighbor\+Sort}$>$, arma\+::mat$>$\+::template Defeatist\+Dual\+Tree\+Traverser, Tree\+Type$<${\bf metric\+::\+Euclidean\+Distance}, {\bf Neighbor\+Search\+Stat}$<${\bf Nearest\+Neighbor\+Sort}$>$, arma\+::mat$>$\+::template Defeatist\+Single\+Tree\+Traverser$>$}\label{namespacemlpack_1_1neighbor_ab46efa07696c7afeca0cfd09d08864ee}


The Defeatist\+K\+NN class is the k-\/nearest-\/neighbors method considering defeatist search. 

It returns L2 distances (Euclidean distances) for each of the k nearest neighbors found. 
\begin{DoxyTemplParams}{Template Parameters}
{\em Tree\+Type} & The tree type to use; must adhere to the Tree\+Type A\+PI, and implement Defeatist Traversers. \\
\hline
\end{DoxyTemplParams}


Definition at line 60 of file typedef.\+hpp.

\index{mlpack\+::neighbor@{mlpack\+::neighbor}!K\+FN@{K\+FN}}
\index{K\+FN@{K\+FN}!mlpack\+::neighbor@{mlpack\+::neighbor}}
\subsubsection[{K\+FN}]{\setlength{\rightskip}{0pt plus 5cm}typedef {\bf Neighbor\+Search}$<${\bf Furthest\+Neighbor\+Sort}, {\bf metric\+::\+Euclidean\+Distance}$>$ {\bf mlpack\+::neighbor\+::\+K\+FN}}\label{namespacemlpack_1_1neighbor_ad4e1ff28336994a46a680b750edaf814}


The K\+FN class is the k-\/furthest-\/neighbors method. 

It returns L2 distances (Euclidean distances) for each of the k furthest neighbors. 

Definition at line 38 of file typedef.\+hpp.

\index{mlpack\+::neighbor@{mlpack\+::neighbor}!K\+NN@{K\+NN}}
\index{K\+NN@{K\+NN}!mlpack\+::neighbor@{mlpack\+::neighbor}}
\subsubsection[{K\+NN}]{\setlength{\rightskip}{0pt plus 5cm}typedef {\bf Neighbor\+Search}$<${\bf Nearest\+Neighbor\+Sort}, {\bf metric\+::\+Euclidean\+Distance}$>$ {\bf mlpack\+::neighbor\+::\+K\+NN}}\label{namespacemlpack_1_1neighbor_aca865b778e506f60fd3bbcf2f34672e5}


The K\+NN class is the k-\/nearest-\/neighbors method. 

It returns L2 distances (Euclidean distances) for each of the k nearest neighbors. 

Definition at line 32 of file typedef.\+hpp.

\index{mlpack\+::neighbor@{mlpack\+::neighbor}!K\+R\+A\+FN@{K\+R\+A\+FN}}
\index{K\+R\+A\+FN@{K\+R\+A\+FN}!mlpack\+::neighbor@{mlpack\+::neighbor}}
\subsubsection[{K\+R\+A\+FN}]{\setlength{\rightskip}{0pt plus 5cm}typedef {\bf R\+A\+Search}$<${\bf Furthest\+Neighbor\+Sort}$>$ {\bf mlpack\+::neighbor\+::\+K\+R\+A\+FN}}\label{namespacemlpack_1_1neighbor_ad0e4cc227121f46981eef5a39d566dc7}


The K\+R\+A\+FN class is the k-\/rank-\/approximate-\/farthest-\/neighbors method. 

It returns L2 distances for each of the k rank-\/approximate farthest-\/neighbors.

The approximation is controlled with two parameters (see allkrann\+\_\+main.\+cpp) which can be specified at search time. So the tree building is done only once while the search can be performed multiple times with different approximation levels. 

Definition at line 47 of file ra\+\_\+typedef.\+hpp.

\index{mlpack\+::neighbor@{mlpack\+::neighbor}!K\+R\+A\+NN@{K\+R\+A\+NN}}
\index{K\+R\+A\+NN@{K\+R\+A\+NN}!mlpack\+::neighbor@{mlpack\+::neighbor}}
\subsubsection[{K\+R\+A\+NN}]{\setlength{\rightskip}{0pt plus 5cm}typedef {\bf R\+A\+Search} {\bf mlpack\+::neighbor\+::\+K\+R\+A\+NN}}\label{namespacemlpack_1_1neighbor_a20061d60da6692023b5a30ec5384463b}


The K\+R\+A\+NN class is the k-\/rank-\/approximate-\/nearest-\/neighbors method. 

It returns L2 distances for each of the k rank-\/approximate nearest-\/neighbors.

The approximation is controlled with two parameters (see allkrann\+\_\+main.\+cpp) which can be specified at search time. So the tree building is done only once while the search can be performed multiple times with different approximation levels. 

Definition at line 36 of file ra\+\_\+typedef.\+hpp.

\index{mlpack\+::neighbor@{mlpack\+::neighbor}!N\+S\+Type@{N\+S\+Type}}
\index{N\+S\+Type@{N\+S\+Type}!mlpack\+::neighbor@{mlpack\+::neighbor}}
\subsubsection[{N\+S\+Type}]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename Sort\+Policy , template$<$ typename Tree\+Metric\+Type, typename Tree\+Stat\+Type, typename Tree\+Mat\+Type $>$ class Tree\+Type$>$ using {\bf mlpack\+::neighbor\+::\+N\+S\+Type} = typedef {\bf Neighbor\+Search}$<$Sort\+Policy, {\bf metric\+::\+Euclidean\+Distance}, arma\+::mat, Tree\+Type, Tree\+Type$<${\bf metric\+::\+Euclidean\+Distance}, {\bf Neighbor\+Search\+Stat}$<$Sort\+Policy$>$, arma\+::mat$>$\+::template Dual\+Tree\+Traverser$>$}\label{namespacemlpack_1_1neighbor_a00f8d5f4713b164a0f856ebe82b00b6e}


Alias template for euclidean neighbor search. 



Definition at line 42 of file ns\+\_\+model.\+hpp.

\index{mlpack\+::neighbor@{mlpack\+::neighbor}!Spill\+K\+NN@{Spill\+K\+NN}}
\index{Spill\+K\+NN@{Spill\+K\+NN}!mlpack\+::neighbor@{mlpack\+::neighbor}}
\subsubsection[{Spill\+K\+NN}]{\setlength{\rightskip}{0pt plus 5cm}typedef {\bf Defeatist\+K\+NN}$<${\bf tree\+::\+S\+P\+Tree}$>$ {\bf mlpack\+::neighbor\+::\+Spill\+K\+NN}}\label{namespacemlpack_1_1neighbor_ae946f106083dcd4d51010329df0ccc90}


The Spill\+K\+NN class is the k-\/nearest-\/neighbors method considering defeatist search on S\+P\+Tree. 

It returns L2 distances (Euclidean distances) for each of the k nearest neighbors found. 

Definition at line 67 of file typedef.\+hpp.



\subsection{Enumeration Type Documentation}
\index{mlpack\+::neighbor@{mlpack\+::neighbor}!Neighbor\+Search\+Mode@{Neighbor\+Search\+Mode}}
\index{Neighbor\+Search\+Mode@{Neighbor\+Search\+Mode}!mlpack\+::neighbor@{mlpack\+::neighbor}}
\subsubsection[{Neighbor\+Search\+Mode}]{\setlength{\rightskip}{0pt plus 5cm}enum {\bf mlpack\+::neighbor\+::\+Neighbor\+Search\+Mode}}\label{namespacemlpack_1_1neighbor_a77313e33f7e679dd62047c737e50be56}


Neighbor\+Search\+Mode represents the different neighbor search modes available. 

\begin{Desc}
\item[Enumerator]\par
\begin{description}
\index{N\+A\+I\+V\+E\+\_\+\+M\+O\+DE@{N\+A\+I\+V\+E\+\_\+\+M\+O\+DE}!mlpack\+::neighbor@{mlpack\+::neighbor}}\index{mlpack\+::neighbor@{mlpack\+::neighbor}!N\+A\+I\+V\+E\+\_\+\+M\+O\+DE@{N\+A\+I\+V\+E\+\_\+\+M\+O\+DE}}\item[{\em 
N\+A\+I\+V\+E\+\_\+\+M\+O\+DE\label{namespacemlpack_1_1neighbor_a77313e33f7e679dd62047c737e50be56a527cee74536f4be0526acc59bbe10be7}
}]\index{S\+I\+N\+G\+L\+E\+\_\+\+T\+R\+E\+E\+\_\+\+M\+O\+DE@{S\+I\+N\+G\+L\+E\+\_\+\+T\+R\+E\+E\+\_\+\+M\+O\+DE}!mlpack\+::neighbor@{mlpack\+::neighbor}}\index{mlpack\+::neighbor@{mlpack\+::neighbor}!S\+I\+N\+G\+L\+E\+\_\+\+T\+R\+E\+E\+\_\+\+M\+O\+DE@{S\+I\+N\+G\+L\+E\+\_\+\+T\+R\+E\+E\+\_\+\+M\+O\+DE}}\item[{\em 
S\+I\+N\+G\+L\+E\+\_\+\+T\+R\+E\+E\+\_\+\+M\+O\+DE\label{namespacemlpack_1_1neighbor_a77313e33f7e679dd62047c737e50be56afee89338d05b0dbb1190cc13652b19e0}
}]\index{D\+U\+A\+L\+\_\+\+T\+R\+E\+E\+\_\+\+M\+O\+DE@{D\+U\+A\+L\+\_\+\+T\+R\+E\+E\+\_\+\+M\+O\+DE}!mlpack\+::neighbor@{mlpack\+::neighbor}}\index{mlpack\+::neighbor@{mlpack\+::neighbor}!D\+U\+A\+L\+\_\+\+T\+R\+E\+E\+\_\+\+M\+O\+DE@{D\+U\+A\+L\+\_\+\+T\+R\+E\+E\+\_\+\+M\+O\+DE}}\item[{\em 
D\+U\+A\+L\+\_\+\+T\+R\+E\+E\+\_\+\+M\+O\+DE\label{namespacemlpack_1_1neighbor_a77313e33f7e679dd62047c737e50be56ac74cfb269c1ee9c3a28afda6f1843d58}
}]\index{G\+R\+E\+E\+D\+Y\+\_\+\+S\+I\+N\+G\+L\+E\+\_\+\+T\+R\+E\+E\+\_\+\+M\+O\+DE@{G\+R\+E\+E\+D\+Y\+\_\+\+S\+I\+N\+G\+L\+E\+\_\+\+T\+R\+E\+E\+\_\+\+M\+O\+DE}!mlpack\+::neighbor@{mlpack\+::neighbor}}\index{mlpack\+::neighbor@{mlpack\+::neighbor}!G\+R\+E\+E\+D\+Y\+\_\+\+S\+I\+N\+G\+L\+E\+\_\+\+T\+R\+E\+E\+\_\+\+M\+O\+DE@{G\+R\+E\+E\+D\+Y\+\_\+\+S\+I\+N\+G\+L\+E\+\_\+\+T\+R\+E\+E\+\_\+\+M\+O\+DE}}\item[{\em 
G\+R\+E\+E\+D\+Y\+\_\+\+S\+I\+N\+G\+L\+E\+\_\+\+T\+R\+E\+E\+\_\+\+M\+O\+DE\label{namespacemlpack_1_1neighbor_a77313e33f7e679dd62047c737e50be56aaf75a4f7e90922e55a796c79bd8a104b}
}]\end{description}
\end{Desc}


Definition at line 38 of file neighbor\+\_\+search.\+hpp.



\subsection{Function Documentation}
\index{mlpack\+::neighbor@{mlpack\+::neighbor}!Unmap@{Unmap}}
\index{Unmap@{Unmap}!mlpack\+::neighbor@{mlpack\+::neighbor}}
\subsubsection[{Unmap(const arma\+::\+Mat$<$ size\+\_\+t $>$ \&neighbors, const arma\+::mat \&distances, const std\+::vector$<$ size\+\_\+t $>$ \&reference\+Map, const std\+::vector$<$ size\+\_\+t $>$ \&query\+Map, arma\+::\+Mat$<$ size\+\_\+t $>$ \&neighbors\+Out, arma\+::mat \&distances\+Out, const bool square\+Root=false)}]{\setlength{\rightskip}{0pt plus 5cm}void mlpack\+::neighbor\+::\+Unmap (
\begin{DoxyParamCaption}
\item[{const arma\+::\+Mat$<$ size\+\_\+t $>$ \&}]{neighbors, }
\item[{const arma\+::mat \&}]{distances, }
\item[{const std\+::vector$<$ size\+\_\+t $>$ \&}]{reference\+Map, }
\item[{const std\+::vector$<$ size\+\_\+t $>$ \&}]{query\+Map, }
\item[{arma\+::\+Mat$<$ size\+\_\+t $>$ \&}]{neighbors\+Out, }
\item[{arma\+::mat \&}]{distances\+Out, }
\item[{const bool}]{square\+Root = {\ttfamily false}}
\end{DoxyParamCaption}
)}\label{namespacemlpack_1_1neighbor_a841bafc12b36517208ff283b095dec2f}


Assuming that the datasets have been mapped using the reference\+Map and the query\+Map (such as during kd-\/tree construction), unmap the columns of the distances and neighbors matrices into neighbors\+Out and distances\+Out, and also unmap the entries in each row of neighbors. 

This is useful for the dual-\/tree case.


\begin{DoxyParams}{Parameters}
{\em neighbors} & Matrix of neighbors resulting from neighbor search. \\
\hline
{\em distances} & Matrix of distances resulting from neighbor search. \\
\hline
{\em reference\+Map} & Mapping of reference set to old points. \\
\hline
{\em query\+Map} & Mapping of query set to old points. \\
\hline
{\em neighbors\+Out} & Matrix to store unmapped neighbors into. \\
\hline
{\em distances\+Out} & Matrix to store unmapped distances into. \\
\hline
{\em square\+Root} & If true, take the square root of the distances. \\
\hline
\end{DoxyParams}
\index{mlpack\+::neighbor@{mlpack\+::neighbor}!Unmap@{Unmap}}
\index{Unmap@{Unmap}!mlpack\+::neighbor@{mlpack\+::neighbor}}
\subsubsection[{Unmap(const arma\+::\+Mat$<$ size\+\_\+t $>$ \&neighbors, const arma\+::mat \&distances, const std\+::vector$<$ size\+\_\+t $>$ \&reference\+Map, arma\+::\+Mat$<$ size\+\_\+t $>$ \&neighbors\+Out, arma\+::mat \&distances\+Out, const bool square\+Root=false)}]{\setlength{\rightskip}{0pt plus 5cm}void mlpack\+::neighbor\+::\+Unmap (
\begin{DoxyParamCaption}
\item[{const arma\+::\+Mat$<$ size\+\_\+t $>$ \&}]{neighbors, }
\item[{const arma\+::mat \&}]{distances, }
\item[{const std\+::vector$<$ size\+\_\+t $>$ \&}]{reference\+Map, }
\item[{arma\+::\+Mat$<$ size\+\_\+t $>$ \&}]{neighbors\+Out, }
\item[{arma\+::mat \&}]{distances\+Out, }
\item[{const bool}]{square\+Root = {\ttfamily false}}
\end{DoxyParamCaption}
)}\label{namespacemlpack_1_1neighbor_acc225558031fe27e3336544c50dd642d}


Assuming that the datasets have been mapped using reference\+Map (such as during kd-\/tree construction), unmap the columns of the distances and neighbors matrices into neighbors\+Out and distances\+Out, and also unmap the entries in each row of neighbors. 

This is useful for the single-\/tree case.


\begin{DoxyParams}{Parameters}
{\em neighbors} & Matrix of neighbors resulting from neighbor search. \\
\hline
{\em distances} & Matrix of distances resulting from neighbor search. \\
\hline
{\em reference\+Map} & Mapping of reference set to old points. \\
\hline
{\em neighbors\+Out} & Matrix to store unmapped neighbors into. \\
\hline
{\em distances\+Out} & Matrix to store unmapped distances into. \\
\hline
{\em square\+Root} & If true, take the square root of the distances. \\
\hline
\end{DoxyParams}
