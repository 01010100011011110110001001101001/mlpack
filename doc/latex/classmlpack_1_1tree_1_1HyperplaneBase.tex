\section{mlpack\+:\+:tree\+:\+:Hyperplane\+Base$<$ BoundT, Proj\+VectorT $>$ Class Template Reference}
\label{classmlpack_1_1tree_1_1HyperplaneBase}\index{mlpack\+::tree\+::\+Hyperplane\+Base$<$ Bound\+T, Proj\+Vector\+T $>$@{mlpack\+::tree\+::\+Hyperplane\+Base$<$ Bound\+T, Proj\+Vector\+T $>$}}


\doxyref{Hyperplane\+Base}{p.}{classmlpack_1_1tree_1_1HyperplaneBase} defines a splitting hyperplane based on a projection vector and projection value.  


\subsection*{Public Types}
\begin{DoxyCompactItemize}
\item 
typedef BoundT {\bf Bound\+Type}
\begin{DoxyCompactList}\small\item\em Useful typedef for the bound type. \end{DoxyCompactList}\item 
typedef Proj\+VectorT {\bf Proj\+Vector\+Type}
\begin{DoxyCompactList}\small\item\em Useful typedef for the projection vector type. \end{DoxyCompactList}\end{DoxyCompactItemize}
\subsection*{Public Member Functions}
\begin{DoxyCompactItemize}
\item 
{\bf Hyperplane\+Base} ()
\begin{DoxyCompactList}\small\item\em Empty Constructor. \end{DoxyCompactList}\item 
{\bf Hyperplane\+Base} (const {\bf Proj\+Vector\+Type} \&{\bf proj\+Vect}, double {\bf split\+Val})
\begin{DoxyCompactList}\small\item\em Create the hyperplane with the specified projection vector and split value. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename Vec\+Type $>$ }\\bool {\bf Left} (const Vec\+Type \&point, typename {\bf std\+::enable\+\_\+if\+\_\+t}$<$ {\bf Is\+Vector}$<$ Vec\+Type $>$\+::value $>$ $\ast$=0) const 
\begin{DoxyCompactList}\small\item\em Determine if the given point is to the left of the hyperplane, this means if the projection over the projection vector is negative or zero. \end{DoxyCompactList}\item 
bool {\bf Left} (const {\bf Bound\+Type} \&bound) const 
\begin{DoxyCompactList}\small\item\em Determine if the given bound is to the left of the hyperplane. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename Vec\+Type $>$ }\\double {\bf Project} (const Vec\+Type \&point, typename {\bf std\+::enable\+\_\+if\+\_\+t}$<$ {\bf Is\+Vector}$<$ Vec\+Type $>$\+::value $>$ $\ast$=0) const 
\begin{DoxyCompactList}\small\item\em Project the given point on the projection vector and subtract the split value. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename Vec\+Type $>$ }\\bool {\bf Right} (const Vec\+Type \&point, typename {\bf std\+::enable\+\_\+if\+\_\+t}$<$ {\bf Is\+Vector}$<$ Vec\+Type $>$\+::value $>$ $\ast$=0) const 
\begin{DoxyCompactList}\small\item\em Determine if the given point is to the right of the hyperplane, this means if the projection over the projection vector is positive. \end{DoxyCompactList}\item 
bool {\bf Right} (const {\bf Bound\+Type} \&bound) const 
\begin{DoxyCompactList}\small\item\em Determine if the given bound is to the right of the hyperplane. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename Archive $>$ }\\void {\bf Serialize} (Archive \&ar, const unsigned int)
\begin{DoxyCompactList}\small\item\em Serialization. \end{DoxyCompactList}\end{DoxyCompactItemize}
\subsection*{Private Attributes}
\begin{DoxyCompactItemize}
\item 
{\bf Proj\+Vector\+Type} {\bf proj\+Vect}
\begin{DoxyCompactList}\small\item\em Projection vector. \end{DoxyCompactList}\item 
double {\bf split\+Val}
\begin{DoxyCompactList}\small\item\em Projection value that determines the decision boundary. \end{DoxyCompactList}\end{DoxyCompactItemize}


\subsection{Detailed Description}
\subsubsection*{template$<$typename BoundT, typename Proj\+VectorT$>$\\*
class mlpack\+::tree\+::\+Hyperplane\+Base$<$ Bound\+T, Proj\+Vector\+T $>$}

\doxyref{Hyperplane\+Base}{p.}{classmlpack_1_1tree_1_1HyperplaneBase} defines a splitting hyperplane based on a projection vector and projection value. 


\begin{DoxyTemplParams}{Template Parameters}
{\em BoundT} & The bound type considered. \\
\hline
{\em Proj\+VectorT} & Type of projection vector (\doxyref{Axis\+Parallel\+Proj\+Vector}{p.}{classmlpack_1_1tree_1_1AxisParallelProjVector}, \doxyref{Proj\+Vector}{p.}{classmlpack_1_1tree_1_1ProjVector}). \\
\hline
\end{DoxyTemplParams}


Definition at line 30 of file hyperplane.\+hpp.



\subsection{Member Typedef Documentation}
\index{mlpack\+::tree\+::\+Hyperplane\+Base@{mlpack\+::tree\+::\+Hyperplane\+Base}!Bound\+Type@{Bound\+Type}}
\index{Bound\+Type@{Bound\+Type}!mlpack\+::tree\+::\+Hyperplane\+Base@{mlpack\+::tree\+::\+Hyperplane\+Base}}
\subsubsection[{Bound\+Type}]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename BoundT, typename Proj\+VectorT$>$ typedef BoundT {\bf mlpack\+::tree\+::\+Hyperplane\+Base}$<$ BoundT, Proj\+VectorT $>$\+::{\bf Bound\+Type}}\label{classmlpack_1_1tree_1_1HyperplaneBase_a08d68580ca801322e87e7ae72eaed307}


Useful typedef for the bound type. 



Definition at line 34 of file hyperplane.\+hpp.

\index{mlpack\+::tree\+::\+Hyperplane\+Base@{mlpack\+::tree\+::\+Hyperplane\+Base}!Proj\+Vector\+Type@{Proj\+Vector\+Type}}
\index{Proj\+Vector\+Type@{Proj\+Vector\+Type}!mlpack\+::tree\+::\+Hyperplane\+Base@{mlpack\+::tree\+::\+Hyperplane\+Base}}
\subsubsection[{Proj\+Vector\+Type}]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename BoundT, typename Proj\+VectorT$>$ typedef Proj\+VectorT {\bf mlpack\+::tree\+::\+Hyperplane\+Base}$<$ BoundT, Proj\+VectorT $>$\+::{\bf Proj\+Vector\+Type}}\label{classmlpack_1_1tree_1_1HyperplaneBase_a053c5e0ff7f7d8dc36b486ff5339b1e0}


Useful typedef for the projection vector type. 



Definition at line 36 of file hyperplane.\+hpp.



\subsection{Constructor \& Destructor Documentation}
\index{mlpack\+::tree\+::\+Hyperplane\+Base@{mlpack\+::tree\+::\+Hyperplane\+Base}!Hyperplane\+Base@{Hyperplane\+Base}}
\index{Hyperplane\+Base@{Hyperplane\+Base}!mlpack\+::tree\+::\+Hyperplane\+Base@{mlpack\+::tree\+::\+Hyperplane\+Base}}
\subsubsection[{Hyperplane\+Base()}]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename BoundT, typename Proj\+VectorT$>$ {\bf mlpack\+::tree\+::\+Hyperplane\+Base}$<$ BoundT, Proj\+VectorT $>$\+::{\bf Hyperplane\+Base} (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}}\label{classmlpack_1_1tree_1_1HyperplaneBase_aadc6b448bd30a6602dc1ab795d2615c6}


Empty Constructor. 

By default will consider all points to the left. 

Definition at line 49 of file hyperplane.\+hpp.

\index{mlpack\+::tree\+::\+Hyperplane\+Base@{mlpack\+::tree\+::\+Hyperplane\+Base}!Hyperplane\+Base@{Hyperplane\+Base}}
\index{Hyperplane\+Base@{Hyperplane\+Base}!mlpack\+::tree\+::\+Hyperplane\+Base@{mlpack\+::tree\+::\+Hyperplane\+Base}}
\subsubsection[{Hyperplane\+Base(const Proj\+Vector\+Type \&proj\+Vect, double split\+Val)}]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename BoundT, typename Proj\+VectorT$>$ {\bf mlpack\+::tree\+::\+Hyperplane\+Base}$<$ BoundT, Proj\+VectorT $>$\+::{\bf Hyperplane\+Base} (
\begin{DoxyParamCaption}
\item[{const {\bf Proj\+Vector\+Type} \&}]{proj\+Vect, }
\item[{double}]{split\+Val}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}}\label{classmlpack_1_1tree_1_1HyperplaneBase_a410a59dd63d8425fcb17b07ef520c025}


Create the hyperplane with the specified projection vector and split value. 


\begin{DoxyParams}{Parameters}
{\em proj\+Vect} & Projection vector. \\
\hline
{\em split\+Val} & Split value. \\
\hline
\end{DoxyParams}


Definition at line 59 of file hyperplane.\+hpp.



\subsection{Member Function Documentation}
\index{mlpack\+::tree\+::\+Hyperplane\+Base@{mlpack\+::tree\+::\+Hyperplane\+Base}!Left@{Left}}
\index{Left@{Left}!mlpack\+::tree\+::\+Hyperplane\+Base@{mlpack\+::tree\+::\+Hyperplane\+Base}}
\subsubsection[{Left(const Vec\+Type \&point, typename std\+::enable\+\_\+if\+\_\+t$<$ Is\+Vector$<$ Vec\+Type $>$\+::value $>$ $\ast$=0) const }]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename BoundT, typename Proj\+VectorT$>$ template$<$typename Vec\+Type $>$ bool {\bf mlpack\+::tree\+::\+Hyperplane\+Base}$<$ BoundT, Proj\+VectorT $>$\+::Left (
\begin{DoxyParamCaption}
\item[{const Vec\+Type \&}]{point, }
\item[{typename {\bf std\+::enable\+\_\+if\+\_\+t}$<$ {\bf Is\+Vector}$<$ Vec\+Type $>$\+::value $>$ $\ast$}]{ = {\ttfamily 0}}
\end{DoxyParamCaption}
) const\hspace{0.3cm}{\ttfamily [inline]}}\label{classmlpack_1_1tree_1_1HyperplaneBase_ae3595e00a6ffa95d9d304b3af2bf45e5}


Determine if the given point is to the left of the hyperplane, this means if the projection over the projection vector is negative or zero. 


\begin{DoxyParams}{Parameters}
{\em point} & Point to be analyzed. \\
\hline
\end{DoxyParams}


Definition at line 86 of file hyperplane.\+hpp.



References mlpack\+::tree\+::\+Hyperplane\+Base$<$ Bound\+T, Proj\+Vector\+T $>$\+::\+Project().

\index{mlpack\+::tree\+::\+Hyperplane\+Base@{mlpack\+::tree\+::\+Hyperplane\+Base}!Left@{Left}}
\index{Left@{Left}!mlpack\+::tree\+::\+Hyperplane\+Base@{mlpack\+::tree\+::\+Hyperplane\+Base}}
\subsubsection[{Left(const Bound\+Type \&bound) const }]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename BoundT, typename Proj\+VectorT$>$ bool {\bf mlpack\+::tree\+::\+Hyperplane\+Base}$<$ BoundT, Proj\+VectorT $>$\+::Left (
\begin{DoxyParamCaption}
\item[{const {\bf Bound\+Type} \&}]{bound}
\end{DoxyParamCaption}
) const\hspace{0.3cm}{\ttfamily [inline]}}\label{classmlpack_1_1tree_1_1HyperplaneBase_a581e3bbd25a31c29f6cd993fa22646ce}


Determine if the given bound is to the left of the hyperplane. 


\begin{DoxyParams}{Parameters}
{\em point} & Bound to be analyzed. \\
\hline
\end{DoxyParams}


Definition at line 110 of file hyperplane.\+hpp.



References mlpack\+::tree\+::\+Hyperplane\+Base$<$ Bound\+T, Proj\+Vector\+T $>$\+::split\+Val.

\index{mlpack\+::tree\+::\+Hyperplane\+Base@{mlpack\+::tree\+::\+Hyperplane\+Base}!Project@{Project}}
\index{Project@{Project}!mlpack\+::tree\+::\+Hyperplane\+Base@{mlpack\+::tree\+::\+Hyperplane\+Base}}
\subsubsection[{Project(const Vec\+Type \&point, typename std\+::enable\+\_\+if\+\_\+t$<$ Is\+Vector$<$ Vec\+Type $>$\+::value $>$ $\ast$=0) const }]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename BoundT, typename Proj\+VectorT$>$ template$<$typename Vec\+Type $>$ double {\bf mlpack\+::tree\+::\+Hyperplane\+Base}$<$ BoundT, Proj\+VectorT $>$\+::Project (
\begin{DoxyParamCaption}
\item[{const Vec\+Type \&}]{point, }
\item[{typename {\bf std\+::enable\+\_\+if\+\_\+t}$<$ {\bf Is\+Vector}$<$ Vec\+Type $>$\+::value $>$ $\ast$}]{ = {\ttfamily 0}}
\end{DoxyParamCaption}
) const\hspace{0.3cm}{\ttfamily [inline]}}\label{classmlpack_1_1tree_1_1HyperplaneBase_a1f1dc81716597f6383a744cd9ee22ce8}


Project the given point on the projection vector and subtract the split value. 


\begin{DoxyParams}{Parameters}
{\em point} & Point to be projected. \\
\hline
\end{DoxyParams}


Definition at line 71 of file hyperplane.\+hpp.



References mlpack\+::tree\+::\+Hyperplane\+Base$<$ Bound\+T, Proj\+Vector\+T $>$\+::split\+Val.



Referenced by mlpack\+::tree\+::\+Hyperplane\+Base$<$ Bound\+T, Proj\+Vector\+T $>$\+::\+Left(), and mlpack\+::tree\+::\+Hyperplane\+Base$<$ Bound\+T, Proj\+Vector\+T $>$\+::\+Right().

\index{mlpack\+::tree\+::\+Hyperplane\+Base@{mlpack\+::tree\+::\+Hyperplane\+Base}!Right@{Right}}
\index{Right@{Right}!mlpack\+::tree\+::\+Hyperplane\+Base@{mlpack\+::tree\+::\+Hyperplane\+Base}}
\subsubsection[{Right(const Vec\+Type \&point, typename std\+::enable\+\_\+if\+\_\+t$<$ Is\+Vector$<$ Vec\+Type $>$\+::value $>$ $\ast$=0) const }]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename BoundT, typename Proj\+VectorT$>$ template$<$typename Vec\+Type $>$ bool {\bf mlpack\+::tree\+::\+Hyperplane\+Base}$<$ BoundT, Proj\+VectorT $>$\+::Right (
\begin{DoxyParamCaption}
\item[{const Vec\+Type \&}]{point, }
\item[{typename {\bf std\+::enable\+\_\+if\+\_\+t}$<$ {\bf Is\+Vector}$<$ Vec\+Type $>$\+::value $>$ $\ast$}]{ = {\ttfamily 0}}
\end{DoxyParamCaption}
) const\hspace{0.3cm}{\ttfamily [inline]}}\label{classmlpack_1_1tree_1_1HyperplaneBase_a4c0e448c2f74d5bf29c242916f477f22}


Determine if the given point is to the right of the hyperplane, this means if the projection over the projection vector is positive. 


\begin{DoxyParams}{Parameters}
{\em point} & Point to be analyzed. \\
\hline
\end{DoxyParams}


Definition at line 99 of file hyperplane.\+hpp.



References mlpack\+::tree\+::\+Hyperplane\+Base$<$ Bound\+T, Proj\+Vector\+T $>$\+::\+Project().

\index{mlpack\+::tree\+::\+Hyperplane\+Base@{mlpack\+::tree\+::\+Hyperplane\+Base}!Right@{Right}}
\index{Right@{Right}!mlpack\+::tree\+::\+Hyperplane\+Base@{mlpack\+::tree\+::\+Hyperplane\+Base}}
\subsubsection[{Right(const Bound\+Type \&bound) const }]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename BoundT, typename Proj\+VectorT$>$ bool {\bf mlpack\+::tree\+::\+Hyperplane\+Base}$<$ BoundT, Proj\+VectorT $>$\+::Right (
\begin{DoxyParamCaption}
\item[{const {\bf Bound\+Type} \&}]{bound}
\end{DoxyParamCaption}
) const\hspace{0.3cm}{\ttfamily [inline]}}\label{classmlpack_1_1tree_1_1HyperplaneBase_ae593147f7761697025bff5ccb2d2ca70}


Determine if the given bound is to the right of the hyperplane. 


\begin{DoxyParams}{Parameters}
{\em point} & Bound to be analyzed. \\
\hline
\end{DoxyParams}


Definition at line 122 of file hyperplane.\+hpp.



References mlpack\+::tree\+::\+Hyperplane\+Base$<$ Bound\+T, Proj\+Vector\+T $>$\+::split\+Val.

\index{mlpack\+::tree\+::\+Hyperplane\+Base@{mlpack\+::tree\+::\+Hyperplane\+Base}!Serialize@{Serialize}}
\index{Serialize@{Serialize}!mlpack\+::tree\+::\+Hyperplane\+Base@{mlpack\+::tree\+::\+Hyperplane\+Base}}
\subsubsection[{Serialize(\+Archive \&ar, const unsigned int)}]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename BoundT, typename Proj\+VectorT$>$ template$<$typename Archive $>$ void {\bf mlpack\+::tree\+::\+Hyperplane\+Base}$<$ BoundT, Proj\+VectorT $>$\+::Serialize (
\begin{DoxyParamCaption}
\item[{Archive \&}]{ar, }
\item[{const unsigned}]{int}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}}\label{classmlpack_1_1tree_1_1HyperplaneBase_a0087e07d4c971e2b6a5d283c0c28b95e}


Serialization. 



Definition at line 133 of file hyperplane.\+hpp.



References mlpack\+::data\+::\+Create\+N\+V\+P().



\subsection{Member Data Documentation}
\index{mlpack\+::tree\+::\+Hyperplane\+Base@{mlpack\+::tree\+::\+Hyperplane\+Base}!proj\+Vect@{proj\+Vect}}
\index{proj\+Vect@{proj\+Vect}!mlpack\+::tree\+::\+Hyperplane\+Base@{mlpack\+::tree\+::\+Hyperplane\+Base}}
\subsubsection[{proj\+Vect}]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename BoundT, typename Proj\+VectorT$>$ {\bf Proj\+Vector\+Type} {\bf mlpack\+::tree\+::\+Hyperplane\+Base}$<$ BoundT, Proj\+VectorT $>$\+::proj\+Vect\hspace{0.3cm}{\ttfamily [private]}}\label{classmlpack_1_1tree_1_1HyperplaneBase_ad2421ab2d6df1d92e1fe6fecf93f7151}


Projection vector. 



Definition at line 40 of file hyperplane.\+hpp.

\index{mlpack\+::tree\+::\+Hyperplane\+Base@{mlpack\+::tree\+::\+Hyperplane\+Base}!split\+Val@{split\+Val}}
\index{split\+Val@{split\+Val}!mlpack\+::tree\+::\+Hyperplane\+Base@{mlpack\+::tree\+::\+Hyperplane\+Base}}
\subsubsection[{split\+Val}]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename BoundT, typename Proj\+VectorT$>$ double {\bf mlpack\+::tree\+::\+Hyperplane\+Base}$<$ BoundT, Proj\+VectorT $>$\+::split\+Val\hspace{0.3cm}{\ttfamily [private]}}\label{classmlpack_1_1tree_1_1HyperplaneBase_a4f7af864d49d364b7315455f1cd26caa}


Projection value that determines the decision boundary. 



Definition at line 43 of file hyperplane.\+hpp.



Referenced by mlpack\+::tree\+::\+Hyperplane\+Base$<$ Bound\+T, Proj\+Vector\+T $>$\+::\+Left(), mlpack\+::tree\+::\+Hyperplane\+Base$<$ Bound\+T, Proj\+Vector\+T $>$\+::\+Project(), and mlpack\+::tree\+::\+Hyperplane\+Base$<$ Bound\+T, Proj\+Vector\+T $>$\+::\+Right().



The documentation for this class was generated from the following file\+:\begin{DoxyCompactItemize}
\item 
src/mlpack/core/tree/space\+\_\+split/{\bf hyperplane.\+hpp}\end{DoxyCompactItemize}
