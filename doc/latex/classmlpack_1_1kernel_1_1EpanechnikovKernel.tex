\section{mlpack\+:\+:kernel\+:\+:Epanechnikov\+Kernel Class Reference}
\label{classmlpack_1_1kernel_1_1EpanechnikovKernel}\index{mlpack\+::kernel\+::\+Epanechnikov\+Kernel@{mlpack\+::kernel\+::\+Epanechnikov\+Kernel}}


The Epanechnikov kernel, defined as.  


\subsection*{Public Member Functions}
\begin{DoxyCompactItemize}
\item 
{\bf Epanechnikov\+Kernel} (const double {\bf bandwidth}=1.\+0)
\begin{DoxyCompactList}\small\item\em Instantiate the Epanechnikov kernel with the given bandwidth (default 1.\+0). \end{DoxyCompactList}\item 
{\footnotesize template$<$typename Vec\+TypeA , typename Vec\+TypeB $>$ }\\double {\bf Convolution\+Integral} (const Vec\+TypeA \&a, const Vec\+TypeB \&b)
\begin{DoxyCompactList}\small\item\em Obtains the convolution integral [integral of K($\vert$$\vert$x-\/a$\vert$$\vert$) K($\vert$$\vert$b-\/x$\vert$$\vert$) dx] for the two vectors. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename Vec\+TypeA , typename Vec\+TypeB $>$ }\\double {\bf Evaluate} (const Vec\+TypeA \&a, const Vec\+TypeB \&b) const 
\begin{DoxyCompactList}\small\item\em Evaluate the Epanechnikov kernel on the given two inputs. \end{DoxyCompactList}\item 
double {\bf Evaluate} (const double distance) const 
\begin{DoxyCompactList}\small\item\em Evaluate the Epanechnikov kernel given that the distance between the two input points is known. \end{DoxyCompactList}\item 
double {\bf Gradient} (const double distance) const 
\begin{DoxyCompactList}\small\item\em Evaluate the Gradient of Epanechnikov kernel given that the distance between the two input points is known. \end{DoxyCompactList}\item 
double {\bf Gradient\+For\+Squared\+Distance} (const double distance\+Squared) const 
\begin{DoxyCompactList}\small\item\em Evaluate the Gradient of Epanechnikov kernel given that the squared distance between the two input points is known. \end{DoxyCompactList}\item 
double {\bf Normalizer} (const size\+\_\+t dimension)
\begin{DoxyCompactList}\small\item\em Compute the normalizer of this Epanechnikov kernel for the given dimension. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename Archive $>$ }\\void {\bf Serialize} (Archive \&ar, const unsigned int version)
\begin{DoxyCompactList}\small\item\em Serialize the kernel. \end{DoxyCompactList}\end{DoxyCompactItemize}
\subsection*{Private Attributes}
\begin{DoxyCompactItemize}
\item 
double {\bf bandwidth}
\begin{DoxyCompactList}\small\item\em Bandwidth of the kernel. \end{DoxyCompactList}\item 
double {\bf inverse\+Bandwidth\+Squared}
\begin{DoxyCompactList}\small\item\em Cached value of the inverse bandwidth squared (to speed up computation). \end{DoxyCompactList}\end{DoxyCompactItemize}


\subsection{Detailed Description}
The Epanechnikov kernel, defined as. 

\[ K(x, y) = \max \{0, 1 - || x - y ||^2_2 / b^2 \} \]

where $ b $ is the bandwidth the of the kernel (defaults to 1.\+0). 

Definition at line 30 of file epanechnikov\+\_\+kernel.\+hpp.



\subsection{Constructor \& Destructor Documentation}
\index{mlpack\+::kernel\+::\+Epanechnikov\+Kernel@{mlpack\+::kernel\+::\+Epanechnikov\+Kernel}!Epanechnikov\+Kernel@{Epanechnikov\+Kernel}}
\index{Epanechnikov\+Kernel@{Epanechnikov\+Kernel}!mlpack\+::kernel\+::\+Epanechnikov\+Kernel@{mlpack\+::kernel\+::\+Epanechnikov\+Kernel}}
\subsubsection[{Epanechnikov\+Kernel(const double bandwidth=1.\+0)}]{\setlength{\rightskip}{0pt plus 5cm}mlpack\+::kernel\+::\+Epanechnikov\+Kernel\+::\+Epanechnikov\+Kernel (
\begin{DoxyParamCaption}
\item[{const double}]{bandwidth = {\ttfamily 1.0}}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}}\label{classmlpack_1_1kernel_1_1EpanechnikovKernel_a4b00b7576beafba34b0124b191a0f6ea}


Instantiate the Epanechnikov kernel with the given bandwidth (default 1.\+0). 


\begin{DoxyParams}{Parameters}
{\em bandwidth} & Bandwidth of the kernel. \\
\hline
\end{DoxyParams}


Definition at line 38 of file epanechnikov\+\_\+kernel.\+hpp.



References Convolution\+Integral(), Evaluate(), Gradient(), Gradient\+For\+Squared\+Distance(), Normalizer(), and Serialize().



\subsection{Member Function Documentation}
\index{mlpack\+::kernel\+::\+Epanechnikov\+Kernel@{mlpack\+::kernel\+::\+Epanechnikov\+Kernel}!Convolution\+Integral@{Convolution\+Integral}}
\index{Convolution\+Integral@{Convolution\+Integral}!mlpack\+::kernel\+::\+Epanechnikov\+Kernel@{mlpack\+::kernel\+::\+Epanechnikov\+Kernel}}
\subsubsection[{Convolution\+Integral(const Vec\+Type\+A \&a, const Vec\+Type\+B \&b)}]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename Vec\+TypeA , typename Vec\+TypeB $>$ double mlpack\+::kernel\+::\+Epanechnikov\+Kernel\+::\+Convolution\+Integral (
\begin{DoxyParamCaption}
\item[{const Vec\+TypeA \&}]{a, }
\item[{const Vec\+TypeB \&}]{b}
\end{DoxyParamCaption}
)}\label{classmlpack_1_1kernel_1_1EpanechnikovKernel_a7b4953bcbbaf5ffbefb495116f536523}


Obtains the convolution integral [integral of K($\vert$$\vert$x-\/a$\vert$$\vert$) K($\vert$$\vert$b-\/x$\vert$$\vert$) dx] for the two vectors. 


\begin{DoxyTemplParams}{Template Parameters}
{\em Vec\+Type} & Type of vector (arma\+::vec, arma\+::spvec should be expected). \\
\hline
\end{DoxyTemplParams}

\begin{DoxyParams}{Parameters}
{\em a} & First vector. \\
\hline
{\em b} & Second vector. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
the convolution integral value. 
\end{DoxyReturn}


Referenced by Epanechnikov\+Kernel().

\index{mlpack\+::kernel\+::\+Epanechnikov\+Kernel@{mlpack\+::kernel\+::\+Epanechnikov\+Kernel}!Evaluate@{Evaluate}}
\index{Evaluate@{Evaluate}!mlpack\+::kernel\+::\+Epanechnikov\+Kernel@{mlpack\+::kernel\+::\+Epanechnikov\+Kernel}}
\subsubsection[{Evaluate(const Vec\+Type\+A \&a, const Vec\+Type\+B \&b) const }]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename Vec\+TypeA , typename Vec\+TypeB $>$ double mlpack\+::kernel\+::\+Epanechnikov\+Kernel\+::\+Evaluate (
\begin{DoxyParamCaption}
\item[{const Vec\+TypeA \&}]{a, }
\item[{const Vec\+TypeB \&}]{b}
\end{DoxyParamCaption}
) const}\label{classmlpack_1_1kernel_1_1EpanechnikovKernel_a4fe76eccfddd4d0aefd3330f80e80ffc}


Evaluate the Epanechnikov kernel on the given two inputs. 


\begin{DoxyTemplParams}{Template Parameters}
{\em Vec\+TypeA} & Type of first vector. \\
\hline
{\em Vec\+TypeB} & Type of second vector. \\
\hline
\end{DoxyTemplParams}

\begin{DoxyParams}{Parameters}
{\em a} & One input vector. \\
\hline
{\em b} & The other input vector. \\
\hline
\end{DoxyParams}


Referenced by Epanechnikov\+Kernel().

\index{mlpack\+::kernel\+::\+Epanechnikov\+Kernel@{mlpack\+::kernel\+::\+Epanechnikov\+Kernel}!Evaluate@{Evaluate}}
\index{Evaluate@{Evaluate}!mlpack\+::kernel\+::\+Epanechnikov\+Kernel@{mlpack\+::kernel\+::\+Epanechnikov\+Kernel}}
\subsubsection[{Evaluate(const double distance) const }]{\setlength{\rightskip}{0pt plus 5cm}double mlpack\+::kernel\+::\+Epanechnikov\+Kernel\+::\+Evaluate (
\begin{DoxyParamCaption}
\item[{const double}]{distance}
\end{DoxyParamCaption}
) const}\label{classmlpack_1_1kernel_1_1EpanechnikovKernel_aa7219cae91b2cc41de09a20bd58b804c}


Evaluate the Epanechnikov kernel given that the distance between the two input points is known. 

\index{mlpack\+::kernel\+::\+Epanechnikov\+Kernel@{mlpack\+::kernel\+::\+Epanechnikov\+Kernel}!Gradient@{Gradient}}
\index{Gradient@{Gradient}!mlpack\+::kernel\+::\+Epanechnikov\+Kernel@{mlpack\+::kernel\+::\+Epanechnikov\+Kernel}}
\subsubsection[{Gradient(const double distance) const }]{\setlength{\rightskip}{0pt plus 5cm}double mlpack\+::kernel\+::\+Epanechnikov\+Kernel\+::\+Gradient (
\begin{DoxyParamCaption}
\item[{const double}]{distance}
\end{DoxyParamCaption}
) const}\label{classmlpack_1_1kernel_1_1EpanechnikovKernel_a7e95a4cf9281c01d5eefb01e1a5dc3f0}


Evaluate the Gradient of Epanechnikov kernel given that the distance between the two input points is known. 



Referenced by Epanechnikov\+Kernel().

\index{mlpack\+::kernel\+::\+Epanechnikov\+Kernel@{mlpack\+::kernel\+::\+Epanechnikov\+Kernel}!Gradient\+For\+Squared\+Distance@{Gradient\+For\+Squared\+Distance}}
\index{Gradient\+For\+Squared\+Distance@{Gradient\+For\+Squared\+Distance}!mlpack\+::kernel\+::\+Epanechnikov\+Kernel@{mlpack\+::kernel\+::\+Epanechnikov\+Kernel}}
\subsubsection[{Gradient\+For\+Squared\+Distance(const double distance\+Squared) const }]{\setlength{\rightskip}{0pt plus 5cm}double mlpack\+::kernel\+::\+Epanechnikov\+Kernel\+::\+Gradient\+For\+Squared\+Distance (
\begin{DoxyParamCaption}
\item[{const double}]{distance\+Squared}
\end{DoxyParamCaption}
) const}\label{classmlpack_1_1kernel_1_1EpanechnikovKernel_ab44c5d3e5355014312c64ec4ba481690}


Evaluate the Gradient of Epanechnikov kernel given that the squared distance between the two input points is known. 



Referenced by Epanechnikov\+Kernel().

\index{mlpack\+::kernel\+::\+Epanechnikov\+Kernel@{mlpack\+::kernel\+::\+Epanechnikov\+Kernel}!Normalizer@{Normalizer}}
\index{Normalizer@{Normalizer}!mlpack\+::kernel\+::\+Epanechnikov\+Kernel@{mlpack\+::kernel\+::\+Epanechnikov\+Kernel}}
\subsubsection[{Normalizer(const size\+\_\+t dimension)}]{\setlength{\rightskip}{0pt plus 5cm}double mlpack\+::kernel\+::\+Epanechnikov\+Kernel\+::\+Normalizer (
\begin{DoxyParamCaption}
\item[{const size\+\_\+t}]{dimension}
\end{DoxyParamCaption}
)}\label{classmlpack_1_1kernel_1_1EpanechnikovKernel_a852907dca671dbe76bd4141bbf8fd8d1}


Compute the normalizer of this Epanechnikov kernel for the given dimension. 


\begin{DoxyParams}{Parameters}
{\em dimension} & Dimension to calculate the normalizer for. \\
\hline
\end{DoxyParams}


Referenced by Epanechnikov\+Kernel().

\index{mlpack\+::kernel\+::\+Epanechnikov\+Kernel@{mlpack\+::kernel\+::\+Epanechnikov\+Kernel}!Serialize@{Serialize}}
\index{Serialize@{Serialize}!mlpack\+::kernel\+::\+Epanechnikov\+Kernel@{mlpack\+::kernel\+::\+Epanechnikov\+Kernel}}
\subsubsection[{Serialize(\+Archive \&ar, const unsigned int version)}]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename Archive $>$ void mlpack\+::kernel\+::\+Epanechnikov\+Kernel\+::\+Serialize (
\begin{DoxyParamCaption}
\item[{Archive \&}]{ar, }
\item[{const unsigned int}]{version}
\end{DoxyParamCaption}
)}\label{classmlpack_1_1kernel_1_1EpanechnikovKernel_ac973fea08bb5c7f1378e488b4ab9ab18}


Serialize the kernel. 



Referenced by Epanechnikov\+Kernel().



\subsection{Member Data Documentation}
\index{mlpack\+::kernel\+::\+Epanechnikov\+Kernel@{mlpack\+::kernel\+::\+Epanechnikov\+Kernel}!bandwidth@{bandwidth}}
\index{bandwidth@{bandwidth}!mlpack\+::kernel\+::\+Epanechnikov\+Kernel@{mlpack\+::kernel\+::\+Epanechnikov\+Kernel}}
\subsubsection[{bandwidth}]{\setlength{\rightskip}{0pt plus 5cm}double mlpack\+::kernel\+::\+Epanechnikov\+Kernel\+::bandwidth\hspace{0.3cm}{\ttfamily [private]}}\label{classmlpack_1_1kernel_1_1EpanechnikovKernel_ab3a8ffcfe9e40996bd4ed90222343b7b}


Bandwidth of the kernel. 



Definition at line 100 of file epanechnikov\+\_\+kernel.\+hpp.

\index{mlpack\+::kernel\+::\+Epanechnikov\+Kernel@{mlpack\+::kernel\+::\+Epanechnikov\+Kernel}!inverse\+Bandwidth\+Squared@{inverse\+Bandwidth\+Squared}}
\index{inverse\+Bandwidth\+Squared@{inverse\+Bandwidth\+Squared}!mlpack\+::kernel\+::\+Epanechnikov\+Kernel@{mlpack\+::kernel\+::\+Epanechnikov\+Kernel}}
\subsubsection[{inverse\+Bandwidth\+Squared}]{\setlength{\rightskip}{0pt plus 5cm}double mlpack\+::kernel\+::\+Epanechnikov\+Kernel\+::inverse\+Bandwidth\+Squared\hspace{0.3cm}{\ttfamily [private]}}\label{classmlpack_1_1kernel_1_1EpanechnikovKernel_a600e630485fae4c895fa29eb55445731}


Cached value of the inverse bandwidth squared (to speed up computation). 



Definition at line 102 of file epanechnikov\+\_\+kernel.\+hpp.



The documentation for this class was generated from the following file\+:\begin{DoxyCompactItemize}
\item 
src/mlpack/core/kernels/{\bf epanechnikov\+\_\+kernel.\+hpp}\end{DoxyCompactItemize}
