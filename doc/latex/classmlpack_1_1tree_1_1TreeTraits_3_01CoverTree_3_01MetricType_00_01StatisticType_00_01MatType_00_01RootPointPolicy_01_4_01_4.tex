\section{mlpack\+:\+:tree\+:\+:Tree\+Traits$<$ Cover\+Tree$<$ Metric\+Type, Statistic\+Type, Mat\+Type, Root\+Point\+Policy $>$ $>$ Class Template Reference}
\label{classmlpack_1_1tree_1_1TreeTraits_3_01CoverTree_3_01MetricType_00_01StatisticType_00_01MatType_00_01RootPointPolicy_01_4_01_4}\index{mlpack\+::tree\+::\+Tree\+Traits$<$ Cover\+Tree$<$ Metric\+Type, Statistic\+Type, Mat\+Type, Root\+Point\+Policy $>$ $>$@{mlpack\+::tree\+::\+Tree\+Traits$<$ Cover\+Tree$<$ Metric\+Type, Statistic\+Type, Mat\+Type, Root\+Point\+Policy $>$ $>$}}


The specialization of the \doxyref{Tree\+Traits}{p.}{classmlpack_1_1tree_1_1TreeTraits} class for the \doxyref{Cover\+Tree}{p.}{classmlpack_1_1tree_1_1CoverTree} tree type.  


\subsection*{Static Public Attributes}
\begin{DoxyCompactItemize}
\item 
static const bool {\bf Binary\+Tree} = false
\begin{DoxyCompactList}\small\item\em The cover tree is not necessarily a binary tree. \end{DoxyCompactList}\item 
static const bool {\bf First\+Point\+Is\+Centroid} = true
\begin{DoxyCompactList}\small\item\em Each cover tree node contains only one point, and that point is its centroid. \end{DoxyCompactList}\item 
static const bool {\bf Has\+Duplicated\+Points} = true
\begin{DoxyCompactList}\small\item\em Cover trees do have self-\/children, so points can be included in more than one node. \end{DoxyCompactList}\item 
static const bool {\bf Has\+Overlapping\+Children} = true
\begin{DoxyCompactList}\small\item\em The cover tree (or, this implementation of it) does not require that children represent non-\/overlapping subsets of the parent node. \end{DoxyCompactList}\item 
static const bool {\bf Has\+Self\+Children} = true
\begin{DoxyCompactList}\small\item\em Cover trees do have self-\/children. \end{DoxyCompactList}\item 
static const bool {\bf Rearranges\+Dataset} = false
\begin{DoxyCompactList}\small\item\em Points are not rearranged when the tree is built. \end{DoxyCompactList}\item 
static const bool {\bf Unique\+Num\+Descendants} = true
\begin{DoxyCompactList}\small\item\em Num\+Descendants() represents the number of unique descendant points. \end{DoxyCompactList}\end{DoxyCompactItemize}


\subsection{Detailed Description}
\subsubsection*{template$<$typename Metric\+Type, typename Statistic\+Type, typename Mat\+Type, typename Root\+Point\+Policy$>$\\*
class mlpack\+::tree\+::\+Tree\+Traits$<$ Cover\+Tree$<$ Metric\+Type, Statistic\+Type, Mat\+Type, Root\+Point\+Policy $>$ $>$}

The specialization of the \doxyref{Tree\+Traits}{p.}{classmlpack_1_1tree_1_1TreeTraits} class for the \doxyref{Cover\+Tree}{p.}{classmlpack_1_1tree_1_1CoverTree} tree type. 

It defines characteristics of the cover tree, and is used to help write tree-\/independent (but still optimized) tree-\/based algorithms. See \doxyref{mlpack/core/tree/tree\+\_\+traits.\+hpp}{p.}{tree__traits_8hpp} for more information. 

Definition at line 31 of file traits.\+hpp.



\subsection{Member Data Documentation}
\index{mlpack\+::tree\+::\+Tree\+Traits$<$ Cover\+Tree$<$ Metric\+Type, Statistic\+Type, Mat\+Type, Root\+Point\+Policy $>$ $>$@{mlpack\+::tree\+::\+Tree\+Traits$<$ Cover\+Tree$<$ Metric\+Type, Statistic\+Type, Mat\+Type, Root\+Point\+Policy $>$ $>$}!Binary\+Tree@{Binary\+Tree}}
\index{Binary\+Tree@{Binary\+Tree}!mlpack\+::tree\+::\+Tree\+Traits$<$ Cover\+Tree$<$ Metric\+Type, Statistic\+Type, Mat\+Type, Root\+Point\+Policy $>$ $>$@{mlpack\+::tree\+::\+Tree\+Traits$<$ Cover\+Tree$<$ Metric\+Type, Statistic\+Type, Mat\+Type, Root\+Point\+Policy $>$ $>$}}
\subsubsection[{Binary\+Tree}]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename Metric\+Type , typename Statistic\+Type , typename Mat\+Type , typename Root\+Point\+Policy $>$ const bool {\bf mlpack\+::tree\+::\+Tree\+Traits}$<$ {\bf Cover\+Tree}$<$ Metric\+Type, Statistic\+Type, Mat\+Type, Root\+Point\+Policy $>$ $>$\+::Binary\+Tree = false\hspace{0.3cm}{\ttfamily [static]}}\label{classmlpack_1_1tree_1_1TreeTraits_3_01CoverTree_3_01MetricType_00_01StatisticType_00_01MatType_00_01RootPointPolicy_01_4_01_4_af5c9de674624b85252c356a422a34983}


The cover tree is not necessarily a binary tree. 



Definition at line 65 of file traits.\+hpp.

\index{mlpack\+::tree\+::\+Tree\+Traits$<$ Cover\+Tree$<$ Metric\+Type, Statistic\+Type, Mat\+Type, Root\+Point\+Policy $>$ $>$@{mlpack\+::tree\+::\+Tree\+Traits$<$ Cover\+Tree$<$ Metric\+Type, Statistic\+Type, Mat\+Type, Root\+Point\+Policy $>$ $>$}!First\+Point\+Is\+Centroid@{First\+Point\+Is\+Centroid}}
\index{First\+Point\+Is\+Centroid@{First\+Point\+Is\+Centroid}!mlpack\+::tree\+::\+Tree\+Traits$<$ Cover\+Tree$<$ Metric\+Type, Statistic\+Type, Mat\+Type, Root\+Point\+Policy $>$ $>$@{mlpack\+::tree\+::\+Tree\+Traits$<$ Cover\+Tree$<$ Metric\+Type, Statistic\+Type, Mat\+Type, Root\+Point\+Policy $>$ $>$}}
\subsubsection[{First\+Point\+Is\+Centroid}]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename Metric\+Type , typename Statistic\+Type , typename Mat\+Type , typename Root\+Point\+Policy $>$ const bool {\bf mlpack\+::tree\+::\+Tree\+Traits}$<$ {\bf Cover\+Tree}$<$ Metric\+Type, Statistic\+Type, Mat\+Type, Root\+Point\+Policy $>$ $>$\+::First\+Point\+Is\+Centroid = true\hspace{0.3cm}{\ttfamily [static]}}\label{classmlpack_1_1tree_1_1TreeTraits_3_01CoverTree_3_01MetricType_00_01StatisticType_00_01MatType_00_01RootPointPolicy_01_4_01_4_a14b78196569c0dfde0b9e22ff58fb7f7}


Each cover tree node contains only one point, and that point is its centroid. 



Definition at line 50 of file traits.\+hpp.

\index{mlpack\+::tree\+::\+Tree\+Traits$<$ Cover\+Tree$<$ Metric\+Type, Statistic\+Type, Mat\+Type, Root\+Point\+Policy $>$ $>$@{mlpack\+::tree\+::\+Tree\+Traits$<$ Cover\+Tree$<$ Metric\+Type, Statistic\+Type, Mat\+Type, Root\+Point\+Policy $>$ $>$}!Has\+Duplicated\+Points@{Has\+Duplicated\+Points}}
\index{Has\+Duplicated\+Points@{Has\+Duplicated\+Points}!mlpack\+::tree\+::\+Tree\+Traits$<$ Cover\+Tree$<$ Metric\+Type, Statistic\+Type, Mat\+Type, Root\+Point\+Policy $>$ $>$@{mlpack\+::tree\+::\+Tree\+Traits$<$ Cover\+Tree$<$ Metric\+Type, Statistic\+Type, Mat\+Type, Root\+Point\+Policy $>$ $>$}}
\subsubsection[{Has\+Duplicated\+Points}]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename Metric\+Type , typename Statistic\+Type , typename Mat\+Type , typename Root\+Point\+Policy $>$ const bool {\bf mlpack\+::tree\+::\+Tree\+Traits}$<$ {\bf Cover\+Tree}$<$ Metric\+Type, Statistic\+Type, Mat\+Type, Root\+Point\+Policy $>$ $>$\+::Has\+Duplicated\+Points = true\hspace{0.3cm}{\ttfamily [static]}}\label{classmlpack_1_1tree_1_1TreeTraits_3_01CoverTree_3_01MetricType_00_01StatisticType_00_01MatType_00_01RootPointPolicy_01_4_01_4_a2d68e6640d774f9bcf9d8ec8e98d467f}


Cover trees do have self-\/children, so points can be included in more than one node. 



Definition at line 44 of file traits.\+hpp.

\index{mlpack\+::tree\+::\+Tree\+Traits$<$ Cover\+Tree$<$ Metric\+Type, Statistic\+Type, Mat\+Type, Root\+Point\+Policy $>$ $>$@{mlpack\+::tree\+::\+Tree\+Traits$<$ Cover\+Tree$<$ Metric\+Type, Statistic\+Type, Mat\+Type, Root\+Point\+Policy $>$ $>$}!Has\+Overlapping\+Children@{Has\+Overlapping\+Children}}
\index{Has\+Overlapping\+Children@{Has\+Overlapping\+Children}!mlpack\+::tree\+::\+Tree\+Traits$<$ Cover\+Tree$<$ Metric\+Type, Statistic\+Type, Mat\+Type, Root\+Point\+Policy $>$ $>$@{mlpack\+::tree\+::\+Tree\+Traits$<$ Cover\+Tree$<$ Metric\+Type, Statistic\+Type, Mat\+Type, Root\+Point\+Policy $>$ $>$}}
\subsubsection[{Has\+Overlapping\+Children}]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename Metric\+Type , typename Statistic\+Type , typename Mat\+Type , typename Root\+Point\+Policy $>$ const bool {\bf mlpack\+::tree\+::\+Tree\+Traits}$<$ {\bf Cover\+Tree}$<$ Metric\+Type, Statistic\+Type, Mat\+Type, Root\+Point\+Policy $>$ $>$\+::Has\+Overlapping\+Children = true\hspace{0.3cm}{\ttfamily [static]}}\label{classmlpack_1_1tree_1_1TreeTraits_3_01CoverTree_3_01MetricType_00_01StatisticType_00_01MatType_00_01RootPointPolicy_01_4_01_4_adb6b72a4a9080e9a57a94fd21f19fd98}


The cover tree (or, this implementation of it) does not require that children represent non-\/overlapping subsets of the parent node. 



Definition at line 38 of file traits.\+hpp.

\index{mlpack\+::tree\+::\+Tree\+Traits$<$ Cover\+Tree$<$ Metric\+Type, Statistic\+Type, Mat\+Type, Root\+Point\+Policy $>$ $>$@{mlpack\+::tree\+::\+Tree\+Traits$<$ Cover\+Tree$<$ Metric\+Type, Statistic\+Type, Mat\+Type, Root\+Point\+Policy $>$ $>$}!Has\+Self\+Children@{Has\+Self\+Children}}
\index{Has\+Self\+Children@{Has\+Self\+Children}!mlpack\+::tree\+::\+Tree\+Traits$<$ Cover\+Tree$<$ Metric\+Type, Statistic\+Type, Mat\+Type, Root\+Point\+Policy $>$ $>$@{mlpack\+::tree\+::\+Tree\+Traits$<$ Cover\+Tree$<$ Metric\+Type, Statistic\+Type, Mat\+Type, Root\+Point\+Policy $>$ $>$}}
\subsubsection[{Has\+Self\+Children}]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename Metric\+Type , typename Statistic\+Type , typename Mat\+Type , typename Root\+Point\+Policy $>$ const bool {\bf mlpack\+::tree\+::\+Tree\+Traits}$<$ {\bf Cover\+Tree}$<$ Metric\+Type, Statistic\+Type, Mat\+Type, Root\+Point\+Policy $>$ $>$\+::Has\+Self\+Children = true\hspace{0.3cm}{\ttfamily [static]}}\label{classmlpack_1_1tree_1_1TreeTraits_3_01CoverTree_3_01MetricType_00_01StatisticType_00_01MatType_00_01RootPointPolicy_01_4_01_4_a459e11ad667b321f60a78649b94d83a2}


Cover trees do have self-\/children. 



Definition at line 55 of file traits.\+hpp.

\index{mlpack\+::tree\+::\+Tree\+Traits$<$ Cover\+Tree$<$ Metric\+Type, Statistic\+Type, Mat\+Type, Root\+Point\+Policy $>$ $>$@{mlpack\+::tree\+::\+Tree\+Traits$<$ Cover\+Tree$<$ Metric\+Type, Statistic\+Type, Mat\+Type, Root\+Point\+Policy $>$ $>$}!Rearranges\+Dataset@{Rearranges\+Dataset}}
\index{Rearranges\+Dataset@{Rearranges\+Dataset}!mlpack\+::tree\+::\+Tree\+Traits$<$ Cover\+Tree$<$ Metric\+Type, Statistic\+Type, Mat\+Type, Root\+Point\+Policy $>$ $>$@{mlpack\+::tree\+::\+Tree\+Traits$<$ Cover\+Tree$<$ Metric\+Type, Statistic\+Type, Mat\+Type, Root\+Point\+Policy $>$ $>$}}
\subsubsection[{Rearranges\+Dataset}]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename Metric\+Type , typename Statistic\+Type , typename Mat\+Type , typename Root\+Point\+Policy $>$ const bool {\bf mlpack\+::tree\+::\+Tree\+Traits}$<$ {\bf Cover\+Tree}$<$ Metric\+Type, Statistic\+Type, Mat\+Type, Root\+Point\+Policy $>$ $>$\+::Rearranges\+Dataset = false\hspace{0.3cm}{\ttfamily [static]}}\label{classmlpack_1_1tree_1_1TreeTraits_3_01CoverTree_3_01MetricType_00_01StatisticType_00_01MatType_00_01RootPointPolicy_01_4_01_4_a62166cdde2b4ec5f8b37c13aadf16235}


Points are not rearranged when the tree is built. 



Definition at line 60 of file traits.\+hpp.

\index{mlpack\+::tree\+::\+Tree\+Traits$<$ Cover\+Tree$<$ Metric\+Type, Statistic\+Type, Mat\+Type, Root\+Point\+Policy $>$ $>$@{mlpack\+::tree\+::\+Tree\+Traits$<$ Cover\+Tree$<$ Metric\+Type, Statistic\+Type, Mat\+Type, Root\+Point\+Policy $>$ $>$}!Unique\+Num\+Descendants@{Unique\+Num\+Descendants}}
\index{Unique\+Num\+Descendants@{Unique\+Num\+Descendants}!mlpack\+::tree\+::\+Tree\+Traits$<$ Cover\+Tree$<$ Metric\+Type, Statistic\+Type, Mat\+Type, Root\+Point\+Policy $>$ $>$@{mlpack\+::tree\+::\+Tree\+Traits$<$ Cover\+Tree$<$ Metric\+Type, Statistic\+Type, Mat\+Type, Root\+Point\+Policy $>$ $>$}}
\subsubsection[{Unique\+Num\+Descendants}]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename Metric\+Type , typename Statistic\+Type , typename Mat\+Type , typename Root\+Point\+Policy $>$ const bool {\bf mlpack\+::tree\+::\+Tree\+Traits}$<$ {\bf Cover\+Tree}$<$ Metric\+Type, Statistic\+Type, Mat\+Type, Root\+Point\+Policy $>$ $>$\+::Unique\+Num\+Descendants = true\hspace{0.3cm}{\ttfamily [static]}}\label{classmlpack_1_1tree_1_1TreeTraits_3_01CoverTree_3_01MetricType_00_01StatisticType_00_01MatType_00_01RootPointPolicy_01_4_01_4_aa1fbca79fec713a36bf51408f451facd}


Num\+Descendants() represents the number of unique descendant points. 



Definition at line 70 of file traits.\+hpp.



The documentation for this class was generated from the following file\+:\begin{DoxyCompactItemize}
\item 
src/mlpack/core/tree/cover\+\_\+tree/{\bf traits.\+hpp}\end{DoxyCompactItemize}
