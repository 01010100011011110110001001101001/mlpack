\section{mlpack\+:\+:C\+LI Class Reference}
\label{classmlpack_1_1CLI}\index{mlpack\+::\+C\+LI@{mlpack\+::\+C\+LI}}


Parses the command line for parameters and holds user-\/specified parameters.  


\subsection*{Public Member Functions}
\begin{DoxyCompactItemize}
\item 
{\bf $\sim$\+C\+LI} ()
\begin{DoxyCompactList}\small\item\em Destructor. \end{DoxyCompactList}\end{DoxyCompactItemize}
\subsection*{Static Public Member Functions}
\begin{DoxyCompactItemize}
\item 
{\footnotesize template$<$class T $>$ }\\static void {\bf Add} (const T \&default\+Value, const {\bf std\+::string} \&identifier, const {\bf std\+::string} \&description, const char alias= \textquotesingle{}\textbackslash{}0\textquotesingle{}, const bool required=false, const bool input=true, const bool no\+Transpose=false)
\begin{DoxyCompactList}\small\item\em Adds a parameter to the hierarchy; use the P\+A\+R\+A\+M\+\_\+$\ast$() macros instead of this (i.\+e. \end{DoxyCompactList}\item 
static void {\bf Destroy} ()
\begin{DoxyCompactList}\small\item\em Destroy the \doxyref{C\+LI}{p.}{classmlpack_1_1CLI} object. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename T $>$ }\\static T \& {\bf Get\+Param} (const {\bf std\+::string} \&identifier)
\begin{DoxyCompactList}\small\item\em Grab the value of type T found while parsing. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename T $>$ }\\static T \& {\bf Get\+Raw\+Param} (const {\bf std\+::string} \&identifier)
\begin{DoxyCompactList}\small\item\em Get the raw value of the parameter before the processing that \doxyref{Get\+Param()}{p.}{classmlpack_1_1CLI_ad5ba2689bb15a8f609fc51c27a3f7637} would normally do. \end{DoxyCompactList}\item 
static {\bf C\+LI} \& {\bf Get\+Singleton} ()
\begin{DoxyCompactList}\small\item\em Retrieve the singleton. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename T $>$ }\\static {\bf util\+::\+Parameter\+Type}$<$ T $>$\+::type \& {\bf Get\+Unmapped\+Param} (const {\bf std\+::string} \&identifier)
\begin{DoxyCompactList}\small\item\em Get the unmapped (i.\+e. \end{DoxyCompactList}\item 
static bool {\bf Has\+Param} (const {\bf std\+::string} \&identifier)
\begin{DoxyCompactList}\small\item\em See if the specified flag was found while parsing. \end{DoxyCompactList}\item 
static {\bf std\+::string} {\bf Hyphenate\+String} (const {\bf std\+::string} \&str, int padding)
\begin{DoxyCompactList}\small\item\em Hyphenate a string or split it onto multiple 80-\/character lines, with some amount of padding on each line. \end{DoxyCompactList}\item 
static void {\bf Parse\+Command\+Line} (int argc, char $\ast$$\ast$argv)
\begin{DoxyCompactList}\small\item\em Parses the commandline for arguments. \end{DoxyCompactList}\item 
static void {\bf Print\+Help} (const {\bf std\+::string} \&param=\char`\"{}\char`\"{})
\begin{DoxyCompactList}\small\item\em Print out the help info for the given parameter (or all parameters if no argument is specified). \end{DoxyCompactList}\item 
static void {\bf Register\+Program\+Doc} ({\bf util\+::\+Program\+Doc} $\ast${\bf doc})
\begin{DoxyCompactList}\small\item\em Registers a Program\+Doc object, which contains documentation about the program. \end{DoxyCompactList}\end{DoxyCompactItemize}
\subsection*{Public Attributes}
\begin{DoxyCompactItemize}
\item 
{\bf util\+::\+Program\+Doc} $\ast$ {\bf doc}
\begin{DoxyCompactList}\small\item\em Pointer to the Program\+Doc object. \end{DoxyCompactList}\end{DoxyCompactItemize}
\subsection*{Private Member Functions}
\begin{DoxyCompactItemize}
\item 
{\bf C\+LI} ()
\begin{DoxyCompactList}\small\item\em Make the constructor private, to preclude unauthorized instances. \end{DoxyCompactList}\item 
{\bf C\+LI} (const {\bf C\+LI} \&other)
\begin{DoxyCompactList}\small\item\em Private copy constructor; we don\textquotesingle{}t want copies floating around. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename T $>$ }\\void {\bf Add\+Option} (const char $\ast$opt\+Id, const char $\ast$descr, const typename {\bf std\+::enable\+\_\+if\+\_\+t}$<$!{\bf util\+::\+Is\+Std\+Vector}$<$ T $>$\+::value $>$ $\ast$=0)
\begin{DoxyCompactList}\small\item\em Add an option if it is not a vector type. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename T $>$ }\\void {\bf Add\+Option} (const char $\ast$opt\+Id, const char $\ast$descr, const typename {\bf std\+::enable\+\_\+if\+\_\+t}$<$ {\bf util\+::\+Is\+Std\+Vector}$<$ T $>$\+::value $>$ $\ast$=0)
\begin{DoxyCompactList}\small\item\em Add an option if it is a vector type. \end{DoxyCompactList}\end{DoxyCompactItemize}
\subsection*{Static Private Member Functions}
\begin{DoxyCompactItemize}
\item 
static void {\bf Add\+Alias} (const {\bf std\+::string} \&alias, const {\bf std\+::string} \&original)
\begin{DoxyCompactList}\small\item\em Maps a given alias to a given parameter. \end{DoxyCompactList}\item 
static char {\bf Alias\+Reverse\+Lookup} (const {\bf std\+::string} \&value)
\begin{DoxyCompactList}\small\item\em Returns an alias, if given the name of the original. \end{DoxyCompactList}\end{DoxyCompactItemize}
\subsection*{Private Attributes}
\begin{DoxyCompactItemize}
\item 
std\+::map$<$ char, {\bf std\+::string} $>$ {\bf aliases}
\begin{DoxyCompactList}\small\item\em Convenience map from alias values to names. \end{DoxyCompactList}\item 
po\+::options\+\_\+description {\bf desc}
\begin{DoxyCompactList}\small\item\em The documentation and names of options. \end{DoxyCompactList}\item 
bool {\bf did\+Parse}
\begin{DoxyCompactList}\small\item\em True, if \doxyref{C\+LI}{p.}{classmlpack_1_1CLI} was used to parse command line options. \end{DoxyCompactList}\item 
std\+::list$<$ {\bf std\+::string} $>$ {\bf output\+Options}
\begin{DoxyCompactList}\small\item\em Convenience list of output options. \end{DoxyCompactList}\item 
std\+::map$<$ {\bf std\+::string}, {\bf util\+::\+Param\+Data} $>$ {\bf parameters}
\begin{DoxyCompactList}\small\item\em Map of parameters. \end{DoxyCompactList}\item 
{\bf std\+::string} {\bf program\+Name}
\begin{DoxyCompactList}\small\item\em Holds the name of the program for --version. \end{DoxyCompactList}\item 
std\+::list$<$ {\bf std\+::string} $>$ {\bf required\+Options}
\begin{DoxyCompactList}\small\item\em Convenience list of required options. \end{DoxyCompactList}\item 
{\bf Timers} {\bf timer}
\begin{DoxyCompactList}\small\item\em Holds the timer objects. \end{DoxyCompactList}\item 
po\+::variables\+\_\+map {\bf vmap}
\begin{DoxyCompactList}\small\item\em Values of the options given by user. \end{DoxyCompactList}\end{DoxyCompactItemize}
\subsection*{Static Private Attributes}
\begin{DoxyCompactItemize}
\item 
static {\bf C\+LI} $\ast$ {\bf singleton}
\begin{DoxyCompactList}\small\item\em The singleton itself. \end{DoxyCompactList}\end{DoxyCompactItemize}


\subsection{Detailed Description}
Parses the command line for parameters and holds user-\/specified parameters. 

The \doxyref{C\+LI}{p.}{classmlpack_1_1CLI} class is a subsystem by which parameters for machine learning methods can be specified and accessed. In conjunction with the macros P\+A\+R\+A\+M\+\_\+\+D\+O\+U\+B\+LE, P\+A\+R\+A\+M\+\_\+\+I\+NT, P\+A\+R\+A\+M\+\_\+\+S\+T\+R\+I\+NG, P\+A\+R\+A\+M\+\_\+\+F\+L\+AG, and others, this class aims to make user configurability of mlpack methods very easy. There are only three methods in \doxyref{C\+LI}{p.}{classmlpack_1_1CLI} that a user should need\+: \doxyref{C\+L\+I\+::\+Parse\+Command\+Line()}{p.}{classmlpack_1_1CLI_a1033e1179084cef018a95c42740f662f}, \doxyref{C\+L\+I\+::\+Get\+Param()}{p.}{classmlpack_1_1CLI_ad5ba2689bb15a8f609fc51c27a3f7637}, and \doxyref{C\+L\+I\+::\+Has\+Param()}{p.}{classmlpack_1_1CLI_a6326c29f1487b69658e8e9f9c70689f8} (in addition to the P\+A\+R\+A\+M\+\_\+$\ast$() macros).\subsection{Adding parameters to a program}\label{classmlpack_1_1CLI_addparam}

\begin{DoxyCode}
$ ./executable --bar=5
\end{DoxyCode}


\begin{DoxyNote}{Note}
The = is optional; a space can also be used.
\end{DoxyNote}
A parameter is specified by using one of the following macros (this is not a complete list; see core/io/cli.\+hpp)\+:


\begin{DoxyItemize}
\item \doxyref{P\+A\+R\+A\+M\+\_\+\+F\+L\+A\+G(\+I\+D, D\+E\+S\+C, A\+L\+I\+A\+S)}{p.}{param_8hpp_a59a38dfe16c56a278bd89817216a3739}
\item P\+A\+R\+A\+M\+\_\+\+D\+O\+U\+B\+L\+E(\+I\+D, D\+E\+S\+C, A\+L\+I\+A\+S, D\+E\+F)
\item P\+A\+R\+A\+M\+\_\+\+I\+N\+T(\+I\+D, D\+E\+S\+C, A\+L\+I\+A\+S, D\+E\+F)
\item P\+A\+R\+A\+M\+\_\+\+S\+T\+R\+I\+N\+G(\+I\+D, D\+E\+S\+C, A\+L\+I\+A\+S, D\+E\+F)
\end{DoxyItemize}


\begin{DoxyParams}{Parameters}
{\em ID} & Name of the parameter. \\
\hline
{\em D\+E\+SC} & Short description of the parameter (one/two sentences). \\
\hline
{\em A\+L\+I\+AS} & An alias for the parameter. \\
\hline
{\em D\+EF} & Default value of the parameter.\\
\hline
\end{DoxyParams}
The flag (boolean) type automatically defaults to false; it is specified merely as a flag on the command line (no \textquotesingle{}=true\textquotesingle{} is required).

Here is an example of a few parameters being defined; this is for the K\+NN executable (methods/neighbor\+\_\+search/knn\+\_\+main.\+cpp)\+:


\begin{DoxyCode}
PARAM\_STRING\_REQ(\textcolor{stringliteral}{"reference\_file"}, \textcolor{stringliteral}{"File containing the reference dataset."},
    \textcolor{stringliteral}{"r"});
PARAM\_STRING\_REQ(\textcolor{stringliteral}{"distances\_file"}, \textcolor{stringliteral}{"File to output distances into."}, \textcolor{stringliteral}{"d"});
PARAM\_STRING\_REQ(\textcolor{stringliteral}{"neighbors\_file"}, \textcolor{stringliteral}{"File to output neighbors into."}, \textcolor{stringliteral}{"n"});
PARAM\_INT\_REQ(\textcolor{stringliteral}{"k"}, \textcolor{stringliteral}{"Number of furthest neighbors to find."}, \textcolor{stringliteral}{"k"});
PARAM\_STRING(\textcolor{stringliteral}{"query\_file"}, \textcolor{stringliteral}{"File containing query points (optional)."}, \textcolor{stringliteral}{"q"},
    \textcolor{stringliteral}{""});
PARAM\_INT(\textcolor{stringliteral}{"leaf\_size"}, \textcolor{stringliteral}{"Leaf size for tree building."}, \textcolor{stringliteral}{"l"}, 20);
PARAM_FLAG(\textcolor{stringliteral}{"naive"}, \textcolor{stringliteral}{"If true, O(n^2) naive mode is used for computation."},
    \textcolor{stringliteral}{"N"});
PARAM_FLAG(\textcolor{stringliteral}{"single\_mode"}, \textcolor{stringliteral}{"If true, single-tree search is used (as opposed "}
    \textcolor{stringliteral}{"to dual-tree search."}, \textcolor{stringliteral}{"s"});
\end{DoxyCode}


More documentation is available on the P\+A\+R\+A\+M\+\_\+$\ast$() macros in the documentation for core/io/cli.\+hpp.\subsection{Documenting the program itself}\label{classmlpack_1_1CLI_programinfo}
In addition to allowing documentation for each individual parameter and module, the \doxyref{P\+R\+O\+G\+R\+A\+M\+\_\+\+I\+N\+F\+O()}{p.}{param_8hpp_ad781e52fa8bee6ec70cabb646fa16e00} macro provides support for documenting the program itself. There should only be one instance of the \doxyref{P\+R\+O\+G\+R\+A\+M\+\_\+\+I\+N\+F\+O()}{p.}{param_8hpp_ad781e52fa8bee6ec70cabb646fa16e00} macro. Below is an example\+:


\begin{DoxyCode}
PROGRAM_INFO(\textcolor{stringliteral}{"Maximum Variance Unfolding"}, \textcolor{stringliteral}{"This program performs maximum "}
   \textcolor{stringliteral}{"variance unfolding on the given dataset, writing a lower-dimensional "}
   \textcolor{stringliteral}{"unfolded dataset to the given output file."});
\end{DoxyCode}


This description should be verbose, and explain to a non-\/expert user what the program does and how to use it. If relevant, paper citations should be included.\subsection{Parsing the command line with C\+LI}\label{classmlpack_1_1CLI_parsecli}
To have \doxyref{C\+LI}{p.}{classmlpack_1_1CLI} parse the command line at the beginning of code execution, only a call to \doxyref{Parse\+Command\+Line()}{p.}{classmlpack_1_1CLI_a1033e1179084cef018a95c42740f662f} is necessary\+:


\begin{DoxyCode}
\textcolor{keywordtype}{int} main(\textcolor{keywordtype}{int} argc, \textcolor{keywordtype}{char}** argv)
\{
  CLI::ParseCommandLine(argc, argv);

  ...
\}
\end{DoxyCode}


\doxyref{C\+LI}{p.}{classmlpack_1_1CLI} provides --help and --info options which give nicely formatted documentation of each option; the documentation is generated from the D\+E\+SC arguments in the P\+A\+R\+A\+M\+\_\+$\ast$() macros.\subsection{Getting parameters with C\+LI}\label{classmlpack_1_1CLI_getparam}
When the parameters have been defined, the next important thing is how to access them. For this, the \doxyref{Has\+Param()}{p.}{classmlpack_1_1CLI_a6326c29f1487b69658e8e9f9c70689f8} and \doxyref{Get\+Param()}{p.}{classmlpack_1_1CLI_ad5ba2689bb15a8f609fc51c27a3f7637} methods are used. For instance, to see if the user passed the flag (boolean) \char`\"{}naive\char`\"{}\+:


\begin{DoxyCode}
\textcolor{keywordflow}{if} (CLI::HasParam(\textcolor{stringliteral}{"naive"}))
\{
  Log::Info << \textcolor{stringliteral}{"Naive has been passed!"} << std::endl;
\}
\end{DoxyCode}


To get the value of a parameter, such as a string, use Get\+Param\+:


\begin{DoxyCode}
\textcolor{keyword}{const} std::string filename = CLI::GetParam<std::string>(\textcolor{stringliteral}{"filename"});
\end{DoxyCode}


\begin{DoxyNote}{Note}
Options should only be defined in files which define {\ttfamily main()} (that is, main executables). If options are defined elsewhere, they may be spuriously included into other executables and confuse users. Similarly, if your executable has options which you did not define, it is probably because the option is defined somewhere else and included in your executable.
\end{DoxyNote}
\begin{DoxyRefDesc}{Bug}
\item[{\bf Bug}]The {\bfseries C\+O\+U\+N\+T\+ER} variable is used in most cases to guarantee a unique global identifier for options declared using the P\+A\+R\+A\+M\+\_\+$\ast$() macros. However, not all compilers have this support--most notably, gcc $<$ 4.\+3. In that case, the {\bfseries L\+I\+NE} macro is used as an attempt to get a unique global identifier, but collisions are still possible, and they produce bizarre error messages. See {\tt https\+://github.\+com/mlpack/mlpack/issues/100} for more information. \end{DoxyRefDesc}


Definition at line 175 of file cli.\+hpp.



\subsection{Constructor \& Destructor Documentation}
\index{mlpack\+::\+C\+LI@{mlpack\+::\+C\+LI}!````~C\+LI@{$\sim$\+C\+LI}}
\index{````~C\+LI@{$\sim$\+C\+LI}!mlpack\+::\+C\+LI@{mlpack\+::\+C\+LI}}
\subsubsection[{$\sim$\+C\+L\+I()}]{\setlength{\rightskip}{0pt plus 5cm}mlpack\+::\+C\+L\+I\+::$\sim$\+C\+LI (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)}\label{classmlpack_1_1CLI_a6590d36f559d67da2456d48ee63944c3}


Destructor. 

\index{mlpack\+::\+C\+LI@{mlpack\+::\+C\+LI}!C\+LI@{C\+LI}}
\index{C\+LI@{C\+LI}!mlpack\+::\+C\+LI@{mlpack\+::\+C\+LI}}
\subsubsection[{C\+L\+I()}]{\setlength{\rightskip}{0pt plus 5cm}mlpack\+::\+C\+L\+I\+::\+C\+LI (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [private]}}\label{classmlpack_1_1CLI_a10cdb32649d6ab95d38e9f8d6be96ffe}


Make the constructor private, to preclude unauthorized instances. 

\index{mlpack\+::\+C\+LI@{mlpack\+::\+C\+LI}!C\+LI@{C\+LI}}
\index{C\+LI@{C\+LI}!mlpack\+::\+C\+LI@{mlpack\+::\+C\+LI}}
\subsubsection[{C\+L\+I(const C\+L\+I \&other)}]{\setlength{\rightskip}{0pt plus 5cm}mlpack\+::\+C\+L\+I\+::\+C\+LI (
\begin{DoxyParamCaption}
\item[{const {\bf C\+LI} \&}]{other}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [private]}}\label{classmlpack_1_1CLI_a0aa566255cc1232287b86fe65786c8e7}


Private copy constructor; we don\textquotesingle{}t want copies floating around. 



\subsection{Member Function Documentation}
\index{mlpack\+::\+C\+LI@{mlpack\+::\+C\+LI}!Add@{Add}}
\index{Add@{Add}!mlpack\+::\+C\+LI@{mlpack\+::\+C\+LI}}
\subsubsection[{Add(const T \&default\+Value, const std\+::string \&identifier, const std\+::string \&description, const char alias= \textquotesingle{}\textbackslash{}0\textquotesingle{}, const bool required=false, const bool input=true, const bool no\+Transpose=false)}]{\setlength{\rightskip}{0pt plus 5cm}template$<$class T $>$ static void mlpack\+::\+C\+L\+I\+::\+Add (
\begin{DoxyParamCaption}
\item[{const T \&}]{default\+Value, }
\item[{const {\bf std\+::string} \&}]{identifier, }
\item[{const {\bf std\+::string} \&}]{description, }
\item[{const char}]{alias = {\ttfamily \textquotesingle{}\textbackslash{}0\textquotesingle{}}, }
\item[{const bool}]{required = {\ttfamily false}, }
\item[{const bool}]{input = {\ttfamily true}, }
\item[{const bool}]{no\+Transpose = {\ttfamily false}}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [static]}}\label{classmlpack_1_1CLI_a8f3de51a7d06d086e25d1c8c9664cefe}


Adds a parameter to the hierarchy; use the P\+A\+R\+A\+M\+\_\+$\ast$() macros instead of this (i.\+e. 

P\+A\+R\+A\+M\+\_\+\+I\+N\+T()).


\begin{DoxyParams}{Parameters}
{\em identifier} & The name of the parameter. \\
\hline
{\em description} & Short string description of the parameter. \\
\hline
{\em alias} & An alias for the parameter, defaults to \textquotesingle{}\textbackslash{}0\textquotesingle{} (no alias). \\
\hline
{\em required} & Indicates if parameter must be set on command line. \\
\hline
{\em input} & If true, the parameter is an input (not output) parameter. \\
\hline
{\em no\+Transpose} & If the parameter is a matrix and this is true, then the matrix will not be transposed on loading. \\
\hline
\end{DoxyParams}
\index{mlpack\+::\+C\+LI@{mlpack\+::\+C\+LI}!Add\+Alias@{Add\+Alias}}
\index{Add\+Alias@{Add\+Alias}!mlpack\+::\+C\+LI@{mlpack\+::\+C\+LI}}
\subsubsection[{Add\+Alias(const std\+::string \&alias, const std\+::string \&original)}]{\setlength{\rightskip}{0pt plus 5cm}static void mlpack\+::\+C\+L\+I\+::\+Add\+Alias (
\begin{DoxyParamCaption}
\item[{const {\bf std\+::string} \&}]{alias, }
\item[{const {\bf std\+::string} \&}]{original}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [static]}, {\ttfamily [private]}}\label{classmlpack_1_1CLI_aaa371d0e68a9eff8638ecb99605c8b29}


Maps a given alias to a given parameter. 


\begin{DoxyParams}{Parameters}
{\em alias} & The name of the alias to be mapped. \\
\hline
{\em original} & The name of the parameter to be mapped. \\
\hline
\end{DoxyParams}
\index{mlpack\+::\+C\+LI@{mlpack\+::\+C\+LI}!Add\+Option@{Add\+Option}}
\index{Add\+Option@{Add\+Option}!mlpack\+::\+C\+LI@{mlpack\+::\+C\+LI}}
\subsubsection[{Add\+Option(const char $\ast$opt\+Id, const char $\ast$descr, const typename std\+::enable\+\_\+if\+\_\+t$<$"!util\+::\+Is\+Std\+Vector$<$ T $>$\+::value $>$ $\ast$=0)}]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename T $>$ void mlpack\+::\+C\+L\+I\+::\+Add\+Option (
\begin{DoxyParamCaption}
\item[{const char $\ast$}]{opt\+Id, }
\item[{const char $\ast$}]{descr, }
\item[{const typename {\bf std\+::enable\+\_\+if\+\_\+t}$<$!{\bf util\+::\+Is\+Std\+Vector}$<$ T $>$\+::value $>$ $\ast$}]{ = {\ttfamily 0}}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [private]}}\label{classmlpack_1_1CLI_af0f19c02fd53ba8bcb0dc3ce6b11b942}


Add an option if it is not a vector type. 

This is a utility function used by \doxyref{C\+L\+I\+::\+Add}{p.}{classmlpack_1_1CLI_a8f3de51a7d06d086e25d1c8c9664cefe}.


\begin{DoxyTemplParams}{Template Parameters}
{\em Type} & of parameter. \\
\hline
\end{DoxyTemplParams}

\begin{DoxyParams}{Parameters}
{\em opt\+Id} & Name of parameter. \\
\hline
{\em descr} & Description. \\
\hline
\end{DoxyParams}
\index{mlpack\+::\+C\+LI@{mlpack\+::\+C\+LI}!Add\+Option@{Add\+Option}}
\index{Add\+Option@{Add\+Option}!mlpack\+::\+C\+LI@{mlpack\+::\+C\+LI}}
\subsubsection[{Add\+Option(const char $\ast$opt\+Id, const char $\ast$descr, const typename std\+::enable\+\_\+if\+\_\+t$<$ util\+::\+Is\+Std\+Vector$<$ T $>$\+::value $>$ $\ast$=0)}]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename T $>$ void mlpack\+::\+C\+L\+I\+::\+Add\+Option (
\begin{DoxyParamCaption}
\item[{const char $\ast$}]{opt\+Id, }
\item[{const char $\ast$}]{descr, }
\item[{const typename {\bf std\+::enable\+\_\+if\+\_\+t}$<$ {\bf util\+::\+Is\+Std\+Vector}$<$ T $>$\+::value $>$ $\ast$}]{ = {\ttfamily 0}}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [private]}}\label{classmlpack_1_1CLI_a6af305235aef54caa5f2cc88be3e43f1}


Add an option if it is a vector type. 

This is a utility function used by \doxyref{C\+L\+I\+::\+Add}{p.}{classmlpack_1_1CLI_a8f3de51a7d06d086e25d1c8c9664cefe}.


\begin{DoxyTemplParams}{Template Parameters}
{\em Type} & of parameter. \\
\hline
\end{DoxyTemplParams}

\begin{DoxyParams}{Parameters}
{\em opt\+Id} & Name of parameter. \\
\hline
{\em descr} & Description. \\
\hline
\end{DoxyParams}
\index{mlpack\+::\+C\+LI@{mlpack\+::\+C\+LI}!Alias\+Reverse\+Lookup@{Alias\+Reverse\+Lookup}}
\index{Alias\+Reverse\+Lookup@{Alias\+Reverse\+Lookup}!mlpack\+::\+C\+LI@{mlpack\+::\+C\+LI}}
\subsubsection[{Alias\+Reverse\+Lookup(const std\+::string \&value)}]{\setlength{\rightskip}{0pt plus 5cm}static char mlpack\+::\+C\+L\+I\+::\+Alias\+Reverse\+Lookup (
\begin{DoxyParamCaption}
\item[{const {\bf std\+::string} \&}]{value}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [static]}, {\ttfamily [private]}}\label{classmlpack_1_1CLI_af79542eb8b3212c7f73855a4ca93e481}


Returns an alias, if given the name of the original. 


\begin{DoxyParams}{Parameters}
{\em value} & The value in a key\+:value pair where the key is an alias. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
The alias associated with value. 
\end{DoxyReturn}
\index{mlpack\+::\+C\+LI@{mlpack\+::\+C\+LI}!Destroy@{Destroy}}
\index{Destroy@{Destroy}!mlpack\+::\+C\+LI@{mlpack\+::\+C\+LI}}
\subsubsection[{Destroy()}]{\setlength{\rightskip}{0pt plus 5cm}static void mlpack\+::\+C\+L\+I\+::\+Destroy (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [static]}}\label{classmlpack_1_1CLI_a4f5b42c89f22052530cace3815bfff32}


Destroy the \doxyref{C\+LI}{p.}{classmlpack_1_1CLI} object. 

This resets the pointer to the singleton, so in case someone tries to access it after destruction, a new one will be made (the program will not fail). \index{mlpack\+::\+C\+LI@{mlpack\+::\+C\+LI}!Get\+Param@{Get\+Param}}
\index{Get\+Param@{Get\+Param}!mlpack\+::\+C\+LI@{mlpack\+::\+C\+LI}}
\subsubsection[{Get\+Param(const std\+::string \&identifier)}]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename T $>$ static T\& mlpack\+::\+C\+L\+I\+::\+Get\+Param (
\begin{DoxyParamCaption}
\item[{const {\bf std\+::string} \&}]{identifier}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [static]}}\label{classmlpack_1_1CLI_ad5ba2689bb15a8f609fc51c27a3f7637}


Grab the value of type T found while parsing. 

You can set the value using this reference safely.


\begin{DoxyParams}{Parameters}
{\em identifier} & The name of the parameter in question. \\
\hline
\end{DoxyParams}
\index{mlpack\+::\+C\+LI@{mlpack\+::\+C\+LI}!Get\+Raw\+Param@{Get\+Raw\+Param}}
\index{Get\+Raw\+Param@{Get\+Raw\+Param}!mlpack\+::\+C\+LI@{mlpack\+::\+C\+LI}}
\subsubsection[{Get\+Raw\+Param(const std\+::string \&identifier)}]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename T $>$ static T\& mlpack\+::\+C\+L\+I\+::\+Get\+Raw\+Param (
\begin{DoxyParamCaption}
\item[{const {\bf std\+::string} \&}]{identifier}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [static]}}\label{classmlpack_1_1CLI_a145d1c2bf2b158e8f4405a602715ca8b}


Get the raw value of the parameter before the processing that \doxyref{Get\+Param()}{p.}{classmlpack_1_1CLI_ad5ba2689bb15a8f609fc51c27a3f7637} would normally do. 

Note that this does not perform any data loading or manipulation like \doxyref{Get\+Param()}{p.}{classmlpack_1_1CLI_ad5ba2689bb15a8f609fc51c27a3f7637} does. So if you want to access a matrix or model (or similar) parameter before it is loaded, this is the method to use.


\begin{DoxyParams}{Parameters}
{\em identifier} & The name of the parameter in question. \\
\hline
\end{DoxyParams}
\index{mlpack\+::\+C\+LI@{mlpack\+::\+C\+LI}!Get\+Singleton@{Get\+Singleton}}
\index{Get\+Singleton@{Get\+Singleton}!mlpack\+::\+C\+LI@{mlpack\+::\+C\+LI}}
\subsubsection[{Get\+Singleton()}]{\setlength{\rightskip}{0pt plus 5cm}static {\bf C\+LI}\& mlpack\+::\+C\+L\+I\+::\+Get\+Singleton (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [static]}}\label{classmlpack_1_1CLI_a69e68116871214c7d98bcbfedc3cde2d}


Retrieve the singleton. 

Not exposed to the outside, so as to spare users some ungainly x.\+Get\+Singleton().foo() syntax.

In this case, the singleton is used to store data for the static methods, as there is no point in defining static methods only to have users call private instance methods.

\begin{DoxyReturn}{Returns}
The singleton instance for use in the static methods. 
\end{DoxyReturn}
\index{mlpack\+::\+C\+LI@{mlpack\+::\+C\+LI}!Get\+Unmapped\+Param@{Get\+Unmapped\+Param}}
\index{Get\+Unmapped\+Param@{Get\+Unmapped\+Param}!mlpack\+::\+C\+LI@{mlpack\+::\+C\+LI}}
\subsubsection[{Get\+Unmapped\+Param(const std\+::string \&identifier)}]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename T $>$ static {\bf util\+::\+Parameter\+Type}$<$T$>$\+::type\& mlpack\+::\+C\+L\+I\+::\+Get\+Unmapped\+Param (
\begin{DoxyParamCaption}
\item[{const {\bf std\+::string} \&}]{identifier}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [static]}}\label{classmlpack_1_1CLI_a619b5c9337a4a622739b1d845a727db3}


Get the unmapped (i.\+e. 

what the user specifies on the command-\/line) value of type Parameter\+Type$<$\+T$>$\+::value found while parsing. You can set the value using this reference safely. You should not need to use this function unless you are doing something tricky (like getting the filename a user specified for a matrix parameter or something).


\begin{DoxyParams}{Parameters}
{\em identifier} & The name of the parameter in question. \\
\hline
\end{DoxyParams}
\index{mlpack\+::\+C\+LI@{mlpack\+::\+C\+LI}!Has\+Param@{Has\+Param}}
\index{Has\+Param@{Has\+Param}!mlpack\+::\+C\+LI@{mlpack\+::\+C\+LI}}
\subsubsection[{Has\+Param(const std\+::string \&identifier)}]{\setlength{\rightskip}{0pt plus 5cm}static bool mlpack\+::\+C\+L\+I\+::\+Has\+Param (
\begin{DoxyParamCaption}
\item[{const {\bf std\+::string} \&}]{identifier}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [static]}}\label{classmlpack_1_1CLI_a6326c29f1487b69658e8e9f9c70689f8}


See if the specified flag was found while parsing. 


\begin{DoxyParams}{Parameters}
{\em identifier} & The name of the parameter in question. \\
\hline
\end{DoxyParams}
\index{mlpack\+::\+C\+LI@{mlpack\+::\+C\+LI}!Hyphenate\+String@{Hyphenate\+String}}
\index{Hyphenate\+String@{Hyphenate\+String}!mlpack\+::\+C\+LI@{mlpack\+::\+C\+LI}}
\subsubsection[{Hyphenate\+String(const std\+::string \&str, int padding)}]{\setlength{\rightskip}{0pt plus 5cm}static {\bf std\+::string} mlpack\+::\+C\+L\+I\+::\+Hyphenate\+String (
\begin{DoxyParamCaption}
\item[{const {\bf std\+::string} \&}]{str, }
\item[{int}]{padding}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [static]}}\label{classmlpack_1_1CLI_a26a6935007798a90d2632c3f05245f33}


Hyphenate a string or split it onto multiple 80-\/character lines, with some amount of padding on each line. 

This is ued for option output.


\begin{DoxyParams}{Parameters}
{\em str} & String to hyphenate (splits are on \textquotesingle{} \textquotesingle{}). \\
\hline
{\em padding} & Amount of padding on the left for each new line. \\
\hline
\end{DoxyParams}
\index{mlpack\+::\+C\+LI@{mlpack\+::\+C\+LI}!Parse\+Command\+Line@{Parse\+Command\+Line}}
\index{Parse\+Command\+Line@{Parse\+Command\+Line}!mlpack\+::\+C\+LI@{mlpack\+::\+C\+LI}}
\subsubsection[{Parse\+Command\+Line(int argc, char $\ast$$\ast$argv)}]{\setlength{\rightskip}{0pt plus 5cm}static void mlpack\+::\+C\+L\+I\+::\+Parse\+Command\+Line (
\begin{DoxyParamCaption}
\item[{int}]{argc, }
\item[{char $\ast$$\ast$}]{argv}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [static]}}\label{classmlpack_1_1CLI_a1033e1179084cef018a95c42740f662f}


Parses the commandline for arguments. 


\begin{DoxyParams}{Parameters}
{\em argc} & The number of arguments on the commandline. \\
\hline
{\em argv} & The array of arguments as strings. \\
\hline
\end{DoxyParams}
\index{mlpack\+::\+C\+LI@{mlpack\+::\+C\+LI}!Print\+Help@{Print\+Help}}
\index{Print\+Help@{Print\+Help}!mlpack\+::\+C\+LI@{mlpack\+::\+C\+LI}}
\subsubsection[{Print\+Help(const std\+::string \&param="""")}]{\setlength{\rightskip}{0pt plus 5cm}static void mlpack\+::\+C\+L\+I\+::\+Print\+Help (
\begin{DoxyParamCaption}
\item[{const {\bf std\+::string} \&}]{param = {\ttfamily \char`\"{}\char`\"{}}}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [static]}}\label{classmlpack_1_1CLI_a549e31f19f0b34f093b03679774c2e00}


Print out the help info for the given parameter (or all parameters if no argument is specified). 

\index{mlpack\+::\+C\+LI@{mlpack\+::\+C\+LI}!Register\+Program\+Doc@{Register\+Program\+Doc}}
\index{Register\+Program\+Doc@{Register\+Program\+Doc}!mlpack\+::\+C\+LI@{mlpack\+::\+C\+LI}}
\subsubsection[{Register\+Program\+Doc(util\+::\+Program\+Doc $\ast$doc)}]{\setlength{\rightskip}{0pt plus 5cm}static void mlpack\+::\+C\+L\+I\+::\+Register\+Program\+Doc (
\begin{DoxyParamCaption}
\item[{{\bf util\+::\+Program\+Doc} $\ast$}]{doc}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [static]}}\label{classmlpack_1_1CLI_a1387710297754b9e9cee337c0048abab}


Registers a Program\+Doc object, which contains documentation about the program. 

If this method has been called before (that is, if two Program\+Docs are instantiated in the program), a fatal error will occur.


\begin{DoxyParams}{Parameters}
{\em doc} & Pointer to the Program\+Doc object. \\
\hline
\end{DoxyParams}


\subsection{Member Data Documentation}
\index{mlpack\+::\+C\+LI@{mlpack\+::\+C\+LI}!aliases@{aliases}}
\index{aliases@{aliases}!mlpack\+::\+C\+LI@{mlpack\+::\+C\+LI}}
\subsubsection[{aliases}]{\setlength{\rightskip}{0pt plus 5cm}std\+::map$<$char, {\bf std\+::string}$>$ mlpack\+::\+C\+L\+I\+::aliases\hspace{0.3cm}{\ttfamily [private]}}\label{classmlpack_1_1CLI_abc6bf37bcee5acf0deaafbd8e5f21dbb}


Convenience map from alias values to names. 



Definition at line 310 of file cli.\+hpp.

\index{mlpack\+::\+C\+LI@{mlpack\+::\+C\+LI}!desc@{desc}}
\index{desc@{desc}!mlpack\+::\+C\+LI@{mlpack\+::\+C\+LI}}
\subsubsection[{desc}]{\setlength{\rightskip}{0pt plus 5cm}po\+::options\+\_\+description mlpack\+::\+C\+L\+I\+::desc\hspace{0.3cm}{\ttfamily [private]}}\label{classmlpack_1_1CLI_ad07794e7e7cb51ca8aef9165fdd3e83a}


The documentation and names of options. 



Definition at line 300 of file cli.\+hpp.

\index{mlpack\+::\+C\+LI@{mlpack\+::\+C\+LI}!did\+Parse@{did\+Parse}}
\index{did\+Parse@{did\+Parse}!mlpack\+::\+C\+LI@{mlpack\+::\+C\+LI}}
\subsubsection[{did\+Parse}]{\setlength{\rightskip}{0pt plus 5cm}bool mlpack\+::\+C\+L\+I\+::did\+Parse\hspace{0.3cm}{\ttfamily [private]}}\label{classmlpack_1_1CLI_aefcfe29fde9ffab0987b22ddb9335bae}


True, if \doxyref{C\+LI}{p.}{classmlpack_1_1CLI} was used to parse command line options. 



Definition at line 319 of file cli.\+hpp.

\index{mlpack\+::\+C\+LI@{mlpack\+::\+C\+LI}!doc@{doc}}
\index{doc@{doc}!mlpack\+::\+C\+LI@{mlpack\+::\+C\+LI}}
\subsubsection[{doc}]{\setlength{\rightskip}{0pt plus 5cm}{\bf util\+::\+Program\+Doc}$\ast$ mlpack\+::\+C\+L\+I\+::doc}\label{classmlpack_1_1CLI_ae3f7adb8b51b578121c46821a86548f1}


Pointer to the Program\+Doc object. 



Definition at line 333 of file cli.\+hpp.

\index{mlpack\+::\+C\+LI@{mlpack\+::\+C\+LI}!output\+Options@{output\+Options}}
\index{output\+Options@{output\+Options}!mlpack\+::\+C\+LI@{mlpack\+::\+C\+LI}}
\subsubsection[{output\+Options}]{\setlength{\rightskip}{0pt plus 5cm}std\+::list$<${\bf std\+::string}$>$ mlpack\+::\+C\+L\+I\+::output\+Options\hspace{0.3cm}{\ttfamily [private]}}\label{classmlpack_1_1CLI_a0655cbb006d03d77e9f24c66109795df}


Convenience list of output options. 



Definition at line 306 of file cli.\+hpp.

\index{mlpack\+::\+C\+LI@{mlpack\+::\+C\+LI}!parameters@{parameters}}
\index{parameters@{parameters}!mlpack\+::\+C\+LI@{mlpack\+::\+C\+LI}}
\subsubsection[{parameters}]{\setlength{\rightskip}{0pt plus 5cm}std\+::map$<${\bf std\+::string}, {\bf util\+::\+Param\+Data}$>$ mlpack\+::\+C\+L\+I\+::parameters\hspace{0.3cm}{\ttfamily [private]}}\label{classmlpack_1_1CLI_a2f07a60a407cfb4f53346a585af337b0}


Map of parameters. 



Definition at line 313 of file cli.\+hpp.

\index{mlpack\+::\+C\+LI@{mlpack\+::\+C\+LI}!program\+Name@{program\+Name}}
\index{program\+Name@{program\+Name}!mlpack\+::\+C\+LI@{mlpack\+::\+C\+LI}}
\subsubsection[{program\+Name}]{\setlength{\rightskip}{0pt plus 5cm}{\bf std\+::string} mlpack\+::\+C\+L\+I\+::program\+Name\hspace{0.3cm}{\ttfamily [private]}}\label{classmlpack_1_1CLI_a11f647501dcca51fd44e695ea12c34e8}


Holds the name of the program for --version. 

This is the true program name (argv[0]) not what is given in Program\+Doc. 

Definition at line 323 of file cli.\+hpp.

\index{mlpack\+::\+C\+LI@{mlpack\+::\+C\+LI}!required\+Options@{required\+Options}}
\index{required\+Options@{required\+Options}!mlpack\+::\+C\+LI@{mlpack\+::\+C\+LI}}
\subsubsection[{required\+Options}]{\setlength{\rightskip}{0pt plus 5cm}std\+::list$<${\bf std\+::string}$>$ mlpack\+::\+C\+L\+I\+::required\+Options\hspace{0.3cm}{\ttfamily [private]}}\label{classmlpack_1_1CLI_a541ac19cca46a88a55545f553bf3c3ff}


Convenience list of required options. 



Definition at line 308 of file cli.\+hpp.

\index{mlpack\+::\+C\+LI@{mlpack\+::\+C\+LI}!singleton@{singleton}}
\index{singleton@{singleton}!mlpack\+::\+C\+LI@{mlpack\+::\+C\+LI}}
\subsubsection[{singleton}]{\setlength{\rightskip}{0pt plus 5cm}{\bf C\+LI}$\ast$ mlpack\+::\+C\+L\+I\+::singleton\hspace{0.3cm}{\ttfamily [static]}, {\ttfamily [private]}}\label{classmlpack_1_1CLI_a5b1935a9dc23280d5b1749265efd6129}


The singleton itself. 



Definition at line 316 of file cli.\+hpp.

\index{mlpack\+::\+C\+LI@{mlpack\+::\+C\+LI}!timer@{timer}}
\index{timer@{timer}!mlpack\+::\+C\+LI@{mlpack\+::\+C\+LI}}
\subsubsection[{timer}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Timers} mlpack\+::\+C\+L\+I\+::timer\hspace{0.3cm}{\ttfamily [private]}}\label{classmlpack_1_1CLI_a4ae620f2f1c4359fdb65afab8a0e0885}


Holds the timer objects. 



Definition at line 326 of file cli.\+hpp.

\index{mlpack\+::\+C\+LI@{mlpack\+::\+C\+LI}!vmap@{vmap}}
\index{vmap@{vmap}!mlpack\+::\+C\+LI@{mlpack\+::\+C\+LI}}
\subsubsection[{vmap}]{\setlength{\rightskip}{0pt plus 5cm}po\+::variables\+\_\+map mlpack\+::\+C\+L\+I\+::vmap\hspace{0.3cm}{\ttfamily [private]}}\label{classmlpack_1_1CLI_ae4f8241a1832fb36ba80a27c3fe9d4f6}


Values of the options given by user. 



Definition at line 303 of file cli.\+hpp.



The documentation for this class was generated from the following file\+:\begin{DoxyCompactItemize}
\item 
src/mlpack/core/util/{\bf cli.\+hpp}\end{DoxyCompactItemize}
