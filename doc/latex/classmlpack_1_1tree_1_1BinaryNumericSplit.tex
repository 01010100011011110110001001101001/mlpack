\section{mlpack\+:\+:tree\+:\+:Binary\+Numeric\+Split$<$ Fitness\+Function, Observation\+Type $>$ Class Template Reference}
\label{classmlpack_1_1tree_1_1BinaryNumericSplit}\index{mlpack\+::tree\+::\+Binary\+Numeric\+Split$<$ Fitness\+Function, Observation\+Type $>$@{mlpack\+::tree\+::\+Binary\+Numeric\+Split$<$ Fitness\+Function, Observation\+Type $>$}}


The \doxyref{Binary\+Numeric\+Split}{p.}{classmlpack_1_1tree_1_1BinaryNumericSplit} class implements the numeric feature splitting strategy devised by Gama, Rocha, and Medas in the following paper\+:  


\subsection*{Public Types}
\begin{DoxyCompactItemize}
\item 
typedef {\bf Binary\+Numeric\+Split\+Info}$<$ Observation\+Type $>$ {\bf Split\+Info}
\begin{DoxyCompactList}\small\item\em The splitting information required by the \doxyref{Binary\+Numeric\+Split}{p.}{classmlpack_1_1tree_1_1BinaryNumericSplit}. \end{DoxyCompactList}\end{DoxyCompactItemize}
\subsection*{Public Member Functions}
\begin{DoxyCompactItemize}
\item 
{\bf Binary\+Numeric\+Split} (const size\+\_\+t num\+Classes)
\begin{DoxyCompactList}\small\item\em Create the \doxyref{Binary\+Numeric\+Split}{p.}{classmlpack_1_1tree_1_1BinaryNumericSplit} object with the given number of classes. \end{DoxyCompactList}\item 
{\bf Binary\+Numeric\+Split} (const size\+\_\+t num\+Classes, const {\bf Binary\+Numeric\+Split} \&other)
\begin{DoxyCompactList}\small\item\em Create the \doxyref{Binary\+Numeric\+Split}{p.}{classmlpack_1_1tree_1_1BinaryNumericSplit} object with the given number of classes, using information from the given other split for other parameters. \end{DoxyCompactList}\item 
void {\bf Evaluate\+Fitness\+Function} (double \&best\+Fitness, double \&second\+Best\+Fitness)
\begin{DoxyCompactList}\small\item\em Given the points seen so far, evaluate the fitness function, returning the best possible gain of a binary split. \end{DoxyCompactList}\item 
size\+\_\+t {\bf Majority\+Class} () const 
\begin{DoxyCompactList}\small\item\em The majority class of the points seen so far. \end{DoxyCompactList}\item 
double {\bf Majority\+Probability} () const 
\begin{DoxyCompactList}\small\item\em The probability of the majority class given the points seen so far. \end{DoxyCompactList}\item 
size\+\_\+t {\bf Num\+Children} () const 
\item 
{\footnotesize template$<$typename Archive $>$ }\\void {\bf Serialize} (Archive \&ar, const unsigned int)
\begin{DoxyCompactList}\small\item\em Serialize the object. \end{DoxyCompactList}\item 
void {\bf Split} (arma\+::\+Col$<$ size\+\_\+t $>$ \&child\+Majorities, {\bf Split\+Info} \&split\+Info)
\begin{DoxyCompactList}\small\item\em Given that a split should happen, return the majority classes of the (two) children and an initialized Split\+Info object. \end{DoxyCompactList}\item 
void {\bf Train} (Observation\+Type value, const size\+\_\+t label)
\begin{DoxyCompactList}\small\item\em Train on the given value with the given label. \end{DoxyCompactList}\end{DoxyCompactItemize}
\subsection*{Private Attributes}
\begin{DoxyCompactItemize}
\item 
Observation\+Type {\bf best\+Split}
\begin{DoxyCompactList}\small\item\em A cached best split point. \end{DoxyCompactList}\item 
arma\+::\+Col$<$ size\+\_\+t $>$ {\bf class\+Counts}
\begin{DoxyCompactList}\small\item\em The classes we have seen so far (for majority calculations). \end{DoxyCompactList}\item 
bool {\bf is\+Accurate}
\begin{DoxyCompactList}\small\item\em If true, the cached best split point is accurate (that is, we have not seen any more samples since we calculated it). \end{DoxyCompactList}\item 
std\+::multimap$<$ Observation\+Type, size\+\_\+t $>$ {\bf sorted\+Elements}
\begin{DoxyCompactList}\small\item\em The elements seen so far, in sorted order. \end{DoxyCompactList}\end{DoxyCompactItemize}


\subsection{Detailed Description}
\subsubsection*{template$<$typename Fitness\+Function, typename Observation\+Type = double$>$\\*
class mlpack\+::tree\+::\+Binary\+Numeric\+Split$<$ Fitness\+Function, Observation\+Type $>$}

The \doxyref{Binary\+Numeric\+Split}{p.}{classmlpack_1_1tree_1_1BinaryNumericSplit} class implements the numeric feature splitting strategy devised by Gama, Rocha, and Medas in the following paper\+: 


\begin{DoxyCode}
@inproceedings\{gama2003accurate,
   title=\{Accurate Decision Trees \textcolor{keywordflow}{for} Mining High-Speed Data Streams\},
   author=\{Gama, J. and Rocha, R. and Medas, P.\},
   year=\{2003\},
   booktitle=\{Proceedings of the Ninth ACM SIGKDD International Conference on
       Knowledge Discovery and Data Mining (KDD \textcolor{stringliteral}{'03)\},}
\textcolor{stringliteral}{   pages=\{523--528\}}
\textcolor{stringliteral}{\}}
\end{DoxyCode}


This splitting procedure builds a binary tree on points it has seen so far, and then \doxyref{Evaluate\+Fitness\+Function()}{p.}{classmlpack_1_1tree_1_1BinaryNumericSplit_a4d64c6c75adba844168cbbe307efde4c} returns the best possible split in O(n) time, where n is the number of samples seen so far. Every split with this split type returns only two splits (greater than or equal to the split point, and less than the split point). The \doxyref{Train()}{p.}{classmlpack_1_1tree_1_1BinaryNumericSplit_abeaea8895e56f89904f83793e434fbb3} function should take O(1) time.


\begin{DoxyTemplParams}{Template Parameters}
{\em Fitness\+Function} & Fitness function to use for calculating gain. \\
\hline
{\em Observation\+Type} & Type of observation used by this dimension. \\
\hline
\end{DoxyTemplParams}


Definition at line 47 of file binary\+\_\+numeric\+\_\+split.\+hpp.



\subsection{Member Typedef Documentation}
\index{mlpack\+::tree\+::\+Binary\+Numeric\+Split@{mlpack\+::tree\+::\+Binary\+Numeric\+Split}!Split\+Info@{Split\+Info}}
\index{Split\+Info@{Split\+Info}!mlpack\+::tree\+::\+Binary\+Numeric\+Split@{mlpack\+::tree\+::\+Binary\+Numeric\+Split}}
\subsubsection[{Split\+Info}]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename Fitness\+Function , typename Observation\+Type  = double$>$ typedef {\bf Binary\+Numeric\+Split\+Info}$<$Observation\+Type$>$ {\bf mlpack\+::tree\+::\+Binary\+Numeric\+Split}$<$ Fitness\+Function, Observation\+Type $>$\+::{\bf Split\+Info}}\label{classmlpack_1_1tree_1_1BinaryNumericSplit_aee2d439f8cca76ded95b74c5afa26cfb}


The splitting information required by the \doxyref{Binary\+Numeric\+Split}{p.}{classmlpack_1_1tree_1_1BinaryNumericSplit}. 



Definition at line 51 of file binary\+\_\+numeric\+\_\+split.\+hpp.



\subsection{Constructor \& Destructor Documentation}
\index{mlpack\+::tree\+::\+Binary\+Numeric\+Split@{mlpack\+::tree\+::\+Binary\+Numeric\+Split}!Binary\+Numeric\+Split@{Binary\+Numeric\+Split}}
\index{Binary\+Numeric\+Split@{Binary\+Numeric\+Split}!mlpack\+::tree\+::\+Binary\+Numeric\+Split@{mlpack\+::tree\+::\+Binary\+Numeric\+Split}}
\subsubsection[{Binary\+Numeric\+Split(const size\+\_\+t num\+Classes)}]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename Fitness\+Function , typename Observation\+Type  = double$>$ {\bf mlpack\+::tree\+::\+Binary\+Numeric\+Split}$<$ Fitness\+Function, Observation\+Type $>$\+::{\bf Binary\+Numeric\+Split} (
\begin{DoxyParamCaption}
\item[{const size\+\_\+t}]{num\+Classes}
\end{DoxyParamCaption}
)}\label{classmlpack_1_1tree_1_1BinaryNumericSplit_abc8708f69f59cfc58cc6a1b13d34129a}


Create the \doxyref{Binary\+Numeric\+Split}{p.}{classmlpack_1_1tree_1_1BinaryNumericSplit} object with the given number of classes. 


\begin{DoxyParams}{Parameters}
{\em num\+Classes} & Number of classes in dataset. \\
\hline
\end{DoxyParams}
\index{mlpack\+::tree\+::\+Binary\+Numeric\+Split@{mlpack\+::tree\+::\+Binary\+Numeric\+Split}!Binary\+Numeric\+Split@{Binary\+Numeric\+Split}}
\index{Binary\+Numeric\+Split@{Binary\+Numeric\+Split}!mlpack\+::tree\+::\+Binary\+Numeric\+Split@{mlpack\+::tree\+::\+Binary\+Numeric\+Split}}
\subsubsection[{Binary\+Numeric\+Split(const size\+\_\+t num\+Classes, const Binary\+Numeric\+Split \&other)}]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename Fitness\+Function , typename Observation\+Type  = double$>$ {\bf mlpack\+::tree\+::\+Binary\+Numeric\+Split}$<$ Fitness\+Function, Observation\+Type $>$\+::{\bf Binary\+Numeric\+Split} (
\begin{DoxyParamCaption}
\item[{const size\+\_\+t}]{num\+Classes, }
\item[{const {\bf Binary\+Numeric\+Split}$<$ Fitness\+Function, Observation\+Type $>$ \&}]{other}
\end{DoxyParamCaption}
)}\label{classmlpack_1_1tree_1_1BinaryNumericSplit_adb8992a07351522a4511b549041aa0f8}


Create the \doxyref{Binary\+Numeric\+Split}{p.}{classmlpack_1_1tree_1_1BinaryNumericSplit} object with the given number of classes, using information from the given other split for other parameters. 

In this case, there are no other parameters, but this function is required by the \doxyref{Hoeffding\+Tree}{p.}{classmlpack_1_1tree_1_1HoeffdingTree} class. 

\subsection{Member Function Documentation}
\index{mlpack\+::tree\+::\+Binary\+Numeric\+Split@{mlpack\+::tree\+::\+Binary\+Numeric\+Split}!Evaluate\+Fitness\+Function@{Evaluate\+Fitness\+Function}}
\index{Evaluate\+Fitness\+Function@{Evaluate\+Fitness\+Function}!mlpack\+::tree\+::\+Binary\+Numeric\+Split@{mlpack\+::tree\+::\+Binary\+Numeric\+Split}}
\subsubsection[{Evaluate\+Fitness\+Function(double \&best\+Fitness, double \&second\+Best\+Fitness)}]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename Fitness\+Function , typename Observation\+Type  = double$>$ void {\bf mlpack\+::tree\+::\+Binary\+Numeric\+Split}$<$ Fitness\+Function, Observation\+Type $>$\+::Evaluate\+Fitness\+Function (
\begin{DoxyParamCaption}
\item[{double \&}]{best\+Fitness, }
\item[{double \&}]{second\+Best\+Fitness}
\end{DoxyParamCaption}
)}\label{classmlpack_1_1tree_1_1BinaryNumericSplit_a4d64c6c75adba844168cbbe307efde4c}


Given the points seen so far, evaluate the fitness function, returning the best possible gain of a binary split. 

Note that this takes O(n) time, where n is the number of points seen so far. So this may not exactly be fast...

The best possible split will be stored in best\+Fitness, and the second best possible split will be stored in second\+Best\+Fitness.


\begin{DoxyParams}{Parameters}
{\em best\+Fitness} & Fitness function value for best possible split. \\
\hline
{\em second\+Best\+Fitness} & Fitness function value for second best possible split. \\
\hline
\end{DoxyParams}
\index{mlpack\+::tree\+::\+Binary\+Numeric\+Split@{mlpack\+::tree\+::\+Binary\+Numeric\+Split}!Majority\+Class@{Majority\+Class}}
\index{Majority\+Class@{Majority\+Class}!mlpack\+::tree\+::\+Binary\+Numeric\+Split@{mlpack\+::tree\+::\+Binary\+Numeric\+Split}}
\subsubsection[{Majority\+Class() const }]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename Fitness\+Function , typename Observation\+Type  = double$>$ size\+\_\+t {\bf mlpack\+::tree\+::\+Binary\+Numeric\+Split}$<$ Fitness\+Function, Observation\+Type $>$\+::Majority\+Class (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
) const}\label{classmlpack_1_1tree_1_1BinaryNumericSplit_a37769243377056af37b41adfec46b8bd}


The majority class of the points seen so far. 



Referenced by mlpack\+::tree\+::\+Binary\+Numeric\+Split$<$ Fitness\+Function, Observation\+Type $>$\+::\+Num\+Children().

\index{mlpack\+::tree\+::\+Binary\+Numeric\+Split@{mlpack\+::tree\+::\+Binary\+Numeric\+Split}!Majority\+Probability@{Majority\+Probability}}
\index{Majority\+Probability@{Majority\+Probability}!mlpack\+::tree\+::\+Binary\+Numeric\+Split@{mlpack\+::tree\+::\+Binary\+Numeric\+Split}}
\subsubsection[{Majority\+Probability() const }]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename Fitness\+Function , typename Observation\+Type  = double$>$ double {\bf mlpack\+::tree\+::\+Binary\+Numeric\+Split}$<$ Fitness\+Function, Observation\+Type $>$\+::Majority\+Probability (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
) const}\label{classmlpack_1_1tree_1_1BinaryNumericSplit_a49c45c24bba4a46094664ac806701320}


The probability of the majority class given the points seen so far. 



Referenced by mlpack\+::tree\+::\+Binary\+Numeric\+Split$<$ Fitness\+Function, Observation\+Type $>$\+::\+Num\+Children().

\index{mlpack\+::tree\+::\+Binary\+Numeric\+Split@{mlpack\+::tree\+::\+Binary\+Numeric\+Split}!Num\+Children@{Num\+Children}}
\index{Num\+Children@{Num\+Children}!mlpack\+::tree\+::\+Binary\+Numeric\+Split@{mlpack\+::tree\+::\+Binary\+Numeric\+Split}}
\subsubsection[{Num\+Children() const }]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename Fitness\+Function , typename Observation\+Type  = double$>$ size\+\_\+t {\bf mlpack\+::tree\+::\+Binary\+Numeric\+Split}$<$ Fitness\+Function, Observation\+Type $>$\+::Num\+Children (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
) const\hspace{0.3cm}{\ttfamily [inline]}}\label{classmlpack_1_1tree_1_1BinaryNumericSplit_ad812be693521007d13f9022f3dcc40fd}


Definition at line 93 of file binary\+\_\+numeric\+\_\+split.\+hpp.



References mlpack\+::tree\+::\+Binary\+Numeric\+Split$<$ Fitness\+Function, Observation\+Type $>$\+::\+Majority\+Class(), mlpack\+::tree\+::\+Binary\+Numeric\+Split$<$ Fitness\+Function, Observation\+Type $>$\+::\+Majority\+Probability(), mlpack\+::tree\+::\+Binary\+Numeric\+Split$<$ Fitness\+Function, Observation\+Type $>$\+::\+Serialize(), and mlpack\+::tree\+::\+Binary\+Numeric\+Split$<$ Fitness\+Function, Observation\+Type $>$\+::\+Split().

\index{mlpack\+::tree\+::\+Binary\+Numeric\+Split@{mlpack\+::tree\+::\+Binary\+Numeric\+Split}!Serialize@{Serialize}}
\index{Serialize@{Serialize}!mlpack\+::tree\+::\+Binary\+Numeric\+Split@{mlpack\+::tree\+::\+Binary\+Numeric\+Split}}
\subsubsection[{Serialize(\+Archive \&ar, const unsigned int)}]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename Fitness\+Function , typename Observation\+Type  = double$>$ template$<$typename Archive $>$ void {\bf mlpack\+::tree\+::\+Binary\+Numeric\+Split}$<$ Fitness\+Function, Observation\+Type $>$\+::Serialize (
\begin{DoxyParamCaption}
\item[{Archive \&}]{ar, }
\item[{const unsigned}]{int}
\end{DoxyParamCaption}
)}\label{classmlpack_1_1tree_1_1BinaryNumericSplit_ada680ee52b021bbfdd64d76c8943048c}


Serialize the object. 



Referenced by mlpack\+::tree\+::\+Binary\+Numeric\+Split$<$ Fitness\+Function, Observation\+Type $>$\+::\+Num\+Children().

\index{mlpack\+::tree\+::\+Binary\+Numeric\+Split@{mlpack\+::tree\+::\+Binary\+Numeric\+Split}!Split@{Split}}
\index{Split@{Split}!mlpack\+::tree\+::\+Binary\+Numeric\+Split@{mlpack\+::tree\+::\+Binary\+Numeric\+Split}}
\subsubsection[{Split(arma\+::\+Col$<$ size\+\_\+t $>$ \&child\+Majorities, Split\+Info \&split\+Info)}]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename Fitness\+Function , typename Observation\+Type  = double$>$ void {\bf mlpack\+::tree\+::\+Binary\+Numeric\+Split}$<$ Fitness\+Function, Observation\+Type $>$\+::Split (
\begin{DoxyParamCaption}
\item[{arma\+::\+Col$<$ size\+\_\+t $>$ \&}]{child\+Majorities, }
\item[{{\bf Split\+Info} \&}]{split\+Info}
\end{DoxyParamCaption}
)}\label{classmlpack_1_1tree_1_1BinaryNumericSplit_a3613e157797f9f591c99671211cea694}


Given that a split should happen, return the majority classes of the (two) children and an initialized Split\+Info object. 


\begin{DoxyParams}{Parameters}
{\em child\+Majorities} & Majority classes of the children after the split. \\
\hline
{\em split\+Info} & Split information. \\
\hline
\end{DoxyParams}


Referenced by mlpack\+::tree\+::\+Binary\+Numeric\+Split$<$ Fitness\+Function, Observation\+Type $>$\+::\+Num\+Children().

\index{mlpack\+::tree\+::\+Binary\+Numeric\+Split@{mlpack\+::tree\+::\+Binary\+Numeric\+Split}!Train@{Train}}
\index{Train@{Train}!mlpack\+::tree\+::\+Binary\+Numeric\+Split@{mlpack\+::tree\+::\+Binary\+Numeric\+Split}}
\subsubsection[{Train(\+Observation\+Type value, const size\+\_\+t label)}]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename Fitness\+Function , typename Observation\+Type  = double$>$ void {\bf mlpack\+::tree\+::\+Binary\+Numeric\+Split}$<$ Fitness\+Function, Observation\+Type $>$\+::Train (
\begin{DoxyParamCaption}
\item[{Observation\+Type}]{value, }
\item[{const size\+\_\+t}]{label}
\end{DoxyParamCaption}
)}\label{classmlpack_1_1tree_1_1BinaryNumericSplit_abeaea8895e56f89904f83793e434fbb3}


Train on the given value with the given label. 


\begin{DoxyParams}{Parameters}
{\em value} & The value to train on. \\
\hline
{\em label} & The label to train on. \\
\hline
\end{DoxyParams}


\subsection{Member Data Documentation}
\index{mlpack\+::tree\+::\+Binary\+Numeric\+Split@{mlpack\+::tree\+::\+Binary\+Numeric\+Split}!best\+Split@{best\+Split}}
\index{best\+Split@{best\+Split}!mlpack\+::tree\+::\+Binary\+Numeric\+Split@{mlpack\+::tree\+::\+Binary\+Numeric\+Split}}
\subsubsection[{best\+Split}]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename Fitness\+Function , typename Observation\+Type  = double$>$ Observation\+Type {\bf mlpack\+::tree\+::\+Binary\+Numeric\+Split}$<$ Fitness\+Function, Observation\+Type $>$\+::best\+Split\hspace{0.3cm}{\ttfamily [private]}}\label{classmlpack_1_1tree_1_1BinaryNumericSplit_a45b02598ef3670b154fdf1ff82189f2f}


A cached best split point. 



Definition at line 120 of file binary\+\_\+numeric\+\_\+split.\+hpp.

\index{mlpack\+::tree\+::\+Binary\+Numeric\+Split@{mlpack\+::tree\+::\+Binary\+Numeric\+Split}!class\+Counts@{class\+Counts}}
\index{class\+Counts@{class\+Counts}!mlpack\+::tree\+::\+Binary\+Numeric\+Split@{mlpack\+::tree\+::\+Binary\+Numeric\+Split}}
\subsubsection[{class\+Counts}]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename Fitness\+Function , typename Observation\+Type  = double$>$ arma\+::\+Col$<$size\+\_\+t$>$ {\bf mlpack\+::tree\+::\+Binary\+Numeric\+Split}$<$ Fitness\+Function, Observation\+Type $>$\+::class\+Counts\hspace{0.3cm}{\ttfamily [private]}}\label{classmlpack_1_1tree_1_1BinaryNumericSplit_afa7a1cca0466ba96e7f8e12f50b0d721}


The classes we have seen so far (for majority calculations). 



Definition at line 117 of file binary\+\_\+numeric\+\_\+split.\+hpp.

\index{mlpack\+::tree\+::\+Binary\+Numeric\+Split@{mlpack\+::tree\+::\+Binary\+Numeric\+Split}!is\+Accurate@{is\+Accurate}}
\index{is\+Accurate@{is\+Accurate}!mlpack\+::tree\+::\+Binary\+Numeric\+Split@{mlpack\+::tree\+::\+Binary\+Numeric\+Split}}
\subsubsection[{is\+Accurate}]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename Fitness\+Function , typename Observation\+Type  = double$>$ bool {\bf mlpack\+::tree\+::\+Binary\+Numeric\+Split}$<$ Fitness\+Function, Observation\+Type $>$\+::is\+Accurate\hspace{0.3cm}{\ttfamily [private]}}\label{classmlpack_1_1tree_1_1BinaryNumericSplit_ae930b1c38e4dd56cdc012b2b64da4877}


If true, the cached best split point is accurate (that is, we have not seen any more samples since we calculated it). 



Definition at line 123 of file binary\+\_\+numeric\+\_\+split.\+hpp.

\index{mlpack\+::tree\+::\+Binary\+Numeric\+Split@{mlpack\+::tree\+::\+Binary\+Numeric\+Split}!sorted\+Elements@{sorted\+Elements}}
\index{sorted\+Elements@{sorted\+Elements}!mlpack\+::tree\+::\+Binary\+Numeric\+Split@{mlpack\+::tree\+::\+Binary\+Numeric\+Split}}
\subsubsection[{sorted\+Elements}]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename Fitness\+Function , typename Observation\+Type  = double$>$ std\+::multimap$<$Observation\+Type, size\+\_\+t$>$ {\bf mlpack\+::tree\+::\+Binary\+Numeric\+Split}$<$ Fitness\+Function, Observation\+Type $>$\+::sorted\+Elements\hspace{0.3cm}{\ttfamily [private]}}\label{classmlpack_1_1tree_1_1BinaryNumericSplit_a327b0e3094b57b69401e7ca27321ed72}


The elements seen so far, in sorted order. 



Definition at line 115 of file binary\+\_\+numeric\+\_\+split.\+hpp.



The documentation for this class was generated from the following file\+:\begin{DoxyCompactItemize}
\item 
src/mlpack/methods/hoeffding\+\_\+trees/{\bf binary\+\_\+numeric\+\_\+split.\+hpp}\end{DoxyCompactItemize}
