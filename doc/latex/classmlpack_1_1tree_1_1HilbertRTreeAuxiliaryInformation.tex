\section{mlpack\+:\+:tree\+:\+:Hilbert\+R\+Tree\+Auxiliary\+Information$<$ Tree\+Type, Hilbert\+Value\+Type $>$ Class Template Reference}
\label{classmlpack_1_1tree_1_1HilbertRTreeAuxiliaryInformation}\index{mlpack\+::tree\+::\+Hilbert\+R\+Tree\+Auxiliary\+Information$<$ Tree\+Type, Hilbert\+Value\+Type $>$@{mlpack\+::tree\+::\+Hilbert\+R\+Tree\+Auxiliary\+Information$<$ Tree\+Type, Hilbert\+Value\+Type $>$}}
\subsection*{Public Types}
\begin{DoxyCompactItemize}
\item 
typedef Tree\+Type\+::\+Elem\+Type {\bf Elem\+Type}
\begin{DoxyCompactList}\small\item\em The element type held by the tree. \end{DoxyCompactList}\end{DoxyCompactItemize}
\subsection*{Public Member Functions}
\begin{DoxyCompactItemize}
\item 
{\bf Hilbert\+R\+Tree\+Auxiliary\+Information} ()
\begin{DoxyCompactList}\small\item\em Default constructor. \end{DoxyCompactList}\item 
{\bf Hilbert\+R\+Tree\+Auxiliary\+Information} (const Tree\+Type $\ast$node)
\begin{DoxyCompactList}\small\item\em Construct this as an auxiliary information for the given node. \end{DoxyCompactList}\item 
{\bf Hilbert\+R\+Tree\+Auxiliary\+Information} (const {\bf Hilbert\+R\+Tree\+Auxiliary\+Information} \&other, Tree\+Type $\ast$tree=N\+U\+LL, bool deep\+Copy=true)
\begin{DoxyCompactList}\small\item\em Create an auxiliary information object by copying from another object. \end{DoxyCompactList}\item 
{\bf Hilbert\+R\+Tree\+Auxiliary\+Information} ({\bf Hilbert\+R\+Tree\+Auxiliary\+Information} \&\&other)
\begin{DoxyCompactList}\small\item\em Create an auxiliary information object by moving from the other node. \end{DoxyCompactList}\item 
bool {\bf Handle\+Node\+Insertion} (Tree\+Type $\ast$node, Tree\+Type $\ast$node\+To\+Insert, bool insertion\+Level)
\begin{DoxyCompactList}\small\item\em The Hilbert R tree requires to insert nodes according to their Hilbert value. \end{DoxyCompactList}\item 
bool {\bf Handle\+Node\+Removal} (Tree\+Type $\ast$node, const size\+\_\+t node\+Index)
\begin{DoxyCompactList}\small\item\em The Hilbert R tree requires all nodes to be arranged according to their Hilbert value. \end{DoxyCompactList}\item 
bool {\bf Handle\+Point\+Deletion} (Tree\+Type $\ast$node, const size\+\_\+t local\+Index)
\begin{DoxyCompactList}\small\item\em The Hilbert R tree requires all points to be arranged according to their Hilbert value. \end{DoxyCompactList}\item 
bool {\bf Handle\+Point\+Insertion} (Tree\+Type $\ast$node, const size\+\_\+t point)
\begin{DoxyCompactList}\small\item\em The Hilbert R tree requires to insert points according to their Hilbert value. \end{DoxyCompactList}\item 
const Hilbert\+Value\+Type$<$ {\bf Elem\+Type} $>$ \& {\bf Hilbert\+Value} () const 
\begin{DoxyCompactList}\small\item\em Return the largest Hilbert value of a point covered by the node. \end{DoxyCompactList}\item 
Hilbert\+Value\+Type$<$ {\bf Elem\+Type} $>$ \& {\bf Hilbert\+Value} ()
\begin{DoxyCompactList}\small\item\em Modify the largest Hilbert value of a point covered by the node. \end{DoxyCompactList}\item 
void {\bf Nullify\+Data} ()
\begin{DoxyCompactList}\small\item\em Clear memory. \end{DoxyCompactList}\item 
{\bf Hilbert\+R\+Tree\+Auxiliary\+Information} \& {\bf operator=} (const {\bf Hilbert\+R\+Tree\+Auxiliary\+Information} \&other)
\begin{DoxyCompactList}\small\item\em Copy the auxiliary information. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename Archive $>$ }\\void {\bf Serialize} (Archive \&ar, const unsigned int)
\begin{DoxyCompactList}\small\item\em Serialize the information. \end{DoxyCompactList}\item 
bool {\bf Update\+Auxiliary\+Info} (Tree\+Type $\ast$node)
\begin{DoxyCompactList}\small\item\em Update the auxiliary information in the node. \end{DoxyCompactList}\end{DoxyCompactItemize}
\subsection*{Static Public Member Functions}
\begin{DoxyCompactItemize}
\item 
static const std\+::vector$<$ Tree\+Type $\ast$ $>$ {\bf Children} (const Tree\+Type $\ast$tree)
\begin{DoxyCompactList}\small\item\em Return the children vector of the tree. \end{DoxyCompactList}\end{DoxyCompactItemize}
\subsection*{Private Attributes}
\begin{DoxyCompactItemize}
\item 
Hilbert\+Value\+Type$<$ {\bf Elem\+Type} $>$ {\bf hilbert\+Value}
\begin{DoxyCompactList}\small\item\em The largest Hilbert value of a point enclosed by the node. \end{DoxyCompactList}\end{DoxyCompactItemize}


\subsection{Detailed Description}
\subsubsection*{template$<$typename Tree\+Type, template$<$ typename $>$ class Hilbert\+Value\+Type$>$\\*
class mlpack\+::tree\+::\+Hilbert\+R\+Tree\+Auxiliary\+Information$<$ Tree\+Type, Hilbert\+Value\+Type $>$}



Definition at line 22 of file hilbert\+\_\+r\+\_\+tree\+\_\+auxiliary\+\_\+information.\+hpp.



\subsection{Member Typedef Documentation}
\index{mlpack\+::tree\+::\+Hilbert\+R\+Tree\+Auxiliary\+Information@{mlpack\+::tree\+::\+Hilbert\+R\+Tree\+Auxiliary\+Information}!Elem\+Type@{Elem\+Type}}
\index{Elem\+Type@{Elem\+Type}!mlpack\+::tree\+::\+Hilbert\+R\+Tree\+Auxiliary\+Information@{mlpack\+::tree\+::\+Hilbert\+R\+Tree\+Auxiliary\+Information}}
\subsubsection[{Elem\+Type}]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename Tree\+Type , template$<$ typename $>$ class Hilbert\+Value\+Type$>$ typedef Tree\+Type\+::\+Elem\+Type {\bf mlpack\+::tree\+::\+Hilbert\+R\+Tree\+Auxiliary\+Information}$<$ Tree\+Type, Hilbert\+Value\+Type $>$\+::{\bf Elem\+Type}}\label{classmlpack_1_1tree_1_1HilbertRTreeAuxiliaryInformation_a3412e31e4176c5c8efd187b5e7c9d79b}


The element type held by the tree. 



Definition at line 26 of file hilbert\+\_\+r\+\_\+tree\+\_\+auxiliary\+\_\+information.\+hpp.



\subsection{Constructor \& Destructor Documentation}
\index{mlpack\+::tree\+::\+Hilbert\+R\+Tree\+Auxiliary\+Information@{mlpack\+::tree\+::\+Hilbert\+R\+Tree\+Auxiliary\+Information}!Hilbert\+R\+Tree\+Auxiliary\+Information@{Hilbert\+R\+Tree\+Auxiliary\+Information}}
\index{Hilbert\+R\+Tree\+Auxiliary\+Information@{Hilbert\+R\+Tree\+Auxiliary\+Information}!mlpack\+::tree\+::\+Hilbert\+R\+Tree\+Auxiliary\+Information@{mlpack\+::tree\+::\+Hilbert\+R\+Tree\+Auxiliary\+Information}}
\subsubsection[{Hilbert\+R\+Tree\+Auxiliary\+Information()}]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename Tree\+Type , template$<$ typename $>$ class Hilbert\+Value\+Type$>$ {\bf mlpack\+::tree\+::\+Hilbert\+R\+Tree\+Auxiliary\+Information}$<$ Tree\+Type, Hilbert\+Value\+Type $>$\+::{\bf Hilbert\+R\+Tree\+Auxiliary\+Information} (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)}\label{classmlpack_1_1tree_1_1HilbertRTreeAuxiliaryInformation_a973f3f342560b0521e41385ed8200e95}


Default constructor. 

\index{mlpack\+::tree\+::\+Hilbert\+R\+Tree\+Auxiliary\+Information@{mlpack\+::tree\+::\+Hilbert\+R\+Tree\+Auxiliary\+Information}!Hilbert\+R\+Tree\+Auxiliary\+Information@{Hilbert\+R\+Tree\+Auxiliary\+Information}}
\index{Hilbert\+R\+Tree\+Auxiliary\+Information@{Hilbert\+R\+Tree\+Auxiliary\+Information}!mlpack\+::tree\+::\+Hilbert\+R\+Tree\+Auxiliary\+Information@{mlpack\+::tree\+::\+Hilbert\+R\+Tree\+Auxiliary\+Information}}
\subsubsection[{Hilbert\+R\+Tree\+Auxiliary\+Information(const Tree\+Type $\ast$node)}]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename Tree\+Type , template$<$ typename $>$ class Hilbert\+Value\+Type$>$ {\bf mlpack\+::tree\+::\+Hilbert\+R\+Tree\+Auxiliary\+Information}$<$ Tree\+Type, Hilbert\+Value\+Type $>$\+::{\bf Hilbert\+R\+Tree\+Auxiliary\+Information} (
\begin{DoxyParamCaption}
\item[{const Tree\+Type $\ast$}]{node}
\end{DoxyParamCaption}
)}\label{classmlpack_1_1tree_1_1HilbertRTreeAuxiliaryInformation_a76d71b129c7bf2c675a561e578670dc2}


Construct this as an auxiliary information for the given node. 


\begin{DoxyParams}{Parameters}
{\em node} & The node that stores this auxiliary information. \\
\hline
\end{DoxyParams}
\index{mlpack\+::tree\+::\+Hilbert\+R\+Tree\+Auxiliary\+Information@{mlpack\+::tree\+::\+Hilbert\+R\+Tree\+Auxiliary\+Information}!Hilbert\+R\+Tree\+Auxiliary\+Information@{Hilbert\+R\+Tree\+Auxiliary\+Information}}
\index{Hilbert\+R\+Tree\+Auxiliary\+Information@{Hilbert\+R\+Tree\+Auxiliary\+Information}!mlpack\+::tree\+::\+Hilbert\+R\+Tree\+Auxiliary\+Information@{mlpack\+::tree\+::\+Hilbert\+R\+Tree\+Auxiliary\+Information}}
\subsubsection[{Hilbert\+R\+Tree\+Auxiliary\+Information(const Hilbert\+R\+Tree\+Auxiliary\+Information \&other, Tree\+Type $\ast$tree=\+N\+U\+L\+L, bool deep\+Copy=true)}]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename Tree\+Type , template$<$ typename $>$ class Hilbert\+Value\+Type$>$ {\bf mlpack\+::tree\+::\+Hilbert\+R\+Tree\+Auxiliary\+Information}$<$ Tree\+Type, Hilbert\+Value\+Type $>$\+::{\bf Hilbert\+R\+Tree\+Auxiliary\+Information} (
\begin{DoxyParamCaption}
\item[{const {\bf Hilbert\+R\+Tree\+Auxiliary\+Information}$<$ Tree\+Type, Hilbert\+Value\+Type $>$ \&}]{other, }
\item[{Tree\+Type $\ast$}]{tree = {\ttfamily NULL}, }
\item[{bool}]{deep\+Copy = {\ttfamily true}}
\end{DoxyParamCaption}
)}\label{classmlpack_1_1tree_1_1HilbertRTreeAuxiliaryInformation_a8d93a953d6198fb3496e8c3fa03aa056}


Create an auxiliary information object by copying from another object. 


\begin{DoxyParams}{Parameters}
{\em other} & Another auxiliary information object from which the information will be copied. \\
\hline
{\em tree} & The node that holds the auxiliary information. \\
\hline
{\em deep\+Copy} & If false, the new object uses the same memory (not used here). \\
\hline
\end{DoxyParams}
\index{mlpack\+::tree\+::\+Hilbert\+R\+Tree\+Auxiliary\+Information@{mlpack\+::tree\+::\+Hilbert\+R\+Tree\+Auxiliary\+Information}!Hilbert\+R\+Tree\+Auxiliary\+Information@{Hilbert\+R\+Tree\+Auxiliary\+Information}}
\index{Hilbert\+R\+Tree\+Auxiliary\+Information@{Hilbert\+R\+Tree\+Auxiliary\+Information}!mlpack\+::tree\+::\+Hilbert\+R\+Tree\+Auxiliary\+Information@{mlpack\+::tree\+::\+Hilbert\+R\+Tree\+Auxiliary\+Information}}
\subsubsection[{Hilbert\+R\+Tree\+Auxiliary\+Information(\+Hilbert\+R\+Tree\+Auxiliary\+Information \&\&other)}]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename Tree\+Type , template$<$ typename $>$ class Hilbert\+Value\+Type$>$ {\bf mlpack\+::tree\+::\+Hilbert\+R\+Tree\+Auxiliary\+Information}$<$ Tree\+Type, Hilbert\+Value\+Type $>$\+::{\bf Hilbert\+R\+Tree\+Auxiliary\+Information} (
\begin{DoxyParamCaption}
\item[{{\bf Hilbert\+R\+Tree\+Auxiliary\+Information}$<$ Tree\+Type, Hilbert\+Value\+Type $>$ \&\&}]{other}
\end{DoxyParamCaption}
)}\label{classmlpack_1_1tree_1_1HilbertRTreeAuxiliaryInformation_a09f9ace3fb6dfb9ba1e61fed29eb09e7}


Create an auxiliary information object by moving from the other node. 


\begin{DoxyParams}{Parameters}
{\em other} & The object from which the information will be moved. \\
\hline
\end{DoxyParams}


\subsection{Member Function Documentation}
\index{mlpack\+::tree\+::\+Hilbert\+R\+Tree\+Auxiliary\+Information@{mlpack\+::tree\+::\+Hilbert\+R\+Tree\+Auxiliary\+Information}!Children@{Children}}
\index{Children@{Children}!mlpack\+::tree\+::\+Hilbert\+R\+Tree\+Auxiliary\+Information@{mlpack\+::tree\+::\+Hilbert\+R\+Tree\+Auxiliary\+Information}}
\subsubsection[{Children(const Tree\+Type $\ast$tree)}]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename Tree\+Type , template$<$ typename $>$ class Hilbert\+Value\+Type$>$ static const std\+::vector$<$Tree\+Type$\ast$$>$ {\bf mlpack\+::tree\+::\+Hilbert\+R\+Tree\+Auxiliary\+Information}$<$ Tree\+Type, Hilbert\+Value\+Type $>$\+::Children (
\begin{DoxyParamCaption}
\item[{const Tree\+Type $\ast$}]{tree}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [static]}}\label{classmlpack_1_1tree_1_1HilbertRTreeAuxiliaryInformation_a091b5b8f95d5e06c0f173532ec5e3b1f}


Return the children vector of the tree. 



Definition at line 124 of file hilbert\+\_\+r\+\_\+tree\+\_\+auxiliary\+\_\+information.\+hpp.

\index{mlpack\+::tree\+::\+Hilbert\+R\+Tree\+Auxiliary\+Information@{mlpack\+::tree\+::\+Hilbert\+R\+Tree\+Auxiliary\+Information}!Handle\+Node\+Insertion@{Handle\+Node\+Insertion}}
\index{Handle\+Node\+Insertion@{Handle\+Node\+Insertion}!mlpack\+::tree\+::\+Hilbert\+R\+Tree\+Auxiliary\+Information@{mlpack\+::tree\+::\+Hilbert\+R\+Tree\+Auxiliary\+Information}}
\subsubsection[{Handle\+Node\+Insertion(\+Tree\+Type $\ast$node, Tree\+Type $\ast$node\+To\+Insert, bool insertion\+Level)}]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename Tree\+Type , template$<$ typename $>$ class Hilbert\+Value\+Type$>$ bool {\bf mlpack\+::tree\+::\+Hilbert\+R\+Tree\+Auxiliary\+Information}$<$ Tree\+Type, Hilbert\+Value\+Type $>$\+::Handle\+Node\+Insertion (
\begin{DoxyParamCaption}
\item[{Tree\+Type $\ast$}]{node, }
\item[{Tree\+Type $\ast$}]{node\+To\+Insert, }
\item[{bool}]{insertion\+Level}
\end{DoxyParamCaption}
)}\label{classmlpack_1_1tree_1_1HilbertRTreeAuxiliaryInformation_a3fe74cda65da737d27eee240da175e50}


The Hilbert R tree requires to insert nodes according to their Hilbert value. 

This method should take care of it. It returns false if it does nothing and true if it handles the insertion process.


\begin{DoxyParams}{Parameters}
{\em node} & The node in which the node\+To\+Insert is being inserted. \\
\hline
{\em node\+To\+Insert} & The node being inserted. \\
\hline
{\em insertion\+Level} & The level of the tree at which the node\+To\+Insert should be inserted. \\
\hline
\end{DoxyParams}
\index{mlpack\+::tree\+::\+Hilbert\+R\+Tree\+Auxiliary\+Information@{mlpack\+::tree\+::\+Hilbert\+R\+Tree\+Auxiliary\+Information}!Handle\+Node\+Removal@{Handle\+Node\+Removal}}
\index{Handle\+Node\+Removal@{Handle\+Node\+Removal}!mlpack\+::tree\+::\+Hilbert\+R\+Tree\+Auxiliary\+Information@{mlpack\+::tree\+::\+Hilbert\+R\+Tree\+Auxiliary\+Information}}
\subsubsection[{Handle\+Node\+Removal(\+Tree\+Type $\ast$node, const size\+\_\+t node\+Index)}]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename Tree\+Type , template$<$ typename $>$ class Hilbert\+Value\+Type$>$ bool {\bf mlpack\+::tree\+::\+Hilbert\+R\+Tree\+Auxiliary\+Information}$<$ Tree\+Type, Hilbert\+Value\+Type $>$\+::Handle\+Node\+Removal (
\begin{DoxyParamCaption}
\item[{Tree\+Type $\ast$}]{node, }
\item[{const size\+\_\+t}]{node\+Index}
\end{DoxyParamCaption}
)}\label{classmlpack_1_1tree_1_1HilbertRTreeAuxiliaryInformation_aa77e1101beb6ed53d690b21a66064fd3}


The Hilbert R tree requires all nodes to be arranged according to their Hilbert value. 

This method should take care of saving this property after the deletion process. It returns false if it does nothing and true if it handles the deletion process.


\begin{DoxyParams}{Parameters}
{\em node} & The node from which the node is being deleted. \\
\hline
{\em node\+Index} & The index of the node being deleted. \\
\hline
\end{DoxyParams}
\index{mlpack\+::tree\+::\+Hilbert\+R\+Tree\+Auxiliary\+Information@{mlpack\+::tree\+::\+Hilbert\+R\+Tree\+Auxiliary\+Information}!Handle\+Point\+Deletion@{Handle\+Point\+Deletion}}
\index{Handle\+Point\+Deletion@{Handle\+Point\+Deletion}!mlpack\+::tree\+::\+Hilbert\+R\+Tree\+Auxiliary\+Information@{mlpack\+::tree\+::\+Hilbert\+R\+Tree\+Auxiliary\+Information}}
\subsubsection[{Handle\+Point\+Deletion(\+Tree\+Type $\ast$node, const size\+\_\+t local\+Index)}]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename Tree\+Type , template$<$ typename $>$ class Hilbert\+Value\+Type$>$ bool {\bf mlpack\+::tree\+::\+Hilbert\+R\+Tree\+Auxiliary\+Information}$<$ Tree\+Type, Hilbert\+Value\+Type $>$\+::Handle\+Point\+Deletion (
\begin{DoxyParamCaption}
\item[{Tree\+Type $\ast$}]{node, }
\item[{const size\+\_\+t}]{local\+Index}
\end{DoxyParamCaption}
)}\label{classmlpack_1_1tree_1_1HilbertRTreeAuxiliaryInformation_ae5f5a1ff415f3e2d7b986fa5a02d7802}


The Hilbert R tree requires all points to be arranged according to their Hilbert value. 

This method should take care of saving this property after the deletion process. It returns false if it does nothing and true if it handles the deletion process.


\begin{DoxyParams}{Parameters}
{\em node} & The node from which the point is being deleted. \\
\hline
{\em local\+Index} & The index of the point being deleted. \\
\hline
\end{DoxyParams}
\index{mlpack\+::tree\+::\+Hilbert\+R\+Tree\+Auxiliary\+Information@{mlpack\+::tree\+::\+Hilbert\+R\+Tree\+Auxiliary\+Information}!Handle\+Point\+Insertion@{Handle\+Point\+Insertion}}
\index{Handle\+Point\+Insertion@{Handle\+Point\+Insertion}!mlpack\+::tree\+::\+Hilbert\+R\+Tree\+Auxiliary\+Information@{mlpack\+::tree\+::\+Hilbert\+R\+Tree\+Auxiliary\+Information}}
\subsubsection[{Handle\+Point\+Insertion(\+Tree\+Type $\ast$node, const size\+\_\+t point)}]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename Tree\+Type , template$<$ typename $>$ class Hilbert\+Value\+Type$>$ bool {\bf mlpack\+::tree\+::\+Hilbert\+R\+Tree\+Auxiliary\+Information}$<$ Tree\+Type, Hilbert\+Value\+Type $>$\+::Handle\+Point\+Insertion (
\begin{DoxyParamCaption}
\item[{Tree\+Type $\ast$}]{node, }
\item[{const size\+\_\+t}]{point}
\end{DoxyParamCaption}
)}\label{classmlpack_1_1tree_1_1HilbertRTreeAuxiliaryInformation_acad6cbc10ee05f466c022b3a030be52a}


The Hilbert R tree requires to insert points according to their Hilbert value. 

This method should take care of it. It returns false if it does nothing and true if it handles the insertion process.


\begin{DoxyParams}{Parameters}
{\em node} & The node in which the point is being inserted. \\
\hline
{\em point} & The number of the point being inserted. \\
\hline
\end{DoxyParams}
\index{mlpack\+::tree\+::\+Hilbert\+R\+Tree\+Auxiliary\+Information@{mlpack\+::tree\+::\+Hilbert\+R\+Tree\+Auxiliary\+Information}!Hilbert\+Value@{Hilbert\+Value}}
\index{Hilbert\+Value@{Hilbert\+Value}!mlpack\+::tree\+::\+Hilbert\+R\+Tree\+Auxiliary\+Information@{mlpack\+::tree\+::\+Hilbert\+R\+Tree\+Auxiliary\+Information}}
\subsubsection[{Hilbert\+Value() const }]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename Tree\+Type , template$<$ typename $>$ class Hilbert\+Value\+Type$>$ const Hilbert\+Value\+Type$<${\bf Elem\+Type}$>$\& {\bf mlpack\+::tree\+::\+Hilbert\+R\+Tree\+Auxiliary\+Information}$<$ Tree\+Type, Hilbert\+Value\+Type $>$\+::Hilbert\+Value (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
) const\hspace{0.3cm}{\ttfamily [inline]}}\label{classmlpack_1_1tree_1_1HilbertRTreeAuxiliaryInformation_a3a658e0fa5f192dc3721fb544be38b45}


Return the largest Hilbert value of a point covered by the node. 



Definition at line 133 of file hilbert\+\_\+r\+\_\+tree\+\_\+auxiliary\+\_\+information.\+hpp.



References mlpack\+::tree\+::\+Hilbert\+R\+Tree\+Auxiliary\+Information$<$ Tree\+Type, Hilbert\+Value\+Type $>$\+::hilbert\+Value.

\index{mlpack\+::tree\+::\+Hilbert\+R\+Tree\+Auxiliary\+Information@{mlpack\+::tree\+::\+Hilbert\+R\+Tree\+Auxiliary\+Information}!Hilbert\+Value@{Hilbert\+Value}}
\index{Hilbert\+Value@{Hilbert\+Value}!mlpack\+::tree\+::\+Hilbert\+R\+Tree\+Auxiliary\+Information@{mlpack\+::tree\+::\+Hilbert\+R\+Tree\+Auxiliary\+Information}}
\subsubsection[{Hilbert\+Value()}]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename Tree\+Type , template$<$ typename $>$ class Hilbert\+Value\+Type$>$ Hilbert\+Value\+Type$<${\bf Elem\+Type}$>$\& {\bf mlpack\+::tree\+::\+Hilbert\+R\+Tree\+Auxiliary\+Information}$<$ Tree\+Type, Hilbert\+Value\+Type $>$\+::Hilbert\+Value (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}}\label{classmlpack_1_1tree_1_1HilbertRTreeAuxiliaryInformation_ad60a1b12ee0e9bc0d00bb00a1c86d92c}


Modify the largest Hilbert value of a point covered by the node. 



Definition at line 136 of file hilbert\+\_\+r\+\_\+tree\+\_\+auxiliary\+\_\+information.\+hpp.



References mlpack\+::tree\+::\+Hilbert\+R\+Tree\+Auxiliary\+Information$<$ Tree\+Type, Hilbert\+Value\+Type $>$\+::hilbert\+Value, and mlpack\+::tree\+::\+Hilbert\+R\+Tree\+Auxiliary\+Information$<$ Tree\+Type, Hilbert\+Value\+Type $>$\+::\+Serialize().

\index{mlpack\+::tree\+::\+Hilbert\+R\+Tree\+Auxiliary\+Information@{mlpack\+::tree\+::\+Hilbert\+R\+Tree\+Auxiliary\+Information}!Nullify\+Data@{Nullify\+Data}}
\index{Nullify\+Data@{Nullify\+Data}!mlpack\+::tree\+::\+Hilbert\+R\+Tree\+Auxiliary\+Information@{mlpack\+::tree\+::\+Hilbert\+R\+Tree\+Auxiliary\+Information}}
\subsubsection[{Nullify\+Data()}]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename Tree\+Type , template$<$ typename $>$ class Hilbert\+Value\+Type$>$ void {\bf mlpack\+::tree\+::\+Hilbert\+R\+Tree\+Auxiliary\+Information}$<$ Tree\+Type, Hilbert\+Value\+Type $>$\+::Nullify\+Data (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)}\label{classmlpack_1_1tree_1_1HilbertRTreeAuxiliaryInformation_a522c84f7a280f38fa375dd5a1e619e2b}


Clear memory. 

\index{mlpack\+::tree\+::\+Hilbert\+R\+Tree\+Auxiliary\+Information@{mlpack\+::tree\+::\+Hilbert\+R\+Tree\+Auxiliary\+Information}!operator=@{operator=}}
\index{operator=@{operator=}!mlpack\+::tree\+::\+Hilbert\+R\+Tree\+Auxiliary\+Information@{mlpack\+::tree\+::\+Hilbert\+R\+Tree\+Auxiliary\+Information}}
\subsubsection[{operator=(const Hilbert\+R\+Tree\+Auxiliary\+Information \&other)}]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename Tree\+Type , template$<$ typename $>$ class Hilbert\+Value\+Type$>$ {\bf Hilbert\+R\+Tree\+Auxiliary\+Information}\& {\bf mlpack\+::tree\+::\+Hilbert\+R\+Tree\+Auxiliary\+Information}$<$ Tree\+Type, Hilbert\+Value\+Type $>$\+::operator= (
\begin{DoxyParamCaption}
\item[{const {\bf Hilbert\+R\+Tree\+Auxiliary\+Information}$<$ Tree\+Type, Hilbert\+Value\+Type $>$ \&}]{other}
\end{DoxyParamCaption}
)}\label{classmlpack_1_1tree_1_1HilbertRTreeAuxiliaryInformation_a6c465af786e597653a3a3810d70f065c}


Copy the auxiliary information. 


\begin{DoxyParams}{Parameters}
{\em other} & The object from which the information will be moved. \\
\hline
\end{DoxyParams}
\index{mlpack\+::tree\+::\+Hilbert\+R\+Tree\+Auxiliary\+Information@{mlpack\+::tree\+::\+Hilbert\+R\+Tree\+Auxiliary\+Information}!Serialize@{Serialize}}
\index{Serialize@{Serialize}!mlpack\+::tree\+::\+Hilbert\+R\+Tree\+Auxiliary\+Information@{mlpack\+::tree\+::\+Hilbert\+R\+Tree\+Auxiliary\+Information}}
\subsubsection[{Serialize(\+Archive \&ar, const unsigned int)}]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename Tree\+Type , template$<$ typename $>$ class Hilbert\+Value\+Type$>$ template$<$typename Archive $>$ void {\bf mlpack\+::tree\+::\+Hilbert\+R\+Tree\+Auxiliary\+Information}$<$ Tree\+Type, Hilbert\+Value\+Type $>$\+::Serialize (
\begin{DoxyParamCaption}
\item[{Archive \&}]{ar, }
\item[{const unsigned}]{int}
\end{DoxyParamCaption}
)}\label{classmlpack_1_1tree_1_1HilbertRTreeAuxiliaryInformation_a4a10e363b4330f85de4e8f4d53834643}


Serialize the information. 



Referenced by mlpack\+::tree\+::\+Hilbert\+R\+Tree\+Auxiliary\+Information$<$ Tree\+Type, Hilbert\+Value\+Type $>$\+::\+Hilbert\+Value().

\index{mlpack\+::tree\+::\+Hilbert\+R\+Tree\+Auxiliary\+Information@{mlpack\+::tree\+::\+Hilbert\+R\+Tree\+Auxiliary\+Information}!Update\+Auxiliary\+Info@{Update\+Auxiliary\+Info}}
\index{Update\+Auxiliary\+Info@{Update\+Auxiliary\+Info}!mlpack\+::tree\+::\+Hilbert\+R\+Tree\+Auxiliary\+Information@{mlpack\+::tree\+::\+Hilbert\+R\+Tree\+Auxiliary\+Information}}
\subsubsection[{Update\+Auxiliary\+Info(\+Tree\+Type $\ast$node)}]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename Tree\+Type , template$<$ typename $>$ class Hilbert\+Value\+Type$>$ bool {\bf mlpack\+::tree\+::\+Hilbert\+R\+Tree\+Auxiliary\+Information}$<$ Tree\+Type, Hilbert\+Value\+Type $>$\+::Update\+Auxiliary\+Info (
\begin{DoxyParamCaption}
\item[{Tree\+Type $\ast$}]{node}
\end{DoxyParamCaption}
)}\label{classmlpack_1_1tree_1_1HilbertRTreeAuxiliaryInformation_a8a57e0dbc07e714d816e8b6be8595c00}


Update the auxiliary information in the node. 

The method returns true if the update should be propagated downward.


\begin{DoxyParams}{Parameters}
{\em node} & The node in which the auxiliary information being update. \\
\hline
\end{DoxyParams}


\subsection{Member Data Documentation}
\index{mlpack\+::tree\+::\+Hilbert\+R\+Tree\+Auxiliary\+Information@{mlpack\+::tree\+::\+Hilbert\+R\+Tree\+Auxiliary\+Information}!hilbert\+Value@{hilbert\+Value}}
\index{hilbert\+Value@{hilbert\+Value}!mlpack\+::tree\+::\+Hilbert\+R\+Tree\+Auxiliary\+Information@{mlpack\+::tree\+::\+Hilbert\+R\+Tree\+Auxiliary\+Information}}
\subsubsection[{hilbert\+Value}]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename Tree\+Type , template$<$ typename $>$ class Hilbert\+Value\+Type$>$ Hilbert\+Value\+Type$<${\bf Elem\+Type}$>$ {\bf mlpack\+::tree\+::\+Hilbert\+R\+Tree\+Auxiliary\+Information}$<$ Tree\+Type, Hilbert\+Value\+Type $>$\+::hilbert\+Value\hspace{0.3cm}{\ttfamily [private]}}\label{classmlpack_1_1tree_1_1HilbertRTreeAuxiliaryInformation_a720ea4150f4760357df2f741698fe0c3}


The largest Hilbert value of a point enclosed by the node. 



Definition at line 129 of file hilbert\+\_\+r\+\_\+tree\+\_\+auxiliary\+\_\+information.\+hpp.



Referenced by mlpack\+::tree\+::\+Hilbert\+R\+Tree\+Auxiliary\+Information$<$ Tree\+Type, Hilbert\+Value\+Type $>$\+::\+Hilbert\+Value().



The documentation for this class was generated from the following file\+:\begin{DoxyCompactItemize}
\item 
src/mlpack/core/tree/rectangle\+\_\+tree/{\bf hilbert\+\_\+r\+\_\+tree\+\_\+auxiliary\+\_\+information.\+hpp}\end{DoxyCompactItemize}
