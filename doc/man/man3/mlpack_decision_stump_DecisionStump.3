.TH "mlpack::decision_stump::DecisionStump< MatType >" 3 "Sat Mar 25 2017" "Version master" "mlpack" \" -*- nroff -*-
.ad l
.nh
.SH NAME
mlpack::decision_stump::DecisionStump< MatType > \- This class implements a decision stump\&.  

.SH SYNOPSIS
.br
.PP
.SS "Public Member Functions"

.in +1c
.ti -1c
.RI "\fBDecisionStump\fP (const MatType &data, const arma::Row< size_t > &labels, const size_t \fBclasses\fP, const size_t \fBbucketSize\fP=10)"
.br
.RI "\fIConstructor\&. \fP"
.ti -1c
.RI "\fBDecisionStump\fP (const \fBDecisionStump\fP<> &other, const MatType &data, const arma::Row< size_t > &labels, const arma::rowvec &weights)"
.br
.RI "\fIAlternate constructor which copies the parameters bucketSize and classes from an already initiated decision stump, other\&. \fP"
.ti -1c
.RI "\fBDecisionStump\fP ()"
.br
.RI "\fICreate a decision stump without training\&. \fP"
.ti -1c
.RI "const arma::Col< size_t > \fBBinLabels\fP () const "
.br
.RI "\fIAccess the labels for each split bin\&. \fP"
.ti -1c
.RI "arma::Col< size_t > & \fBBinLabels\fP ()"
.br
.RI "\fIModify the labels for each split bin (be careful!)\&. \fP"
.ti -1c
.RI "void \fBClassify\fP (const MatType &test, arma::Row< size_t > &predictedLabels)"
.br
.RI "\fIClassification function\&. \fP"
.ti -1c
.RI "template<typename Archive > void \fBSerialize\fP (Archive &ar, const unsigned int)"
.br
.RI "\fISerialize the decision stump\&. \fP"
.ti -1c
.RI "const arma::vec & \fBSplit\fP () const "
.br
.RI "\fIAccess the splitting values\&. \fP"
.ti -1c
.RI "arma::vec & \fBSplit\fP ()"
.br
.RI "\fIModify the splitting values (be careful!)\&. \fP"
.ti -1c
.RI "size_t \fBSplitDimension\fP () const "
.br
.RI "\fIAccess the splitting dimension\&. \fP"
.ti -1c
.RI "size_t & \fBSplitDimension\fP ()"
.br
.RI "\fIModify the splitting dimension (be careful!)\&. \fP"
.ti -1c
.RI "void \fBTrain\fP (const MatType &data, const arma::Row< size_t > &labels, const size_t \fBclasses\fP, const size_t \fBbucketSize\fP)"
.br
.RI "\fITrain the decision stump on the given data\&. \fP"
.ti -1c
.RI "void \fBTrain\fP (const MatType &data, const arma::Row< size_t > &labels, const arma::rowvec &weights, const size_t \fBclasses\fP, const size_t \fBbucketSize\fP)"
.br
.RI "\fITrain the decision stump on the given data, with the given weights\&. \fP"
.in -1c
.SS "Private Member Functions"

.in +1c
.ti -1c
.RI "template<bool UseWeights, typename VecType , typename WeightVecType > double \fBCalculateEntropy\fP (const VecType &labels, const WeightVecType &weights)"
.br
.RI "\fICalculate the entropy of the given dimension\&. \fP"
.ti -1c
.RI "template<typename VecType > double \fBCountMostFreq\fP (const VecType &subCols)"
.br
.RI "\fICount the most frequently occurring element in subCols\&. \fP"
.ti -1c
.RI "template<typename VecType > int \fBIsDistinct\fP (const VecType &featureRow)"
.br
.RI "\fIReturns 1 if all the values of featureRow are not same\&. \fP"
.ti -1c
.RI "void \fBMergeRanges\fP ()"
.br
.RI "\fIAfter the 'split' matrix has been set up, merge ranges with identical class labels\&. \fP"
.ti -1c
.RI "template<bool UseWeights, typename VecType > double \fBSetupSplitDimension\fP (const VecType &dimension, const arma::Row< size_t > &labels, const arma::rowvec &weightD)"
.br
.RI "\fISets up dimension as if it were splitting on it and finds entropy when splitting on dimension\&. \fP"
.ti -1c
.RI "template<bool UseWeights> void \fBTrain\fP (const MatType &data, const arma::Row< size_t > &labels, const arma::rowvec &weights)"
.br
.RI "\fITrain the decision stump on the given data and labels\&. \fP"
.ti -1c
.RI "template<typename VecType > void \fBTrainOnDim\fP (const VecType &dimension, const arma::Row< size_t > &labels)"
.br
.RI "\fIAfter having decided the dimension on which to split, train on that dimension\&. \fP"
.in -1c
.SS "Private Attributes"

.in +1c
.ti -1c
.RI "arma::Col< size_t > \fBbinLabels\fP"
.br
.RI "\fIStores the labels for each splitting bin\&. \fP"
.ti -1c
.RI "size_t \fBbucketSize\fP"
.br
.RI "\fIThe minimum number of points in a bucket\&. \fP"
.ti -1c
.RI "size_t \fBclasses\fP"
.br
.RI "\fIThe number of classes (we must store this for boosting)\&. \fP"
.ti -1c
.RI "arma::vec \fBsplit\fP"
.br
.RI "\fIStores the splitting values after training\&. \fP"
.ti -1c
.RI "size_t \fBsplitDimension\fP"
.br
.RI "\fIStores the value of the dimension on which to split\&. \fP"
.in -1c
.SH "Detailed Description"
.PP 

.SS "template<typename MatType = arma::mat>
.br
class mlpack::decision_stump::DecisionStump< MatType >"
This class implements a decision stump\&. 

It constructs a single level decision tree, i\&.e\&., a decision stump\&. It uses entropy to decide splitting ranges\&.
.PP
The stump is parameterized by a splitting dimension (the dimension on which points are split), a vector of bin split values, and a vector of labels for each bin\&. Bin i is specified by the range [split[i], split[i + 1])\&. The last bin has range up to  (split[i + 1] does not exist in that case)\&. Points that are below the first bin will take the label of the first bin\&.
.PP
\fBTemplate Parameters:\fP
.RS 4
\fIMatType\fP Type of matrix that is being used (sparse or dense)\&. 
.RE
.PP

.PP
Definition at line 34 of file decision_stump\&.hpp\&.
.SH "Constructor & Destructor Documentation"
.PP 
.SS "template<typename MatType = arma::mat> \fBmlpack::decision_stump::DecisionStump\fP< MatType >::\fBDecisionStump\fP (const MatType & data, const arma::Row< size_t > & labels, const size_t classes, const size_t bucketSize = \fC10\fP)"

.PP
Constructor\&. Train on the provided data\&. Generate a decision stump from data\&.
.PP
\fBParameters:\fP
.RS 4
\fIdata\fP Input, training data\&. 
.br
\fIlabels\fP Labels of training data\&. 
.br
\fIclasses\fP Number of distinct classes in labels\&. 
.br
\fIbucketSize\fP Minimum size of bucket when splitting\&. 
.RE
.PP

.SS "template<typename MatType = arma::mat> \fBmlpack::decision_stump::DecisionStump\fP< MatType >::\fBDecisionStump\fP (const \fBDecisionStump\fP<> & other, const MatType & data, const arma::Row< size_t > & labels, const arma::rowvec & weights)"

.PP
Alternate constructor which copies the parameters bucketSize and classes from an already initiated decision stump, other\&. It appropriately sets the weight vector\&.
.PP
\fBParameters:\fP
.RS 4
\fIother\fP The other initiated Decision Stump object from which we copy the values\&. 
.br
\fIdata\fP The data on which to train this object on\&. 
.br
\fIlabels\fP The labels of data\&. 
.br
\fIweights\fP Weight vector to use while training\&. For boosting purposes\&. 
.RE
.PP

.SS "template<typename MatType = arma::mat> \fBmlpack::decision_stump::DecisionStump\fP< MatType >::\fBDecisionStump\fP ()"

.PP
Create a decision stump without training\&. This stump will not be useful and will always return a class of 0 for anything that is to be classified, so it would be a prudent idea to call \fBTrain()\fP after using this constructor\&. 
.SH "Member Function Documentation"
.PP 
.SS "template<typename MatType = arma::mat> const arma::Col<size_t> \fBmlpack::decision_stump::DecisionStump\fP< MatType >::BinLabels () const\fC [inline]\fP"

.PP
Access the labels for each split bin\&. 
.PP
Definition at line 127 of file decision_stump\&.hpp\&.
.PP
References mlpack::decision_stump::DecisionStump< MatType >::binLabels\&.
.SS "template<typename MatType = arma::mat> arma::Col<size_t>& \fBmlpack::decision_stump::DecisionStump\fP< MatType >::BinLabels ()\fC [inline]\fP"

.PP
Modify the labels for each split bin (be careful!)\&. 
.PP
Definition at line 129 of file decision_stump\&.hpp\&.
.PP
References mlpack::decision_stump::DecisionStump< MatType >::binLabels, and mlpack::decision_stump::DecisionStump< MatType >::Serialize()\&.
.SS "template<typename MatType = arma::mat> template<bool UseWeights, typename VecType , typename WeightVecType > double \fBmlpack::decision_stump::DecisionStump\fP< MatType >::CalculateEntropy (const VecType & labels, const WeightVecType & weights)\fC [private]\fP"

.PP
Calculate the entropy of the given dimension\&. 
.PP
\fBParameters:\fP
.RS 4
\fIlabels\fP Corresponding labels of the dimension\&. 
.br
\fIclasses\fP Number of classes\&. 
.br
\fIweights\fP Weights for this set of labels\&. 
.RE
.PP
\fBTemplate Parameters:\fP
.RS 4
\fIUseWeights\fP If true, the weights in the weight vector will be used (otherwise they are ignored)\&. 
.RE
.PP

.SS "template<typename MatType = arma::mat> void \fBmlpack::decision_stump::DecisionStump\fP< MatType >::Classify (const MatType & test, arma::Row< size_t > & predictedLabels)"

.PP
Classification function\&. After training, classify test, and put the predicted classes in predictedLabels\&.
.PP
\fBParameters:\fP
.RS 4
\fItest\fP Testing data or data to classify\&. 
.br
\fIpredictedLabels\fP Vector to store the predicted classes after classifying test data\&. 
.RE
.PP

.SS "template<typename MatType = arma::mat> template<typename VecType > double \fBmlpack::decision_stump::DecisionStump\fP< MatType >::CountMostFreq (const VecType & subCols)\fC [private]\fP"

.PP
Count the most frequently occurring element in subCols\&. 
.PP
\fBParameters:\fP
.RS 4
\fIsubCols\fP The vector in which to find the most frequently occurring element\&. 
.RE
.PP

.SS "template<typename MatType = arma::mat> template<typename VecType > int \fBmlpack::decision_stump::DecisionStump\fP< MatType >::IsDistinct (const VecType & featureRow)\fC [private]\fP"

.PP
Returns 1 if all the values of featureRow are not same\&. 
.PP
\fBParameters:\fP
.RS 4
\fIfeatureRow\fP The dimension which is checked for identical values\&. 
.RE
.PP

.SS "template<typename MatType = arma::mat> void \fBmlpack::decision_stump::DecisionStump\fP< MatType >::MergeRanges ()\fC [private]\fP"

.PP
After the 'split' matrix has been set up, merge ranges with identical class labels\&. 
.SS "template<typename MatType = arma::mat> template<typename Archive > void \fBmlpack::decision_stump::DecisionStump\fP< MatType >::Serialize (Archive & ar, const unsigned int)"

.PP
Serialize the decision stump\&. 
.PP
Referenced by mlpack::decision_stump::DecisionStump< MatType >::BinLabels()\&.
.SS "template<typename MatType = arma::mat> template<bool UseWeights, typename VecType > double \fBmlpack::decision_stump::DecisionStump\fP< MatType >::SetupSplitDimension (const VecType & dimension, const arma::Row< size_t > & labels, const arma::rowvec & weightD)\fC [private]\fP"

.PP
Sets up dimension as if it were splitting on it and finds entropy when splitting on dimension\&. 
.PP
\fBParameters:\fP
.RS 4
\fIdimension\fP A row from the training data, which might be a candidate for the splitting dimension\&. 
.RE
.PP
\fBTemplate Parameters:\fP
.RS 4
\fIUseWeights\fP Whether we need to run a weighted Decision Stump\&. 
.RE
.PP

.SS "template<typename MatType = arma::mat> const arma::vec& \fBmlpack::decision_stump::DecisionStump\fP< MatType >::Split () const\fC [inline]\fP"

.PP
Access the splitting values\&. 
.PP
Definition at line 122 of file decision_stump\&.hpp\&.
.PP
References mlpack::decision_stump::DecisionStump< MatType >::split\&.
.SS "template<typename MatType = arma::mat> arma::vec& \fBmlpack::decision_stump::DecisionStump\fP< MatType >::Split ()\fC [inline]\fP"

.PP
Modify the splitting values (be careful!)\&. 
.PP
Definition at line 124 of file decision_stump\&.hpp\&.
.PP
References mlpack::decision_stump::DecisionStump< MatType >::split\&.
.SS "template<typename MatType = arma::mat> size_t \fBmlpack::decision_stump::DecisionStump\fP< MatType >::SplitDimension () const\fC [inline]\fP"

.PP
Access the splitting dimension\&. 
.PP
Definition at line 117 of file decision_stump\&.hpp\&.
.PP
References mlpack::decision_stump::DecisionStump< MatType >::splitDimension\&.
.SS "template<typename MatType = arma::mat> size_t& \fBmlpack::decision_stump::DecisionStump\fP< MatType >::SplitDimension ()\fC [inline]\fP"

.PP
Modify the splitting dimension (be careful!)\&. 
.PP
Definition at line 119 of file decision_stump\&.hpp\&.
.PP
References mlpack::decision_stump::DecisionStump< MatType >::splitDimension\&.
.SS "template<typename MatType = arma::mat> void \fBmlpack::decision_stump::DecisionStump\fP< MatType >::Train (const MatType & data, const arma::Row< size_t > & labels, const size_t classes, const size_t bucketSize)"

.PP
Train the decision stump on the given data\&. This completely overwrites any previous training data, so after training the stump may be completely different\&.
.PP
\fBParameters:\fP
.RS 4
\fIdata\fP Dataset to train on\&. 
.br
\fIlabels\fP Labels for each point in the dataset\&. 
.br
\fIclasses\fP Number of classes in the dataset\&. 
.br
\fIbucketSize\fP Minimum size of bucket when splitting\&. 
.RE
.PP

.SS "template<typename MatType = arma::mat> void \fBmlpack::decision_stump::DecisionStump\fP< MatType >::Train (const MatType & data, const arma::Row< size_t > & labels, const arma::rowvec & weights, const size_t classes, const size_t bucketSize)"

.PP
Train the decision stump on the given data, with the given weights\&. This completely overwrites any previous training data, so after training the stump may be completely different\&.
.PP
\fBParameters:\fP
.RS 4
\fIdata\fP Dataset to train on\&. 
.br
\fIlabels\fP Labels for each point in the dataset\&. 
.br
\fIweights\fP Weights for each point in the dataset\&. 
.br
\fIclasses\fP Number of classes in the dataset\&. 
.br
\fIbucketSize\fP Minimum size of bucket when splitting\&. 
.RE
.PP

.SS "template<typename MatType = arma::mat> template<bool UseWeights> void \fBmlpack::decision_stump::DecisionStump\fP< MatType >::Train (const MatType & data, const arma::Row< size_t > & labels, const arma::rowvec & weights)\fC [private]\fP"

.PP
Train the decision stump on the given data and labels\&. 
.PP
\fBParameters:\fP
.RS 4
\fIdata\fP Dataset to train on\&. 
.br
\fIlabels\fP Labels for dataset\&. 
.br
\fIweights\fP Weights for this set of labels\&. 
.RE
.PP
\fBTemplate Parameters:\fP
.RS 4
\fIUseWeights\fP If true, the weights in the weight vector will be used (otherwise they are ignored)\&. 
.RE
.PP

.SS "template<typename MatType = arma::mat> template<typename VecType > void \fBmlpack::decision_stump::DecisionStump\fP< MatType >::TrainOnDim (const VecType & dimension, const arma::Row< size_t > & labels)\fC [private]\fP"

.PP
After having decided the dimension on which to split, train on that dimension\&. 
.PP
\fBTemplate Parameters:\fP
.RS 4
\fIdimension\fP dimension is the dimension decided by the constructor on which we now train the decision stump\&. 
.RE
.PP

.SH "Member Data Documentation"
.PP 
.SS "template<typename MatType = arma::mat> arma::Col<size_t> \fBmlpack::decision_stump::DecisionStump\fP< MatType >::binLabels\fC [private]\fP"

.PP
Stores the labels for each splitting bin\&. 
.PP
Definition at line 146 of file decision_stump\&.hpp\&.
.PP
Referenced by mlpack::decision_stump::DecisionStump< MatType >::BinLabels()\&.
.SS "template<typename MatType = arma::mat> size_t \fBmlpack::decision_stump::DecisionStump\fP< MatType >::bucketSize\fC [private]\fP"

.PP
The minimum number of points in a bucket\&. 
.PP
Definition at line 139 of file decision_stump\&.hpp\&.
.SS "template<typename MatType = arma::mat> size_t \fBmlpack::decision_stump::DecisionStump\fP< MatType >::classes\fC [private]\fP"

.PP
The number of classes (we must store this for boosting)\&. 
.PP
Definition at line 137 of file decision_stump\&.hpp\&.
.SS "template<typename MatType = arma::mat> arma::vec \fBmlpack::decision_stump::DecisionStump\fP< MatType >::split\fC [private]\fP"

.PP
Stores the splitting values after training\&. 
.PP
Definition at line 144 of file decision_stump\&.hpp\&.
.PP
Referenced by mlpack::decision_stump::DecisionStump< MatType >::Split()\&.
.SS "template<typename MatType = arma::mat> size_t \fBmlpack::decision_stump::DecisionStump\fP< MatType >::splitDimension\fC [private]\fP"

.PP
Stores the value of the dimension on which to split\&. 
.PP
Definition at line 142 of file decision_stump\&.hpp\&.
.PP
Referenced by mlpack::decision_stump::DecisionStump< MatType >::SplitDimension()\&.

.SH "Author"
.PP 
Generated automatically by Doxygen for mlpack from the source code\&.
