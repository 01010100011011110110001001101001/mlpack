.TH "src/mlpack/core/data/serialization_template_version.hpp" 3 "Sat Mar 25 2017" "Version master" "mlpack" \" -*- nroff -*-
.ad l
.nh
.SH NAME
src/mlpack/core/data/serialization_template_version.hpp \- 
.SH SYNOPSIS
.br
.PP
.SS "Macros"

.in +1c
.ti -1c
.RI "#define \fBBOOST_TEMPLATE_CLASS_VERSION\fP(SIGNATURE,  T,  N)"
.br
.RI "\fIUse this like BOOST_CLASS_VERSION(), but for templated classes\&. \fP"
.in -1c
.SH "Detailed Description"
.PP 

.PP
\fBAuthor:\fP
.RS 4
Ryan Curtin
.RE
.PP
A better version of the BOOST_CLASS_VERSION() macro that supports templated classes\&.
.PP
mlpack is free software; you may redistribute it and/or modify it under the terms of the 3-clause BSD license\&. You should have received a copy of the 3-clause BSD license along with mlpack\&. If not, see http://www.opensource.org/licenses/BSD-3-Clause for more information\&. 
.PP
Definition in file \fBserialization_template_version\&.hpp\fP\&.
.SH "Macro Definition Documentation"
.PP 
.SS "#define BOOST_TEMPLATE_CLASS_VERSION(SIGNATURE, T, N)"
\fBValue:\fP
.PP
.nf
namespace boost { \
namespace serialization { \
SIGNATURE \
struct version<mlpack::data::SecondShim<T>> \
{ \
  typedef mpl::int_<N> type; \
  typedef mpl::integral_c_tag tag; \
  BOOST_STATIC_CONSTANT(int, value = version::type::value); \
  BOOST_MPL_ASSERT(( \
      boost::mpl::less< \
          boost::mpl::int_<N>, \
          boost::mpl::int_<256> \
      > \
  )); \
}; \
} \
}
.fi
.PP
Use this like BOOST_CLASS_VERSION(), but for templated classes\&. The first argument is the signature for the template\&. Here is an example for math::Range<eT>:
.PP
\fBBOOST_TEMPLATE_CLASS_VERSION(template<typename eT>, math::Range<eT>, 1)\fP; 
.PP
Definition at line 23 of file serialization_template_version\&.hpp\&.
.SH "Author"
.PP 
Generated automatically by Doxygen for mlpack from the source code\&.
