.TH "mlpack::neighbor::LSHSearch< SortPolicy >" 3 "Sat Mar 25 2017" "Version master" "mlpack" \" -*- nroff -*-
.ad l
.nh
.SH NAME
mlpack::neighbor::LSHSearch< SortPolicy > \- The \fBLSHSearch\fP class; this class builds a hash on the reference set and uses this hash to compute the distance-approximate nearest-neighbors of the given queries\&.  

.SH SYNOPSIS
.br
.PP
.SS "Classes"

.in +1c
.ti -1c
.RI "struct \fBCandidateCmp\fP"
.br
.RI "\fICompare two candidates based on the distance\&. \fP"
.in -1c
.SS "Public Member Functions"

.in +1c
.ti -1c
.RI "\fBLSHSearch\fP (const arma::mat &\fBreferenceSet\fP, const arma::cube &\fBprojections\fP, const double \fBhashWidth\fP=0\&.0, const size_t \fBsecondHashSize\fP=99901, const size_t \fBbucketSize\fP=500)"
.br
.RI "\fIThis function initializes the LSH class\&. \fP"
.ti -1c
.RI "\fBLSHSearch\fP (const arma::mat &\fBreferenceSet\fP, const size_t \fBnumProj\fP, const size_t \fBnumTables\fP, const double \fBhashWidth\fP=0\&.0, const size_t \fBsecondHashSize\fP=99901, const size_t \fBbucketSize\fP=500)"
.br
.RI "\fIThis function initializes the LSH class\&. \fP"
.ti -1c
.RI "\fBLSHSearch\fP ()"
.br
.RI "\fICreate an untrained LSH model\&. \fP"
.ti -1c
.RI "\fBLSHSearch\fP (const \fBLSHSearch\fP &other)"
.br
.RI "\fICopy the given LSH model\&. \fP"
.ti -1c
.RI "\fBLSHSearch\fP (\fBLSHSearch\fP &&other)"
.br
.RI "\fITake ownership of the given LSH model\&. \fP"
.ti -1c
.RI "\fB~LSHSearch\fP ()"
.br
.RI "\fIClean memory\&. \fP"
.ti -1c
.RI "size_t \fBBucketSize\fP () const "
.br
.RI "\fIGet the bucket size of the second hash\&. \fP"
.ti -1c
.RI "size_t \fBDistanceEvaluations\fP () const "
.br
.RI "\fIReturn the number of distance evaluations performed\&. \fP"
.ti -1c
.RI "size_t & \fBDistanceEvaluations\fP ()"
.br
.RI "\fIModify the number of distance evaluations performed\&. \fP"
.ti -1c
.RI "size_t \fBNumProjections\fP () const "
.br
.RI "\fIGet the number of projections\&. \fP"
.ti -1c
.RI "const arma::mat & \fBOffsets\fP () const "
.br
.RI "\fIGet the offsets 'b' for each of the projections\&. (One 'b' per column\&.) \fP"
.ti -1c
.RI "\fBLSHSearch\fP & \fBoperator=\fP (const \fBLSHSearch\fP &other)"
.br
.RI "\fICopy the given LSH model\&. \fP"
.ti -1c
.RI "\fBLSHSearch\fP & \fBoperator=\fP (\fBLSHSearch\fP &&other)"
.br
.RI "\fITake ownership of the given LSH model\&. \fP"
.ti -1c
.RI "const arma::cube & \fBProjections\fP ()"
.br
.RI "\fIGet the projection tables\&. \fP"
.ti -1c
.RI "void \fBProjections\fP (const arma::cube &projTables)"
.br
.RI "\fIChange the projection tables (this retrains the LSH model)\&. \fP"
.ti -1c
.RI "const arma::mat & \fBReferenceSet\fP () const "
.br
.RI "\fIReturn the reference dataset\&. \fP"
.ti -1c
.RI "void \fBSearch\fP (const arma::mat &querySet, const size_t k, arma::Mat< size_t > &resultingNeighbors, arma::mat &distances, const size_t numTablesToSearch=0, const size_t T=0)"
.br
.RI "\fICompute the nearest neighbors of the points in the given query set and store the output in the given matrices\&. \fP"
.ti -1c
.RI "void \fBSearch\fP (const size_t k, arma::Mat< size_t > &resultingNeighbors, arma::mat &distances, const size_t numTablesToSearch=0, size_t T=0)"
.br
.RI "\fICompute the nearest neighbors and store the output in the given matrices\&. \fP"
.ti -1c
.RI "const std::vector< arma::Col< size_t > > & \fBSecondHashTable\fP () const "
.br
.RI "\fIGet the second hash table\&. \fP"
.ti -1c
.RI "const arma::vec & \fBSecondHashWeights\fP () const "
.br
.RI "\fIGet the weights of the second hash\&. \fP"
.ti -1c
.RI "template<typename Archive > void \fBSerialize\fP (Archive &ar, const unsigned int version)"
.br
.RI "\fISerialize the LSH model\&. \fP"
.ti -1c
.RI "void \fBTrain\fP (const arma::mat &\fBreferenceSet\fP, const size_t \fBnumProj\fP, const size_t \fBnumTables\fP, const double \fBhashWidth\fP=0\&.0, const size_t \fBsecondHashSize\fP=99901, const size_t \fBbucketSize\fP=500, const arma::cube &projection=arma::cube())"
.br
.RI "\fITrain the LSH model on the given dataset\&. \fP"
.in -1c
.SS "Static Public Member Functions"

.in +1c
.ti -1c
.RI "static double \fBComputeRecall\fP (const arma::Mat< size_t > &foundNeighbors, const arma::Mat< size_t > &realNeighbors)"
.br
.RI "\fICompute the recall (% of neighbors found) given the neighbors returned by \fBLSHSearch::Search\fP and a 'ground truth' set of neighbors\&. \fP"
.in -1c
.SS "Private Types"

.in +1c
.ti -1c
.RI "typedef std::pair< double, size_t > \fBCandidate\fP"
.br
.RI "\fICandidate represents a possible candidate neighbor (distance, index)\&. \fP"
.ti -1c
.RI "typedef std::priority_queue< \fBCandidate\fP, std::vector< \fBCandidate\fP >, \fBCandidateCmp\fP > \fBCandidateList\fP"
.br
.RI "\fIUse a priority queue to represent the list of candidate neighbors\&. \fP"
.in -1c
.SS "Private Member Functions"

.in +1c
.ti -1c
.RI "void \fBBaseCase\fP (const size_t queryIndex, const arma::uvec &referenceIndices, const size_t k, arma::Mat< size_t > &neighbors, arma::mat &distances) const "
.br
.RI "\fIThis is a helper function that computes the distance of the query to the neighbor candidates and appropriately stores the best 'k' candidates\&. \fP"
.ti -1c
.RI "void \fBBaseCase\fP (const size_t queryIndex, const arma::uvec &referenceIndices, const size_t k, const arma::mat &querySet, arma::Mat< size_t > &neighbors, arma::mat &distances) const "
.br
.RI "\fIThis is a helper function that computes the distance of the query to the neighbor candidates and appropriately stores the best 'k' candidates\&. \fP"
.ti -1c
.RI "void \fBGetAdditionalProbingBins\fP (const arma::vec &queryCode, const arma::vec &queryCodeNotFloored, const size_t T, arma::mat &additionalProbingBins) const "
.br
.RI "\fIThis function implements the core idea behind Multiprobe LSH\&. \fP"
.ti -1c
.RI "bool \fBPerturbationExpand\fP (std::vector< bool > &A) const "
.br
.RI "\fIInline function used by GetAdditionalProbingBins\&. \fP"
.ti -1c
.RI "double \fBPerturbationScore\fP (const std::vector< bool > &A, const arma::vec &scores) const "
.br
.RI "\fIReturns the score of a perturbation vector generated by perturbation set A\&. \fP"
.ti -1c
.RI "bool \fBPerturbationShift\fP (std::vector< bool > &A) const "
.br
.RI "\fIInline function used by GetAdditionalProbingBins\&. \fP"
.ti -1c
.RI "bool \fBPerturbationValid\fP (const std::vector< bool > &A) const "
.br
.RI "\fIReturn true if perturbation set A is valid\&. \fP"
.ti -1c
.RI "template<typename VecType > void \fBReturnIndicesFromTable\fP (const VecType &queryPoint, arma::uvec &referenceIndices, size_t numTablesToSearch, const size_t T) const "
.br
.RI "\fIThis function takes a query and hashes it into each of the hash tables to get keys for the query and then the key is hashed to a bucket of the second hash table and all the points (if any) in those buckets are collected as the potential neighbor candidates\&. \fP"
.in -1c
.SS "Private Attributes"

.in +1c
.ti -1c
.RI "arma::Col< size_t > \fBbucketContentSize\fP"
.br
.RI "\fIThe number of elements present in each hash bucket; should be secondHashSize\&. \fP"
.ti -1c
.RI "arma::Col< size_t > \fBbucketRowInHashTable\fP"
.br
.RI "\fIFor a particular hash value, points to the row in secondHashTable corresponding to this value\&. \fP"
.ti -1c
.RI "size_t \fBbucketSize\fP"
.br
.RI "\fIThe bucket size of the second hash\&. \fP"
.ti -1c
.RI "size_t \fBdistanceEvaluations\fP"
.br
.RI "\fIThe number of distance evaluations\&. \fP"
.ti -1c
.RI "double \fBhashWidth\fP"
.br
.RI "\fIThe hash width\&. \fP"
.ti -1c
.RI "size_t \fBnumProj\fP"
.br
.RI "\fIThe number of projections\&. \fP"
.ti -1c
.RI "size_t \fBnumTables\fP"
.br
.RI "\fIThe number of hash tables\&. \fP"
.ti -1c
.RI "arma::mat \fBoffsets\fP"
.br
.RI "\fIThe list of the offsets 'b' for each of the projection for each table\&. \fP"
.ti -1c
.RI "bool \fBownsSet\fP"
.br
.RI "\fIIf true, we own the reference set\&. \fP"
.ti -1c
.RI "arma::cube \fBprojections\fP"
.br
.RI "\fIThe arma::cube containing the projection matrix of each table\&. \fP"
.ti -1c
.RI "const arma::mat * \fBreferenceSet\fP"
.br
.RI "\fIReference dataset\&. \fP"
.ti -1c
.RI "size_t \fBsecondHashSize\fP"
.br
.RI "\fIThe big prime representing the size of the second hash\&. \fP"
.ti -1c
.RI "std::vector< arma::Col< size_t > > \fBsecondHashTable\fP"
.br
.RI "\fIThe final hash table; should be (< secondHashSize) vectors each with (<= bucketSize) elements\&. \fP"
.ti -1c
.RI "arma::vec \fBsecondHashWeights\fP"
.br
.RI "\fIThe weights of the second hash\&. \fP"
.in -1c
.SH "Detailed Description"
.PP 

.SS "template<typename SortPolicy = NearestNeighborSort>
.br
class mlpack::neighbor::LSHSearch< SortPolicy >"
The \fBLSHSearch\fP class; this class builds a hash on the reference set and uses this hash to compute the distance-approximate nearest-neighbors of the given queries\&. 


.PP
\fBTemplate Parameters:\fP
.RS 4
\fISortPolicy\fP The sort policy for distances; see \fBNearestNeighborSort\fP\&. 
.RE
.PP

.PP
Definition at line 62 of file lsh_search\&.hpp\&.
.SH "Member Typedef Documentation"
.PP 
.SS "template<typename SortPolicy  = NearestNeighborSort> typedef std::pair<double, size_t> \fBmlpack::neighbor::LSHSearch\fP< SortPolicy >::\fBCandidate\fP\fC [private]\fP"

.PP
Candidate represents a possible candidate neighbor (distance, index)\&. 
.PP
Definition at line 460 of file lsh_search\&.hpp\&.
.SS "template<typename SortPolicy  = NearestNeighborSort> typedef std::priority_queue<\fBCandidate\fP, std::vector<\fBCandidate\fP>, \fBCandidateCmp\fP> \fBmlpack::neighbor::LSHSearch\fP< SortPolicy >::\fBCandidateList\fP\fC [private]\fP"

.PP
Use a priority queue to represent the list of candidate neighbors\&. 
.PP
Definition at line 472 of file lsh_search\&.hpp\&.
.SH "Constructor & Destructor Documentation"
.PP 
.SS "template<typename SortPolicy  = NearestNeighborSort> \fBmlpack::neighbor::LSHSearch\fP< SortPolicy >::\fBLSHSearch\fP (const arma::mat & referenceSet, const arma::cube & projections, const double hashWidth = \fC0\&.0\fP, const size_t secondHashSize = \fC99901\fP, const size_t bucketSize = \fC500\fP)"

.PP
This function initializes the LSH class\&. It builds the hash on the reference set with 2-stable distributions\&. See the individual functions performing the hashing for details on how the hashing is done\&.
.PP
\fBParameters:\fP
.RS 4
\fIreferenceSet\fP Set of reference points and the set of queries\&. 
.br
\fIprojections\fP Cube of projection tables\&. For a cube of size (a, b, c) we set numProj = a, numTables = c\&. b is the reference set dimensionality\&. 
.br
\fIhashWidth\fP The width of hash for every table\&. If 0 (the default) is provided, then the hash width is automatically obtained by computing the average pairwise distance of 25 pairs\&. This should be a reasonable upper bound on the nearest-neighbor distance in general\&. 
.br
\fIsecondHashSize\fP The size of the second hash table\&. This should be a large prime number\&. 
.br
\fIbucketSize\fP The size of the bucket in the second hash table\&. This is the maximum number of points that can be hashed into single bucket\&. A value of 0 indicates that there is no limit (so the second hash table can be arbitrarily large---be careful!)\&. 
.RE
.PP

.SS "template<typename SortPolicy  = NearestNeighborSort> \fBmlpack::neighbor::LSHSearch\fP< SortPolicy >::\fBLSHSearch\fP (const arma::mat & referenceSet, const size_t numProj, const size_t numTables, const double hashWidth = \fC0\&.0\fP, const size_t secondHashSize = \fC99901\fP, const size_t bucketSize = \fC500\fP)"

.PP
This function initializes the LSH class\&. It builds the hash one the reference set using the provided projections\&. See the individual functions performing the hashing for details on how the hashing is done\&.
.PP
\fBParameters:\fP
.RS 4
\fIreferenceSet\fP Set of reference points and the set of queries\&. 
.br
\fInumProj\fP Number of projections in each hash table (anything between 10-50 might be a decent choice)\&. 
.br
\fInumTables\fP Total number of hash tables (anything between 10-20 should suffice)\&. 
.br
\fIhashWidth\fP The width of hash for every table\&. If 0 (the default) is provided, then the hash width is automatically obtained by computing the average pairwise distance of 25 pairs\&. This should be a reasonable upper bound on the nearest-neighbor distance in general\&. 
.br
\fIsecondHashSize\fP The size of the second hash table\&. This should be a large prime number\&. 
.br
\fIbucketSize\fP The size of the bucket in the second hash table\&. This is the maximum number of points that can be hashed into single bucket\&. A value of 0 indicates that there is no limit (so the second hash table can be arbitrarily large---be careful!)\&. 
.RE
.PP

.SS "template<typename SortPolicy  = NearestNeighborSort> \fBmlpack::neighbor::LSHSearch\fP< SortPolicy >::\fBLSHSearch\fP ()"

.PP
Create an untrained LSH model\&. Be sure to call \fBTrain()\fP before calling \fBSearch()\fP; otherwise, an exception will be thrown when \fBSearch()\fP is called\&. 
.SS "template<typename SortPolicy  = NearestNeighborSort> \fBmlpack::neighbor::LSHSearch\fP< SortPolicy >::\fBLSHSearch\fP (const \fBLSHSearch\fP< SortPolicy > & other)"

.PP
Copy the given LSH model\&. 
.PP
\fBParameters:\fP
.RS 4
\fIother\fP Other LSH model to copy\&. 
.RE
.PP

.SS "template<typename SortPolicy  = NearestNeighborSort> \fBmlpack::neighbor::LSHSearch\fP< SortPolicy >::\fBLSHSearch\fP (\fBLSHSearch\fP< SortPolicy > && other)"

.PP
Take ownership of the given LSH model\&. 
.PP
\fBParameters:\fP
.RS 4
\fIother\fP Other LSH model to take ownership of\&. 
.RE
.PP

.SS "template<typename SortPolicy  = NearestNeighborSort> \fBmlpack::neighbor::LSHSearch\fP< SortPolicy >::~\fBLSHSearch\fP ()"

.PP
Clean memory\&. 
.SH "Member Function Documentation"
.PP 
.SS "template<typename SortPolicy  = NearestNeighborSort> void \fBmlpack::neighbor::LSHSearch\fP< SortPolicy >::BaseCase (const size_t queryIndex, const arma::uvec & referenceIndices, const size_t k, arma::Mat< size_t > & neighbors, arma::mat & distances) const\fC [private]\fP"

.PP
This is a helper function that computes the distance of the query to the neighbor candidates and appropriately stores the best 'k' candidates\&. This is specific to the monochromatic search case, where the query set is the reference set\&.
.PP
\fBParameters:\fP
.RS 4
\fIqueryIndex\fP The index of the query in question 
.br
\fIreferenceIndices\fP The vector of indices of candidate neighbors for the query\&. 
.br
\fIk\fP Number of neighbors to search for\&. 
.br
\fIneighbors\fP Matrix holding output neighbors\&. 
.br
\fIdistances\fP Matrix holding output distances\&. 
.RE
.PP

.PP
Referenced by mlpack::neighbor::LSHSearch< SortPolicy >::Projections()\&.
.SS "template<typename SortPolicy  = NearestNeighborSort> void \fBmlpack::neighbor::LSHSearch\fP< SortPolicy >::BaseCase (const size_t queryIndex, const arma::uvec & referenceIndices, const size_t k, const arma::mat & querySet, arma::Mat< size_t > & neighbors, arma::mat & distances) const\fC [private]\fP"

.PP
This is a helper function that computes the distance of the query to the neighbor candidates and appropriately stores the best 'k' candidates\&. This is specific to bichromatic search, where the query set is not the same as the reference set\&.
.PP
\fBParameters:\fP
.RS 4
\fIqueryIndex\fP The index of the query in question 
.br
\fIreferenceIndices\fP The vector of indices of candidate neighbors for the query\&. 
.br
\fIk\fP Number of neighbors to search for\&. 
.br
\fIquerySet\fP Set of query points\&. 
.br
\fIneighbors\fP Matrix holding output neighbors\&. 
.br
\fIdistances\fP Matrix holding output distances\&. 
.RE
.PP

.SS "template<typename SortPolicy  = NearestNeighborSort> size_t \fBmlpack::neighbor::LSHSearch\fP< SortPolicy >::BucketSize () const\fC [inline]\fP"

.PP
Get the bucket size of the second hash\&. 
.PP
Definition at line 280 of file lsh_search\&.hpp\&.
.PP
References mlpack::neighbor::LSHSearch< SortPolicy >::bucketSize\&.
.SS "template<typename SortPolicy  = NearestNeighborSort> static double \fBmlpack::neighbor::LSHSearch\fP< SortPolicy >::ComputeRecall (const arma::Mat< size_t > & foundNeighbors, const arma::Mat< size_t > & realNeighbors)\fC [static]\fP"

.PP
Compute the recall (% of neighbors found) given the neighbors returned by \fBLSHSearch::Search\fP and a 'ground truth' set of neighbors\&. The recall returned will be in the range [0, 1]\&.
.PP
\fBParameters:\fP
.RS 4
\fIfoundNeighbors\fP Set of neighbors to compute recall of\&. 
.br
\fIrealNeighbors\fP Set of 'ground truth' neighbors to compute recall against\&. 
.RE
.PP

.SS "template<typename SortPolicy  = NearestNeighborSort> size_t \fBmlpack::neighbor::LSHSearch\fP< SortPolicy >::DistanceEvaluations () const\fC [inline]\fP"

.PP
Return the number of distance evaluations performed\&. 
.PP
Definition at line 263 of file lsh_search\&.hpp\&.
.PP
References mlpack::neighbor::LSHSearch< SortPolicy >::distanceEvaluations\&.
.SS "template<typename SortPolicy  = NearestNeighborSort> size_t& \fBmlpack::neighbor::LSHSearch\fP< SortPolicy >::DistanceEvaluations ()\fC [inline]\fP"

.PP
Modify the number of distance evaluations performed\&. 
.PP
Definition at line 265 of file lsh_search\&.hpp\&.
.PP
References mlpack::neighbor::LSHSearch< SortPolicy >::distanceEvaluations\&.
.SS "template<typename SortPolicy  = NearestNeighborSort> void \fBmlpack::neighbor::LSHSearch\fP< SortPolicy >::GetAdditionalProbingBins (const arma::vec & queryCode, const arma::vec & queryCodeNotFloored, const size_t T, arma::mat & additionalProbingBins) const\fC [private]\fP"

.PP
This function implements the core idea behind Multiprobe LSH\&. It is called by ReturnIndicesFromTables when T > 0\&. Given a query's code and its projection location, GetAdditionalProbingBins will calculate the T most likely alternative bin codes (other than queryCode) where a query's neighbors might be found in\&.
.PP
\fBParameters:\fP
.RS 4
\fIqueryCode\fP vector containing the numProj-dimensional query code\&. 
.br
\fIqueryCodeNotFloored\fP vector containing the projection location of the query\&. 
.br
\fIT\fP number of additional probing bins\&. 
.br
\fIadditionalProbingBins\fP matrix\&. Each column will hold one additional bin\&. 
.RE
.PP

.PP
Referenced by mlpack::neighbor::LSHSearch< SortPolicy >::Projections()\&.
.SS "template<typename SortPolicy  = NearestNeighborSort> size_t \fBmlpack::neighbor::LSHSearch\fP< SortPolicy >::NumProjections () const\fC [inline]\fP"

.PP
Get the number of projections\&. 
.PP
Definition at line 271 of file lsh_search\&.hpp\&.
.SS "template<typename SortPolicy  = NearestNeighborSort> const arma::mat& \fBmlpack::neighbor::LSHSearch\fP< SortPolicy >::Offsets () const\fC [inline]\fP"

.PP
Get the offsets 'b' for each of the projections\&. (One 'b' per column\&.) 
.PP
Definition at line 274 of file lsh_search\&.hpp\&.
.PP
References mlpack::neighbor::LSHSearch< SortPolicy >::offsets\&.
.SS "template<typename SortPolicy  = NearestNeighborSort> \fBLSHSearch\fP& \fBmlpack::neighbor::LSHSearch\fP< SortPolicy >::operator= (const \fBLSHSearch\fP< SortPolicy > & other)"

.PP
Copy the given LSH model\&. 
.PP
\fBParameters:\fP
.RS 4
\fIother\fP Other LSH model to copy\&. 
.RE
.PP

.SS "template<typename SortPolicy  = NearestNeighborSort> \fBLSHSearch\fP& \fBmlpack::neighbor::LSHSearch\fP< SortPolicy >::operator= (\fBLSHSearch\fP< SortPolicy > && other)"

.PP
Take ownership of the given LSH model\&. 
.PP
\fBParameters:\fP
.RS 4
\fIother\fP Other LSH model to take ownership of\&. 
.RE
.PP

.SS "template<typename SortPolicy  = NearestNeighborSort> bool \fBmlpack::neighbor::LSHSearch\fP< SortPolicy >::PerturbationExpand (std::vector< bool > & A) const\fC [private]\fP"

.PP
Inline function used by GetAdditionalProbingBins\&. The vector expansion operation adds the element [1 + (largest_element)] to a vector A, where largest_element is the largest element of A\&. Returns true if resulting vector is valid, otherwise false\&.
.PP
\fBParameters:\fP
.RS 4
\fIA\fP perturbation set to expand\&. 
.RE
.PP

.PP
Referenced by mlpack::neighbor::LSHSearch< SortPolicy >::Projections()\&.
.SS "template<typename SortPolicy  = NearestNeighborSort> double \fBmlpack::neighbor::LSHSearch\fP< SortPolicy >::PerturbationScore (const std::vector< bool > & A, const arma::vec & scores) const\fC [private]\fP"

.PP
Returns the score of a perturbation vector generated by perturbation set A\&. The score of a pertubation set (vector) is the sum of scores of the participating actions\&. 
.PP
\fBParameters:\fP
.RS 4
\fIA\fP perturbation set to compute the score of\&. 
.br
\fIscores\fP vector containing score of each perturbation\&. 
.RE
.PP

.PP
Referenced by mlpack::neighbor::LSHSearch< SortPolicy >::Projections()\&.
.SS "template<typename SortPolicy  = NearestNeighborSort> bool \fBmlpack::neighbor::LSHSearch\fP< SortPolicy >::PerturbationShift (std::vector< bool > & A) const\fC [private]\fP"

.PP
Inline function used by GetAdditionalProbingBins\&. The vector shift operation replaces the largest element of a vector A with (largest element)
.IP "\(bu" 2
1\&. Returns true if resulting vector is valid, otherwise false\&.
.PP
.PP
\fBParameters:\fP
.RS 4
\fIA\fP perturbation set to shift\&. 
.RE
.PP

.PP
Referenced by mlpack::neighbor::LSHSearch< SortPolicy >::Projections()\&.
.SS "template<typename SortPolicy  = NearestNeighborSort> bool \fBmlpack::neighbor::LSHSearch\fP< SortPolicy >::PerturbationValid (const std::vector< bool > & A) const\fC [private]\fP"

.PP
Return true if perturbation set A is valid\&. A perturbation set is invalid if it contains two (or more) actions for the same dimension or dimensions that are larger than the queryCode's dimensions\&.
.PP
\fBParameters:\fP
.RS 4
\fIA\fP perturbation set to validate\&. 
.RE
.PP

.PP
Referenced by mlpack::neighbor::LSHSearch< SortPolicy >::Projections()\&.
.SS "template<typename SortPolicy  = NearestNeighborSort> const arma::cube& \fBmlpack::neighbor::LSHSearch\fP< SortPolicy >::Projections ()\fC [inline]\fP"

.PP
Get the projection tables\&. 
.PP
Definition at line 287 of file lsh_search\&.hpp\&.
.PP
References mlpack::neighbor::LSHSearch< SortPolicy >::projections\&.
.SS "template<typename SortPolicy  = NearestNeighborSort> void \fBmlpack::neighbor::LSHSearch\fP< SortPolicy >::Projections (const arma::cube & projTables)\fC [inline]\fP"

.PP
Change the projection tables (this retrains the LSH model)\&. 
.PP
Definition at line 290 of file lsh_search\&.hpp\&.
.PP
References mlpack::neighbor::LSHSearch< SortPolicy >::BaseCase(), mlpack::neighbor::LSHSearch< SortPolicy >::bucketSize, mlpack::neighbor::LSHSearch< SortPolicy >::GetAdditionalProbingBins(), mlpack::neighbor::LSHSearch< SortPolicy >::hashWidth, mlpack::neighbor::LSHSearch< SortPolicy >::PerturbationExpand(), mlpack::neighbor::LSHSearch< SortPolicy >::PerturbationScore(), mlpack::neighbor::LSHSearch< SortPolicy >::PerturbationShift(), mlpack::neighbor::LSHSearch< SortPolicy >::PerturbationValid(), mlpack::neighbor::LSHSearch< SortPolicy >::ReturnIndicesFromTable(), mlpack::neighbor::LSHSearch< SortPolicy >::secondHashSize, and mlpack::neighbor::LSHSearch< SortPolicy >::Train()\&.
.SS "template<typename SortPolicy  = NearestNeighborSort> const arma::mat& \fBmlpack::neighbor::LSHSearch\fP< SortPolicy >::ReferenceSet () const\fC [inline]\fP"

.PP
Return the reference dataset\&. 
.PP
Definition at line 268 of file lsh_search\&.hpp\&.
.PP
References mlpack::neighbor::LSHSearch< SortPolicy >::referenceSet\&.
.SS "template<typename SortPolicy  = NearestNeighborSort> template<typename VecType > void \fBmlpack::neighbor::LSHSearch\fP< SortPolicy >::ReturnIndicesFromTable (const VecType & queryPoint, arma::uvec & referenceIndices, size_t numTablesToSearch, const size_t T) const\fC [private]\fP"

.PP
This function takes a query and hashes it into each of the hash tables to get keys for the query and then the key is hashed to a bucket of the second hash table and all the points (if any) in those buckets are collected as the potential neighbor candidates\&. 
.PP
\fBParameters:\fP
.RS 4
\fIqueryPoint\fP The query point currently being processed\&. 
.br
\fIreferenceIndices\fP The list of neighbor candidates obtained from hashing the query into all the hash tables and eventually into multiple buckets of the second hash table\&. 
.br
\fInumTablesToSearch\fP The number of tables to perform the search in\&. If 0, all tables are searched\&. 
.br
\fIT\fP The number of additional probing bins for multiprobe LSH\&. If 0, single-probe is used\&. 
.RE
.PP

.PP
Referenced by mlpack::neighbor::LSHSearch< SortPolicy >::Projections()\&.
.SS "template<typename SortPolicy  = NearestNeighborSort> void \fBmlpack::neighbor::LSHSearch\fP< SortPolicy >::Search (const arma::mat & querySet, const size_t k, arma::Mat< size_t > & resultingNeighbors, arma::mat & distances, const size_t numTablesToSearch = \fC0\fP, const size_t T = \fC0\fP)"

.PP
Compute the nearest neighbors of the points in the given query set and store the output in the given matrices\&. The matrices will be set to the size of n columns by k rows, where n is the number of points in the query dataset and k is the number of neighbors being searched for\&.
.PP
\fBParameters:\fP
.RS 4
\fIquerySet\fP Set of query points\&. 
.br
\fIk\fP Number of neighbors to search for\&. 
.br
\fIresultingNeighbors\fP Matrix storing lists of neighbors for each query point\&. 
.br
\fIdistances\fP Matrix storing distances of neighbors for each query point\&. 
.br
\fInumTablesToSearch\fP This parameter allows the user to have control over the number of hash tables to be searched\&. This allows the user to pick the number of tables it can afford for the time available without having to build hashing for every table size\&. By default, this is set to zero in which case all tables are considered\&. 
.br
\fIT\fP The number of additional probing bins to examine with multiprobe LSH\&. If T = 0, classic single-probe LSH is run (default)\&. 
.RE
.PP

.SS "template<typename SortPolicy  = NearestNeighborSort> void \fBmlpack::neighbor::LSHSearch\fP< SortPolicy >::Search (const size_t k, arma::Mat< size_t > & resultingNeighbors, arma::mat & distances, const size_t numTablesToSearch = \fC0\fP, size_t T = \fC0\fP)"

.PP
Compute the nearest neighbors and store the output in the given matrices\&. The matrices will be set to the size of n columns by k rows, where n is the number of points in the query dataset and k is the number of neighbors being searched for\&.
.PP
\fBParameters:\fP
.RS 4
\fIk\fP Number of neighbors to search for\&. 
.br
\fIresultingNeighbors\fP Matrix storing lists of neighbors for each query point\&. 
.br
\fIdistances\fP Matrix storing distances of neighbors for each query point\&. 
.br
\fInumTablesToSearch\fP This parameter allows the user to have control over the number of hash tables to be searched\&. This allows the user to pick the number of tables it can afford for the time available without having to build hashing for every table size\&. By default, this is set to zero in which case all tables are considered\&. 
.RE
.PP

.SS "template<typename SortPolicy  = NearestNeighborSort> const std::vector<arma::Col<size_t> >& \fBmlpack::neighbor::LSHSearch\fP< SortPolicy >::SecondHashTable () const\fC [inline]\fP"

.PP
Get the second hash table\&. 
.PP
Definition at line 283 of file lsh_search\&.hpp\&.
.PP
References mlpack::neighbor::LSHSearch< SortPolicy >::secondHashTable\&.
.SS "template<typename SortPolicy  = NearestNeighborSort> const arma::vec& \fBmlpack::neighbor::LSHSearch\fP< SortPolicy >::SecondHashWeights () const\fC [inline]\fP"

.PP
Get the weights of the second hash\&. 
.PP
Definition at line 277 of file lsh_search\&.hpp\&.
.PP
References mlpack::neighbor::LSHSearch< SortPolicy >::secondHashWeights\&.
.SS "template<typename SortPolicy  = NearestNeighborSort> template<typename Archive > void \fBmlpack::neighbor::LSHSearch\fP< SortPolicy >::Serialize (Archive & ar, const unsigned int version)"

.PP
Serialize the LSH model\&. 
.PP
\fBParameters:\fP
.RS 4
\fIar\fP Archive to serialize to\&. 
.RE
.PP

.SS "template<typename SortPolicy  = NearestNeighborSort> void \fBmlpack::neighbor::LSHSearch\fP< SortPolicy >::Train (const arma::mat & referenceSet, const size_t numProj, const size_t numTables, const double hashWidth = \fC0\&.0\fP, const size_t secondHashSize = \fC99901\fP, const size_t bucketSize = \fC500\fP, const arma::cube & projection = \fCarma::cube()\fP)"

.PP
Train the LSH model on the given dataset\&. If a correctly-sized projection cube is not provided, this means building new hash tables\&. Otherwise, we use the projections provided by the user\&.
.PP
\fBParameters:\fP
.RS 4
\fIreferenceSet\fP Set of reference points and the set of queries\&. 
.br
\fInumProj\fP Number of projections in each hash table (anything between 10-50 might be a decent choice)\&. 
.br
\fInumTables\fP Total number of hash tables (anything between 10-20 should suffice)\&. 
.br
\fIhashWidth\fP The width of hash for every table\&. If 0 (the default) is provided, then the hash width is automatically obtained by computing the average pairwise distance of 25 pairs\&. This should be a reasonable upper bound on the nearest-neighbor distance in general\&. 
.br
\fIsecondHashSize\fP The size of the second hash table\&. This should be a large prime number\&. 
.br
\fIbucketSize\fP The size of the bucket in the second hash table\&. This is the maximum number of points that can be hashed into single bucket\&. A value of 0 indicates that there is no limit (so the second hash table can be arbitrarily large---be careful!)\&. 
.br
\fIprojections\fP Cube of projection tables\&. For a cube of size (a, b, c) we set numProj = a, numTables = c\&. b is the reference set dimensionality\&. 
.RE
.PP

.PP
Referenced by mlpack::neighbor::LSHSearch< SortPolicy >::Projections()\&.
.SH "Member Data Documentation"
.PP 
.SS "template<typename SortPolicy  = NearestNeighborSort> arma::Col<size_t> \fBmlpack::neighbor::LSHSearch\fP< SortPolicy >::bucketContentSize\fC [private]\fP"

.PP
The number of elements present in each hash bucket; should be secondHashSize\&. 
.PP
Definition at line 450 of file lsh_search\&.hpp\&.
.SS "template<typename SortPolicy  = NearestNeighborSort> arma::Col<size_t> \fBmlpack::neighbor::LSHSearch\fP< SortPolicy >::bucketRowInHashTable\fC [private]\fP"

.PP
For a particular hash value, points to the row in secondHashTable corresponding to this value\&. Length secondHashSize\&. 
.PP
Definition at line 454 of file lsh_search\&.hpp\&.
.SS "template<typename SortPolicy  = NearestNeighborSort> size_t \fBmlpack::neighbor::LSHSearch\fP< SortPolicy >::bucketSize\fC [private]\fP"

.PP
The bucket size of the second hash\&. 
.PP
Definition at line 442 of file lsh_search\&.hpp\&.
.PP
Referenced by mlpack::neighbor::LSHSearch< SortPolicy >::BucketSize(), and mlpack::neighbor::LSHSearch< SortPolicy >::Projections()\&.
.SS "template<typename SortPolicy  = NearestNeighborSort> size_t \fBmlpack::neighbor::LSHSearch\fP< SortPolicy >::distanceEvaluations\fC [private]\fP"

.PP
The number of distance evaluations\&. 
.PP
Definition at line 457 of file lsh_search\&.hpp\&.
.PP
Referenced by mlpack::neighbor::LSHSearch< SortPolicy >::DistanceEvaluations()\&.
.SS "template<typename SortPolicy  = NearestNeighborSort> double \fBmlpack::neighbor::LSHSearch\fP< SortPolicy >::hashWidth\fC [private]\fP"

.PP
The hash width\&. 
.PP
Definition at line 433 of file lsh_search\&.hpp\&.
.PP
Referenced by mlpack::neighbor::LSHSearch< SortPolicy >::Projections()\&.
.SS "template<typename SortPolicy  = NearestNeighborSort> size_t \fBmlpack::neighbor::LSHSearch\fP< SortPolicy >::numProj\fC [private]\fP"

.PP
The number of projections\&. 
.PP
Definition at line 422 of file lsh_search\&.hpp\&.
.SS "template<typename SortPolicy  = NearestNeighborSort> size_t \fBmlpack::neighbor::LSHSearch\fP< SortPolicy >::numTables\fC [private]\fP"

.PP
The number of hash tables\&. 
.PP
Definition at line 424 of file lsh_search\&.hpp\&.
.SS "template<typename SortPolicy  = NearestNeighborSort> arma::mat \fBmlpack::neighbor::LSHSearch\fP< SortPolicy >::offsets\fC [private]\fP"

.PP
The list of the offsets 'b' for each of the projection for each table\&. 
.PP
Definition at line 430 of file lsh_search\&.hpp\&.
.PP
Referenced by mlpack::neighbor::LSHSearch< SortPolicy >::Offsets()\&.
.SS "template<typename SortPolicy  = NearestNeighborSort> bool \fBmlpack::neighbor::LSHSearch\fP< SortPolicy >::ownsSet\fC [private]\fP"

.PP
If true, we own the reference set\&. 
.PP
Definition at line 419 of file lsh_search\&.hpp\&.
.SS "template<typename SortPolicy  = NearestNeighborSort> arma::cube \fBmlpack::neighbor::LSHSearch\fP< SortPolicy >::projections\fC [private]\fP"

.PP
The arma::cube containing the projection matrix of each table\&. 
.PP
Definition at line 427 of file lsh_search\&.hpp\&.
.PP
Referenced by mlpack::neighbor::LSHSearch< SortPolicy >::Projections()\&.
.SS "template<typename SortPolicy  = NearestNeighborSort> const arma::mat* \fBmlpack::neighbor::LSHSearch\fP< SortPolicy >::referenceSet\fC [private]\fP"

.PP
Reference dataset\&. 
.PP
Definition at line 417 of file lsh_search\&.hpp\&.
.PP
Referenced by mlpack::neighbor::LSHSearch< SortPolicy >::ReferenceSet()\&.
.SS "template<typename SortPolicy  = NearestNeighborSort> size_t \fBmlpack::neighbor::LSHSearch\fP< SortPolicy >::secondHashSize\fC [private]\fP"

.PP
The big prime representing the size of the second hash\&. 
.PP
Definition at line 436 of file lsh_search\&.hpp\&.
.PP
Referenced by mlpack::neighbor::LSHSearch< SortPolicy >::Projections()\&.
.SS "template<typename SortPolicy  = NearestNeighborSort> std::vector<arma::Col<size_t> > \fBmlpack::neighbor::LSHSearch\fP< SortPolicy >::secondHashTable\fC [private]\fP"

.PP
The final hash table; should be (< secondHashSize) vectors each with (<= bucketSize) elements\&. 
.PP
Definition at line 446 of file lsh_search\&.hpp\&.
.PP
Referenced by mlpack::neighbor::LSHSearch< SortPolicy >::SecondHashTable()\&.
.SS "template<typename SortPolicy  = NearestNeighborSort> arma::vec \fBmlpack::neighbor::LSHSearch\fP< SortPolicy >::secondHashWeights\fC [private]\fP"

.PP
The weights of the second hash\&. 
.PP
Definition at line 439 of file lsh_search\&.hpp\&.
.PP
Referenced by mlpack::neighbor::LSHSearch< SortPolicy >::SecondHashWeights()\&.

.SH "Author"
.PP 
Generated automatically by Doxygen for mlpack from the source code\&.
