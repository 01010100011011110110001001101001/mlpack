.TH "mlpack::optimization::RMSprop< DecomposableFunctionType >" 3 "Sat Mar 25 2017" "Version master" "mlpack" \" -*- nroff -*-
.ad l
.nh
.SH NAME
mlpack::optimization::RMSprop< DecomposableFunctionType > \- \fBRMSprop\fP is an optimizer that utilizes the magnitude of recent gradients to normalize the gradients\&.  

.SH SYNOPSIS
.br
.PP
.SS "Public Member Functions"

.in +1c
.ti -1c
.RI "\fBRMSprop\fP (DecomposableFunctionType &\fBfunction\fP, const double \fBstepSize\fP=0\&.01, const double \fBalpha\fP=0\&.99, const double \fBeps\fP=1e\-8, const size_t maxIterations=100000, const double tolerance=1e\-5, const bool shuffle=true)"
.br
.RI "\fIConstruct the \fBRMSprop\fP optimizer with the given function and parameters\&. \fP"
.ti -1c
.RI "double \fBAlpha\fP () const "
.br
.RI "\fIGet the smoothing parameter\&. \fP"
.ti -1c
.RI "double & \fBAlpha\fP ()"
.br
.RI "\fIModify the smoothing parameter\&. \fP"
.ti -1c
.RI "double \fBEpsilon\fP () const "
.br
.RI "\fIGet the value used to initialise the mean squared gradient parameter\&. \fP"
.ti -1c
.RI "double & \fBEpsilon\fP ()"
.br
.RI "\fIModify the value used to initialise the mean squared gradient parameter\&. \fP"
.ti -1c
.RI "const DecomposableFunctionType & \fBFunction\fP () const "
.br
.RI "\fIGet the instantiated function to be optimized\&. \fP"
.ti -1c
.RI "DecomposableFunctionType & \fBFunction\fP ()"
.br
.RI "\fIModify the instantiated function\&. \fP"
.ti -1c
.RI "size_t \fBMaxIterations\fP () const "
.br
.RI "\fIGet the maximum number of iterations (0 indicates no limit)\&. \fP"
.ti -1c
.RI "size_t & \fBMaxIterations\fP ()"
.br
.RI "\fIModify the maximum number of iterations (0 indicates no limit)\&. \fP"
.ti -1c
.RI "double \fBOptimize\fP (arma::mat &iterate)"
.br
.RI "\fIOptimize the given function using \fBRMSprop\fP\&. \fP"
.ti -1c
.RI "bool \fBShuffle\fP () const "
.br
.RI "\fIGet whether or not the individual functions are shuffled\&. \fP"
.ti -1c
.RI "bool & \fBShuffle\fP ()"
.br
.RI "\fIModify whether or not the individual functions are shuffled\&. \fP"
.ti -1c
.RI "double \fBStepSize\fP () const "
.br
.RI "\fIGet the step size\&. \fP"
.ti -1c
.RI "double & \fBStepSize\fP ()"
.br
.RI "\fIModify the step size\&. \fP"
.ti -1c
.RI "double \fBTolerance\fP () const "
.br
.RI "\fIGet the tolerance for termination\&. \fP"
.ti -1c
.RI "double & \fBTolerance\fP ()"
.br
.RI "\fIModify the tolerance for termination\&. \fP"
.in -1c
.SS "Private Attributes"

.in +1c
.ti -1c
.RI "double \fBalpha\fP"
.br
.RI "\fIThe smoothing parameter\&. \fP"
.ti -1c
.RI "double \fBeps\fP"
.br
.RI "\fIThe value used to initialise the mean squared gradient parameter\&. \fP"
.ti -1c
.RI "DecomposableFunctionType & \fBfunction\fP"
.br
.RI "\fIThe instantiated function\&. \fP"
.ti -1c
.RI "size_t \fBmaxIterations\fP"
.br
.RI "\fIThe maximum number of allowed iterations\&. \fP"
.ti -1c
.RI "bool \fBshuffle\fP"
.br
.RI "\fIControls whether or not the individual functions are shuffled when iterating\&. \fP"
.ti -1c
.RI "double \fBstepSize\fP"
.br
.RI "\fIThe step size for each example\&. \fP"
.ti -1c
.RI "double \fBtolerance\fP"
.br
.RI "\fIThe tolerance for termination\&. \fP"
.in -1c
.SH "Detailed Description"
.PP 

.SS "template<typename DecomposableFunctionType>
.br
class mlpack::optimization::RMSprop< DecomposableFunctionType >"
\fBRMSprop\fP is an optimizer that utilizes the magnitude of recent gradients to normalize the gradients\&. 

In its basic form, given a step rate $ \gamma $ and a decay term $ \alpha $ we perform the following updates:
.PP
\begin{eqnarray*} r_t &=& (1 - \gamma) f'(\Delta_t)^2 + \gamma r_{t - 1} \\ v_{t + 1} &=& \frac{\alpha}{\sqrt{r_t}}f'(\Delta_t) \\ \Delta_{t + 1} &=& \Delta_t - v_{t + 1} \end{eqnarray*}.PP
For more information, see the following\&.
.PP
.PP
.nf
@misc{tieleman2012,
  title={Lecture 6\&.5 - rmsprop, COURSERA: Neural Networks for Machine
  Learning},
  year={2012}
}
.fi
.PP
.PP
For \fBRMSprop\fP to work, a DecomposableFunctionType template parameter is required\&. This class must implement the following function:
.PP
size_t NumFunctions(); double Evaluate(const arma::mat& coordinates, const size_t i); void Gradient(const arma::mat& coordinates, const size_t i, arma::mat& gradient);
.PP
NumFunctions() should return the number of functions ( $n$), and in the other two functions, the parameter i refers to which individual function (or gradient) is being evaluated\&. So, for the case of a data-dependent function, such as NCA (see \fBmlpack::nca::NCA\fP), NumFunctions() should return the number of points in the dataset, and Evaluate(coordinates, 0) will evaluate the objective function on the first point in the dataset (presumably, the dataset is held internally in the DecomposableFunctionType)\&.
.PP
\fBTemplate Parameters:\fP
.RS 4
\fIDecomposableFunctionType\fP Decomposable objective function type to be minimized\&. 
.RE
.PP

.PP
Definition at line 64 of file rmsprop\&.hpp\&.
.SH "Constructor & Destructor Documentation"
.PP 
.SS "template<typename DecomposableFunctionType > \fBmlpack::optimization::RMSprop\fP< DecomposableFunctionType >::\fBRMSprop\fP (DecomposableFunctionType & function, const double stepSize = \fC0\&.01\fP, const double alpha = \fC0\&.99\fP, const double eps = \fC1e\-8\fP, const size_t maxIterations = \fC100000\fP, const double tolerance = \fC1e\-5\fP, const bool shuffle = \fCtrue\fP)"

.PP
Construct the \fBRMSprop\fP optimizer with the given function and parameters\&. The defaults here are not necessarily good for the given problem, so it is suggested that the values used be tailored to the task at hand\&. The maximum number of iterations refers to the maximum number of points that are processed (i\&.e\&., one iteration equals one point; one iteration does not equal one pass over the dataset)\&.
.PP
\fBParameters:\fP
.RS 4
\fIfunction\fP Function to be optimized (minimized)\&. 
.br
\fIstepSize\fP Step size for each iteration\&. 
.br
\fIalpha\fP Smoothing constant, similar to that used in \fBAdaDelta\fP and momentum methods\&. 
.br
\fIeps\fP Value used to initialise the mean squared gradient parameter\&. 
.br
\fImaxIterations\fP Maximum number of iterations allowed (0 means no limit)\&. 
.br
\fItolerance\fP Maximum absolute tolerance to terminate algorithm\&. 
.br
\fIshuffle\fP If true, the function order is shuffled; otherwise, each function is visited in linear order\&. 
.RE
.PP

.SH "Member Function Documentation"
.PP 
.SS "template<typename DecomposableFunctionType > double \fBmlpack::optimization::RMSprop\fP< DecomposableFunctionType >::Alpha () const\fC [inline]\fP"

.PP
Get the smoothing parameter\&. 
.PP
Definition at line 115 of file rmsprop\&.hpp\&.
.PP
References mlpack::optimization::RMSprop< DecomposableFunctionType >::alpha\&.
.SS "template<typename DecomposableFunctionType > double& \fBmlpack::optimization::RMSprop\fP< DecomposableFunctionType >::Alpha ()\fC [inline]\fP"

.PP
Modify the smoothing parameter\&. 
.PP
Definition at line 117 of file rmsprop\&.hpp\&.
.PP
References mlpack::optimization::RMSprop< DecomposableFunctionType >::alpha\&.
.SS "template<typename DecomposableFunctionType > double \fBmlpack::optimization::RMSprop\fP< DecomposableFunctionType >::Epsilon () const\fC [inline]\fP"

.PP
Get the value used to initialise the mean squared gradient parameter\&. 
.PP
Definition at line 120 of file rmsprop\&.hpp\&.
.PP
References mlpack::optimization::RMSprop< DecomposableFunctionType >::eps\&.
.SS "template<typename DecomposableFunctionType > double& \fBmlpack::optimization::RMSprop\fP< DecomposableFunctionType >::Epsilon ()\fC [inline]\fP"

.PP
Modify the value used to initialise the mean squared gradient parameter\&. 
.PP
Definition at line 122 of file rmsprop\&.hpp\&.
.PP
References mlpack::optimization::RMSprop< DecomposableFunctionType >::eps\&.
.SS "template<typename DecomposableFunctionType > const DecomposableFunctionType& \fBmlpack::optimization::RMSprop\fP< DecomposableFunctionType >::Function () const\fC [inline]\fP"

.PP
Get the instantiated function to be optimized\&. 
.PP
Definition at line 105 of file rmsprop\&.hpp\&.
.SS "template<typename DecomposableFunctionType > DecomposableFunctionType& \fBmlpack::optimization::RMSprop\fP< DecomposableFunctionType >::Function ()\fC [inline]\fP"

.PP
Modify the instantiated function\&. 
.PP
Definition at line 107 of file rmsprop\&.hpp\&.
.SS "template<typename DecomposableFunctionType > size_t \fBmlpack::optimization::RMSprop\fP< DecomposableFunctionType >::MaxIterations () const\fC [inline]\fP"

.PP
Get the maximum number of iterations (0 indicates no limit)\&. 
.PP
Definition at line 125 of file rmsprop\&.hpp\&.
.PP
References mlpack::optimization::RMSprop< DecomposableFunctionType >::maxIterations\&.
.SS "template<typename DecomposableFunctionType > size_t& \fBmlpack::optimization::RMSprop\fP< DecomposableFunctionType >::MaxIterations ()\fC [inline]\fP"

.PP
Modify the maximum number of iterations (0 indicates no limit)\&. 
.PP
Definition at line 127 of file rmsprop\&.hpp\&.
.PP
References mlpack::optimization::RMSprop< DecomposableFunctionType >::maxIterations\&.
.SS "template<typename DecomposableFunctionType > double \fBmlpack::optimization::RMSprop\fP< DecomposableFunctionType >::Optimize (arma::mat & iterate)"

.PP
Optimize the given function using \fBRMSprop\fP\&. The given starting point will be modified to store the finishing point of the algorithm, and the final objective value is returned\&.
.PP
\fBParameters:\fP
.RS 4
\fIiterate\fP Starting point (will be modified)\&. 
.RE
.PP
\fBReturns:\fP
.RS 4
Objective value of the final point\&. 
.RE
.PP

.SS "template<typename DecomposableFunctionType > bool \fBmlpack::optimization::RMSprop\fP< DecomposableFunctionType >::Shuffle () const\fC [inline]\fP"

.PP
Get whether or not the individual functions are shuffled\&. 
.PP
Definition at line 135 of file rmsprop\&.hpp\&.
.PP
References mlpack::optimization::RMSprop< DecomposableFunctionType >::shuffle\&.
.SS "template<typename DecomposableFunctionType > bool& \fBmlpack::optimization::RMSprop\fP< DecomposableFunctionType >::Shuffle ()\fC [inline]\fP"

.PP
Modify whether or not the individual functions are shuffled\&. 
.PP
Definition at line 137 of file rmsprop\&.hpp\&.
.PP
References mlpack::optimization::RMSprop< DecomposableFunctionType >::shuffle\&.
.SS "template<typename DecomposableFunctionType > double \fBmlpack::optimization::RMSprop\fP< DecomposableFunctionType >::StepSize () const\fC [inline]\fP"

.PP
Get the step size\&. 
.PP
Definition at line 110 of file rmsprop\&.hpp\&.
.PP
References mlpack::optimization::RMSprop< DecomposableFunctionType >::stepSize\&.
.SS "template<typename DecomposableFunctionType > double& \fBmlpack::optimization::RMSprop\fP< DecomposableFunctionType >::StepSize ()\fC [inline]\fP"

.PP
Modify the step size\&. 
.PP
Definition at line 112 of file rmsprop\&.hpp\&.
.PP
References mlpack::optimization::RMSprop< DecomposableFunctionType >::stepSize\&.
.SS "template<typename DecomposableFunctionType > double \fBmlpack::optimization::RMSprop\fP< DecomposableFunctionType >::Tolerance () const\fC [inline]\fP"

.PP
Get the tolerance for termination\&. 
.PP
Definition at line 130 of file rmsprop\&.hpp\&.
.PP
References mlpack::optimization::RMSprop< DecomposableFunctionType >::tolerance\&.
.SS "template<typename DecomposableFunctionType > double& \fBmlpack::optimization::RMSprop\fP< DecomposableFunctionType >::Tolerance ()\fC [inline]\fP"

.PP
Modify the tolerance for termination\&. 
.PP
Definition at line 132 of file rmsprop\&.hpp\&.
.PP
References mlpack::optimization::RMSprop< DecomposableFunctionType >::tolerance\&.
.SH "Member Data Documentation"
.PP 
.SS "template<typename DecomposableFunctionType > double \fBmlpack::optimization::RMSprop\fP< DecomposableFunctionType >::alpha\fC [private]\fP"

.PP
The smoothing parameter\&. 
.PP
Definition at line 147 of file rmsprop\&.hpp\&.
.PP
Referenced by mlpack::optimization::RMSprop< DecomposableFunctionType >::Alpha()\&.
.SS "template<typename DecomposableFunctionType > double \fBmlpack::optimization::RMSprop\fP< DecomposableFunctionType >::eps\fC [private]\fP"

.PP
The value used to initialise the mean squared gradient parameter\&. 
.PP
Definition at line 150 of file rmsprop\&.hpp\&.
.PP
Referenced by mlpack::optimization::RMSprop< DecomposableFunctionType >::Epsilon()\&.
.SS "template<typename DecomposableFunctionType > DecomposableFunctionType& \fBmlpack::optimization::RMSprop\fP< DecomposableFunctionType >::function\fC [private]\fP"

.PP
The instantiated function\&. 
.PP
Definition at line 141 of file rmsprop\&.hpp\&.
.SS "template<typename DecomposableFunctionType > size_t \fBmlpack::optimization::RMSprop\fP< DecomposableFunctionType >::maxIterations\fC [private]\fP"

.PP
The maximum number of allowed iterations\&. 
.PP
Definition at line 153 of file rmsprop\&.hpp\&.
.PP
Referenced by mlpack::optimization::RMSprop< DecomposableFunctionType >::MaxIterations()\&.
.SS "template<typename DecomposableFunctionType > bool \fBmlpack::optimization::RMSprop\fP< DecomposableFunctionType >::shuffle\fC [private]\fP"

.PP
Controls whether or not the individual functions are shuffled when iterating\&. 
.PP
Definition at line 160 of file rmsprop\&.hpp\&.
.PP
Referenced by mlpack::optimization::RMSprop< DecomposableFunctionType >::Shuffle()\&.
.SS "template<typename DecomposableFunctionType > double \fBmlpack::optimization::RMSprop\fP< DecomposableFunctionType >::stepSize\fC [private]\fP"

.PP
The step size for each example\&. 
.PP
Definition at line 144 of file rmsprop\&.hpp\&.
.PP
Referenced by mlpack::optimization::RMSprop< DecomposableFunctionType >::StepSize()\&.
.SS "template<typename DecomposableFunctionType > double \fBmlpack::optimization::RMSprop\fP< DecomposableFunctionType >::tolerance\fC [private]\fP"

.PP
The tolerance for termination\&. 
.PP
Definition at line 156 of file rmsprop\&.hpp\&.
.PP
Referenced by mlpack::optimization::RMSprop< DecomposableFunctionType >::Tolerance()\&.

.SH "Author"
.PP 
Generated automatically by Doxygen for mlpack from the source code\&.
