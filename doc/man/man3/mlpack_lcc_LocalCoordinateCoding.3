.TH "mlpack::lcc::LocalCoordinateCoding" 3 "Sat Mar 25 2017" "Version master" "mlpack" \" -*- nroff -*-
.ad l
.nh
.SH NAME
mlpack::lcc::LocalCoordinateCoding \- An implementation of Local Coordinate Coding (LCC) that codes data which approximately lives on a manifold using a variation of l1-norm regularized sparse coding; in LCC, the penalty on the absolute value of each point's coefficient for each atom is weighted by the squared distance of that point to that atom\&.  

.SH SYNOPSIS
.br
.PP
.SS "Public Member Functions"

.in +1c
.ti -1c
.RI "template<typename DictionaryInitializer  = sparse_coding::DataDependentRandomInitializer> \fBLocalCoordinateCoding\fP (const arma::mat &data, const size_t \fBatoms\fP, const double \fBlambda\fP, const size_t \fBmaxIterations\fP=0, const double \fBtolerance\fP=0\&.01, const DictionaryInitializer &initializer=DictionaryInitializer())"
.br
.RI "\fISet the parameters to \fBLocalCoordinateCoding\fP, and train the dictionary\&. \fP"
.ti -1c
.RI "\fBLocalCoordinateCoding\fP (const size_t \fBatoms\fP=0, const double \fBlambda\fP=0\&.0, const size_t \fBmaxIterations\fP=0, const double \fBtolerance\fP=0\&.01)"
.br
.RI "\fISet the parameters to \fBLocalCoordinateCoding\fP\&. \fP"
.ti -1c
.RI "size_t \fBAtoms\fP () const "
.br
.RI "\fIGet the number of atoms\&. \fP"
.ti -1c
.RI "size_t & \fBAtoms\fP ()"
.br
.RI "\fIModify the number of atoms\&. \fP"
.ti -1c
.RI "const arma::mat & \fBDictionary\fP () const "
.br
.RI "\fIAccessor for dictionary\&. \fP"
.ti -1c
.RI "arma::mat & \fBDictionary\fP ()"
.br
.RI "\fIMutator for dictionary\&. \fP"
.ti -1c
.RI "void \fBEncode\fP (const arma::mat &data, arma::mat &codes)"
.br
.RI "\fICode each point via distance-weighted LARS\&. \fP"
.ti -1c
.RI "double \fBLambda\fP () const "
.br
.RI "\fIGet the L1 regularization parameter\&. \fP"
.ti -1c
.RI "double & \fBLambda\fP ()"
.br
.RI "\fIModify the L1 regularization parameter\&. \fP"
.ti -1c
.RI "size_t \fBMaxIterations\fP () const "
.br
.RI "\fIGet the maximum number of iterations\&. \fP"
.ti -1c
.RI "size_t & \fBMaxIterations\fP ()"
.br
.RI "\fIModify the maximum number of iterations\&. \fP"
.ti -1c
.RI "double \fBObjective\fP (const arma::mat &data, const arma::mat &codes, const arma::uvec &adjacencies) const "
.br
.RI "\fICompute objective function given the list of adjacencies\&. \fP"
.ti -1c
.RI "void \fBOptimizeDictionary\fP (const arma::mat &data, const arma::mat &codes, const arma::uvec &adjacencies)"
.br
.RI "\fILearn dictionary by solving linear system\&. \fP"
.ti -1c
.RI "template<typename Archive > void \fBSerialize\fP (Archive &ar, const unsigned int)"
.br
.RI "\fISerialize the model\&. \fP"
.ti -1c
.RI "double \fBTolerance\fP () const "
.br
.RI "\fIGet the objective tolerance\&. \fP"
.ti -1c
.RI "double & \fBTolerance\fP ()"
.br
.RI "\fIModify the objective tolerance\&. \fP"
.ti -1c
.RI "template<typename DictionaryInitializer  = sparse_coding::DataDependentRandomInitializer> void \fBTrain\fP (const arma::mat &data, const DictionaryInitializer &initializer=DictionaryInitializer())"
.br
.RI "\fIRun local coordinate coding\&. \fP"
.in -1c
.SS "Private Attributes"

.in +1c
.ti -1c
.RI "size_t \fBatoms\fP"
.br
.RI "\fINumber of atoms in dictionary\&. \fP"
.ti -1c
.RI "arma::mat \fBdictionary\fP"
.br
.RI "\fIDictionary (columns are atoms)\&. \fP"
.ti -1c
.RI "double \fBlambda\fP"
.br
.RI "\fIl1 regularization term\&. \fP"
.ti -1c
.RI "size_t \fBmaxIterations\fP"
.br
.RI "\fIMaximum number of iterations during training\&. \fP"
.ti -1c
.RI "double \fBtolerance\fP"
.br
.RI "\fITolerance for main objective\&. \fP"
.in -1c
.SH "Detailed Description"
.PP 
An implementation of Local Coordinate Coding (LCC) that codes data which approximately lives on a manifold using a variation of l1-norm regularized sparse coding; in LCC, the penalty on the absolute value of each point's coefficient for each atom is weighted by the squared distance of that point to that atom\&. 

Let d be the number of dimensions in the original space, m the number of training points, and k the number of atoms in the dictionary (the dimension of the learned feature space)\&. The training data X is a d-by-m matrix where each column is a point and each row is a dimension\&. The dictionary D is a d-by-k matrix, and the sparse codes matrix Z is a k-by-m matrix\&. This program seeks to minimize the objective: min_{D,Z} ||X - D Z||_{Fro}^2
.IP "\(bu" 2
lambda sum_{i=1}^m sum_{j=1}^k dist(X_i,D_j)^2 Z_i^j where lambda > 0\&.
.PP
.PP
This problem is solved by an algorithm that alternates between a dictionary learning step and a sparse coding step\&. The dictionary learning step updates the dictionary D by solving a linear system (note that the objective is a positive definite quadratic program)\&. The sparse coding step involves solving a large number of weighted l1-norm regularized linear regression problems problems; this can be done efficiently using LARS, an algorithm that can solve the LASSO (paper below)\&.
.PP
The papers are listed below\&.
.PP
.PP
.nf
@incollection{NIPS2009_0719,
  title = {Nonlinear Learning using Local Coordinate Coding},
  author = {Kai Yu and Tong Zhang and Yihong Gong},
  booktitle = {Advances in Neural Information Processing Systems 22},
  editor = {Y\&. Bengio and D\&. Schuurmans and J\&. Lafferty and C\&. K\&. I\&. Williams
      and A\&. Culotta},
  pages = {2223--2231},
  year = {2009}
}
.fi
.PP
.PP
.PP
.nf
@article{efron2004least,
  title={Least angle regression},
  author={Efron, B\&. and Hastie, T\&. and Johnstone, I\&. and Tibshirani, R\&.},
  journal={The Annals of statistics},
  volume={32},
  number={2},
  pages={407--499},
  year={2004},
  publisher={Institute of Mathematical Statistics}
}
.fi
.PP
 
.PP
Definition at line 79 of file lcc\&.hpp\&.
.SH "Constructor & Destructor Documentation"
.PP 
.SS "template<typename DictionaryInitializer  = sparse_coding::DataDependentRandomInitializer> mlpack::lcc::LocalCoordinateCoding::LocalCoordinateCoding (const arma::mat & data, const size_t atoms, const double lambda, const size_t maxIterations = \fC0\fP, const double tolerance = \fC0\&.01\fP, const DictionaryInitializer & initializer = \fCDictionaryInitializer()\fP)"

.PP
Set the parameters to \fBLocalCoordinateCoding\fP, and train the dictionary\&. This constructor will also initialize the dictionary using the given DictionaryInitializer before training\&.
.PP
If you want to initialize the dictionary to a custom matrix, consider either writing your own DictionaryInitializer class (with void Initialize(const arma::mat& data, arma::mat& dictionary) function), or call the constructor that does not take a data matrix, then call \fBDictionary()\fP to set the dictionary matrix to a matrix of your choosing, and then call \fBTrain()\fP with \fBsparse_coding::NothingInitializer\fP (i\&.e\&. Train<sparse_coding::NothingInitializer>(data))\&.
.PP
\fBParameters:\fP
.RS 4
\fIdata\fP Data matrix\&. 
.br
\fIatoms\fP Number of atoms in dictionary\&. 
.br
\fIlambda\fP Regularization parameter for weighted l1-norm penalty\&. 
.br
\fImaxIterations\fP Maximum number of iterations for training (0 runs until convergence)\&. 
.br
\fItolerance\fP Tolerance for the objective function\&. 
.RE
.PP

.SS "mlpack::lcc::LocalCoordinateCoding::LocalCoordinateCoding (const size_t atoms = \fC0\fP, const double lambda = \fC0\&.0\fP, const size_t maxIterations = \fC0\fP, const double tolerance = \fC0\&.01\fP)"

.PP
Set the parameters to \fBLocalCoordinateCoding\fP\&. This constructor will not train the model, and a subsequent call to \fBTrain()\fP will be required before the model can encode points with \fBEncode()\fP\&. The default values for atoms and lambda should be changed if you intend to train the model!
.PP
\fBParameters:\fP
.RS 4
\fIatoms\fP Number of atoms in dictionary\&. 
.br
\fIlambda\fP Regularization parameter for weighted l1-norm penalty\&. 
.br
\fImaxIterations\fP Maximum number of iterations for training (0 runs until convergence)\&. 
.br
\fItolerance\fP Tolerance for the objective function\&. 
.RE
.PP

.SH "Member Function Documentation"
.PP 
.SS "size_t mlpack::lcc::LocalCoordinateCoding::Atoms () const\fC [inline]\fP"

.PP
Get the number of atoms\&. 
.PP
Definition at line 174 of file lcc\&.hpp\&.
.PP
References atoms\&.
.SS "size_t& mlpack::lcc::LocalCoordinateCoding::Atoms ()\fC [inline]\fP"

.PP
Modify the number of atoms\&. 
.PP
Definition at line 176 of file lcc\&.hpp\&.
.PP
References atoms\&.
.SS "const arma::mat& mlpack::lcc::LocalCoordinateCoding::Dictionary () const\fC [inline]\fP"

.PP
Accessor for dictionary\&. 
.PP
Definition at line 179 of file lcc\&.hpp\&.
.PP
References dictionary\&.
.SS "arma::mat& mlpack::lcc::LocalCoordinateCoding::Dictionary ()\fC [inline]\fP"

.PP
Mutator for dictionary\&. 
.PP
Definition at line 181 of file lcc\&.hpp\&.
.PP
References dictionary\&.
.SS "void mlpack::lcc::LocalCoordinateCoding::Encode (const arma::mat & data, arma::mat & codes)"

.PP
Code each point via distance-weighted LARS\&. 
.PP
\fBParameters:\fP
.RS 4
\fIdata\fP Matrix containing points to encode\&. 
.br
\fIcodes\fP Output matrix to store codes in\&. 
.RE
.PP

.SS "double mlpack::lcc::LocalCoordinateCoding::Lambda () const\fC [inline]\fP"

.PP
Get the L1 regularization parameter\&. 
.PP
Definition at line 184 of file lcc\&.hpp\&.
.PP
References lambda\&.
.SS "double& mlpack::lcc::LocalCoordinateCoding::Lambda ()\fC [inline]\fP"

.PP
Modify the L1 regularization parameter\&. 
.PP
Definition at line 186 of file lcc\&.hpp\&.
.PP
References lambda\&.
.SS "size_t mlpack::lcc::LocalCoordinateCoding::MaxIterations () const\fC [inline]\fP"

.PP
Get the maximum number of iterations\&. 
.PP
Definition at line 189 of file lcc\&.hpp\&.
.PP
References maxIterations\&.
.SS "size_t& mlpack::lcc::LocalCoordinateCoding::MaxIterations ()\fC [inline]\fP"

.PP
Modify the maximum number of iterations\&. 
.PP
Definition at line 191 of file lcc\&.hpp\&.
.PP
References maxIterations\&.
.SS "double mlpack::lcc::LocalCoordinateCoding::Objective (const arma::mat & data, const arma::mat & codes, const arma::uvec & adjacencies) const"

.PP
Compute objective function given the list of adjacencies\&. 
.SS "void mlpack::lcc::LocalCoordinateCoding::OptimizeDictionary (const arma::mat & data, const arma::mat & codes, const arma::uvec & adjacencies)"

.PP
Learn dictionary by solving linear system\&. 
.PP
\fBParameters:\fP
.RS 4
\fIadjacencies\fP Indices of entries (unrolled column by column) of the coding matrix Z that are non-zero (the adjacency matrix for the bipartite graph of points and atoms) 
.RE
.PP

.SS "template<typename Archive > void mlpack::lcc::LocalCoordinateCoding::Serialize (Archive & ar, const unsigned int)"

.PP
Serialize the model\&. 
.PP
Referenced by Tolerance()\&.
.SS "double mlpack::lcc::LocalCoordinateCoding::Tolerance () const\fC [inline]\fP"

.PP
Get the objective tolerance\&. 
.PP
Definition at line 194 of file lcc\&.hpp\&.
.PP
References tolerance\&.
.SS "double& mlpack::lcc::LocalCoordinateCoding::Tolerance ()\fC [inline]\fP"

.PP
Modify the objective tolerance\&. 
.PP
Definition at line 196 of file lcc\&.hpp\&.
.PP
References Serialize(), and tolerance\&.
.SS "template<typename DictionaryInitializer  = sparse_coding::DataDependentRandomInitializer> void mlpack::lcc::LocalCoordinateCoding::Train (const arma::mat & data, const DictionaryInitializer & initializer = \fCDictionaryInitializer()\fP)"

.PP
Run local coordinate coding\&. 
.PP
\fBParameters:\fP
.RS 4
\fInIterations\fP Maximum number of iterations to run algorithm\&. 
.br
\fIobjTolerance\fP Tolerance of objective function\&. When the objective function changes by a value lower than this tolerance, the optimization terminates\&. 
.RE
.PP

.SH "Member Data Documentation"
.PP 
.SS "size_t mlpack::lcc::LocalCoordinateCoding::atoms\fC [private]\fP"

.PP
Number of atoms in dictionary\&. 
.PP
Definition at line 204 of file lcc\&.hpp\&.
.PP
Referenced by Atoms()\&.
.SS "arma::mat mlpack::lcc::LocalCoordinateCoding::dictionary\fC [private]\fP"

.PP
Dictionary (columns are atoms)\&. 
.PP
Definition at line 207 of file lcc\&.hpp\&.
.PP
Referenced by Dictionary()\&.
.SS "double mlpack::lcc::LocalCoordinateCoding::lambda\fC [private]\fP"

.PP
l1 regularization term\&. 
.PP
Definition at line 210 of file lcc\&.hpp\&.
.PP
Referenced by Lambda()\&.
.SS "size_t mlpack::lcc::LocalCoordinateCoding::maxIterations\fC [private]\fP"

.PP
Maximum number of iterations during training\&. 
.PP
Definition at line 213 of file lcc\&.hpp\&.
.PP
Referenced by MaxIterations()\&.
.SS "double mlpack::lcc::LocalCoordinateCoding::tolerance\fC [private]\fP"

.PP
Tolerance for main objective\&. 
.PP
Definition at line 215 of file lcc\&.hpp\&.
.PP
Referenced by Tolerance()\&.

.SH "Author"
.PP 
Generated automatically by Doxygen for mlpack from the source code\&.
